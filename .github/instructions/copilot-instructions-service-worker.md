---
applyTo: '**/service-worker.{js,ts}'
---

# Copilot Instructions for Service Worker Development - PrismWeave Project

## Service Worker Overview - PrismWeave Browser Extension

- **Manifest Version**: V3 (Chrome/Edge compatible)
- **Architecture**: Self-contained service worker with inline implementations
- **Critical Pattern**: NO external imports, all functionality must be self-contained
- **Storage**: Chrome storage APIs (sync/local) with proper error handling
- **Message Handling**: Async message processing with validation

## ⚠️ CRITICAL: Module System Requirements

### Modern ES6 Module Approach (UPDATED - Current Best Practice)

**IMPORTANT UPDATE**: The latest implementation successfully uses ES6 modules in Manifest V3 service workers when properly configured with TypeScript compilation.

### ✅ CORRECT PATTERN (ES6 Modules with Proper Build)
```typescript
// Generated by Copilot
// Service worker with ES6 module support for PrismWeave browser extension

import { IDocumentMetadata, IMessageData, IMessageResponse, ISettings } from '../types/index.js';
import { GitOperations } from '../utils/git-operations.js';
import { createLogger } from '../utils/logger.js';
import { SettingsManager } from '../utils/settings-manager.js';

console.log('Service Worker starting...');

// Initialize logger
const swLogger = createLogger('ServiceWorker');

// Define service-worker specific interfaces
interface IContentExtractionData {
  html: string;
  title?: string;
  url?: string;
  metadata?: Record<string, unknown>;
  markdown?: string;
  frontmatter?: string;
  images?: string[];
}

interface IContentExtractionResult {
  success: boolean;
  data?: IContentExtractionData;
  error?: string;
  extractionMethod?: 'content-script' | 'direct';
  timestamp?: string;
}

// Initialize managers with proper error handling
let settingsManager: SettingsManager;
let gitOperations: GitOperations;

try {
  settingsManager = new SettingsManager();
  gitOperations = new GitOperations();
  swLogger.info('Service managers initialized successfully');
} catch (error) {
  swLogger.error('Failed to initialize service managers:', error);
}
```

### Key Requirements for ES6 Module Success:

1. **TypeScript Configuration**: Use proper `tsconfig.json` with ES2020 target
2. **File Extensions**: Always use `.js` extensions in import statements
3. **Build Process**: Ensure TypeScript compiles to proper module format
4. **Manifest Configuration**: Set `"type": "module"` if needed

### ❌ LEGACY PATTERNS (Avoid These - Outdated)
```typescript
// OLD APPROACH - No longer recommended
// Self-contained service worker with inline implementations
// This was the old workaround before proper ES6 module support
```

The **self-contained approach** is now **legacy** - modern Chrome extensions with proper TypeScript build support ES6 modules natively.

## Message Handling Pattern

### Complete Message Handler Template (UPDATED)
```typescript
// Generated by Copilot
// Modern message handling with ES6 imports and comprehensive error handling

chrome.runtime.onMessage.addListener(
  (
    message: IMessageData,
    sender: chrome.runtime.MessageSender,
    sendResponse: (response: IMessageResponse) => void
  ) => {
    swLogger.info('Received message:', message.type);

    // Handle message asynchronously
    handleMessage(message, sender)
      .then(result => {
        swLogger.debug('Message handled successfully:', message.type);
        sendResponse({ success: true, data: result });
      })
      .catch(error => {
        swLogger.error('Error handling message:', message.type, error);
        sendResponse({ success: false, error: error.message });
      });

    return true; // Keep message channel open for async response
  }
);

async function handleMessage(
  message: IMessageData,
  sender: chrome.runtime.MessageSender
): Promise<unknown> {
  // 1. Validate message structure
  if (!message || typeof message.type !== 'string') {
    throw new Error('Invalid message format');
  }

  // 2. Validate manager initialization for data operations
  const requiresManager = [
    'GET_SETTINGS',
    'UPDATE_SETTINGS',
    'RESET_SETTINGS',
    'VALIDATE_SETTINGS',
  ];
  if (requiresManager.includes(message.type) && !settingsManager) {
    throw new Error('Service manager not initialized');
  }

  // 3. Handle specific message types with comprehensive functionality
  switch (message.type) {
    case 'GET_SETTINGS':
      return await settingsManager!.getSettings();
      
    case 'UPDATE_SETTINGS':
      if (!message.data || typeof message.data !== 'object') {
        throw new Error('Invalid settings data provided');
      }
      await settingsManager!.updateSettings(message.data);
      return { success: true };
      
    case 'RESET_SETTINGS':
      await settingsManager!.resetSettings();
      return { success: true };
      
    case 'VALIDATE_SETTINGS':
      const currentSettings = await settingsManager!.getSettings();
      return settingsManager!.validateSettings(currentSettings);
      
    case 'TEST_CONNECTION':
      return await testGitHubConnection();

    case 'CAPTURE_PAGE':
      return await handleCapturePage(message.data);
      
    case 'GET_STATUS':
      return {
        initialized: !!settingsManager,
        version: chrome.runtime.getManifest().version,
        timestamp: new Date().toISOString(),
      };

    default:
      throw new Error(`Unknown message type: ${message.type}`);
  }
}
```

## Chrome Extension Lifecycle Management

### Installation and Updates
```typescript
// Generated by Copilot
// Extension lifecycle management

chrome.runtime.onInstalled.addListener(async (details: chrome.runtime.InstalledDetails) => {
  try {
    console.log('Extension event:', details.reason);
    
    switch (details.reason) {
      case 'install':
        console.log('Extension installed for the first time');
        await initializeExtension();
        break;
        
      case 'update':
        console.log('Extension updated from version:', details.previousVersion);
        await handleExtensionUpdate(details.previousVersion);
        break;
        
      case 'chrome_update':
        console.log('Chrome browser updated');
        break;
    }
  } catch (error) {
    console.error('Error handling installation:', error);
  }
});

async function initializeExtension(): Promise<void> {
  try {
    // Set up default settings
    const defaultSettings = settingsManager ? await settingsManager.getSettings() : {};
    console.log('Extension initialized with settings:', defaultSettings);
  } catch (error) {
    console.error('Extension initialization failed:', error);
  }
}

async function handleExtensionUpdate(previousVersion?: string): Promise<void> {
  try {
    console.log('Updating extension from version:', previousVersion);
    // Migration logic if needed
  } catch (error) {
    console.error('Extension update failed:', error);
  }
}
```

## Chrome Storage Integration

### Storage Patterns with Error Handling
```typescript
// Generated by Copilot
// Chrome storage operations with comprehensive error handling

class ServiceWorkerStorageManager {
  private static readonly MAX_RETRIES = 3;
  private static readonly RETRY_DELAY = 1000;

  static async safeStorageGet<T = Record<string, unknown>>(
    keys: string | string[] | Record<string, unknown>
  ): Promise<T> {
    for (let attempt = 1; attempt <= this.MAX_RETRIES; attempt++) {
      try {
        return await new Promise<T>((resolve, reject) => {
          chrome.storage.sync.get(keys, (result: T) => {
            if (chrome.runtime.lastError) {
              reject(new Error(chrome.runtime.lastError.message));
            } else {
              resolve(result);
            }
          });
        });
      } catch (error) {
        console.warn(`Storage get attempt ${attempt} failed:`, error);
        
        if (attempt === this.MAX_RETRIES) {
          // Try local storage as fallback
          try {
            return await new Promise<T>((resolve, reject) => {
              chrome.storage.local.get(keys, (result: T) => {
                if (chrome.runtime.lastError) {
                  reject(new Error(chrome.runtime.lastError.message));
                } else {
                  resolve(result);
                }
              });
            });
          } catch (localError) {
            console.error('Both sync and local storage failed:', localError);
            throw new Error('Storage unavailable');
          }
        }
        
        await this.delay(this.RETRY_DELAY * attempt);
      }
    }
    
    throw new Error('Storage operation failed after retries');
  }

  static async safeStorageSet(data: Record<string, unknown>): Promise<void> {
    try {
      await new Promise<void>((resolve, reject) => {
        chrome.storage.sync.set(data, () => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
          } else {
            resolve();
          }
        });
      });
    } catch (error) {
      console.warn('Sync storage failed, trying local:', error);
      
      // Fallback to local storage
      await new Promise<void>((resolve, reject) => {
        chrome.storage.local.set(data, () => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
          } else {
            resolve();
          }
        });
      });
    }
  }

  private static delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

## Advanced Content Script Integration (NEW)

### Dynamic Content Script Injection with Library Dependencies
```typescript
// Generated by Copilot
// Advanced content script injection with library dependency management

async function ensureContentScriptInjected(tabId: number): Promise<void> {
  try {
    swLogger.debug('Ensuring content script is injected in tab:', tabId);

    // Get tab info to validate it's a valid web page
    const tab = await chrome.tabs.get(tabId);
    if (
      !tab.url ||
      tab.url.startsWith('chrome://') ||
      tab.url.startsWith('chrome-extension://') ||
      tab.url.startsWith('moz-extension://')
    ) {
      throw new Error('Cannot inject content script into special pages');
    }

    // Check if content script is already available by sending a ping
    const pingResult = await new Promise<boolean>(resolve => {
      const timeout = setTimeout(() => resolve(false), 1000); // 1 second timeout for ping

      chrome.tabs.sendMessage(tabId, { type: 'PING' }, response => {
        clearTimeout(timeout);
        if (chrome.runtime.lastError) {
          swLogger.debug(
            'Ping failed (expected if script not injected):',
            chrome.runtime.lastError.message
          );
          resolve(false);
        } else {
          resolve(!!response);
        }
      });
    });

    if (pingResult) {
      swLogger.debug('Content script already active');
      return;
    }

    // Inject TurndownService library first
    swLogger.debug('Injecting TurndownService library...');
    try {
      await chrome.scripting.executeScript({
        target: { tabId },
        files: ['libs/turndown.min.js'],
      });
      swLogger.debug('TurndownService library injected successfully');
    } catch (libraryError) {
      swLogger.warn('Failed to inject TurndownService library:', libraryError);
      // This is not fatal - markdown conversion will require TurndownService to work properly
    }

    // Inject content script if not available
    swLogger.debug('Injecting content script...');
    try {
      await chrome.scripting.executeScript({
        target: { tabId },
        files: ['content/content-script.js'],
      });

      swLogger.debug('Content script injected successfully');

      // Wait a bit for the script to initialize
      await new Promise(resolve => setTimeout(resolve, 500));
    } catch (scriptError) {
      swLogger.warn(
        'Failed to inject content script file, script may not be built yet:',
        scriptError
      );
      // This is not a fatal error - we'll use direct extraction instead
      throw new Error('Content script injection failed');
    }
  } catch (error) {
    swLogger.error('Failed to ensure content script injection:', error);
    throw error;
  }
}

async function extractContentFromTab(tabId: number): Promise<IContentExtractionResult> {
  return new Promise<IContentExtractionResult>((resolve, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error('Content extraction timeout after 10 seconds'));
    }, 10000); // 10 second timeout

    swLogger.debug('Sending EXTRACT_AND_CONVERT message to tab:', tabId);

    chrome.tabs.sendMessage(
      tabId,
      {
        type: 'EXTRACT_AND_CONVERT_TO_MARKDOWN',
        data: {
          extractionRules: ['article', 'main', '.content', '#content', 'body'],
          includeImages: true,
          cleanHtml: true,
          convertToMarkdown: true, // Request markdown conversion in content script
        },
      },
      (response: IContentExtractionResult) => {
        clearTimeout(timeout);

        if (chrome.runtime.lastError) {
          swLogger.error('Content script message error:', chrome.runtime.lastError.message);
          reject(new Error(chrome.runtime.lastError.message));
        } else if (!response) {
          swLogger.error('No response received from content script');
          reject(new Error('No response received from content script'));
        } else if (!response.success) {
          swLogger.error('Content script reported failure:', response.error);
          reject(new Error(response.error || 'Content extraction failed'));
        } else {
          swLogger.debug('Content extraction and conversion successful via content script');
          resolve(response);
        }
      }
    );
  });
}
```

### Multi-Layer Fallback Strategy (NEW)
```typescript
// Generated by Copilot
// Sophisticated fallback strategy for content extraction

async function extractContentDirectly(tabId: number): Promise<IContentExtractionResult> {
  try {
    swLogger.debug('Extracting content directly from tab:', tabId);

    // Execute extraction script directly in the page
    const results = await chrome.scripting.executeScript({
      target: { tabId },
      func: () => {
        // Direct extraction function that runs in page context
        const getPageTitle = (): string => {
          return document.title || 'Untitled';
        };

        const getPageUrl = (): string => {
          return window.location.href;
        };

        const extractMainContent = (): string => {
          // Try to find main content using semantic selectors
          const contentSelectors = [
            'article',
            '[role="article"]',
            'main',
            '[role="main"]',
            '.content',
            '#content',
            '.post-content',
            '.entry-content',
            '.article-content',
            '.page-content',
          ];

          let contentElement: Element | null = null;
          for (const selector of contentSelectors) {
            contentElement = document.querySelector(selector);
            if (
              contentElement &&
              contentElement.textContent &&
              contentElement.textContent.trim().length > 100
            ) {
              break;
            }
          }

          if (!contentElement) {
            contentElement = document.body;
          }

          return contentElement?.innerHTML || document.body.innerHTML;
        };

        const extractMetadata = (): Record<string, string> => {
          const metadata: Record<string, string> = {};

          // Extract meta tags
          const metaTags = document.querySelectorAll('meta');
          metaTags.forEach(meta => {
            const name = meta.getAttribute('name') || meta.getAttribute('property');
            const content = meta.getAttribute('content');
            if (name && content) {
              metadata[name] = content;
            }
          });

          return metadata;
        };

        return {
          title: getPageTitle(),
          url: getPageUrl(),
          html: extractMainContent(),
          metadata: extractMetadata(),
        };
      },
    });

    if (!results || results.length === 0 || !results[0].result) {
      throw new Error('Failed to execute extraction script');
    }

    const extractedData = results[0].result;
    swLogger.debug('Direct extraction completed successfully');

    return {
      success: true,
      data: {
        html: extractedData.html,
        title: extractedData.title,
        url: extractedData.url,
        metadata: extractedData.metadata,
      },
      extractionMethod: 'direct',
      timestamp: new Date().toISOString(),
    };
  } catch (error) {
    swLogger.error('Direct content extraction failed:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown extraction error',
      extractionMethod: 'direct',
      timestamp: new Date().toISOString(),
    };
  }
}
```

## GitHub API Integration (ENHANCED)

### Comprehensive GitHub Operations with Multi-Step Validation
```typescript
// Generated by Copilot
// Enhanced GitHub API operations with comprehensive testing and validation

async function testGitHubConnection(): Promise<unknown> {
  try {
    swLogger.info('Testing GitHub connection...');

    if (!settingsManager) {
      throw new Error('Settings manager not available');
    }

    const settings = await settingsManager.getSettings();

    // Validate required settings
    if (!settings.githubToken || !settings.githubRepo) {
      return {
        success: false,
        status: 'failed',
        error: 'GitHub token and repository are required',
        timestamp: new Date().toISOString(),
      };
    }

    // Parse repository
    const repoMatch = settings.githubRepo.match(/^([^\/]+)\/([^\/]+)$/);
    if (!repoMatch) {
      return {
        success: false,
        status: 'failed',
        error: 'Invalid repository format. Use "owner/repo"',
        timestamp: new Date().toISOString(),
      };
    }

    const [, owner, repo] = repoMatch;

    // Test 1: Validate GitHub token by getting user info
    swLogger.debug('Testing GitHub token...');
    const userResponse = await fetch('https://api.github.com/user', {
      headers: {
        Authorization: `token ${settings.githubToken}`,
        Accept: 'application/vnd.github.v3+json',
        'User-Agent': 'PrismWeave-Extension/1.0',
      },
    });

    if (!userResponse.ok) {
      swLogger.error('GitHub token validation failed:', userResponse.status);
      return {
        success: false,
        status: 'failed',
        error: `Invalid GitHub token (${userResponse.status})`,
        timestamp: new Date().toISOString(),
      };
    }

    const userData = await userResponse.json();
    swLogger.debug('GitHub user validated:', userData.login);

    // Test 2: Check repository access
    swLogger.debug('Testing repository access...');
    const repoResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}`, {
      headers: {
        Authorization: `token ${settings.githubToken}`,
        Accept: 'application/vnd.github.v3+json',
        'User-Agent': 'PrismWeave-Extension/1.0',
      },
    });

    if (!repoResponse.ok) {
      swLogger.error('Repository access failed:', repoResponse.status);
      const errorMsg =
        repoResponse.status === 404
          ? 'Repository not found or no access'
          : `Repository access failed (${repoResponse.status})`;
      return {
        success: false,
        status: 'failed',
        error: errorMsg,
        timestamp: new Date().toISOString(),
      };
    }

    const repoData = await repoResponse.json();
    swLogger.debug('Repository access confirmed:', repoData.full_name);

    // Test 3: Check write permissions by testing contents API
    swLogger.debug('Testing write permissions...');
    const contentsResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents`, {
      headers: {
        Authorization: `token ${settings.githubToken}`,
        Accept: 'application/vnd.github.v3+json',
        'User-Agent': 'PrismWeave-Extension/1.0',
      },
    });

    const hasWriteAccess = contentsResponse.ok;
    if (!hasWriteAccess) {
      swLogger.warn('Limited repository access - may not have write permissions');
    }

    // Success response with detailed information
    return {
      success: true,
      status: 'connected',
      message: 'GitHub connection test successful',
      details: {
        user: userData.login,
        userType: userData.type,
        repository: repoData.full_name,
        repositoryPrivate: repoData.private,
        hasWriteAccess: hasWriteAccess,
        permissions: repoData.permissions || { admin: false, push: false, pull: true },
      },
      timestamp: new Date().toISOString(),
    };
  } catch (error) {
    swLogger.error('GitHub connection test failed:', error);
    return {
      success: false,
      status: 'failed',
      error: error instanceof Error ? error.message : 'Unknown error occurred',
      timestamp: new Date().toISOString(),
    };
  }
}

async function commitToGitHub(params: {
  token: string;
  repo: string;
  filePath: string;
  content: string;
  message: string;
  url?: string;
}): Promise<{ success: boolean; data?: any; error?: string }> {
  try {
    const { token, repo, filePath, content, message } = params;

    swLogger.info('Starting GitHub commit process:', {
      repo,
      filePath,
      messageLength: message.length,
      contentLength: content.length,
    });

    // Parse repository owner and name
    const repoMatch = repo.match(/^([^\/]+)\/([^\/]+)$/);
    if (!repoMatch) {
      throw new Error('Invalid repository format');
    }

    const [, owner, repoName] = repoMatch;
    swLogger.debug('Parsed repository:', { owner, repoName });

    // Check if file already exists
    let existingFile = null;
    try {
      swLogger.debug('Checking if file already exists...');
      const existingResponse = await fetch(
        `https://api.github.com/repos/${owner}/${repoName}/contents/${filePath}`,
        {
          headers: {
            Authorization: `token ${token}`,
            Accept: 'application/vnd.github.v3+json',
            'User-Agent': 'PrismWeave-Extension/1.0',
          },
        }
      );

      if (existingResponse.ok) {
        existingFile = await existingResponse.json();
        swLogger.debug('File exists, will update with SHA:', existingFile.sha);
      } else {
        swLogger.debug(
          'File does not exist, will create new file. Status:',
          existingResponse.status
        );
      }
    } catch (error) {
      // File doesn't exist, which is fine
      swLogger.debug('File existence check failed (normal for new files):', error);
    }

    // Prepare commit data
    const commitData: any = {
      message,
      content: btoa(unescape(encodeURIComponent(content))), // Base64 encode
      branch: 'main', // Default to main branch
    };

    // Include SHA if file exists (for updates)
    if (existingFile && existingFile.sha) {
      commitData.sha = existingFile.sha;
    }

    swLogger.debug('Commit data prepared:', {
      hasMessage: !!commitData.message,
      hasContent: !!commitData.content,
      branch: commitData.branch,
      hasSha: !!commitData.sha,
    });

    // Create or update file
    const apiUrl = `https://api.github.com/repos/${owner}/${repoName}/contents/${filePath}`;
    swLogger.debug('Making GitHub API request to:', apiUrl);

    const response = await fetch(apiUrl, {
      method: 'PUT',
      headers: {
        Authorization: `token ${token}`,
        Accept: 'application/vnd.github.v3+json',
        'User-Agent': 'PrismWeave-Extension/1.0',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(commitData),
    });

    swLogger.debug('GitHub API response status:', response.status);

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      const errorMessage = `GitHub API error: ${response.status} - ${errorData.message || 'Unknown error'}`;
      swLogger.error('GitHub API error details:', { status: response.status, errorData });
      throw new Error(errorMessage);
    }

    const result = await response.json();
    swLogger.info('Successfully committed to GitHub:', result.content?.html_url);

    return {
      success: true,
      data: result.content,
    };
  } catch (error) {
    swLogger.error('GitHub commit failed:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}
```

## Error Handling and Logging

### Comprehensive Error Management
```typescript
// Generated by Copilot
// Error handling utilities (self-contained)

interface IErrorContext {
  operation: string;
  tabId?: number;
  url?: string;
  timestamp: string;
  [key: string]: unknown;
}

class ServiceWorkerErrorHandler {
  static logError(error: Error, context: Partial<IErrorContext> = {}): void {
    const errorInfo = {
      message: error.message,
      stack: error.stack,
      timestamp: new Date().toISOString(),
      context: {
        operation: 'unknown',
        ...context
      }
    };

    console.error('Service Worker Error:', errorInfo);
    
    // Store error for potential reporting
    this.storeError(errorInfo);
  }

  static async storeError(errorInfo: Record<string, unknown>): Promise<void> {
    try {
      const stored = await chrome.storage.local.get('error_log');
      const errorLog = stored.error_log || [];
      
      // Keep only last 50 errors to prevent storage bloat
      errorLog.push(errorInfo);
      if (errorLog.length > 50) {
        errorLog.shift();
      }
      
      await chrome.storage.local.set({ error_log: errorLog });
    } catch (storageError) {
      console.warn('Failed to store error:', storageError);
    }
  }

  static async getErrorLog(): Promise<Record<string, unknown>[]> {
    try {
      const stored = await chrome.storage.local.get('error_log');
      return stored.error_log || [];
    } catch (error) {
      console.error('Failed to retrieve error log:', error);
      return [];
    }
  }
}

// Global error handler
window.addEventListener('error', (event) => {
  ServiceWorkerErrorHandler.logError(
    new Error(event.message), 
    { 
      operation: 'global_error',
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno
    }
  );
});

window.addEventListener('unhandledrejection', (event) => {
  ServiceWorkerErrorHandler.logError(
    new Error(event.reason?.message || 'Unhandled promise rejection'),
    { operation: 'unhandled_rejection' }
  );
});
```

## Performance Optimization

### Memory and Performance Management
```typescript
// Generated by Copilot
// Performance optimization utilities

class ServiceWorkerPerformanceManager {
  private static operationTimes = new Map<string, number>();

  static startTimer(operation: string): void {
    this.operationTimes.set(operation, Date.now());
  }

  static endTimer(operation: string): number {
    const startTime = this.operationTimes.get(operation);
    if (!startTime) {
      console.warn(`No start time found for operation: ${operation}`);
      return 0;
    }
    
    const duration = Date.now() - startTime;
    this.operationTimes.delete(operation);
    
    console.log(`Operation ${operation} took ${duration}ms`);
    return duration;
  }

  static debounce<T extends (...args: any[]) => any>(
    func: T, 
    wait: number
  ): (...args: Parameters<T>) => void {
    let timeout: NodeJS.Timeout;
    
    return (...args: Parameters<T>) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => func(...args), wait);
    };
  }

  static throttle<T extends (...args: any[]) => any>(
    func: T, 
    limit: number
  ): (...args: Parameters<T>) => void {
    let inThrottle: boolean;
    
    return (...args: Parameters<T>) => {
      if (!inThrottle) {
        func(...args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }
}
```

### Current Performance Profile
- **Content Extraction**: Optimized with 79% test coverage
- **Service Worker**: Needs optimization (0% coverage, self-contained required)
- **Memory Management**: Critical for browser extension limits
- **Message Passing**: Async patterns with timeout handling

## Testing Considerations

### Service Worker Testing Patterns
- Mock Chrome APIs completely for unit tests
- Test message handling with various message types
- Test error scenarios and edge cases
- Test storage operations with quota limits
- Test GitHub API integration with mock responses

### Example Test Structure
```typescript
// In tests: service-worker.test.ts
describe('ServiceWorker - Message Handling', () => {
  beforeEach(() => {
    // Mock all Chrome APIs
    global.chrome = {
      storage: { sync: { get: jest.fn(), set: jest.fn() } },
      runtime: { onMessage: { addListener: jest.fn() } },
      tabs: { sendMessage: jest.fn() }
    };
  });

  test('Should handle GET_SETTINGS message', async () => {
    // Test implementation
  });
});
```

## Current Testing Status (Updated)
- **Total Tests**: 48 passing tests across 5 test suites
- **Coverage**: 18.4% overall (targeting 60%+ improvement)
- **High Priority**: Service worker (0% coverage), Error handler (0% coverage)
- **Framework**: Jest with TypeScript, jsdom environment
- **CI/CD**: Automated testing on commit/PR

## Best Practices Summary (UPDATED)

1. **ES6 Module Support**: Use modern ES6 imports with proper TypeScript configuration
2. **Error Handling**: Wrap all operations in try-catch blocks with comprehensive logging
3. **Validation**: Validate all message inputs and manager state before processing
4. **Logging**: Use structured logging (swLogger) for debugging and monitoring
5. **Storage**: Use Chrome storage APIs with fallback strategies and retry mechanisms
6. **Performance**: Implement debouncing, throttling, and timeout handling where needed
7. **Type Safety**: Leverage TypeScript imports and interfaces for better type checking
8. **Testing**: Design code to be testable with proper mocking of Chrome APIs
9. **Content Script Coordination**: Use sophisticated injection and fallback strategies
10. **GitHub Integration**: Implement multi-step validation and comprehensive error reporting

## Modern Development Patterns

### Architecture Evolution
- **OLD**: Self-contained service workers with inline implementations
- **NEW**: Modular ES6 imports with proper build pipeline support
- **Benefits**: Better code organization, type safety, maintainability, and testing

### TypeScript Configuration for Service Workers
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ES2020",
    "moduleResolution": "node",
    "strict": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true
  }
}
```

### Build Process Requirements
1. **TypeScript Compilation**: Proper ES2020 target with module support
2. **File Extension Mapping**: Use `.js` extensions in import statements for Chrome compatibility
3. **Module Resolution**: Ensure bundler/compiler properly resolves module dependencies
4. **Source Maps**: Enable source maps for debugging in Chrome DevTools

## Common Pitfalls to Avoid (UPDATED)

1. ❌ Using outdated self-contained patterns instead of ES6 modules
2. ❌ Not properly configuring TypeScript for ES6 module support
3. ❌ Missing `.js` extensions in import statements
4. ❌ Not validating message structure and data before processing
5. ❌ Missing error handling for async operations
6. ❌ Not implementing storage fallbacks and retry mechanisms
7. ❌ Forgetting to return `true` in message listeners for async responses
8. ❌ Not handling manager initialization failures gracefully
9. ❌ Missing Chrome API error checking in all operations
10. ❌ Not implementing proper timeout handling for long-running operations
11. ❌ Insufficient logging for debugging complex workflows
12. ❌ Not using structured logger (swLogger) for consistent log formatting

## Migration from Legacy Patterns

### From Self-Contained to ES6 Modules
```typescript
// BEFORE (Legacy - Self-contained)
class ServiceWorkerSettingsManager {
  // Inline implementation
}

// AFTER (Modern - ES6 Imports)
import { SettingsManager } from '../utils/settings-manager.js';
const settingsManager = new SettingsManager();
```

### Benefits of Modern Approach
- **Code Reusability**: Share utilities between service worker and other components
- **Type Safety**: Full TypeScript support with proper imports
- **Maintainability**: Centralized utility classes reduce duplication
- **Testing**: Easier to unit test modular components
- **Development Experience**: Better IDE support and intellisense
