---
applyTo: '**/service-worker.{js,ts}'
---

# Copilot Instructions for Service Worker Development - PrismWeave Project

## Service Worker Overview - PrismWeave Browser Extension

- **Manifest Version**: V3 (Chrome/Edge compatible)
- **Architecture**: Self-contained service worker with inline implementations
- **Critical Pattern**: NO external imports, all functionality must be self-contained
- **Storage**: Chrome storage APIs (sync/local) with proper error handling
- **Message Handling**: Async message processing with validation

## ⚠️ CRITICAL: Module System Requirements

### ❌ BROKEN PATTERNS (Avoid These)
```typescript
// DON'T DO THIS - Will cause "Unexpected token 'export'" errors
import { SettingsManager } from '../utils/settings-manager.js';
importScripts('../utils/helper.js');

// This will fail in Manifest V3 service workers
```

### ✅ CORRECT PATTERN (Self-Contained)
```typescript
// Generated by Copilot
// Self-contained service worker - ALL functionality inline

console.log('Service Worker starting...');

// 1. Define ALL interfaces inline (no imports)
interface IMessageData {
  type: string;
  data?: Record<string, unknown>;
  timestamp?: number;
}

interface ISettingsData {
  githubToken?: string;
  githubRepo?: string;
  autoCommit?: boolean;
  defaultFolder?: string;
  [key: string]: unknown;
}

// 2. Implement ALL classes inline (no external dependencies)
class ServiceWorkerSettingsManager {
  private static readonly SETTINGS_KEY = 'prismweave_settings';

  async getSettings(): Promise<ISettingsData> {
    try {
      const result = await chrome.storage.sync.get(ServiceWorkerSettingsManager.SETTINGS_KEY);
      return result[ServiceWorkerSettingsManager.SETTINGS_KEY] || this.getDefaultSettings();
    } catch (error) {
      console.error('Error getting settings:', error);
      return this.getDefaultSettings();
    }
  }

  private getDefaultSettings(): ISettingsData {
    return {
      githubToken: '',
      githubRepo: '',
      autoCommit: true,
      defaultFolder: 'unsorted'
    };
  }

  async updateSettings(settings: Partial<ISettingsData>): Promise<void> {
    try {
      const current = await this.getSettings();
      const updated = { ...current, ...settings };
      await chrome.storage.sync.set({
        [ServiceWorkerSettingsManager.SETTINGS_KEY]: updated
      });
    } catch (error) {
      console.error('Error updating settings:', error);
      throw error;
    }
  }
}

// 3. Initialize managers with error handling
let settingsManager: ServiceWorkerSettingsManager;
try {
  settingsManager = new ServiceWorkerSettingsManager();
  console.log('Service worker managers initialized');
} catch (error) {
  console.error('Failed to initialize service worker:', error);
}
```

## Message Handling Pattern

### Complete Message Handler Template
```typescript
// Generated by Copilot
// Robust message handling with validation and error handling

interface IMessageResponse {
  success: boolean;
  data?: unknown;
  error?: string;
}

chrome.runtime.onMessage.addListener((
  message: IMessageData,
  sender: chrome.runtime.MessageSender,
  sendResponse: (response: IMessageResponse) => void
) => {
  console.log('Received message:', message.type);
  
  // Handle message asynchronously
  handleMessage(message, sender)
    .then(result => {
      console.log('Message handled successfully:', message.type);
      sendResponse({ success: true, data: result });
    })
    .catch(error => {
      console.error('Error handling message:', message.type, error);
      sendResponse({ success: false, error: error.message });
    });
  
  return true; // Keep message channel open for async response
});

async function handleMessage(message: IMessageData, sender: chrome.runtime.MessageSender): Promise<unknown> {
  // 1. Validate message structure
  if (!message || typeof message.type !== 'string') {
    throw new Error('Invalid message format');
  }

  // 2. Validate manager initialization
  if (!settingsManager) {
    throw new Error('Service worker not properly initialized');
  }

  // 3. Handle specific message types
  switch (message.type) {
    case 'GET_SETTINGS':
      return await settingsManager.getSettings();
      
    case 'UPDATE_SETTINGS':
      if (!message.data || typeof message.data !== 'object') {
        throw new Error('Invalid settings data provided');
      }
      await settingsManager.updateSettings(message.data as Partial<ISettingsData>);
      return { success: true };
      
    case 'CAPTURE_PAGE':
      return await handleCapturePage(message.data, sender);
      
    case 'TEST_GITHUB_CONNECTION':
      return await testGitHubConnection();
      
    case 'GET_STATUS':
      return {
        initialized: !!settingsManager,
        version: chrome.runtime.getManifest().version,
        timestamp: new Date().toISOString()
      };
      
    default:
      throw new Error(`Unknown message type: ${message.type}`);
  }
}
```

## Chrome Extension Lifecycle Management

### Installation and Updates
```typescript
// Generated by Copilot
// Extension lifecycle management

chrome.runtime.onInstalled.addListener(async (details: chrome.runtime.InstalledDetails) => {
  try {
    console.log('Extension event:', details.reason);
    
    switch (details.reason) {
      case 'install':
        console.log('Extension installed for the first time');
        await initializeExtension();
        break;
        
      case 'update':
        console.log('Extension updated from version:', details.previousVersion);
        await handleExtensionUpdate(details.previousVersion);
        break;
        
      case 'chrome_update':
        console.log('Chrome browser updated');
        break;
    }
  } catch (error) {
    console.error('Error handling installation:', error);
  }
});

async function initializeExtension(): Promise<void> {
  try {
    // Set up default settings
    const defaultSettings = settingsManager ? await settingsManager.getSettings() : {};
    console.log('Extension initialized with settings:', defaultSettings);
  } catch (error) {
    console.error('Extension initialization failed:', error);
  }
}

async function handleExtensionUpdate(previousVersion?: string): Promise<void> {
  try {
    console.log('Updating extension from version:', previousVersion);
    // Migration logic if needed
  } catch (error) {
    console.error('Extension update failed:', error);
  }
}
```

## Chrome Storage Integration

### Storage Patterns with Error Handling
```typescript
// Generated by Copilot
// Chrome storage operations with comprehensive error handling

class ServiceWorkerStorageManager {
  private static readonly MAX_RETRIES = 3;
  private static readonly RETRY_DELAY = 1000;

  static async safeStorageGet<T = Record<string, unknown>>(
    keys: string | string[] | Record<string, unknown>
  ): Promise<T> {
    for (let attempt = 1; attempt <= this.MAX_RETRIES; attempt++) {
      try {
        return await new Promise<T>((resolve, reject) => {
          chrome.storage.sync.get(keys, (result: T) => {
            if (chrome.runtime.lastError) {
              reject(new Error(chrome.runtime.lastError.message));
            } else {
              resolve(result);
            }
          });
        });
      } catch (error) {
        console.warn(`Storage get attempt ${attempt} failed:`, error);
        
        if (attempt === this.MAX_RETRIES) {
          // Try local storage as fallback
          try {
            return await new Promise<T>((resolve, reject) => {
              chrome.storage.local.get(keys, (result: T) => {
                if (chrome.runtime.lastError) {
                  reject(new Error(chrome.runtime.lastError.message));
                } else {
                  resolve(result);
                }
              });
            });
          } catch (localError) {
            console.error('Both sync and local storage failed:', localError);
            throw new Error('Storage unavailable');
          }
        }
        
        await this.delay(this.RETRY_DELAY * attempt);
      }
    }
    
    throw new Error('Storage operation failed after retries');
  }

  static async safeStorageSet(data: Record<string, unknown>): Promise<void> {
    try {
      await new Promise<void>((resolve, reject) => {
        chrome.storage.sync.set(data, () => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
          } else {
            resolve();
          }
        });
      });
    } catch (error) {
      console.warn('Sync storage failed, trying local:', error);
      
      // Fallback to local storage
      await new Promise<void>((resolve, reject) => {
        chrome.storage.local.set(data, () => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
          } else {
            resolve();
          }
        });
      });
    }
  }

  private static delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

## Content Script Integration

### Content Script Injection and Communication
```typescript
// Generated by Copilot
// Content script injection and message handling

async function handleCapturePage(data: Record<string, unknown> = {}, sender: chrome.runtime.MessageSender): Promise<unknown> {
  try {
    const tabId = sender.tab?.id;
    if (!tabId) {
      throw new Error('No tab ID available for capture');
    }

    // Ensure content script is injected
    await ensureContentScriptInjected(tabId);
    
    // Send extraction request to content script
    const result = await sendMessageToTab(tabId, 'EXTRACT_CONTENT', data);
    
    // Process the extracted content
    return await processExtractedContent(result, tabId);
    
  } catch (error) {
    console.error('Error in handleCapturePage:', error);
    throw error;
  }
}

async function ensureContentScriptInjected(tabId: number): Promise<void> {
  try {
    // Test if content script is already injected
    await sendMessageToTab(tabId, 'PING', {});
  } catch (error) {
    // Content script not injected, inject it
    console.log('Injecting content script into tab:', tabId);
    
    await chrome.scripting.executeScript({
      target: { tabId },
      files: ['content/content-script.js']
    });
    
    // Wait a moment for injection to complete
    await new Promise(resolve => setTimeout(resolve, 100));
  }
}

async function sendMessageToTab<T = unknown>(
  tabId: number, 
  type: string, 
  data: Record<string, unknown> = {}
): Promise<T> {
  return new Promise<T>((resolve, reject) => {
    chrome.tabs.sendMessage(
      tabId,
      { type, data, timestamp: Date.now() },
      (response) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else if (response?.success === false) {
          reject(new Error(response.error || 'Tab message failed'));
        } else {
          resolve(response?.data as T);
        }
      }
    );
  });
}
```

## GitHub API Integration

### GitHub Operations in Service Worker
```typescript
// Generated by Copilot
// GitHub API operations (self-contained in service worker)

async function testGitHubConnection(): Promise<{ status: string; message: string }> {
  try {
    const settings = await settingsManager.getSettings();
    
    if (!settings.githubToken || !settings.githubRepo) {
      return { 
        status: 'error', 
        message: 'GitHub token and repository must be configured' 
      };
    }

    const [owner, repo] = settings.githubRepo.split('/');
    if (!owner || !repo) {
      return { 
        status: 'error', 
        message: 'Invalid repository format. Use: owner/repository' 
      };
    }

    const response = await fetch(`https://api.github.com/repos/${owner}/${repo}`, {
      headers: {
        'Authorization': `token ${settings.githubToken}`,
        'Accept': 'application/vnd.github.v3+json',
        'User-Agent': 'PrismWeave-Extension/1.0'
      }
    });

    if (response.ok) {
      const repoData = await response.json();
      return { 
        status: 'success', 
        message: `Connected to ${repoData.full_name}` 
      };
    } else {
      const errorText = await response.text();
      return { 
        status: 'error', 
        message: `GitHub API error: ${response.status} - ${errorText}` 
      };
    }
    
  } catch (error) {
    console.error('GitHub connection test failed:', error);
    return { 
      status: 'error', 
      message: `Connection failed: ${error.message}` 
    };
  }
}

async function commitToGitHub(
  filePath: string, 
  content: string, 
  message: string
): Promise<{ success: boolean; url?: string; error?: string }> {
  try {
    const settings = await settingsManager.getSettings();
    
    if (!settings.githubToken || !settings.githubRepo) {
      throw new Error('GitHub credentials not configured');
    }

    const [owner, repo] = settings.githubRepo.split('/');
    const apiUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`;

    // Get current file SHA if it exists
    let sha: string | undefined;
    try {
      const existingResponse = await fetch(apiUrl, {
        headers: {
          'Authorization': `token ${settings.githubToken}`,
          'Accept': 'application/vnd.github.v3+json'
        }
      });
      
      if (existingResponse.ok) {
        const existingFile = await existingResponse.json();
        sha = existingFile.sha;
      }
    } catch (error) {
      // File doesn't exist, which is fine
      console.log('File does not exist yet, creating new file');
    }

    const commitData = {
      message,
      content: btoa(unescape(encodeURIComponent(content))),
      ...(sha && { sha })
    };

    const response = await fetch(apiUrl, {
      method: 'PUT',
      headers: {
        'Authorization': `token ${settings.githubToken}`,
        'Content-Type': 'application/json',
        'Accept': 'application/vnd.github.v3+json'
      },
      body: JSON.stringify(commitData)
    });

    if (response.ok) {
      const result = await response.json();
      return { 
        success: true, 
        url: result.content.html_url 
      };
    } else {
      const errorText = await response.text();
      throw new Error(`GitHub API error: ${response.status} - ${errorText}`);
    }

  } catch (error) {
    console.error('GitHub commit failed:', error);
    return { 
      success: false, 
      error: error.message 
    };
  }
}
```

## Error Handling and Logging

### Comprehensive Error Management
```typescript
// Generated by Copilot
// Error handling utilities (self-contained)

interface IErrorContext {
  operation: string;
  tabId?: number;
  url?: string;
  timestamp: string;
  [key: string]: unknown;
}

class ServiceWorkerErrorHandler {
  static logError(error: Error, context: Partial<IErrorContext> = {}): void {
    const errorInfo = {
      message: error.message,
      stack: error.stack,
      timestamp: new Date().toISOString(),
      context: {
        operation: 'unknown',
        ...context
      }
    };

    console.error('Service Worker Error:', errorInfo);
    
    // Store error for potential reporting
    this.storeError(errorInfo);
  }

  static async storeError(errorInfo: Record<string, unknown>): Promise<void> {
    try {
      const stored = await chrome.storage.local.get('error_log');
      const errorLog = stored.error_log || [];
      
      // Keep only last 50 errors to prevent storage bloat
      errorLog.push(errorInfo);
      if (errorLog.length > 50) {
        errorLog.shift();
      }
      
      await chrome.storage.local.set({ error_log: errorLog });
    } catch (storageError) {
      console.warn('Failed to store error:', storageError);
    }
  }

  static async getErrorLog(): Promise<Record<string, unknown>[]> {
    try {
      const stored = await chrome.storage.local.get('error_log');
      return stored.error_log || [];
    } catch (error) {
      console.error('Failed to retrieve error log:', error);
      return [];
    }
  }
}

// Global error handler
window.addEventListener('error', (event) => {
  ServiceWorkerErrorHandler.logError(
    new Error(event.message), 
    { 
      operation: 'global_error',
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno
    }
  );
});

window.addEventListener('unhandledrejection', (event) => {
  ServiceWorkerErrorHandler.logError(
    new Error(event.reason?.message || 'Unhandled promise rejection'),
    { operation: 'unhandled_rejection' }
  );
});
```

## Performance Optimization

### Memory and Performance Management
```typescript
// Generated by Copilot
// Performance optimization utilities

class ServiceWorkerPerformanceManager {
  private static operationTimes = new Map<string, number>();

  static startTimer(operation: string): void {
    this.operationTimes.set(operation, Date.now());
  }

  static endTimer(operation: string): number {
    const startTime = this.operationTimes.get(operation);
    if (!startTime) {
      console.warn(`No start time found for operation: ${operation}`);
      return 0;
    }
    
    const duration = Date.now() - startTime;
    this.operationTimes.delete(operation);
    
    console.log(`Operation ${operation} took ${duration}ms`);
    return duration;
  }

  static debounce<T extends (...args: any[]) => any>(
    func: T, 
    wait: number
  ): (...args: Parameters<T>) => void {
    let timeout: NodeJS.Timeout;
    
    return (...args: Parameters<T>) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => func(...args), wait);
    };
  }

  static throttle<T extends (...args: any[]) => any>(
    func: T, 
    limit: number
  ): (...args: Parameters<T>) => void {
    let inThrottle: boolean;
    
    return (...args: Parameters<T>) => {
      if (!inThrottle) {
        func(...args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }
}
```

## Testing Considerations

### Service Worker Testing Patterns
- Mock Chrome APIs completely for unit tests
- Test message handling with various message types
- Test error scenarios and edge cases
- Test storage operations with quota limits
- Test GitHub API integration with mock responses

### Example Test Structure
```typescript
// In tests: service-worker.test.ts
describe('ServiceWorker - Message Handling', () => {
  beforeEach(() => {
    // Mock all Chrome APIs
    global.chrome = {
      storage: { sync: { get: jest.fn(), set: jest.fn() } },
      runtime: { onMessage: { addListener: jest.fn() } },
      tabs: { sendMessage: jest.fn() }
    };
  });

  test('Should handle GET_SETTINGS message', async () => {
    // Test implementation
  });
});
```

## Best Practices Summary

1. **Self-Contained**: Never use imports or external dependencies
2. **Error Handling**: Wrap all operations in try-catch blocks
3. **Validation**: Validate all message inputs and manager state
4. **Logging**: Include comprehensive logging for debugging
5. **Storage**: Use Chrome storage APIs with fallbacks
6. **Performance**: Implement debouncing and throttling where needed
7. **Type Safety**: Define all interfaces inline with proper typing
8. **Testing**: Design code to be testable with proper mocking

## Common Pitfalls to Avoid

1. ❌ Using import/export statements in service workers
2. ❌ Depending on external utility files  
3. ❌ Not validating message structure and data
4. ❌ Missing error handling for async operations
5. ❌ Not implementing storage fallbacks
6. ❌ Forgetting to return `true` in message listeners
7. ❌ Not handling manager initialization failures
8. ❌ Missing Chrome API error checking
