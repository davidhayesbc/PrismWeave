---
applyTo: '**/*.{ts,tsx}'
---

# Copilot Instructions for TypeScript Development - PrismWeave Project

## TypeScript Overview - PrismWeave Project

- **Target**: ES2020 with strict TypeScript configuration
- **Module System**: CommonJS for browser extension, ES6 modules for other components
- **Testing**: Jest with TypeScript support and comprehensive type checking
- **Build Process**: TypeScript compilation with proper type declaration generation
- **Architecture**: Strongly typed interfaces for cross-component communication

## TypeScript Configuration Standards

### Core TypeScript Configuration
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",  // For browser extension compatibility
    "lib": ["ES2020", "DOM"],
    "moduleResolution": "node",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "typeRoots": ["./node_modules/@types", "./src/types"],
    "types": ["chrome", "jest", "node"]
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts", "coverage"]
}
```

### Project-Specific TypeScript Patterns

#### Interface Design for PrismWeave
```typescript
// Generated by Copilot
// Core type definitions for PrismWeave project

// Document management interfaces
interface IDocument {
  readonly id: string;
  title: string;
  content: string;
  markdown: string;
  url: string;
  domain: string;
  tags: string[];
  metadata: IDocumentMetadata;
  extractedAt: Date;
  lastModified: Date;
  version: number;
}

interface IDocumentMetadata {
  readonly sourceUrl: string;
  readonly originalTitle: string;
  author?: string;
  publishedAt?: Date;
  description?: string;
  keywords: string[];
  images: string[];
  wordCount: number;
  readingTime: number;
  language: string;
  [key: string]: unknown;
}

// Content extraction interfaces
interface IExtractionConfig {
  includeImages: boolean;
  includeLinks: boolean;
  cleanHtml: boolean;
  customSelectors: string[];
  excludeSelectors: string[];
  maxWordCount?: number;
  preserveFormatting: boolean;
}

interface IExtractionResult {
  success: boolean;
  document?: IDocument;
  error?: IExtractionError;
  warnings: string[];
  extractionTime: number;
  byteSize: number;
}

interface IExtractionError {
  code: ExtractionErrorCode;
  message: string;
  details?: Record<string, unknown>;
  stack?: string;
}

// Settings and configuration interfaces
interface ISettings {
  github: IGitHubSettings;
  extraction: IExtractionConfig;
  ai: IAISettings;
  general: IGeneralSettings;
}

interface IGitHubSettings {
  token: string;
  repository: string;
  branch: string;
  autoCommit: boolean;
  commitMessageTemplate: string;
  folderStructure: IFolderStructure;
}

interface IAISettings {
  ollamaEndpoint: string;
  defaultModel: string;
  enableProcessing: boolean;
  batchSize: number;
  maxTokens: number;
}

interface IGeneralSettings {
  theme: 'light' | 'dark' | 'auto';
  autoSync: boolean;
  debugMode: boolean;
  maxStorageSize: number;
  retentionDays: number;
}

// Message passing interfaces
interface IMessage<T = Record<string, unknown>> {
  readonly type: string;
  readonly id: string;
  data: T;
  timestamp: number;
  source: MessageSource;
  target?: MessageTarget;
}

interface IMessageResponse<T = unknown> {
  readonly messageId: string;
  success: boolean;
  data?: T;
  error?: IError;
  timestamp: number;
}

// Error handling interfaces
interface IError {
  code: string;
  message: string;
  details?: Record<string, unknown>;
  stack?: string;
  timestamp: Date;
  context: string;
}

// Utility types for the project
type MessageSource = 'service-worker' | 'content-script' | 'popup' | 'options' | 'vscode-extension';
type MessageTarget = MessageSource;
type ExtractionErrorCode = 'NETWORK_ERROR' | 'PARSING_ERROR' | 'TIMEOUT' | 'PERMISSION_DENIED' | 'INVALID_CONTENT';
type DocumentStatus = 'draft' | 'extracted' | 'processed' | 'synced' | 'error';
type SyncStatus = 'pending' | 'syncing' | 'synced' | 'conflict' | 'error';
```

## Type-Safe Class Patterns

### Generic Service Classes
```typescript
// Generated by Copilot
// Generic service class with comprehensive type safety

abstract class BaseService<TConfig extends Record<string, unknown>, TResult> {
  protected readonly _config: Readonly<TConfig>;
  private _isInitialized: boolean = false;
  private _lastError: IError | null = null;

  constructor(config: TConfig) {
    this._config = Object.freeze({ ...config });
  }

  async initialize(): Promise<void> {
    if (this._isInitialized) {
      return;
    }

    try {
      await this.onInitialize();
      this._isInitialized = true;
      this._lastError = null;
    } catch (error) {
      this._lastError = this.createError(error as Error, 'initialization');
      throw this._lastError;
    }
  }

  protected abstract onInitialize(): Promise<void>;

  async execute<TInput = unknown>(input: TInput): Promise<TResult> {
    if (!this._isInitialized) {
      throw new Error('Service must be initialized before use');
    }

    try {
      return await this.onExecute(input);
    } catch (error) {
      this._lastError = this.createError(error as Error, 'execution');
      throw this._lastError;
    }
  }

  protected abstract onExecute<TInput>(input: TInput): Promise<TResult>;

  get isInitialized(): boolean {
    return this._isInitialized;
  }

  get lastError(): IError | null {
    return this._lastError;
  }

  get config(): Readonly<TConfig> {
    return this._config;
  }

  private createError(error: Error, context: string): IError {
    return {
      code: `${this.constructor.name.toUpperCase()}_ERROR`,
      message: error.message,
      stack: error.stack,
      timestamp: new Date(),
      context: `${this.constructor.name}.${context}`
    };
  }
}

// Example implementation
class ContentExtractionService extends BaseService<IExtractionConfig, IExtractionResult> {
  private _converter: MarkdownConverter | null = null;

  protected async onInitialize(): Promise<void> {
    this._converter = new MarkdownConverter(this._config);
    await this._converter.initialize();
  }

  protected async onExecute<string>(url: string): Promise<IExtractionResult> {
    if (!this._converter) {
      throw new Error('Converter not initialized');
    }

    const startTime = Date.now();
    
    try {
      const document = await this.extractDocument(url);
      const extractionTime = Date.now() - startTime;
      
      return {
        success: true,
        document,
        warnings: [],
        extractionTime,
        byteSize: new Blob([document.content]).size
      };
    } catch (error) {
      return {
        success: false,
        error: this.createExtractionError(error as Error),
        warnings: [],
        extractionTime: Date.now() - startTime,
        byteSize: 0
      };
    }
  }

  private async extractDocument(url: string): Promise<IDocument> {
    // Implementation here
    throw new Error('Not implemented');
  }

  private createExtractionError(error: Error): IExtractionError {
    return {
      code: 'PARSING_ERROR',
      message: error.message,
      details: { url: window.location.href },
      stack: error.stack
    };
  }
}
```

### Type-Safe Event Emitters
```typescript
// Generated by Copilot
// Type-safe event emitter with strict typing

type EventMap = {
  'document:extracted': { document: IDocument };
  'document:updated': { document: IDocument; changes: string[] };
  'document:deleted': { documentId: string };
  'sync:started': { operation: string };
  'sync:completed': { operation: string; result: unknown };
  'sync:failed': { operation: string; error: IError };
  'settings:changed': { settings: Partial<ISettings> };
  'error:occurred': { error: IError };
};

class TypedEventEmitter<TEventMap extends Record<string, unknown>> {
  private _listeners = new Map<keyof TEventMap, Set<Function>>();

  on<TEvent extends keyof TEventMap>(
    event: TEvent,
    listener: (data: TEventMap[TEvent]) => void
  ): void {
    if (!this._listeners.has(event)) {
      this._listeners.set(event, new Set());
    }
    this._listeners.get(event)!.add(listener);
  }

  off<TEvent extends keyof TEventMap>(
    event: TEvent,
    listener: (data: TEventMap[TEvent]) => void
  ): void {
    const listeners = this._listeners.get(event);
    if (listeners) {
      listeners.delete(listener);
    }
  }

  emit<TEvent extends keyof TEventMap>(
    event: TEvent,
    data: TEventMap[TEvent]
  ): void {
    const listeners = this._listeners.get(event);
    if (listeners) {
      listeners.forEach(listener => {
        try {
          listener(data);
        } catch (error) {
          console.error(`Error in event listener for ${String(event)}:`, error);
        }
      });
    }
  }

  once<TEvent extends keyof TEventMap>(
    event: TEvent,
    listener: (data: TEventMap[TEvent]) => void
  ): void {
    const onceListener = (data: TEventMap[TEvent]) => {
      this.off(event, onceListener);
      listener(data);
    };
    this.on(event, onceListener);
  }

  removeAllListeners<TEvent extends keyof TEventMap>(event?: TEvent): void {
    if (event) {
      this._listeners.delete(event);
    } else {
      this._listeners.clear();
    }
  }

  listenerCount<TEvent extends keyof TEventMap>(event: TEvent): number {
    return this._listeners.get(event)?.size || 0;
  }
}

// Usage example
const eventBus = new TypedEventEmitter<EventMap>();

// Type-safe event handling
eventBus.on('document:extracted', (data) => {
  // data is automatically typed as { document: IDocument }
  console.log('Document extracted:', data.document.title);
});

eventBus.emit('document:extracted', { 
  document: extractedDocument // Must match IDocument interface
});
```

### Advanced Generic Utilities
```typescript
// Generated by Copilot
// Advanced TypeScript utilities for PrismWeave

// Conditional type for async result handling
type AsyncResult<T> = Promise<{
  success: true;
  data: T;
} | {
  success: false;
  error: IError;
}>;

// Utility for safe async operations
async function safeAsync<T>(
  operation: () => Promise<T>,
  context: string = 'unknown'
): AsyncResult<T> {
  try {
    const data = await operation();
    return { success: true, data };
  } catch (error) {
    return {
      success: false,
      error: {
        code: 'ASYNC_ERROR',
        message: (error as Error).message,
        stack: (error as Error).stack,
        timestamp: new Date(),
        context
      }
    };
  }
}

// Type-safe configuration validator
type ConfigValidator<T> = {
  [K in keyof T]: (value: unknown) => value is T[K];
};

class TypeSafeConfig<T extends Record<string, unknown>> {
  private _config: T;
  private _validators: ConfigValidator<T>;

  constructor(initialConfig: T, validators: ConfigValidator<T>) {
    this._config = { ...initialConfig };
    this._validators = validators;
    this.validate();
  }

  get<K extends keyof T>(key: K): T[K] {
    return this._config[key];
  }

  set<K extends keyof T>(key: K, value: T[K]): void {
    if (!this._validators[key](value)) {
      throw new Error(`Invalid value for config key: ${String(key)}`);
    }
    this._config[key] = value;
  }

  update(updates: Partial<T>): void {
    for (const [key, value] of Object.entries(updates)) {
      if (key in this._validators) {
        this.set(key as keyof T, value as T[keyof T]);
      }
    }
  }

  toJSON(): T {
    return { ...this._config };
  }

  private validate(): void {
    for (const [key, validator] of Object.entries(this._validators)) {
      const value = this._config[key as keyof T];
      if (!validator(value)) {
        throw new Error(`Invalid configuration value for: ${key}`);
      }
    }
  }
}

// Branded types for better type safety
type DocumentId = string & { readonly __brand: 'DocumentId' };
type Timestamp = number & { readonly __brand: 'Timestamp' };
type URL = string & { readonly __brand: 'URL' };

// Type guards for branded types
function isDocumentId(value: string): value is DocumentId {
  return /^doc_[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/.test(value);
}

function isTimestamp(value: number): value is Timestamp {
  return Number.isInteger(value) && value > 0;
}

function isValidURL(value: string): value is URL {
  try {
    new globalThis.URL(value);
    return true;
  } catch {
    return false;
  }
}

// Factory functions for branded types
function createDocumentId(): DocumentId {
  const uuid = crypto.randomUUID();
  return `doc_${uuid}` as DocumentId;
}

function createTimestamp(): Timestamp {
  return Date.now() as Timestamp;
}

function createURL(urlString: string): URL {
  if (!isValidURL(urlString)) {
    throw new Error(`Invalid URL: ${urlString}`);
  }
  return urlString as URL;
}
```

## Async/Await Patterns

### Promise-Based API Wrappers
```typescript
// Generated by Copilot
// Type-safe Chrome API wrappers with proper async/await

class ChromeStorageWrapper {
  static async get<T = Record<string, unknown>>(
    keys: string | string[] | Record<string, unknown>,
    useSync: boolean = true
  ): Promise<T> {
    const storage = useSync ? chrome.storage.sync : chrome.storage.local;
    
    return new Promise<T>((resolve, reject) => {
      storage.get(keys, (result: T) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve(result);
        }
      });
    });
  }

  static async set(
    data: Record<string, unknown>,
    useSync: boolean = true
  ): Promise<void> {
    const storage = useSync ? chrome.storage.sync : chrome.storage.local;
    
    return new Promise<void>((resolve, reject) => {
      storage.set(data, () => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve();
        }
      });
    });
  }

  static async remove(
    keys: string | string[],
    useSync: boolean = true
  ): Promise<void> {
    const storage = useSync ? chrome.storage.sync : chrome.storage.local;
    
    return new Promise<void>((resolve, reject) => {
      storage.remove(keys, () => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve();
        }
      });
    });
  }
}

class ChromeTabsWrapper {
  static async sendMessage<TRequest, TResponse>(
    tabId: number,
    message: TRequest
  ): Promise<TResponse> {
    return new Promise<TResponse>((resolve, reject) => {
      chrome.tabs.sendMessage(tabId, message, (response: TResponse) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve(response);
        }
      });
    });
  }

  static async query(queryInfo: chrome.tabs.QueryInfo): Promise<chrome.tabs.Tab[]> {
    return new Promise<chrome.tabs.Tab[]>((resolve, reject) => {
      chrome.tabs.query(queryInfo, (tabs) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve(tabs);
        }
      });
    });
  }

  static async executeScript<TResult>(
    tabId: number,
    details: chrome.scripting.ScriptInjection
  ): Promise<TResult[]> {
    return new Promise<TResult[]>((resolve, reject) => {
      chrome.scripting.executeScript({
        target: { tabId },
        ...details
      }, (results) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve(results.map(r => r.result));
        }
      });
    });
  }
}
```

### Async Iteration and Processing
```typescript
// Generated by Copilot
// Type-safe async iteration patterns

class AsyncProcessor<TInput, TOutput> {
  private _concurrency: number;
  private _timeout: number;

  constructor(concurrency: number = 3, timeout: number = 30000) {
    this._concurrency = concurrency;
    this._timeout = timeout;
  }

  async processAll(
    items: TInput[],
    processor: (item: TInput) => Promise<TOutput>
  ): Promise<Array<{ success: true; result: TOutput } | { success: false; error: Error }>> {
    const chunks = this.chunkArray(items, this._concurrency);
    const results: Array<{ success: true; result: TOutput } | { success: false; error: Error }> = [];

    for (const chunk of chunks) {
      const chunkPromises = chunk.map(async (item) => {
        try {
          const result = await this.withTimeout(processor(item), this._timeout);
          return { success: true as const, result };
        } catch (error) {
          return { success: false as const, error: error as Error };
        }
      });

      const chunkResults = await Promise.all(chunkPromises);
      results.push(...chunkResults);
    }

    return results;
  }

  async *processStream(
    items: TInput[],
    processor: (item: TInput) => Promise<TOutput>
  ): AsyncGenerator<{ success: true; result: TOutput } | { success: false; error: Error }, void, unknown> {
    for (const item of items) {
      try {
        const result = await this.withTimeout(processor(item), this._timeout);
        yield { success: true as const, result };
      } catch (error) {
        yield { success: false as const, error: error as Error };
      }
    }
  }

  private chunkArray<T>(array: T[], chunkSize: number): T[][] {
    const chunks: T[][] = [];
    for (let i = 0; i < array.length; i += chunkSize) {
      chunks.push(array.slice(i, i + chunkSize));
    }
    return chunks;
  }

  private async withTimeout<T>(promise: Promise<T>, timeout: number): Promise<T> {
    const timeoutPromise = new Promise<never>((_, reject) => {
      setTimeout(() => reject(new Error(`Operation timed out after ${timeout}ms`)), timeout);
    });

    return Promise.race([promise, timeoutPromise]);
  }
}
```

## Error Handling and Validation

### Comprehensive Error Types
```typescript
// Generated by Copilot
// Comprehensive error handling with type safety

abstract class BaseError extends Error {
  abstract readonly code: string;
  readonly timestamp: Date;
  readonly context: string;
  readonly details: Record<string, unknown>;

  constructor(
    message: string,
    context: string = 'unknown',
    details: Record<string, unknown> = {}
  ) {
    super(message);
    this.name = this.constructor.name;
    this.timestamp = new Date();
    this.context = context;
    this.details = details;
    
    // Maintain proper stack trace
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }

  toJSON(): Record<string, unknown> {
    return {
      name: this.name,
      code: this.code,
      message: this.message,
      timestamp: this.timestamp.toISOString(),
      context: this.context,
      details: this.details,
      stack: this.stack
    };
  }
}

class ValidationError extends BaseError {
  readonly code = 'VALIDATION_ERROR' as const;
  readonly field: string;

  constructor(field: string, message: string, details: Record<string, unknown> = {}) {
    super(`Validation failed for field '${field}': ${message}`, 'validation', details);
    this.field = field;
  }
}

class NetworkError extends BaseError {
  readonly code = 'NETWORK_ERROR' as const;
  readonly statusCode?: number;

  constructor(message: string, statusCode?: number, details: Record<string, unknown> = {}) {
    super(message, 'network', details);
    this.statusCode = statusCode;
  }
}

class ExtractionError extends BaseError {
  readonly code = 'EXTRACTION_ERROR' as const;
  readonly extractionType: 'content' | 'metadata' | 'images';

  constructor(
    extractionType: 'content' | 'metadata' | 'images',
    message: string,
    details: Record<string, unknown> = {}
  ) {
    super(message, `extraction:${extractionType}`, details);
    this.extractionType = extractionType;
  }
}

// Type guards for error handling
function isValidationError(error: unknown): error is ValidationError {
  return error instanceof ValidationError;
}

function isNetworkError(error: unknown): error is NetworkError {
  return error instanceof NetworkError;
}

function isExtractionError(error: unknown): error is ExtractionError {
  return error instanceof ExtractionError;
}

// Result type for operations that can fail
type Result<T, E extends BaseError = BaseError> = {
  success: true;
  data: T;
} | {
  success: false;
  error: E;
};

// Helper function to create Result types
function createResult<T, E extends BaseError = BaseError>(
  data: T
): Result<T, E> {
  return { success: true, data };
}

function createError<T, E extends BaseError = BaseError>(
  error: E
): Result<T, E> {
  return { success: false, error };
}
```

### Type-Safe Validation
```typescript
// Generated by Copilot
// Comprehensive validation with TypeScript

interface ValidationRule<T> {
  validate: (value: T) => boolean;
  message: string;
}

class Validator<T> {
  private _rules: ValidationRule<T>[] = [];

  add(rule: ValidationRule<T>): this {
    this._rules.push(rule);
    return this;
  }

  required(message: string = 'Field is required'): this {
    return this.add({
      validate: (value) => value !== null && value !== undefined && value !== '',
      message
    });
  }

  minLength(min: number, message?: string): this {
    return this.add({
      validate: (value) => typeof value === 'string' && value.length >= min,
      message: message || `Minimum length is ${min}`
    });
  }

  maxLength(max: number, message?: string): this {
    return this.add({
      validate: (value) => typeof value === 'string' && value.length <= max,
      message: message || `Maximum length is ${max}`
    });
  }

  pattern(regex: RegExp, message?: string): this {
    return this.add({
      validate: (value) => typeof value === 'string' && regex.test(value),
      message: message || 'Invalid format'
    });
  }

  custom(validate: (value: T) => boolean, message: string): this {
    return this.add({ validate, message });
  }

  validate(value: T): ValidationResult {
    const errors: string[] = [];

    for (const rule of this._rules) {
      if (!rule.validate(value)) {
        errors.push(rule.message);
      }
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }
}

interface ValidationResult {
  isValid: boolean;
  errors: string[];
}

// Schema validation for complex objects
type ValidationSchema<T> = {
  [K in keyof T]: Validator<T[K]>;
};

class ObjectValidator<T extends Record<string, unknown>> {
  private _schema: ValidationSchema<T>;

  constructor(schema: ValidationSchema<T>) {
    this._schema = schema;
  }

  validate(obj: T): { isValid: boolean; errors: Record<keyof T, string[]> } {
    const errors: Record<keyof T, string[]> = {} as Record<keyof T, string[]>;
    let isValid = true;

    for (const [key, validator] of Object.entries(this._schema)) {
      const result = (validator as Validator<unknown>).validate(obj[key as keyof T]);
      if (!result.isValid) {
        errors[key as keyof T] = result.errors;
        isValid = false;
      }
    }

    return { isValid, errors };
  }
}

// Example usage
const settingsValidator = new ObjectValidator<IGitHubSettings>({
  token: new Validator<string>()
    .required('GitHub token is required')
    .minLength(40, 'GitHub token must be at least 40 characters'),
  
  repository: new Validator<string>()
    .required('Repository is required')
    .pattern(/^[\w\-\.]+\/[\w\-\.]+$/, 'Repository must be in format: owner/repo'),
  
  branch: new Validator<string>()
    .required('Branch is required')
    .pattern(/^[\w\-\/]+$/, 'Invalid branch name'),
  
  autoCommit: new Validator<boolean>()
    .required('Auto commit setting is required'),
  
  commitMessageTemplate: new Validator<string>()
    .required('Commit message template is required')
    .minLength(10, 'Commit message template too short')
});
```

## Testing TypeScript Code

### Type-Safe Test Utilities
```typescript
// Generated by Copilot
// Type-safe testing utilities for TypeScript

// Mock factory with type safety
class TypedMockFactory {
  static createMock<T extends Record<string, unknown>>(
    partial: Partial<T> = {}
  ): jest.Mocked<T> {
    const mock = partial as jest.Mocked<T>;
    
    return new Proxy(mock, {
      get(target, prop) {
        if (prop in target) {
          return target[prop as keyof T];
        }
        
        // Auto-create jest.fn() for missing methods
        if (typeof prop === 'string') {
          const fn = jest.fn();
          target[prop as keyof T] = fn as T[keyof T];
          return fn;
        }
        
        return undefined;
      }
    });
  }

  static createPartialMock<T extends Record<string, unknown>>(
    implementation: Partial<T>
  ): jest.Mocked<T> {
    return this.createMock<T>(implementation);
  }
}

// Type-safe test data builders
class DocumentBuilder {
  private _document: Partial<IDocument> = {};

  static create(): DocumentBuilder {
    return new DocumentBuilder();
  }

  withId(id: DocumentId): this {
    this._document.id = id;
    return this;
  }

  withTitle(title: string): this {
    this._document.title = title;
    return this;
  }

  withUrl(url: URL): this {
    this._document.url = url;
    return this;
  }

  withContent(content: string): this {
    this._document.content = content;
    return this;
  }

  withTags(tags: string[]): this {
    this._document.tags = tags;
    return this;
  }

  build(): IDocument {
    const defaults: IDocument = {
      id: createDocumentId(),
      title: 'Test Document',
      content: 'Test content',
      markdown: '# Test Document\n\nTest content',
      url: 'https://example.com' as URL,
      domain: 'example.com',
      tags: [],
      metadata: {
        sourceUrl: 'https://example.com' as URL,
        originalTitle: 'Test Document',
        keywords: [],
        images: [],
        wordCount: 2,
        readingTime: 1,
        language: 'en'
      },
      extractedAt: new Date(),
      lastModified: new Date(),
      version: 1
    };

    return { ...defaults, ...this._document } as IDocument;
  }
}

// Test utilities with type safety
class TestUtils {
  static async expectAsync<T>(
    promise: Promise<T>
  ): Promise<jest.JestMatchers<T>> {
    const result = await promise;
    return expect(result);
  }

  static expectType<T>(value: unknown): jest.Matchers<T> {
    return expect(value) as jest.Matchers<T>;
  }

  static createAsyncMock<T extends (...args: any[]) => Promise<any>>(
    implementation?: T
  ): jest.MockedFunction<T> {
    return jest.fn(implementation) as jest.MockedFunction<T>;
  }

  static waitFor(
    condition: () => boolean,
    timeout: number = 5000,
    interval: number = 100
  ): Promise<void> {
    return new Promise((resolve, reject) => {
      const startTime = Date.now();
      
      const check = () => {
        if (condition()) {
          resolve();
        } else if (Date.now() - startTime > timeout) {
          reject(new Error('Condition not met within timeout'));
        } else {
          setTimeout(check, interval);
        }
      };
      
      check();
    });
  }
}

// Example test with type safety
describe('DocumentBuilder', () => {
  test('should build document with all required fields', () => {
    const document = DocumentBuilder.create()
      .withTitle('Test Article')
      .withContent('This is a test article')
      .withTags(['test', 'article'])
      .build();

    expect(document.title).toBe('Test Article');
    expect(document.content).toBe('This is a test article');
    expect(document.tags).toEqual(['test', 'article']);
    TestUtils.expectType<IDocument>(document);
  });

  test('should create async mock with proper typing', async () => {
    const mockExtractor = TypedMockFactory.createMock<ContentExtractionService>();
    const mockResult: IExtractionResult = {
      success: true,
      document: DocumentBuilder.create().build(),
      warnings: [],
      extractionTime: 100,
      byteSize: 1024
    };

    mockExtractor.execute.mockResolvedValue(mockResult);

    const result = await mockExtractor.execute('https://example.com');
    expect(result.success).toBe(true);
    expect(result.document?.title).toBe('Test Document');
  });
});
```

## Best Practices Summary

1. **Strict Type Safety**: Use strict TypeScript configuration with comprehensive type checking
2. **Interface Design**: Create clear, comprehensive interfaces for all data structures
3. **Generic Programming**: Leverage TypeScript generics for reusable, type-safe components
4. **Error Handling**: Use custom error classes with proper type guards
5. **Async Patterns**: Use proper async/await patterns with type-safe promise handling
6. **Validation**: Implement type-safe validation for user inputs and API responses
7. **Testing**: Use type-safe testing utilities and builders for reliable tests
8. **Branded Types**: Use branded types for better type safety where appropriate
9. **Event Handling**: Implement type-safe event emitters for inter-component communication
10. **Configuration**: Use type-safe configuration management with validation

## Common TypeScript Pitfalls to Avoid

1. ❌ Using `any` type instead of proper typing
2. ❌ Not handling undefined/null values properly
3. ❌ Missing type guards for runtime type checking
4. ❌ Inconsistent error handling patterns
5. ❌ Not using branded types for domain-specific values
6. ❌ Improper async/await error handling
7. ❌ Missing validation for external data sources
8. ❌ Not leveraging TypeScript utility types
9. ❌ Inconsistent interface naming conventions
10. ❌ Not using proper generic constraints
