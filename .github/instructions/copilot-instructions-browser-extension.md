---
applyTo: '**/*.{js,ts}'
---

# Copilot Instructions for Browser Extension Code Generation - PrismWeave Project

<!-- Specialized instructions for generating TypeScript browser extension code for the PrismWeave project -->

## Browser Extension Overview

- **Target**: Chrome/Edge Manifest V3 extension
- **Language**: TypeScript (compiled to JavaScript)
- **Purpose**: Web page capture, content extraction, and Git synchronization
- **Architecture**: Service worker + content scripts + popup/options UI
- **Build Process**: TypeScript → JavaScript (via tsc/webpack/esbuild)

## Code Generation Guidelines

### TypeScript Configuration

- Always include proper type annotations
- Use interfaces for complex objects
- Leverage Chrome extension type definitions
- Use strict TypeScript settings
- **IMPORTANT**: Use `"module": "CommonJS"` in tsconfig.json for Chrome extension compatibility

### Chrome Extension Module Compatibility

Chrome extension service workers and content scripts have specific module system requirements:

#### Service Worker Requirements

- **NO ES6 modules**: Service workers cannot use `import`/`export` statements
- **Use CommonJS**: TypeScript must compile to CommonJS format
- **importScripts()**: Load utilities via `importScripts()` function
- **Global assignments**: Utilities must be available globally

#### Correct TypeScript Configuration

```json
{
  "compilerOptions": {
    "module": "CommonJS", // CRITICAL: Not "ES2020" or "ESNext"
    "target": "ES2020",
    "moduleResolution": "node"
  }
}
```

#### Service Worker Pattern (UPDATED - Self-Contained)

```typescript
// Generated by Copilot
// Self-contained service worker - NO external dependencies

// Define interfaces inline (no imports)
interface IMessageData {
  type: string;
  data?: Record<string, unknown>;
  timestamp?: number;
}

interface ISettingsData {
  githubToken?: string;
  githubRepo?: string;
  [key: string]: unknown;
}

// Self-contained settings manager
class ServiceWorkerSettingsManager {
  private static readonly SETTINGS_KEY = 'app_settings';

  async getSettings(): Promise<ISettingsData> {
    try {
      const result = await chrome.storage.sync.get(ServiceWorkerSettingsManager.SETTINGS_KEY);
      return result[ServiceWorkerSettingsManager.SETTINGS_KEY] || this.getDefaultSettings();
    } catch (error) {
      console.error('Error getting settings:', error);
      return this.getDefaultSettings();
    }
  }

  private getDefaultSettings(): ISettingsData {
    return { githubToken: '', githubRepo: '' };
  }
}

// Initialize service worker manager
let settingsManager: ServiceWorkerSettingsManager;
try {
  settingsManager = new ServiceWorkerSettingsManager();
} catch (error) {
  console.error('Failed to initialize settings manager:', error);
}
```

#### Utility File Pattern (FIXED)

Utility files must support both CommonJS exports and global assignments:

```typescript
// Generated by Copilot
// Utility file with dual export pattern

// Define types inline (no imports)
interface IUtilitySettings {
  [key: string]: unknown;
}

class UtilityName {
  // Implementation
}

// Export for ES6 modules (popup, options, content scripts)
export { UtilityName };

// Make available globally for service worker importScripts compatibility
if (typeof globalThis !== 'undefined') {
  (globalThis as any).UtilityName = UtilityName;
} else if (typeof self !== 'undefined') {
  (self as any).UtilityName = UtilityName;
}
```

#### What NOT to do (BROKEN)

```typescript
// ❌ WRONG - This causes "Unexpected token 'export'" errors
import { ISettings } from '../types/index.js';

export class MyUtility {
  // This will fail in service workers
}
```

#### What TO do (WORKING)

```typescript
// ✅ CORRECT - Service worker compatible
interface IMyUtilitySettings {
  [key: string]: unknown;
}

class MyUtility {
  // Implementation
}

// Dual export pattern
export { MyUtility };
if (typeof globalThis !== 'undefined') {
  (globalThis as any).MyUtility = MyUtility;
} else if (typeof self !== 'undefined') {
  (self as any).MyUtility = MyUtility;
}
```

### Module Structure

```typescript
// Generated by Copilot
// Always include this header comment in generated files

interface IModuleSettings {
  enabled: boolean;
  timeout: number;
  apiKey?: string;
}

// Standard module pattern for browser extension components
class ModuleName {
  private _privateField: string | null; // Use underscore for private fields
  public publicField: Record<string, unknown>;

  constructor(private _settings: IModuleSettings) {
    this._privateField = null;
    this.publicField = {};
  }

  async methodName(input: string): Promise<string> {
    try {
      // Implementation with proper error handling
      return this.processInput(input);
    } catch (error) {
      console.error('ModuleName: Error in methodName:', error);
      throw error;
    }
  }

  private processInput(input: string): string {
    return input.trim();
  }
}
```

### Service Worker (Background Script) Patterns

```typescript
// Generated by Copilot
// Service worker for Manifest V3 - Self-contained implementation

interface IMessageData {
  type: string;
  data?: Record<string, unknown>;
  timestamp?: number;
}

interface IMessageResponse {
  success: boolean;
  data?: unknown;
  error?: string;
}

// Simple logger - defined inline
const logger = {
  info: (...args: any[]) => console.log('[INFO]', ...args),
  error: (...args: any[]) => console.error('[ERROR]', ...args),
};

// Self-contained settings manager
class ServiceWorkerSettingsManager {
  private static readonly SETTINGS_KEY = 'app_settings';

  async getSettings(): Promise<Record<string, unknown>> {
    try {
      const result = await chrome.storage.sync.get(ServiceWorkerSettingsManager.SETTINGS_KEY);
      return result[ServiceWorkerSettingsManager.SETTINGS_KEY] || {};
    } catch (error) {
      logger.error('Settings error:', error);
      return {};
    }
  }
}

// Initialize manager
let settingsManager: ServiceWorkerSettingsManager;
try {
  settingsManager = new ServiceWorkerSettingsManager();
} catch (error) {
  logger.error('Failed to initialize manager:', error);
}

chrome.runtime.onInstalled.addListener(async (details: chrome.runtime.InstalledDetails) => {
  try {
    if (details.reason === 'install') {
      logger.info('Extension installed');
    }
  } catch (error) {
    logger.error('Installation error:', error);
  }
});

chrome.runtime.onMessage.addListener(
  (
    message: IMessageData,
    sender: chrome.runtime.MessageSender,
    sendResponse: (response: IMessageResponse) => void,
  ) => {
    handleMessage(message, sender)
      .then((result) => sendResponse({ success: true, data: result }))
      .catch((error) => {
        logger.error('Message handling error:', error);
        sendResponse({ success: false, error: error.message });
      });
    return true; // Keep message channel open for async response
  },
);

async function handleMessage(
  message: IMessageData,
  sender: chrome.runtime.MessageSender,
): Promise<unknown> {
  // Validate manager initialization
  if (!settingsManager) {
    throw new Error('Service worker not properly initialized');
  }

  switch (message.type) {
    case 'GET_SETTINGS':
      return await settingsManager.getSettings(); // Real implementation
    case 'CAPTURE_PAGE':
      return { success: true, message: 'Capture logic here' };
    default:
      throw new Error(`Unknown message type: ${message.type}`);
  }
}
```

### Content Script Patterns

```typescript
// Generated by Copilot
// Content script injection pattern

interface ISettings {
  enabled: boolean;
  extractionRules: string[];
  apiEndpoint?: string;
}

(function () {
  'use strict';

  class ContentExtractor {
    private _isInitialized: boolean = false;
    private _settings: ISettings | null = null;

    constructor() {
      this._isInitialized = false;
      this._settings = null;
    }

    async initialize(): Promise<void> {
      if (this._isInitialized) return;

      try {
        this._settings = await this._loadSettings();
        this._isInitialized = true;
      } catch (error) {
        console.error('ContentExtractor: Initialization failed:', error);
      }
    }

    private async _loadSettings(): Promise<ISettings> {
      return new Promise<ISettings>((resolve, reject) => {
        chrome.runtime.sendMessage(
          { type: 'GET_SETTINGS' },
          (response: { success: boolean; data?: ISettings; error?: string }) => {
            if (chrome.runtime.lastError) {
              reject(new Error(chrome.runtime.lastError.message));
            } else if (!response.success) {
              reject(new Error(response.error || 'Failed to load settings'));
            } else {
              resolve(response.data!);
            }
          },
        );
      });
    }

    async extractContent(): Promise<string> {
      if (!this._isInitialized || !this._settings) {
        throw new Error('ContentExtractor not initialized');
      }

      // Content extraction logic
      return document.documentElement.outerHTML;
    }
  }

  // Auto-initialize when DOM is ready
  const extractor = new ContentExtractor();

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      extractor.initialize();
    });
  } else {
    extractor.initialize();
  }

  // Export for use by other scripts
  (window as any).contentExtractor = extractor;
})();
```

### Storage Patterns

```typescript
// Generated by Copilot
// Chrome storage API wrapper with error handling

type StorageKeys = string | string[] | Record<string, unknown> | null;
type StorageResult<T = Record<string, unknown>> = Promise<T>;

class StorageManager {
  static async get<T = Record<string, unknown>>(
    keys: StorageKeys,
    useSync: boolean = true,
  ): StorageResult<T> {
    const storage = useSync ? chrome.storage.sync : chrome.storage.local;

    return new Promise<T>((resolve, reject) => {
      storage.get(keys, (result: T) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve(result);
        }
      });
    });
  }

  static async set(data: Record<string, unknown>, useSync: boolean = true): Promise<void> {
    const storage = useSync ? chrome.storage.sync : chrome.storage.local;

    return new Promise<void>((resolve, reject) => {
      storage.set(data, () => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve();
        }
      });
    });
  }

  static async remove(keys: string | string[], useSync: boolean = true): Promise<void> {
    const storage = useSync ? chrome.storage.sync : chrome.storage.local;

    return new Promise<void>((resolve, reject) => {
      storage.remove(keys, () => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve();
        }
      });
    });
  }
}
```

### Message Passing Patterns

```typescript
// Generated by Copilot
// Standardized message passing utilities

interface IMessage {
  type: string;
  data?: Record<string, unknown>;
  timestamp?: number;
}

interface IMessageResponse {
  success: boolean;
  data?: unknown;
  error?: string;
}

class MessageBus {
  static async sendToBackground<T = unknown>(
    type: string,
    data: Record<string, unknown> = {},
  ): Promise<T> {
    return new Promise<T>((resolve, reject) => {
      const message: IMessage = { type, data, timestamp: Date.now() };

      chrome.runtime.sendMessage(message, (response: IMessageResponse) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else if (response && response.error) {
          reject(new Error(response.error));
        } else {
          resolve(response.data as T);
        }
      });
    });
  }

  static async sendToTab<T = unknown>(
    tabId: number,
    type: string,
    data: Record<string, unknown> = {},
  ): Promise<T> {
    return new Promise<T>((resolve, reject) => {
      const message: IMessage = { type, data, timestamp: Date.now() };

      chrome.tabs.sendMessage(tabId, message, (response: IMessageResponse) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve(response?.data as T);
        }
      });
    });
  }

  static async sendToAllTabs<T = unknown>(
    type: string,
    data: Record<string, unknown> = {},
  ): Promise<T[]> {
    const tabs = await this.getActiveTabs();
    const promises = tabs.map((tab) => this.sendToTab<T>(tab.id!, type, data).catch(() => null));
    const results = await Promise.all(promises);
    return results.filter((result) => result !== null) as T[];
  }

  private static async getActiveTabs(): Promise<chrome.tabs.Tab[]> {
    return new Promise((resolve) => {
      chrome.tabs.query({}, (tabs) => {
        resolve(tabs);
      });
    });
  }
}
```

### DOM Manipulation Patterns

```typescript
// Generated by Copilot
// Safe DOM manipulation utilities

interface IElementAttributes {
  [key: string]: string | Record<string, string>;
  className?: string;
  style?: Record<string, string>;
}

class DOMUtils {
  static safeQuerySelector<T extends Element = Element>(
    selector: string,
    context: Document | Element = document,
  ): T | null {
    try {
      return context.querySelector<T>(selector);
    } catch (error) {
      console.warn('DOMUtils: Invalid selector:', selector, error);
      return null;
    }
  }

  static safeQuerySelectorAll<T extends Element = Element>(
    selector: string,
    context: Document | Element = document,
  ): T[] {
    try {
      return Array.from(context.querySelectorAll<T>(selector));
    } catch (error) {
      console.warn('DOMUtils: Invalid selector:', selector, error);
      return [];
    }
  }

  static createElement<K extends keyof HTMLElementTagNameMap>(
    tag: K,
    attributes: IElementAttributes = {},
    textContent: string = '',
  ): HTMLElementTagNameMap[K] {
    const element = document.createElement(tag);

    Object.entries(attributes).forEach(([key, value]) => {
      if (key === 'className' && typeof value === 'string') {
        element.className = value;
      } else if (key === 'style' && typeof value === 'object') {
        Object.assign(element.style, value);
      } else if (typeof value === 'string') {
        element.setAttribute(key, value);
      }
    });

    if (textContent) {
      element.textContent = textContent;
    }

    return element;
  }

  static waitForElement<T extends Element = Element>(
    selector: string,
    timeout: number = 5000,
  ): Promise<T | null> {
    return new Promise((resolve) => {
      const element = this.safeQuerySelector<T>(selector);
      if (element) {
        resolve(element);
        return;
      }

      const observer = new MutationObserver(() => {
        const element = this.safeQuerySelector<T>(selector);
        if (element) {
          observer.disconnect();
          resolve(element);
        }
      });

      observer.observe(document.body, {
        childList: true,
        subtree: true,
      });

      setTimeout(() => {
        observer.disconnect();
        resolve(null);
      }, timeout);
    });
  }
}
```

### Error Handling Patterns

```javascript
// Generated by Copilot
// Centralized error handling for browser extension

class ErrorHandler {
  static handle(error, context = 'Unknown') {
    const errorInfo = {
      message: error.message,
      stack: error.stack,
      context,
      timestamp: new Date().toISOString(),
      url: window.location?.href || 'Unknown',
    };

    console.error(`${context}:`, errorInfo);

    // Optionally send to background for logging
    if (typeof chrome !== 'undefined' && chrome.runtime) {
      chrome.runtime
        .sendMessage({
          type: 'LOG_ERROR',
          data: errorInfo,
        })
        .catch(() => {
          // Ignore messaging errors to prevent recursive issues
        });
    }

    return errorInfo;
  }

  static async withErrorHandling(asyncFn, context = 'Unknown') {
    try {
      return await asyncFn();
    } catch (error) {
      this.handle(error, context);
      throw error;
    }
  }
}
```

### UI Component Patterns

```javascript
// Generated by Copilot
// Reusable UI components for extension popup/options

class UIComponent {
  constructor(container) {
    this._container = container;
    this._isRendered = false;
    this._eventListeners = [];
  }

  render() {
    if (this._isRendered) return;

    this._container.innerHTML = this._getTemplate();
    this._bindEvents();
    this._isRendered = true;
  }

  _getTemplate() {
    return '<div>Override this method</div>';
  }

  _bindEvents() {
    // Override in subclasses
  }

  _addEventListener(element, event, handler) {
    element.addEventListener(event, handler);
    this._eventListeners.push({ element, event, handler });
  }

  destroy() {
    // Clean up event listeners
    this._eventListeners.forEach(({ element, event, handler }) => {
      element.removeEventListener(event, handler);
    });
    this._eventListeners = [];
    this._isRendered = false;
  }
}
```

### Git Integration Patterns

```javascript
// Generated by Copilot
// Git operations wrapper for browser extension

class GitManager {
  constructor(settings) {
    this._settings = settings;
    this._apiBase = 'https://api.github.com';
  }

  async createCommit(filePath, content, message) {
    try {
      const { owner, repo } = this._parseGitHubRepo(this._settings.githubRepo);

      // Get current file SHA if it exists
      const currentFile = await this._getFile(owner, repo, filePath);

      const commitData = {
        message,
        content: btoa(unescape(encodeURIComponent(content))),
        ...(currentFile && { sha: currentFile.sha }),
      };

      const response = await fetch(`${this._apiBase}/repos/${owner}/${repo}/contents/${filePath}`, {
        method: 'PUT',
        headers: {
          Authorization: `token ${this._settings.githubToken}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(commitData),
      });

      if (!response.ok) {
        throw new Error(`GitHub API error: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      ErrorHandler.handle(error, 'GitManager.createCommit');
      throw error;
    }
  }

  _parseGitHubRepo(repoString) {
    const match = repoString.match(/^([^\/]+)\/([^\/]+)$/);
    if (!match) {
      throw new Error('Invalid GitHub repository format');
    }
    return { owner: match[1], repo: match[2] };
  }

  async _getFile(owner, repo, path) {
    try {
      const response = await fetch(`${this._apiBase}/repos/${owner}/${repo}/contents/${path}`, {
        headers: {
          Authorization: `token ${this._settings.githubToken}`,
        },
      });

      if (response.status === 404) {
        return null; // File doesn't exist
      }

      if (!response.ok) {
        throw new Error(`GitHub API error: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      if (error.message.includes('404')) {
        return null;
      }
      throw error;
    }
  }
}
```

## Security Best Practices

### Content Security Policy

- Always use `chrome.scripting.executeScript` for dynamic script injection
- Avoid `eval()` and `new Function()`
- Sanitize all user inputs and web content
- Use `chrome.storage` instead of localStorage for sensitive data

### Permission Management

```javascript
// Generated by Copilot
// Dynamic permission requests

class PermissionManager {
  static async requestPermissions(permissions) {
    return new Promise((resolve) => {
      chrome.permissions.request({ permissions }, (granted) => {
        resolve(granted);
      });
    });
  }

  static async hasPermissions(permissions) {
    return new Promise((resolve) => {
      chrome.permissions.contains({ permissions }, (hasPermissions) => {
        resolve(hasPermissions);
      });
    });
  }
}
```

## Performance Optimization

### Current Performance Profile

- **Content Extraction**: Optimized with 79% test coverage
- **Service Worker**: Needs optimization (0% coverage, self-contained required)
- **Memory Management**: Critical for browser extension limits
- **Message Passing**: Async patterns with timeout handling

### Lazy Loading Pattern

```javascript
// Generated by Copilot
// Lazy module loading for better performance

class LazyLoader {
  constructor() {
    this._modules = new Map();
  }

  async loadModule(moduleName, importPath) {
    if (this._modules.has(moduleName)) {
      return this._modules.get(moduleName);
    }

    try {
      const module = await import(importPath);
      this._modules.set(moduleName, module);
      return module;
    } catch (error) {
      ErrorHandler.handle(error, `LazyLoader.loadModule(${moduleName})`);
      throw error;
    }
  }
}
```

### Memory Management

```javascript
// Generated by Copilot
// Memory-conscious patterns for browser extensions

class MemoryManager {
  static createWeakCache() {
    return new WeakMap();
  }

  static debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  static throttle(func, limit) {
    let inThrottle;
    return function (...args) {
      if (!inThrottle) {
        func.apply(this, args);
        inThrottle = true;
        setTimeout(() => (inThrottle = false), limit);
      }
    };
  }
}
```

## Current Testing Status (Updated)

- **Total Tests**: 48 passing tests across 5 test suites
- **Coverage**: 18.4% overall (targeting 60%+ improvement)
- **High Priority**: Service worker (0% coverage), Error handler (0% coverage)
- **Framework**: Jest with TypeScript, jsdom environment
- **CI/CD**: Automated testing on commit/PR

## Testing Considerations

- Always include unit tests for business logic
- Mock Chrome APIs in tests using Jest mocks
- Test error conditions and edge cases
- Use integration tests for message passing flows
- Test UI components with simulated user interactions
- **Priority Focus**: Service worker self-contained patterns, content extraction edge cases

## File Naming Conventions

- Use kebab-case for file names: `content-extractor.ts`
- Use descriptive module names: `settings-popup.ts`, `capture-content-script.ts`
- Group related files in logical directories
- Include component type in names: `settings-popup.ts`, `capture-content-script.ts`

## TypeScript-Specific Guidelines

- Use `@types/chrome` for Chrome API type definitions
- Enable strict mode in `tsconfig.json`
- Use proper generics for reusable components
- Prefer `interface` over `type` for object shapes
- Use `const assertions` for immutable data
- Leverage utility types (`Partial<T>`, `Pick<T>`, etc.)

### Service Worker Best Practices (CRITICAL)

Based on real-world implementation experience, follow these critical patterns for Chrome extension service workers:

#### AVOID importScripts() - Use Self-Contained Approach

**❌ PROBLEMATIC PATTERN**:

```typescript
// DON'T DO THIS - Creates dependency and loading issues
importScripts('../utils/settings-manager.js');
declare const SettingsManager: any;

// Service worker becomes dependent on external files
const settingsManager = new SettingsManager();
```

**✅ CORRECT PATTERN**:

```typescript
// Generated by Copilot
// Self-contained service worker - NO external dependencies

// Define all interfaces inline
interface ISettingsData {
  githubToken?: string;
  githubRepo?: string;
  [key: string]: unknown;
}

// Implement functionality directly in service worker
class ServiceWorkerSettingsManager {
  private static readonly SETTINGS_KEY = 'prismweave_settings';

  async getSettings(): Promise<ISettingsData> {
    try {
      const result = await chrome.storage.sync.get(ServiceWorkerSettingsManager.SETTINGS_KEY);
      return result[ServiceWorkerSettingsManager.SETTINGS_KEY] || this.getDefaultSettings();
    } catch (error) {
      console.error('Error getting settings:', error);
      return this.getDefaultSettings();
    }
  }

  private getDefaultSettings(): ISettingsData {
    return {
      githubToken: '',
      githubRepo: '',
      // ... other defaults
    };
  }
}
```

#### Service Worker Implementation Pattern

```typescript
// Generated by Copilot
// Complete self-contained service worker pattern

console.log('Service Worker starting...');

// Type definitions - define inline, no imports
interface IMessageData {
  type: string;
  data?: Record<string, unknown>;
  timestamp?: number;
}

interface IMessageResponse {
  success: boolean;
  data?: unknown;
  error?: string;
}

// Simple logger - define inline
const logger = {
  info: (...args: any[]) => console.log('[INFO]', ...args),
  debug: (...args: any[]) => console.log('[DEBUG]', ...args),
  warn: (...args: any[]) => console.warn('[WARN]', ...args),
  error: (...args: any[]) => console.error('[ERROR]', ...args),
};

// Self-contained manager classes
class ServiceWorkerManager {
  // Implementation here - no external dependencies
}

// Initialize managers
let manager: ServiceWorkerManager;
try {
  manager = new ServiceWorkerManager();
  logger.info('Manager initialized successfully');
} catch (error) {
  logger.error('Failed to initialize manager:', error);
}

// Chrome extension event listeners
chrome.runtime.onInstalled.addListener(async (details: chrome.runtime.InstalledDetails) => {
  try {
    logger.info('Extension installed/updated:', details.reason);
    if (details.reason === 'install') {
      // Initialize extension on first install
    }
  } catch (error) {
    logger.error('Error handling installation:', error);
  }
});

chrome.runtime.onMessage.addListener(
  (
    message: IMessageData,
    sender: chrome.runtime.MessageSender,
    sendResponse: (response: IMessageResponse) => void,
  ) => {
    logger.info('Received message:', message.type);

    // Handle message asynchronously
    handleMessage(message, sender)
      .then((result) => {
        logger.debug('Message handled successfully:', message.type);
        sendResponse({ success: true, data: result });
      })
      .catch((error) => {
        logger.error('Error handling message:', message.type, error);
        sendResponse({ success: false, error: error.message });
      });

    return true; // Keep message channel open for async response
  },
);

// Message handler - implement actual functionality, not mock data
async function handleMessage(
  message: IMessageData,
  sender: chrome.runtime.MessageSender,
): Promise<unknown> {
  switch (message.type) {
    case 'GET_SETTINGS':
      if (!manager) {
        throw new Error('Manager not initialized');
      }
      return await manager.getSettings(); // REAL implementation

    case 'UPDATE_SETTINGS':
      if (!manager) {
        throw new Error('Manager not initialized');
      }
      if (!message.data) {
        throw new Error('No settings data provided');
      }
      await manager.updateSettings(message.data);
      return { success: true };

    default:
      throw new Error(`Unknown message type: ${message.type}`);
  }
}

logger.info('Service Worker initialized successfully');
```

#### Why This Approach Works Better

1. **No Import Dependencies**: Service worker is completely self-contained
2. **Real Functionality**: Handlers actually implement logic instead of returning mock data
3. **Proper Error Handling**: Validates manager initialization and input data
4. **Type Safety**: All interfaces defined inline for full type checking
5. **Chrome Storage Integration**: Direct use of chrome.storage APIs without wrapper dependencies

#### Service Worker Storage Patterns

```typescript
// Generated by Copilot
// Direct Chrome storage usage in service worker

class ServiceWorkerStorageManager {
  private static readonly STORAGE_KEY = 'app_data';

  async getData<T = Record<string, unknown>>(): Promise<T> {
    try {
      const result = await chrome.storage.sync.get(ServiceWorkerStorageManager.STORAGE_KEY);
      return result[ServiceWorkerStorageManager.STORAGE_KEY] || ({} as T);
    } catch (error) {
      console.error('Storage get error:', error);
      return {} as T;
    }
  }

  async setData(data: Record<string, unknown>): Promise<void> {
    try {
      await chrome.storage.sync.set({
        [ServiceWorkerStorageManager.STORAGE_KEY]: data,
      });
    } catch (error) {
      console.error('Storage set error:', error);
      throw error;
    }
  }

  async updateData(updates: Record<string, unknown>): Promise<void> {
    try {
      const currentData = await this.getData();
      const newData = { ...currentData, ...updates };
      await this.setData(newData);
    } catch (error) {
      console.error('Storage update error:', error);
      throw error;
    }
  }
}
```

#### Service Worker Message Validation

```typescript
// Generated by Copilot
// Robust message handling with validation

async function handleMessage(
  message: IMessageData,
  sender: chrome.runtime.MessageSender,
): Promise<unknown> {
  // Validate message structure
  if (!message || typeof message.type !== 'string') {
    throw new Error('Invalid message format');
  }

  // Validate manager initialization for data operations
  const requiresManager = ['GET_SETTINGS', 'UPDATE_SETTINGS', 'VALIDATE_SETTINGS'];
  if (requiresManager.includes(message.type) && !manager) {
    throw new Error('Service manager not initialized');
  }

  switch (message.type) {
    case 'GET_SETTINGS':
      return await manager!.getSettings();

    case 'UPDATE_SETTINGS':
      if (!message.data || typeof message.data !== 'object') {
        throw new Error('Invalid settings data provided');
      }
      await manager!.updateSettings(message.data);
      return { success: true };

    case 'VALIDATE_SETTINGS':
      return await manager!.validateSettings();

    case 'GET_STATUS':
      return {
        initialized: !!manager,
        version: chrome.runtime.getManifest().version,
        timestamp: new Date().toISOString(),
      };

    default:
      throw new Error(`Unknown message type: ${message.type}`);
  }
}
```

#### Service Worker Lifecycle Management

```typescript
// Generated by Copilot
// Proper service worker lifecycle handling

// Track service worker state
let isInitialized = false;
let initializationPromise: Promise<void> | null = null;

async function ensureInitialized(): Promise<void> {
  if (isInitialized) return;

  if (initializationPromise) {
    return initializationPromise;
  }

  initializationPromise = initializeServiceWorker();
  await initializationPromise;
  isInitialized = true;
}

async function initializeServiceWorker(): Promise<void> {
  try {
    // Initialize managers
    manager = new ServiceWorkerManager();

    // Perform any startup tasks
    logger.info('Service worker fully initialized');
  } catch (error) {
    logger.error('Service worker initialization failed:', error);
    throw error;
  }
}

// Use in message handler
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  ensureInitialized()
    .then(() => handleMessage(message, sender))
    .then((result) => sendResponse({ success: true, data: result }))
    .catch((error) => {
      logger.error('Message handling error:', error);
      sendResponse({ success: false, error: error.message });
    });

  return true;
});
```
