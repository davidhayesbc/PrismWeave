---
applyTo: '**/*.{js,ts}'
---

# Copilot Instructions for Browser Extension Code Generation - PrismWeave Project

<!-- Specialized instructions for generating TypeScript browser extension code for the PrismWeave project -->

## Browser Extension Overview
- **Target**: Chrome/Edge Manifest V3 extension
- **Language**: TypeScript (compiled to JavaScript)
- **Purpose**: Web page capture, content extraction, and Git synchronization
- **Architecture**: Service worker + content scripts + popup/options UI
- **Build Process**: TypeScript → JavaScript (via tsc/webpack/esbuild)

## Code Generation Guidelines

### TypeScript Configuration
- Always include proper type annotations
- Use interfaces for complex objects
- Leverage Chrome extension type definitions
- Use strict TypeScript settings
- **IMPORTANT**: Use `"module": "CommonJS"` in tsconfig.json for Chrome extension compatibility

### Chrome Extension Module Compatibility
Chrome extension service workers and content scripts have specific module system requirements:

#### Service Worker Requirements
- **NO ES6 modules**: Service workers cannot use `import`/`export` statements
- **Use CommonJS**: TypeScript must compile to CommonJS format
- **importScripts()**: Load utilities via `importScripts()` function
- **Global assignments**: Utilities must be available globally

#### Correct TypeScript Configuration
```json
{
  "compilerOptions": {
    "module": "CommonJS",  // CRITICAL: Not "ES2020" or "ESNext"
    "target": "ES2020",
    "moduleResolution": "node"
  }
}
```

#### Service Worker Pattern (FIXED)
```typescript
// Generated by Copilot
// Service worker - NO ES6 imports allowed

// Define interfaces inline (no imports)
interface IMessageData {
  type: string;
  data?: Record<string, unknown>;
  timestamp?: number;
}

// Load utilities via importScripts
importScripts('../utils/settings-manager.js');
importScripts('../utils/error-handler.js');

// Declare globals for TypeScript
declare const SettingsManager: any;
declare const ErrorHandler: any;

class PrismWeaveBackground {
  private settingsManager: any;
  
  constructor() {
    // Use global constructors
    this.settingsManager = new SettingsManager();
  }
}

// Initialize service worker
const backgroundService = new PrismWeaveBackground();
```

#### Utility File Pattern (FIXED)
Utility files must support both CommonJS exports and global assignments:

```typescript
// Generated by Copilot
// Utility file with dual export pattern

// Define types inline (no imports)
interface IUtilitySettings {
  [key: string]: unknown;
}

class UtilityName {
  // Implementation
}

// Export for ES6 modules (popup, options, content scripts)
export { UtilityName };

// Make available globally for service worker importScripts compatibility
if (typeof globalThis !== 'undefined') {
  (globalThis as any).UtilityName = UtilityName;
} else if (typeof self !== 'undefined') {
  (self as any).UtilityName = UtilityName;
}
```

#### What NOT to do (BROKEN)
```typescript
// ❌ WRONG - This causes "Unexpected token 'export'" errors
import { ISettings } from '../types/index.js';

export class MyUtility {
  // This will fail in service workers
}
```

#### What TO do (WORKING)
```typescript
// ✅ CORRECT - Service worker compatible
interface IMyUtilitySettings {
  [key: string]: unknown;
}

class MyUtility {
  // Implementation
}

// Dual export pattern
export { MyUtility };
if (typeof globalThis !== 'undefined') {
  (globalThis as any).MyUtility = MyUtility;
} else if (typeof self !== 'undefined') {
  (self as any).MyUtility = MyUtility;
}
```

### Module Structure
```typescript
// Generated by Copilot
// Always include this header comment in generated files

interface IModuleSettings {
  enabled: boolean;
  timeout: number;
  apiKey?: string;
}

// Standard module pattern for browser extension components
class ModuleName {
  private _privateField: string | null; // Use underscore for private fields
  public publicField: Record<string, unknown>;

  constructor(private _settings: IModuleSettings) {
    this._privateField = null;
    this.publicField = {};
  }

  async methodName(input: string): Promise<string> {
    try {
      // Implementation with proper error handling
      return this.processInput(input);
    } catch (error) {
      console.error('ModuleName: Error in methodName:', error);
      throw error;
    }
  }

  private processInput(input: string): string {
    return input.trim();
  }
}
```

### Service Worker (Background Script) Patterns
```typescript
// Generated by Copilot
// Service worker for Manifest V3

interface IMessageData {
  type: string;
  data?: Record<string, unknown>;
  timestamp?: number;
}

interface IMessageResponse {
  success: boolean;
  data?: unknown;
  error?: string;
}

chrome.runtime.onInstalled.addListener(async (details: chrome.runtime.InstalledDetails) => {
  try {
    if (details.reason === 'install') {
      // Initialize extension on first install
      await initializeExtension();
    }
  } catch (error) {
    console.error('Background: Installation error:', error);
  }
});

chrome.runtime.onMessage.addListener((
  message: IMessageData,
  sender: chrome.runtime.MessageSender,
  sendResponse: (response: IMessageResponse) => void
) => {
  // Use async/await pattern for message handling
  handleMessage(message, sender)
    .then(result => sendResponse({ success: true, data: result }))
    .catch(error => {
      console.error('Background: Message handling error:', error);
      sendResponse({ success: false, error: error.message });
    });
  return true; // Keep message channel open for async response
});

async function handleMessage(message: IMessageData, sender: chrome.runtime.MessageSender): Promise<unknown> {
  switch (message.type) {
    case 'CAPTURE_PAGE':
      return await capturePage(message.data);
    case 'GET_SETTINGS':
      return await getSettings();
    default:
      throw new Error(`Unknown message type: ${message.type}`);
  }
}

async function initializeExtension(): Promise<void> {
  // Extension initialization logic
}

async function capturePage(data: unknown): Promise<unknown> {
  // Page capture logic
  return data;
}

async function getSettings(): Promise<Record<string, unknown>> {
  // Settings retrieval logic
  return {};
}
```

### Content Script Patterns
```typescript
// Generated by Copilot
// Content script injection pattern

interface ISettings {
  enabled: boolean;
  extractionRules: string[];
  apiEndpoint?: string;
}

(function() {
  'use strict';
  
  class ContentExtractor {
    private _isInitialized: boolean = false;
    private _settings: ISettings | null = null;

    constructor() {
      this._isInitialized = false;
      this._settings = null;
    }

    async initialize(): Promise<void> {
      if (this._isInitialized) return;
      
      try {
        this._settings = await this._loadSettings();
        this._isInitialized = true;
      } catch (error) {
        console.error('ContentExtractor: Initialization failed:', error);
      }
    }

    private async _loadSettings(): Promise<ISettings> {
      return new Promise<ISettings>((resolve, reject) => {
        chrome.runtime.sendMessage(
          { type: 'GET_SETTINGS' },
          (response: { success: boolean; data?: ISettings; error?: string }) => {
            if (chrome.runtime.lastError) {
              reject(new Error(chrome.runtime.lastError.message));
            } else if (!response.success) {
              reject(new Error(response.error || 'Failed to load settings'));
            } else {
              resolve(response.data!);
            }
          }
        );
      });
    }

    async extractContent(): Promise<string> {
      if (!this._isInitialized || !this._settings) {
        throw new Error('ContentExtractor not initialized');
      }
      
      // Content extraction logic
      return document.documentElement.outerHTML;
    }
  }

  // Auto-initialize when DOM is ready
  const extractor = new ContentExtractor();
  
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      extractor.initialize();
    });
  } else {
    extractor.initialize();
  }

  // Export for use by other scripts
  (window as any).contentExtractor = extractor;
})();
```

### Storage Patterns
```typescript
// Generated by Copilot
// Chrome storage API wrapper with error handling

type StorageKeys = string | string[] | Record<string, unknown> | null;
type StorageResult<T = Record<string, unknown>> = Promise<T>;

class StorageManager {
  static async get<T = Record<string, unknown>>(
    keys: StorageKeys, 
    useSync: boolean = true
  ): StorageResult<T> {
    const storage = useSync ? chrome.storage.sync : chrome.storage.local;
    
    return new Promise<T>((resolve, reject) => {
      storage.get(keys, (result: T) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve(result);
        }
      });
    });
  }

  static async set(
    data: Record<string, unknown>, 
    useSync: boolean = true
  ): Promise<void> {
    const storage = useSync ? chrome.storage.sync : chrome.storage.local;
    
    return new Promise<void>((resolve, reject) => {
      storage.set(data, () => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve();
        }
      });
    });
  }

  static async remove(
    keys: string | string[], 
    useSync: boolean = true
  ): Promise<void> {
    const storage = useSync ? chrome.storage.sync : chrome.storage.local;
    
    return new Promise<void>((resolve, reject) => {
      storage.remove(keys, () => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve();
        }
      });
    });
  }
}
```

### Message Passing Patterns
```typescript
// Generated by Copilot
// Standardized message passing utilities

interface IMessage {
  type: string;
  data?: Record<string, unknown>;
  timestamp?: number;
}

interface IMessageResponse {
  success: boolean;
  data?: unknown;
  error?: string;
}

class MessageBus {
  static async sendToBackground<T = unknown>(
    type: string, 
    data: Record<string, unknown> = {}
  ): Promise<T> {
    return new Promise<T>((resolve, reject) => {
      const message: IMessage = { type, data, timestamp: Date.now() };
      
      chrome.runtime.sendMessage(
        message,
        (response: IMessageResponse) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
          } else if (response && response.error) {
            reject(new Error(response.error));
          } else {
            resolve(response.data as T);
          }
        }
      );
    });
  }

  static async sendToTab<T = unknown>(
    tabId: number,
    type: string, 
    data: Record<string, unknown> = {}
  ): Promise<T> {
    return new Promise<T>((resolve, reject) => {
      const message: IMessage = { type, data, timestamp: Date.now() };
      
      chrome.tabs.sendMessage(
        tabId,
        message,
        (response: IMessageResponse) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
          } else {
            resolve(response?.data as T);
          }
        }
      );
    });
  }

  static async sendToAllTabs<T = unknown>(
    type: string,
    data: Record<string, unknown> = {}
  ): Promise<T[]> {
    const tabs = await this.getActiveTabs();
    const promises = tabs.map(tab => 
      this.sendToTab<T>(tab.id!, type, data).catch(() => null)
    );
    const results = await Promise.all(promises);
    return results.filter(result => result !== null) as T[];
  }

  private static async getActiveTabs(): Promise<chrome.tabs.Tab[]> {
    return new Promise((resolve) => {
      chrome.tabs.query({}, (tabs) => {
        resolve(tabs);
      });
    });
  }
}
```

### DOM Manipulation Patterns
```typescript
// Generated by Copilot
// Safe DOM manipulation utilities

interface IElementAttributes {
  [key: string]: string | Record<string, string>;
  className?: string;
  style?: Record<string, string>;
}

class DOMUtils {
  static safeQuerySelector<T extends Element = Element>(
    selector: string, 
    context: Document | Element = document
  ): T | null {
    try {
      return context.querySelector<T>(selector);
    } catch (error) {
      console.warn('DOMUtils: Invalid selector:', selector, error);
      return null;
    }
  }

  static safeQuerySelectorAll<T extends Element = Element>(
    selector: string, 
    context: Document | Element = document
  ): T[] {
    try {
      return Array.from(context.querySelectorAll<T>(selector));
    } catch (error) {
      console.warn('DOMUtils: Invalid selector:', selector, error);
      return [];
    }
  }

  static createElement<K extends keyof HTMLElementTagNameMap>(
    tag: K,
    attributes: IElementAttributes = {},
    textContent: string = ''
  ): HTMLElementTagNameMap[K] {
    const element = document.createElement(tag);
    
    Object.entries(attributes).forEach(([key, value]) => {
      if (key === 'className' && typeof value === 'string') {
        element.className = value;
      } else if (key === 'style' && typeof value === 'object') {
        Object.assign(element.style, value);
      } else if (typeof value === 'string') {
        element.setAttribute(key, value);
      }
    });

    if (textContent) {
      element.textContent = textContent;
    }

    return element;
  }

  static waitForElement<T extends Element = Element>(
    selector: string,
    timeout: number = 5000
  ): Promise<T | null> {
    return new Promise((resolve) => {
      const element = this.safeQuerySelector<T>(selector);
      if (element) {
        resolve(element);
        return;
      }

      const observer = new MutationObserver(() => {
        const element = this.safeQuerySelector<T>(selector);
        if (element) {
          observer.disconnect();
          resolve(element);
        }
      });

      observer.observe(document.body, {
        childList: true,
        subtree: true
      });

      setTimeout(() => {
        observer.disconnect();
        resolve(null);
      }, timeout);
    });
  }
}
```

### Error Handling Patterns
```javascript
// Generated by Copilot
// Centralized error handling for browser extension

class ErrorHandler {
  static handle(error, context = 'Unknown') {
    const errorInfo = {
      message: error.message,
      stack: error.stack,
      context,
      timestamp: new Date().toISOString(),
      url: window.location?.href || 'Unknown'
    };

    console.error(`${context}:`, errorInfo);
    
    // Optionally send to background for logging
    if (typeof chrome !== 'undefined' && chrome.runtime) {
      chrome.runtime.sendMessage({
        type: 'LOG_ERROR',
        data: errorInfo
      }).catch(() => {
        // Ignore messaging errors to prevent recursive issues
      });
    }

    return errorInfo;
  }

  static async withErrorHandling(asyncFn, context = 'Unknown') {
    try {
      return await asyncFn();
    } catch (error) {
      this.handle(error, context);
      throw error;
    }
  }
}
```

### UI Component Patterns
```javascript
// Generated by Copilot
// Reusable UI components for extension popup/options

class UIComponent {
  constructor(container) {
    this._container = container;
    this._isRendered = false;
    this._eventListeners = [];
  }

  render() {
    if (this._isRendered) return;
    
    this._container.innerHTML = this._getTemplate();
    this._bindEvents();
    this._isRendered = true;
  }

  _getTemplate() {
    return '<div>Override this method</div>';
  }

  _bindEvents() {
    // Override in subclasses
  }

  _addEventListener(element, event, handler) {
    element.addEventListener(event, handler);
    this._eventListeners.push({ element, event, handler });
  }

  destroy() {
    // Clean up event listeners
    this._eventListeners.forEach(({ element, event, handler }) => {
      element.removeEventListener(event, handler);
    });
    this._eventListeners = [];
    this._isRendered = false;
  }
}
```

### Git Integration Patterns
```javascript
// Generated by Copilot
// Git operations wrapper for browser extension

class GitManager {
  constructor(settings) {
    this._settings = settings;
    this._apiBase = 'https://api.github.com';
  }

  async createCommit(filePath, content, message) {
    try {
      const { owner, repo } = this._parseGitHubRepo(this._settings.githubRepo);
      
      // Get current file SHA if it exists
      const currentFile = await this._getFile(owner, repo, filePath);
      
      const commitData = {
        message,
        content: btoa(unescape(encodeURIComponent(content))),
        ...(currentFile && { sha: currentFile.sha })
      };

      const response = await fetch(
        `${this._apiBase}/repos/${owner}/${repo}/contents/${filePath}`,
        {
          method: 'PUT',
          headers: {
            'Authorization': `token ${this._settings.githubToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(commitData)
        }
      );

      if (!response.ok) {
        throw new Error(`GitHub API error: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      ErrorHandler.handle(error, 'GitManager.createCommit');
      throw error;
    }
  }

  _parseGitHubRepo(repoString) {
    const match = repoString.match(/^([^\/]+)\/([^\/]+)$/);
    if (!match) {
      throw new Error('Invalid GitHub repository format');
    }
    return { owner: match[1], repo: match[2] };
  }

  async _getFile(owner, repo, path) {
    try {
      const response = await fetch(
        `${this._apiBase}/repos/${owner}/${repo}/contents/${path}`,
        {
          headers: {
            'Authorization': `token ${this._settings.githubToken}`
          }
        }
      );

      if (response.status === 404) {
        return null; // File doesn't exist
      }

      if (!response.ok) {
        throw new Error(`GitHub API error: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      if (error.message.includes('404')) {
        return null;
      }
      throw error;
    }
  }
}
```

## Security Best Practices

### Content Security Policy
- Always use `chrome.scripting.executeScript` for dynamic script injection
- Avoid `eval()` and `new Function()`
- Sanitize all user inputs and web content
- Use `chrome.storage` instead of localStorage for sensitive data

### Permission Management
```javascript
// Generated by Copilot
// Dynamic permission requests

class PermissionManager {
  static async requestPermissions(permissions) {
    return new Promise((resolve) => {
      chrome.permissions.request(
        { permissions },
        (granted) => {
          resolve(granted);
        }
      );
    });
  }

  static async hasPermissions(permissions) {
    return new Promise((resolve) => {
      chrome.permissions.contains(
        { permissions },
        (hasPermissions) => {
          resolve(hasPermissions);
        }
      );
    });
  }
}
```

## Performance Optimization

### Lazy Loading Pattern
```javascript
// Generated by Copilot
// Lazy module loading for better performance

class LazyLoader {
  constructor() {
    this._modules = new Map();
  }

  async loadModule(moduleName, importPath) {
    if (this._modules.has(moduleName)) {
      return this._modules.get(moduleName);
    }

    try {
      const module = await import(importPath);
      this._modules.set(moduleName, module);
      return module;
    } catch (error) {
      ErrorHandler.handle(error, `LazyLoader.loadModule(${moduleName})`);
      throw error;
    }
  }
}
```

### Memory Management
```javascript
// Generated by Copilot
// Memory-conscious patterns for browser extensions

class MemoryManager {
  static createWeakCache() {
    return new WeakMap();
  }

  static debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  static throttle(func, limit) {
    let inThrottle;
    return function(...args) {
      if (!inThrottle) {
        func.apply(this, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }
}
```

## Testing Considerations
- Always include unit tests for business logic
- Mock Chrome APIs in tests using Jest mocks
- Test error conditions and edge cases
- Use integration tests for message passing flows
- Test UI components with simulated user interactions

## File Naming Conventions
- Use kebab-case for file names: `content-extractor.ts`
- Use descriptive module names: `github-api-client.ts`
- Group related files in logical directories
- Include component type in names: `settings-popup.ts`, `capture-content-script.ts`

## TypeScript-Specific Guidelines
- Use `@types/chrome` for Chrome API type definitions
- Enable strict mode in `tsconfig.json`
- Use proper generics for reusable components
- Prefer `interface` over `type` for object shapes
- Use `const assertions` for immutable data
- Leverage utility types (`Partial<T>`, `Pick<T>`, etc.)
