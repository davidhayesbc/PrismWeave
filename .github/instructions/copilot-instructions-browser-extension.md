---
applyTo: '**/*.js'
---

# Copilot Instructions for Browser Extension Code Generation - PrismWeave Project

<!-- Specialized instructions for generating browser extension code for the PrismWeave project -->

## Browser Extension Overview
- **Target**: Chrome/Edge Manifest V3 extension
- **Purpose**: Web page capture, content extraction, and Git synchronization
- **Architecture**: Service worker + content scripts + popup/options UI

## Code Generation Guidelines

### Module Structure
```javascript

// Standard module pattern for browser extension components
class ModuleName {
  constructor() {
    this._privateField = null; // Use underscore for private fields
    this.publicField = {};
  }

  async methodName() {
    try {
      // Implementation with proper error handling
    } catch (error) {
      console.error('ModuleName: Error in methodName:', error);
      throw error;
    }
  }
}
```

### Service Worker (Background Script) Patterns
```javascript
// Generated by Copilot
// Service worker for Manifest V3

chrome.runtime.onInstalled.addListener(async (details) => {
  try {
    if (details.reason === 'install') {
      // Initialize extension on first install
    }
  } catch (error) {
    console.error('Background: Installation error:', error);
  }
});

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  // Use async/await pattern for message handling
  handleMessage(message, sender).then(sendResponse).catch(error => {
    console.error('Background: Message handling error:', error);
    sendResponse({ error: error.message });
  });
  return true; // Keep message channel open for async response
});

async function handleMessage(message, sender) {
  switch (message.type) {
    case 'CAPTURE_PAGE':
      return await capturePage(message.data);
    default:
      throw new Error(`Unknown message type: ${message.type}`);
  }
}
```

### Content Script Patterns
```javascript
// Generated by Copilot
// Content script injection pattern

(function() {
  'use strict';
  
  class ContentExtractor {
    constructor() {
      this._isInitialized = false;
      this.settings = null;
    }

    async initialize() {
      if (this._isInitialized) return;
      
      try {
        this.settings = await this._loadSettings();
        this._isInitialized = true;
      } catch (error) {
        console.error('ContentExtractor: Initialization failed:', error);
      }
    }

    async _loadSettings() {
      return new Promise((resolve, reject) => {
        chrome.runtime.sendMessage(
          { type: 'GET_SETTINGS' },
          (response) => {
            if (chrome.runtime.lastError) {
              reject(new Error(chrome.runtime.lastError.message));
            } else {
              resolve(response);
            }
          }
        );
      });
    }
  }

  // Auto-initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      new ContentExtractor().initialize();
    });
  } else {
    new ContentExtractor().initialize();
  }
})();
```

### Storage Patterns
```javascript
// Generated by Copilot
// Chrome storage API wrapper with error handling

class StorageManager {
  static async get(keys, useSync = true) {
    const storage = useSync ? chrome.storage.sync : chrome.storage.local;
    
    return new Promise((resolve, reject) => {
      storage.get(keys, (result) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve(result);
        }
      });
    });
  }

  static async set(data, useSync = true) {
    const storage = useSync ? chrome.storage.sync : chrome.storage.local;
    
    return new Promise((resolve, reject) => {
      storage.set(data, () => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve();
        }
      });
    });
  }
}
```

### Message Passing Patterns
```javascript
// Generated by Copilot
// Standardized message passing utilities

class MessageBus {
  static async sendToBackground(type, data = {}) {
    return new Promise((resolve, reject) => {
      chrome.runtime.sendMessage(
        { type, data, timestamp: Date.now() },
        (response) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
          } else if (response && response.error) {
            reject(new Error(response.error));
          } else {
            resolve(response);
          }
        }
      );
    });
  }

  static async sendToTab(tabId, type, data = {}) {
    return new Promise((resolve, reject) => {
      chrome.tabs.sendMessage(
        tabId,
        { type, data, timestamp: Date.now() },
        (response) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
          } else {
            resolve(response);
          }
        }
      );
    });
  }
}
```

### DOM Manipulation Patterns
```javascript
// Generated by Copilot
// Safe DOM manipulation utilities

class DOMUtils {
  static safeQuerySelector(selector, context = document) {
    try {
      return context.querySelector(selector);
    } catch (error) {
      console.warn('DOMUtils: Invalid selector:', selector, error);
      return null;
    }
  }

  static safeQuerySelectorAll(selector, context = document) {
    try {
      return Array.from(context.querySelectorAll(selector));
    } catch (error) {
      console.warn('DOMUtils: Invalid selector:', selector, error);
      return [];
    }
  }

  static createElement(tag, attributes = {}, textContent = '') {
    const element = document.createElement(tag);
    
    Object.entries(attributes).forEach(([key, value]) => {
      if (key === 'className') {
        element.className = value;
      } else if (key === 'style' && typeof value === 'object') {
        Object.assign(element.style, value);
      } else {
        element.setAttribute(key, value);
      }
    });

    if (textContent) {
      element.textContent = textContent;
    }

    return element;
  }
}
```

### Error Handling Patterns
```javascript
// Generated by Copilot
// Centralized error handling for browser extension

class ErrorHandler {
  static handle(error, context = 'Unknown') {
    const errorInfo = {
      message: error.message,
      stack: error.stack,
      context,
      timestamp: new Date().toISOString(),
      url: window.location?.href || 'Unknown'
    };

    console.error(`${context}:`, errorInfo);
    
    // Optionally send to background for logging
    if (typeof chrome !== 'undefined' && chrome.runtime) {
      chrome.runtime.sendMessage({
        type: 'LOG_ERROR',
        data: errorInfo
      }).catch(() => {
        // Ignore messaging errors to prevent recursive issues
      });
    }

    return errorInfo;
  }

  static async withErrorHandling(asyncFn, context = 'Unknown') {
    try {
      return await asyncFn();
    } catch (error) {
      this.handle(error, context);
      throw error;
    }
  }
}
```

### UI Component Patterns
```javascript
// Generated by Copilot
// Reusable UI components for extension popup/options

class UIComponent {
  constructor(container) {
    this._container = container;
    this._isRendered = false;
    this._eventListeners = [];
  }

  render() {
    if (this._isRendered) return;
    
    this._container.innerHTML = this._getTemplate();
    this._bindEvents();
    this._isRendered = true;
  }

  _getTemplate() {
    return '<div>Override this method</div>';
  }

  _bindEvents() {
    // Override in subclasses
  }

  _addEventListener(element, event, handler) {
    element.addEventListener(event, handler);
    this._eventListeners.push({ element, event, handler });
  }

  destroy() {
    // Clean up event listeners
    this._eventListeners.forEach(({ element, event, handler }) => {
      element.removeEventListener(event, handler);
    });
    this._eventListeners = [];
    this._isRendered = false;
  }
}
```

### Git Integration Patterns
```javascript
// Generated by Copilot
// Git operations wrapper for browser extension

class GitManager {
  constructor(settings) {
    this._settings = settings;
    this._apiBase = 'https://api.github.com';
  }

  async createCommit(filePath, content, message) {
    try {
      const { owner, repo } = this._parseGitHubRepo(this._settings.githubRepo);
      
      // Get current file SHA if it exists
      const currentFile = await this._getFile(owner, repo, filePath);
      
      const commitData = {
        message,
        content: btoa(unescape(encodeURIComponent(content))),
        ...(currentFile && { sha: currentFile.sha })
      };

      const response = await fetch(
        `${this._apiBase}/repos/${owner}/${repo}/contents/${filePath}`,
        {
          method: 'PUT',
          headers: {
            'Authorization': `token ${this._settings.githubToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(commitData)
        }
      );

      if (!response.ok) {
        throw new Error(`GitHub API error: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      ErrorHandler.handle(error, 'GitManager.createCommit');
      throw error;
    }
  }

  _parseGitHubRepo(repoString) {
    const match = repoString.match(/^([^\/]+)\/([^\/]+)$/);
    if (!match) {
      throw new Error('Invalid GitHub repository format');
    }
    return { owner: match[1], repo: match[2] };
  }

  async _getFile(owner, repo, path) {
    try {
      const response = await fetch(
        `${this._apiBase}/repos/${owner}/${repo}/contents/${path}`,
        {
          headers: {
            'Authorization': `token ${this._settings.githubToken}`
          }
        }
      );

      if (response.status === 404) {
        return null; // File doesn't exist
      }

      if (!response.ok) {
        throw new Error(`GitHub API error: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      if (error.message.includes('404')) {
        return null;
      }
      throw error;
    }
  }
}
```

## Security Best Practices

### Content Security Policy
- Always use `chrome.scripting.executeScript` for dynamic script injection
- Avoid `eval()` and `new Function()`
- Sanitize all user inputs and web content
- Use `chrome.storage` instead of localStorage for sensitive data

### Permission Management
```javascript
// Generated by Copilot
// Dynamic permission requests

class PermissionManager {
  static async requestPermissions(permissions) {
    return new Promise((resolve) => {
      chrome.permissions.request(
        { permissions },
        (granted) => {
          resolve(granted);
        }
      );
    });
  }

  static async hasPermissions(permissions) {
    return new Promise((resolve) => {
      chrome.permissions.contains(
        { permissions },
        (hasPermissions) => {
          resolve(hasPermissions);
        }
      );
    });
  }
}
```

## Performance Optimization

### Lazy Loading Pattern
```javascript
// Generated by Copilot
// Lazy module loading for better performance

class LazyLoader {
  constructor() {
    this._modules = new Map();
  }

  async loadModule(moduleName, importPath) {
    if (this._modules.has(moduleName)) {
      return this._modules.get(moduleName);
    }

    try {
      const module = await import(importPath);
      this._modules.set(moduleName, module);
      return module;
    } catch (error) {
      ErrorHandler.handle(error, `LazyLoader.loadModule(${moduleName})`);
      throw error;
    }
  }
}
```

### Memory Management
```javascript
// Generated by Copilot
// Memory-conscious patterns for browser extensions

class MemoryManager {
  static createWeakCache() {
    return new WeakMap();
  }

  static debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  static throttle(func, limit) {
    let inThrottle;
    return function(...args) {
      if (!inThrottle) {
        func.apply(this, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }
}
```

## Testing Considerations
- Always include unit tests for business logic
- Mock Chrome APIs in tests using Jest mocks
- Test error conditions and edge cases
- Use integration tests for message passing flows
- Test UI components with simulated user interactions

## File Naming Conventions
- Use kebab-case for file names: `content-extractor.js`
- Use descriptive module names: `github-api-client.js`
- Group related files in logical directories
- Include component type in names: `settings-popup.js`, `capture-content-script.js`
