---
applyTo: '**/content/*.{js,ts}'
---

# Copilot Instructions for Content Script Development - PrismWeave Project

## Content Script Overview - PrismWeave Browser Extension

- **Purpose**: Extract clean content from web pages and convert to markdown
- **Environment**: Runs in web page context with DOM access
- **Communication**: Message passing with service worker and popup
- **Key Features**: Content extraction, markdown conversion, image handling
- **Injection**: Dynamic injection via chrome.scripting API from service worker

## Content Script Architecture

### Self-Contained Content Script Pattern
```typescript
// Generated by Copilot
// Content script with complete functionality and error handling

(function() {
  'use strict';
  
  console.log('PrismWeave content script loading...');

  // Type definitions inline (no imports in content scripts)
  interface IExtractionConfig {
    includeImages: boolean;
    includeLinks: boolean;
    cleanHtml: boolean;
    customSelectors?: string[];
    excludeSelectors?: string[];
  }

  interface IExtractedContent {
    title: string;
    url: string;
    markdown: string;
    images: string[];
    metadata: Record<string, unknown>;
    extractedAt: string;
  }

  interface IMessageData {
    type: string;
    data?: Record<string, unknown>;
    timestamp?: number;
  }

  interface IMessageResponse {
    success: boolean;
    data?: unknown;
    error?: string;
  }

  // Content extraction engine
  class ContentExtractor {
    private _isInitialized: boolean = false;
    private _config: IExtractionConfig;
    private _turndown: any = null; // Turndown converter instance

    constructor(config: Partial<IExtractionConfig> = {}) {
      this._config = {
        includeImages: true,
        includeLinks: true,
        cleanHtml: true,
        customSelectors: [],
        excludeSelectors: [
          'script', 'style', 'nav', 'header', 'footer', 
          '.advertisement', '.ad', '.popup', '.modal'
        ],
        ...config
      };
    }

    async initialize(): Promise<void> {
      if (this._isInitialized) return;

      try {
        // Initialize markdown converter
        this._initializeTurndown();
        this._isInitialized = true;
        console.log('ContentExtractor initialized successfully');
      } catch (error) {
        console.error('ContentExtractor initialization failed:', error);
        throw error;
      }
    }

    private _initializeTurndown(): void {
      // Self-contained Turndown implementation
      this._turndown = {
        turndown: (html: string): string => {
          // Basic HTML to Markdown conversion
          return this._basicHtmlToMarkdown(html);
        }
      };
    }

    private _basicHtmlToMarkdown(html: string): string {
      // Basic HTML to markdown conversion rules
      let markdown = html;
      
      // Headers
      markdown = markdown.replace(/<h([1-6])[^>]*>(.*?)<\/h[1-6]>/gi, (match, level, content) => {
        const headerLevel = '#'.repeat(parseInt(level));
        return `\n${headerLevel} ${this._stripHtml(content)}\n`;
      });
      
      // Paragraphs
      markdown = markdown.replace(/<p[^>]*>(.*?)<\/p>/gi, '\n$1\n');
      
      // Strong/Bold
      markdown = markdown.replace(/<(strong|b)[^>]*>(.*?)<\/(strong|b)>/gi, '**$2**');
      
      // Emphasis/Italic
      markdown = markdown.replace(/<(em|i)[^>]*>(.*?)<\/(em|i)>/gi, '*$2*');
      
      // Links
      if (this._config.includeLinks) {
        markdown = markdown.replace(/<a[^>]*href=["']([^"']*)["'][^>]*>(.*?)<\/a>/gi, '[$2]($1)');
      }
      
      // Images
      if (this._config.includeImages) {
        markdown = markdown.replace(/<img[^>]*src=["']([^"']*)["'][^>]*alt=["']([^"']*)["'][^>]*>/gi, '![$2]($1)');
        markdown = markdown.replace(/<img[^>]*alt=["']([^"']*)["'][^>]*src=["']([^"']*)["'][^>]*>/gi, '![$1]($2)');
        markdown = markdown.replace(/<img[^>]*src=["']([^"']*)["'][^>]*>/gi, '![]($1)');
      }
      
      // Lists
      markdown = markdown.replace(/<ul[^>]*>(.*?)<\/ul>/gis, (match, content) => {
        const items = content.replace(/<li[^>]*>(.*?)<\/li>/gi, '- $1\n');
        return `\n${items}\n`;
      });
      
      markdown = markdown.replace(/<ol[^>]*>(.*?)<\/ol>/gis, (match, content) => {
        let counter = 1;
        const items = content.replace(/<li[^>]*>(.*?)<\/li>/gi, () => `${counter++}. $1\n`);
        return `\n${items}\n`;
      });
      
      // Code blocks
      markdown = markdown.replace(/<pre[^>]*><code[^>]*>(.*?)<\/code><\/pre>/gis, '\n```\n$1\n```\n');
      markdown = markdown.replace(/<code[^>]*>(.*?)<\/code>/gi, '`$1`');
      
      // Blockquotes
      markdown = markdown.replace(/<blockquote[^>]*>(.*?)<\/blockquote>/gis, (match, content) => {
        const lines = this._stripHtml(content).split('\n');
        return '\n' + lines.map(line => `> ${line}`).join('\n') + '\n';
      });
      
      // Line breaks
      markdown = markdown.replace(/<br[^>]*>/gi, '\n');
      
      // Strip remaining HTML
      markdown = this._stripHtml(markdown);
      
      // Clean up whitespace
      markdown = markdown.replace(/\n\s*\n\s*\n/g, '\n\n');
      markdown = markdown.trim();
      
      return markdown;
    }

    private _stripHtml(html: string): string {
      return html.replace(/<[^>]*>/g, '').trim();
    }

    async extractContent(): Promise<IExtractedContent> {
      if (!this._isInitialized) {
        await this.initialize();
      }

      try {
        const content = this._extractMainContent();
        const cleanedContent = this._cleanContent(content);
        const markdown = this._convertToMarkdown(cleanedContent);
        const images = this._extractImages();
        const metadata = this._extractMetadata();

        return {
          title: this._extractTitle(),
          url: window.location.href,
          markdown,
          images,
          metadata,
          extractedAt: new Date().toISOString()
        };
      } catch (error) {
        console.error('Content extraction failed:', error);
        throw error;
      }
    }

    private _extractMainContent(): Element {
      // Try common content selectors in order of preference
      const contentSelectors = [
        'article',
        'main',
        '[role="main"]',
        '.content',
        '.post',
        '.entry',
        '#content',
        '#main',
        '.main-content'
      ];

      // First try custom selectors if provided
      if (this._config.customSelectors && this._config.customSelectors.length > 0) {
        for (const selector of this._config.customSelectors) {
          const element = document.querySelector(selector);
          if (element) {
            return element;
          }
        }
      }

      // Try standard content selectors
      for (const selector of contentSelectors) {
        const element = document.querySelector(selector);
        if (element && this._hasSubstantialContent(element)) {
          return element;
        }
      }

      // Fallback to body if no specific content area found
      return document.body;
    }

    private _hasSubstantialContent(element: Element): boolean {
      const textContent = element.textContent || '';
      const wordCount = textContent.split(/\s+/).filter(word => word.length > 0).length;
      return wordCount > 50; // Require at least 50 words for substantial content
    }

    private _cleanContent(content: Element): Element {
      const cloned = content.cloneNode(true) as Element;

      // Remove excluded elements
      if (this._config.excludeSelectors) {
        this._config.excludeSelectors.forEach(selector => {
          const elements = cloned.querySelectorAll(selector);
          elements.forEach(el => el.remove());
        });
      }

      // Remove common unwanted elements
      const unwantedSelectors = [
        'script', 'style', 'noscript', 'iframe',
        '.advertisement', '.ad', '.ads', '.popup', '.modal',
        '.social-share', '.comments', '.related-posts',
        '[style*="display: none"]', '[style*="visibility: hidden"]'
      ];

      unwantedSelectors.forEach(selector => {
        const elements = cloned.querySelectorAll(selector);
        elements.forEach(el => el.remove());
      });

      return cloned;
    }

    private _convertToMarkdown(content: Element): string {
      const html = content.innerHTML;
      return this._turndown.turndown(html);
    }

    private _extractImages(): string[] {
      const images: string[] = [];
      const imgElements = document.querySelectorAll('img');

      imgElements.forEach(img => {
        const src = img.src;
        if (src && !src.startsWith('data:') && src.length > 0) {
          // Convert relative URLs to absolute
          const absoluteUrl = new URL(src, window.location.href).href;
          if (!images.includes(absoluteUrl)) {
            images.push(absoluteUrl);
          }
        }
      });

      return images;
    }

    private _extractTitle(): string {
      // Try multiple title sources
      const titleSources = [
        () => document.querySelector('h1')?.textContent,
        () => document.querySelector('[property="og:title"]')?.getAttribute('content'),
        () => document.querySelector('[name="twitter:title"]')?.getAttribute('content'),
        () => document.title,
        () => document.querySelector('title')?.textContent
      ];

      for (const source of titleSources) {
        const title = source();
        if (title && title.trim().length > 0) {
          return title.trim();
        }
      }

      return 'Untitled Page';
    }

    private _extractMetadata(): Record<string, unknown> {
      const metadata: Record<string, unknown> = {};

      // Extract Open Graph metadata
      document.querySelectorAll('[property^="og:"]').forEach(meta => {
        const property = meta.getAttribute('property');
        const content = meta.getAttribute('content');
        if (property && content) {
          metadata[property] = content;
        }
      });

      // Extract Twitter Card metadata
      document.querySelectorAll('[name^="twitter:"]').forEach(meta => {
        const name = meta.getAttribute('name');
        const content = meta.getAttribute('content');
        if (name && content) {
          metadata[name] = content;
        }
      });

      // Extract standard meta tags
      document.querySelectorAll('meta[name]').forEach(meta => {
        const name = meta.getAttribute('name');
        const content = meta.getAttribute('content');
        if (name && content) {
          metadata[name] = content;
        }
      });

      // Add page information
      metadata.url = window.location.href;
      metadata.domain = window.location.hostname;
      metadata.extractedAt = new Date().toISOString();
      metadata.userAgent = navigator.userAgent;

      return metadata;
    }
  }

  // Message handling
  class ContentScriptMessageHandler {
    private _extractor: ContentExtractor;

    constructor() {
      this._extractor = new ContentExtractor();
    }

    async initialize(): Promise<void> {
      await this._extractor.initialize();
      this._setupMessageListener();
      console.log('Content script message handler initialized');
    }

    private _setupMessageListener(): void {
      chrome.runtime.onMessage.addListener((
        message: IMessageData,
        sender: chrome.runtime.MessageSender,
        sendResponse: (response: IMessageResponse) => void
      ) => {
        this._handleMessage(message)
          .then(result => sendResponse({ success: true, data: result }))
          .catch(error => {
            console.error('Content script message error:', error);
            sendResponse({ success: false, error: error.message });
          });
        
        return true; // Keep message channel open for async response
      });
    }

    private async _handleMessage(message: IMessageData): Promise<unknown> {
      switch (message.type) {
        case 'PING':
          return { status: 'ready', timestamp: Date.now() };
          
        case 'EXTRACT_CONTENT':
          return await this._extractor.extractContent();
          
        case 'GET_PAGE_INFO':
          return {
            title: document.title,
            url: window.location.href,
            domain: window.location.hostname
          };
          
        case 'UPDATE_CONFIG':
          if (message.data) {
            this._extractor = new ContentExtractor(message.data as Partial<IExtractionConfig>);
            await this._extractor.initialize();
          }
          return { success: true };
          
        default:
          throw new Error(`Unknown message type: ${message.type}`);
      }
    }
  }

  // Initialize content script
  const messageHandler = new ContentScriptMessageHandler();
  
  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      messageHandler.initialize().catch(error => {
        console.error('Content script initialization failed:', error);
      });
    });
  } else {
    messageHandler.initialize().catch(error => {
      console.error('Content script initialization failed:', error);
    });
  }

  // Export for debugging (optional)
  if (typeof window !== 'undefined') {
    (window as any).prismweaveContentScript = {
      messageHandler,
      version: '1.0.0'
    };
  }

  console.log('PrismWeave content script loaded successfully');
})();
```

## DOM Interaction Patterns

### Safe DOM Querying
```typescript
// Generated by Copilot
// Safe DOM manipulation utilities for content scripts

class DOMHelper {
  static safeQuerySelector<T extends Element = Element>(
    selector: string,
    context: Document | Element = document
  ): T | null {
    try {
      return context.querySelector<T>(selector);
    } catch (error) {
      console.warn('Invalid selector:', selector, error);
      return null;
    }
  }

  static safeQuerySelectorAll<T extends Element = Element>(
    selector: string,
    context: Document | Element = document
  ): T[] {
    try {
      return Array.from(context.querySelectorAll<T>(selector));
    } catch (error) {
      console.warn('Invalid selector:', selector, error);
      return [];
    }
  }

  static getTextContent(element: Element | null): string {
    if (!element) return '';
    return element.textContent?.trim() || '';
  }

  static getAttributeValue(element: Element | null, attribute: string): string {
    if (!element) return '';
    return element.getAttribute(attribute) || '';
  }

  static isElementVisible(element: Element): boolean {
    if (!element) return false;
    
    const style = window.getComputedStyle(element);
    return style.display !== 'none' && 
           style.visibility !== 'hidden' && 
           style.opacity !== '0';
  }

  static waitForElement<T extends Element = Element>(
    selector: string,
    timeout: number = 5000,
    context: Document | Element = document
  ): Promise<T | null> {
    return new Promise((resolve) => {
      const element = this.safeQuerySelector<T>(selector, context);
      if (element) {
        resolve(element);
        return;
      }

      const observer = new MutationObserver(() => {
        const element = this.safeQuerySelector<T>(selector, context);
        if (element) {
          observer.disconnect();
          resolve(element);
        }
      });

      observer.observe(context === document ? document.body : context as Element, {
        childList: true,
        subtree: true
      });

      setTimeout(() => {
        observer.disconnect();
        resolve(null);
      }, timeout);
    });
  }
}
```

## Content Extraction Strategies

### Advanced Content Detection
```typescript
// Generated by Copilot
// Advanced content detection algorithms

class ContentDetector {
  static detectMainContent(): Element | null {
    // Score-based content detection
    const candidates = this._getCandidateElements();
    let bestCandidate: { element: Element; score: number } | null = null;

    for (const candidate of candidates) {
      const score = this._scoreElement(candidate);
      if (!bestCandidate || score > bestCandidate.score) {
        bestCandidate = { element: candidate, score };
      }
    }

    return bestCandidate?.element || null;
  }

  private static _getCandidateElements(): Element[] {
    const candidates: Element[] = [];
    
    // Try semantic HTML elements first
    const semanticSelectors = [
      'article', 'main', '[role="main"]', 'section'
    ];
    
    semanticSelectors.forEach(selector => {
      const elements = DOMHelper.safeQuerySelectorAll(selector);
      candidates.push(...elements);
    });

    // Try common content class names
    const contentSelectors = [
      '.content', '.post', '.entry', '.article',
      '#content', '#main', '#post', '#entry'
    ];

    contentSelectors.forEach(selector => {
      const element = DOMHelper.safeQuerySelector(selector);
      if (element && !candidates.includes(element)) {
        candidates.push(element);
      }
    });

    // Fallback to analyzing all divs
    if (candidates.length === 0) {
      const divs = DOMHelper.safeQuerySelectorAll('div');
      candidates.push(...divs.filter(div => this._isContentCandidate(div)));
    }

    return candidates;
  }

  private static _scoreElement(element: Element): number {
    let score = 0;
    const text = element.textContent || '';
    
    // Word count scoring
    const wordCount = text.split(/\s+/).filter(word => word.length > 2).length;
    score += Math.min(wordCount / 10, 50); // Max 50 points for word count
    
    // Paragraph count scoring  
    const paragraphs = element.querySelectorAll('p').length;
    score += paragraphs * 2;
    
    // Link density penalty (too many links = likely navigation)
    const links = element.querySelectorAll('a').length;
    const linkDensity = links / Math.max(wordCount, 1);
    if (linkDensity > 0.3) {
      score -= 20;
    }
    
    // Semantic element bonus
    if (element.tagName.toLowerCase() === 'article') score += 15;
    if (element.tagName.toLowerCase() === 'main') score += 10;
    
    // Class name scoring
    const className = element.className.toLowerCase();
    if (className.includes('content')) score += 10;
    if (className.includes('post')) score += 8;
    if (className.includes('article')) score += 8;
    if (className.includes('entry')) score += 5;
    
    // Negative scoring for common non-content areas
    if (className.includes('sidebar')) score -= 10;
    if (className.includes('footer')) score -= 10;
    if (className.includes('header')) score -= 10;
    if (className.includes('nav')) score -= 15;
    if (className.includes('menu')) score -= 10;
    
    return Math.max(score, 0);
  }

  private static _isContentCandidate(element: Element): boolean {
    const text = element.textContent || '';
    const wordCount = text.split(/\s+/).filter(word => word.length > 2).length;
    
    // Must have substantial text content
    if (wordCount < 30) return false;
    
    // Must be visible
    if (!DOMHelper.isElementVisible(element)) return false;
    
    // Must not be a known non-content element
    const tagName = element.tagName.toLowerCase();
    const excludeTags = ['script', 'style', 'nav', 'header', 'footer'];
    if (excludeTags.includes(tagName)) return false;
    
    return true;
  }
}
```

## Markdown Conversion

### Enhanced Markdown Converter
```typescript
// Generated by Copilot
// Self-contained markdown conversion with advanced features

class MarkdownConverter {
  private _options: {
    includeImages: boolean;
    includeLinks: boolean;
    codeBlockLanguage: string;
    preserveFormatting: boolean;
  };

  constructor(options: Partial<typeof this._options> = {}) {
    this._options = {
      includeImages: true,
      includeLinks: true,
      codeBlockLanguage: '',
      preserveFormatting: true,
      ...options
    };
  }

  convert(html: string): string {
    let markdown = html;

    // Process in order of complexity (most specific first)
    markdown = this._convertCodeBlocks(markdown);
    markdown = this._convertHeaders(markdown);
    markdown = this._convertLists(markdown);
    markdown = this._convertBlockquotes(markdown);
    markdown = this._convertTables(markdown);
    markdown = this._convertImages(markdown);
    markdown = this._convertLinks(markdown);
    markdown = this._convertTextFormatting(markdown);
    markdown = this._convertLineBreaks(markdown);
    markdown = this._cleanupHtml(markdown);
    markdown = this._normalizeWhitespace(markdown);

    return markdown;
  }

  private _convertHeaders(html: string): string {
    return html.replace(/<h([1-6])[^>]*>(.*?)<\/h[1-6]>/gi, (match, level, content) => {
      const headerLevel = '#'.repeat(parseInt(level));
      const cleanContent = this._stripHtml(content).trim();
      return `\n${headerLevel} ${cleanContent}\n`;
    });
  }

  private _convertLists(html: string): string {
    // Unordered lists
    html = html.replace(/<ul[^>]*>(.*?)<\/ul>/gis, (match, content) => {
      const items = content.replace(/<li[^>]*>(.*?)<\/li>/gi, (liMatch: string, liContent: string) => {
        const cleanContent = this._stripHtml(liContent).trim();
        return `- ${cleanContent}\n`;
      });
      return `\n${items}\n`;
    });

    // Ordered lists
    html = html.replace(/<ol[^>]*>(.*?)<\/ol>/gis, (match, content) => {
      let counter = 1;
      const items = content.replace(/<li[^>]*>(.*?)<\/li>/gi, (liMatch: string, liContent: string) => {
        const cleanContent = this._stripHtml(liContent).trim();
        return `${counter++}. ${cleanContent}\n`;
      });
      return `\n${items}\n`;
    });

    return html;
  }

  private _convertCodeBlocks(html: string): string {
    // Pre + code blocks
    html = html.replace(/<pre[^>]*><code[^>]*>(.*?)<\/code><\/pre>/gis, (match, content) => {
      const cleanContent = this._decodeHtmlEntities(content).trim();
      const language = this._options.codeBlockLanguage;
      return `\n\`\`\`${language}\n${cleanContent}\n\`\`\`\n`;
    });

    // Inline code
    html = html.replace(/<code[^>]*>(.*?)<\/code>/gi, (match, content) => {
      const cleanContent = this._stripHtml(content);
      return `\`${cleanContent}\``;
    });

    return html;
  }

  private _convertBlockquotes(html: string): string {
    return html.replace(/<blockquote[^>]*>(.*?)<\/blockquote>/gis, (match, content) => {
      const cleanContent = this._stripHtml(content).trim();
      const lines = cleanContent.split('\n');
      const quotedLines = lines.map(line => `> ${line.trim()}`);
      return `\n${quotedLines.join('\n')}\n`;
    });
  }

  private _convertTables(html: string): string {
    return html.replace(/<table[^>]*>(.*?)<\/table>/gis, (match, content) => {
      const rows: string[] = [];
      const headerMatch = content.match(/<thead[^>]*>(.*?)<\/thead>/is);
      const bodyMatch = content.match(/<tbody[^>]*>(.*?)<\/tbody>/is);
      
      // Process header
      if (headerMatch) {
        const headerRow = this._convertTableRow(headerMatch[1]);
        if (headerRow) {
          rows.push(headerRow);
          // Add separator row
          const separatorCells = headerRow.split('|').map(() => '---');
          rows.push(separatorCells.join('|'));
        }
      }
      
      // Process body rows
      if (bodyMatch) {
        const bodyRows = bodyMatch[1].match(/<tr[^>]*>(.*?)<\/tr>/gis);
        if (bodyRows) {
          bodyRows.forEach(row => {
            const convertedRow = this._convertTableRow(row);
            if (convertedRow) rows.push(convertedRow);
          });
        }
      }
      
      return rows.length > 0 ? `\n${rows.join('\n')}\n` : '';
    });
  }

  private _convertTableRow(rowHtml: string): string | null {
    const cells = rowHtml.match(/<t[hd][^>]*>(.*?)<\/t[hd]>/gis);
    if (!cells) return null;
    
    const convertedCells = cells.map(cell => {
      const content = cell.replace(/<t[hd][^>]*>(.*?)<\/t[hd]>/i, '$1');
      return this._stripHtml(content).trim();
    });
    
    return `|${convertedCells.join('|')}|`;
  }

  private _convertImages(html: string): string {
    if (!this._options.includeImages) {
      return html.replace(/<img[^>]*>/gi, '');
    }

    return html.replace(/<img[^>]*src=["']([^"']*)["'][^>]*alt=["']([^"']*)["'][^>]*>/gi, '![$2]($1)')
               .replace(/<img[^>]*alt=["']([^"']*)["'][^>]*src=["']([^"']*)["'][^>]*>/gi, '![$1]($2)')
               .replace(/<img[^>]*src=["']([^"']*)["'][^>]*>/gi, '![]($1)');
  }

  private _convertLinks(html: string): string {
    if (!this._options.includeLinks) {
      return html.replace(/<a[^>]*>(.*?)<\/a>/gi, '$1');
    }

    return html.replace(/<a[^>]*href=["']([^"']*)["'][^>]*>(.*?)<\/a>/gi, '[$2]($1)');
  }

  private _convertTextFormatting(html: string): string {
    // Bold/Strong
    html = html.replace(/<(strong|b)[^>]*>(.*?)<\/(strong|b)>/gi, '**$2**');
    
    // Italic/Emphasis  
    html = html.replace(/<(em|i)[^>]*>(.*?)<\/(em|i)>/gi, '*$2*');
    
    // Strikethrough
    html = html.replace(/<(del|s|strike)[^>]*>(.*?)<\/(del|s|strike)>/gi, '~~$2~~');
    
    return html;
  }

  private _convertLineBreaks(html: string): string {
    return html.replace(/<br[^>]*\/?>/gi, '\n');
  }

  private _cleanupHtml(html: string): string {
    // Remove remaining HTML tags
    return html.replace(/<[^>]*>/g, '');
  }

  private _stripHtml(html: string): string {
    return html.replace(/<[^>]*>/g, '').trim();
  }

  private _decodeHtmlEntities(text: string): string {
    const entityMap: Record<string, string> = {
      '&lt;': '<',
      '&gt;': '>',
      '&amp;': '&',
      '&quot;': '"',
      '&#39;': "'",
      '&nbsp;': ' '
    };

    return text.replace(/&(?:lt|gt|amp|quot|#39|nbsp);/g, (entity) => {
      return entityMap[entity] || entity;
    });
  }

  private _normalizeWhitespace(markdown: string): string {
    // Remove excessive blank lines
    markdown = markdown.replace(/\n\s*\n\s*\n/g, '\n\n');
    
    // Trim leading/trailing whitespace
    markdown = markdown.trim();
    
    // Ensure single newline at end
    return markdown + '\n';
  }
}
```

## Message Communication

### Robust Message Handling
```typescript
// Generated by Copilot
// Enhanced message communication system

class ContentMessageBus {
  private static _instance: ContentMessageBus | null = null;
  private _messageQueue: Array<{ resolve: Function; reject: Function; timeout: NodeJS.Timeout }> = [];

  static getInstance(): ContentMessageBus {
    if (!this._instance) {
      this._instance = new ContentMessageBus();
    }
    return this._instance;
  }

  async sendToBackground<T = unknown>(
    type: string,
    data: Record<string, unknown> = {},
    timeout: number = 10000
  ): Promise<T> {
    return new Promise<T>((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        reject(new Error(`Message timeout: ${type}`));
      }, timeout);

      this._messageQueue.push({ resolve, reject, timeout: timeoutId });

      const message: IMessageData = {
        type,
        data,
        timestamp: Date.now()
      };

      chrome.runtime.sendMessage(message, (response: IMessageResponse) => {
        // Clear timeout
        clearTimeout(timeoutId);
        
        // Remove from queue
        const index = this._messageQueue.findIndex(item => item.timeout === timeoutId);
        if (index >= 0) {
          this._messageQueue.splice(index, 1);
        }

        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else if (response?.success === false) {
          reject(new Error(response.error || 'Message failed'));
        } else {
          resolve(response?.data as T);
        }
      });
    });
  }

  // Clean up any pending messages
  cleanup(): void {
    this._messageQueue.forEach(({ reject, timeout }) => {
      clearTimeout(timeout);
      reject(new Error('Content script cleanup'));
    });
    this._messageQueue = [];
  }
}
```

## Error Handling

### Content Script Error Management
```typescript
// Generated by Copilot
// Comprehensive error handling for content scripts

class ContentErrorHandler {
  private static _errors: Array<{ error: Error; context: string; timestamp: string }> = [];

  static handle(error: Error, context: string = 'unknown'): void {
    const errorInfo = {
      error,
      context,
      timestamp: new Date().toISOString()
    };

    this._errors.push(errorInfo);
    
    // Keep only last 20 errors to prevent memory issues
    if (this._errors.length > 20) {
      this._errors.shift();
    }

    console.error(`Content Script Error [${context}]:`, error);

    // Try to report to background script
    try {
      ContentMessageBus.getInstance().sendToBackground('LOG_ERROR', {
        message: error.message,
        stack: error.stack,
        context,
        url: window.location.href,
        timestamp: errorInfo.timestamp
      }).catch(() => {
        // Ignore errors when reporting errors to prevent recursion
      });
    } catch (reportError) {
      // Silently ignore reporting errors
    }
  }

  static getErrors(): Array<{ error: Error; context: string; timestamp: string }> {
    return [...this._errors];
  }

  static clearErrors(): void {
    this._errors = [];
  }

  static async withErrorHandling<T>(
    asyncFn: () => Promise<T>,
    context: string = 'unknown'
  ): Promise<T> {
    try {
      return await asyncFn();
    } catch (error) {
      this.handle(error as Error, context);
      throw error;
    }
  }
}

// Global error handlers
window.addEventListener('error', (event) => {
  ContentErrorHandler.handle(
    new Error(event.message),
    `global_error:${event.filename}:${event.lineno}`
  );
});

window.addEventListener('unhandledrejection', (event) => {
  ContentErrorHandler.handle(
    new Error(event.reason?.message || 'Unhandled promise rejection'),
    'unhandled_rejection'
  );
});
```

## Performance Optimization

### Content Script Performance Best Practices
```typescript
// Generated by Copilot
// Performance optimization utilities

class ContentPerformanceManager {
  private static _observers: MutationObserver[] = [];
  private static _timers: Set<NodeJS.Timeout> = new Set();

  static debounce<T extends (...args: any[]) => any>(
    func: T,
    wait: number
  ): (...args: Parameters<T>) => void {
    let timeout: NodeJS.Timeout;
    
    return (...args: Parameters<T>) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => func(...args), wait);
      this._timers.add(timeout);
    };
  }

  static throttle<T extends (...args: any[]) => any>(
    func: T,
    limit: number
  ): (...args: Parameters<T>) => void {
    let inThrottle: boolean;
    
    return (...args: Parameters<T>) => {
      if (!inThrottle) {
        func(...args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }

  static observeChanges(
    target: Element,
    callback: MutationCallback,
    options: MutationObserverInit = { childList: true, subtree: true }
  ): MutationObserver {
    const observer = new MutationObserver(callback);
    observer.observe(target, options);
    this._observers.push(observer);
    return observer;
  }

  static cleanup(): void {
    // Disconnect all observers
    this._observers.forEach(observer => observer.disconnect());
    this._observers = [];
    
    // Clear all timers
    this._timers.forEach(timer => clearTimeout(timer));
    this._timers.clear();
    
    // Clean up message bus
    ContentMessageBus.getInstance().cleanup();
    
    console.log('Content script performance cleanup completed');
  }
}

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  ContentPerformanceManager.cleanup();
});
```

## Testing Patterns

### Content Script Testing Considerations
```typescript
// In tests: content-script.test.ts
describe('ContentScript', () => {
  let mockChrome: any;
  
  beforeEach(() => {
    // Mock DOM
    document.body.innerHTML = `
      <article>
        <h1>Test Title</h1>
        <p>Test content paragraph.</p>
      </article>
    `;
    
    // Mock Chrome APIs
    mockChrome = {
      runtime: {
        sendMessage: jest.fn(),
        onMessage: {
          addListener: jest.fn()
        }
      }
    };
    (global as any).chrome = mockChrome;
  });

  test('Should extract content correctly', async () => {
    const extractor = new ContentExtractor();
    await extractor.initialize();
    
    const result = await extractor.extractContent();
    
    expect(result.title).toBe('Test Title');
    expect(result.markdown).toContain('# Test Title');
    expect(result.url).toBe(window.location.href);
  });
});
```

## Best Practices Summary

1. **Self-Contained**: Keep all functionality within the content script
2. **DOM Safety**: Use safe DOM querying methods
3. **Message Handling**: Implement robust async message communication  
4. **Error Handling**: Wrap operations in try-catch blocks
5. **Performance**: Use debouncing/throttling and cleanup observers
6. **Content Detection**: Use scoring algorithms for better content extraction
7. **Markdown Quality**: Implement comprehensive HTML to markdown conversion
8. **Memory Management**: Clean up observers and timers on page unload
