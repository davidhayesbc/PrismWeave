// Generated by Copilot
// Main extension entry point for PrismWeave RAG Assistant

import * as vscode from 'vscode';
import { ModelManager } from './models/model-manager';
import { DocumentRetriever } from './rag/document-retriever';
import { SidebarProvider } from './ui/sidebar-provider';
import { ConfigManager } from './utils/config';
import { Logger } from './utils/logger';

// Global extension context
let extensionContext: vscode.ExtensionContext;
let modelManager: ModelManager;
let documentRetriever: DocumentRetriever;
let sidebarProvider: SidebarProvider;

export async function activate(context: vscode.ExtensionContext) {
  extensionContext = context;
  
  try {
    // Initialize logger
    Logger.initialize(context);
    Logger.info('PrismWeave RAG Assistant activating...');

    // Initialize configuration
    const config = new ConfigManager();
    await config.initialize();

    // Initialize model manager
    modelManager = new ModelManager(config);
    await modelManager.initialize();

    // Initialize document retriever
    documentRetriever = new DocumentRetriever(config);
    await documentRetriever.initialize();

    // Initialize sidebar provider
    sidebarProvider = new SidebarProvider(context, modelManager, documentRetriever);
    
    // Register webview provider
    context.subscriptions.push(
      vscode.window.registerWebviewViewProvider(
        'prismweave.ragChat',
        sidebarProvider,
        { webviewOptions: { retainContextWhenHidden: true } }
      )
    );

    // Register commands
    registerCommands(context);

    // Set context for when clause
    vscode.commands.executeCommand('setContext', 'prismweave.enabled', true);

    Logger.info('PrismWeave RAG Assistant activated successfully');
  } catch (error) {
    Logger.error('Failed to activate PrismWeave RAG Assistant:', error);
    vscode.window.showErrorMessage(
      `Failed to activate PrismWeave RAG Assistant: ${error instanceof Error ? error.message : 'Unknown error'}`
    );
  }
}

export function deactivate() {
  Logger.info('PrismWeave RAG Assistant deactivating...');
  
  // Clean up resources
  if (modelManager) {
    modelManager.dispose();
  }
  
  if (documentRetriever) {
    documentRetriever.dispose();
  }
  
  if (sidebarProvider) {
    sidebarProvider.dispose();
  }
  
  Logger.info('PrismWeave RAG Assistant deactivated');
}

function registerCommands(context: vscode.ExtensionContext) {
  // Open chat command
  const openChatCommand = vscode.commands.registerCommand(
    'prismweave.openChat',
    async () => {
      try {
        await vscode.commands.executeCommand('prismweave.ragChat.focus');
        Logger.info('RAG Chat opened');
      } catch (error) {
        Logger.error('Failed to open RAG Chat:', error);
        vscode.window.showErrorMessage('Failed to open RAG Chat');
      }
    }
  );

  // Generate document command
  const generateDocumentCommand = vscode.commands.registerCommand(
    'prismweave.generateDocument',
    async () => {
      try {
        const query = await vscode.window.showInputBox({
          prompt: 'Enter your document generation query',
          placeHolder: 'e.g., "Write an article about machine learning trends"'
        });

        if (!query) {
          return;
        }

        const filename = await vscode.window.showInputBox({
          prompt: 'Enter filename for the generated document',
          placeHolder: 'e.g., "ml-trends-2025.md"',
          validateInput: (value) => {
            if (!value) {
              return 'Filename is required';
            }
            if (!value.endsWith('.md')) {
              return 'Filename must end with .md';
            }
            return null;
          }
        });

        if (!filename) {
          return;
        }

        // Show progress and generate document
        vscode.window.withProgress({
          location: vscode.ProgressLocation.Notification,
          title: 'Generating document...',
          cancellable: false
        }, async (progress) => {
          try {
            progress.report({ message: 'Searching relevant documents...' });
            
            // This will be implemented in Phase 7
            await new Promise(resolve => setTimeout(resolve, 2000)); // Placeholder
            
            progress.report({ message: 'Generating content...' });
            
            // Placeholder for actual generation
            await new Promise(resolve => setTimeout(resolve, 3000));
            
            vscode.window.showInformationMessage(`Document "${filename}" generated successfully!`);
            Logger.info(`Document generated: ${filename}`);
          } catch (error) {
            Logger.error('Failed to generate document:', error);
            vscode.window.showErrorMessage('Failed to generate document');
          }
        });
      } catch (error) {
        Logger.error('Failed to execute generate document command:', error);
        vscode.window.showErrorMessage('Failed to generate document');
      }
    }
  );

  // Search documents command
  const searchDocumentsCommand = vscode.commands.registerCommand(
    'prismweave.searchDocuments',
    async () => {
      try {
        const query = await vscode.window.showInputBox({
          prompt: 'Enter your search query',
          placeHolder: 'e.g., "machine learning algorithms"'
        });

        if (!query) {
          return;
        }

        // Show progress and search
        vscode.window.withProgress({
          location: vscode.ProgressLocation.Notification,
          title: 'Searching documents...',
          cancellable: false
        }, async (progress) => {
          try {
            progress.report({ message: 'Querying ChromaDB...' });
            
            // This will be implemented in Phase 3
            const results = await documentRetriever.search(query);
            
            // Show results in sidebar
            if (sidebarProvider) {
              sidebarProvider.showSearchResults(query, results);
            }
            
            vscode.window.showInformationMessage(`Found ${results.length} relevant documents`);
            Logger.info(`Search completed: ${results.length} results for "${query}"`);
          } catch (error) {
            Logger.error('Failed to search documents:', error);
            vscode.window.showErrorMessage('Failed to search documents');
          }
        });
      } catch (error) {
        Logger.error('Failed to execute search command:', error);
        vscode.window.showErrorMessage('Failed to search documents');
      }
    }
  );

  // Refresh models command
  const refreshModelsCommand = vscode.commands.registerCommand(
    'prismweave.refreshModels',
    async () => {
      try {
        vscode.window.withProgress({
          location: vscode.ProgressLocation.Notification,
          title: 'Refreshing models...',
          cancellable: false
        }, async (progress) => {
          try {
            progress.report({ message: 'Reloading model configurations...' });
            
            await modelManager.refresh();
            
            vscode.window.showInformationMessage('Models refreshed successfully');
            Logger.info('Models refreshed');
          } catch (error) {
            Logger.error('Failed to refresh models:', error);
            vscode.window.showErrorMessage('Failed to refresh models');
          }
        });
      } catch (error) {
        Logger.error('Failed to execute refresh models command:', error);
        vscode.window.showErrorMessage('Failed to refresh models');
      }
    }
  );

  // Register all commands
  context.subscriptions.push(
    openChatCommand,
    generateDocumentCommand,
    searchDocumentsCommand,
    refreshModelsCommand
  );
}

// Export for testing
export function getExtensionContext(): vscode.ExtensionContext {
  return extensionContext;
}

export function getModelManager(): ModelManager {
  return modelManager;
}

export function getDocumentRetriever(): DocumentRetriever {
  return documentRetriever;
}
