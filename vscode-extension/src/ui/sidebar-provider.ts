// Generated by Copilot
// Sidebar provider for the RAG chat interface

import * as vscode from 'vscode';
import { ModelManager } from '../models/model-manager';
import { DocumentRetriever } from '../rag/document-retriever';
import { ISearchResult, IRetrievedDocument } from '../types/rag';
import { IChatMessage, IChatSession, IWebviewMessage } from '../types/ui';
import { Logger } from '../utils/logger';

export class SidebarProvider implements vscode.WebviewViewProvider {
  private _view?: vscode.WebviewView;
  private _currentSession: IChatSession | null = null;
  private _modelManager: ModelManager;
  private _documentRetriever: DocumentRetriever;

  constructor(
    private _context: vscode.ExtensionContext,
    modelManager: ModelManager,
    documentRetriever: DocumentRetriever
  ) {
    this._modelManager = modelManager;
    this._documentRetriever = documentRetriever;
  }

  resolveWebviewView(webviewView: vscode.WebviewView): void {
    this._view = webviewView;

    webviewView.webview.options = {
      enableScripts: true,
      localResourceRoots: [
        this._context.extensionUri
      ]
    };

    webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);

    // Handle messages from webview
    webviewView.webview.onDidReceiveMessage(
      message => this._handleWebviewMessage(message),
      undefined,
      this._context.subscriptions
    );

    // Initialize a new chat session
    this._initializeSession();
  }

  async showSearchResults(query: string, results: ISearchResult[]): Promise<void> {
    if (!this._view) {
      return;
    }

    const message: IWebviewMessage = {
      type: 'showSearchResults',
      payload: {
        query,
        results: results.map(result => ({
          title: result.document.title,
          snippet: result.snippet,
          score: result.score,
          source: result.document.path,
          metadata: result.document
        })),
        totalResults: results.length,
        executionTime: 0 // This will be calculated in the actual implementation
      }
    };

    await this._view.webview.postMessage(message);
  }

  dispose(): void {
    // WebviewView doesn't have a dispose method
    // The view will be disposed by VS Code automatically
    this._view = undefined;
  }

  private _initializeSession(): void {
    const now = new Date();
    this._currentSession = {
      id: `session-${Date.now()}`,
      title: 'New Chat',
      messages: [],
      startedAt: now,
      lastActivity: now,
      createdAt: now,
      updatedAt: now
    };

    Logger.info(`New chat session initialized: ${this._currentSession?.id}`);
  }

  private async _handleWebviewMessage(message: IWebviewMessage): Promise<void> {
    try {
      switch (message.type) {
        case 'sendMessage':
          await this._handleSendMessage((message.data || message.payload) as { content: string });
          break;
        case 'clearChat':
          await this._handleClearChat();
          break;
        case 'regenerateResponse':
          await this._handleRegenerateResponse();
          break;
        case 'ready':
          await this._handleWebviewReady();
          break;
        default:
          Logger.warn(`Unknown message type: ${message.type}`);
      }
    } catch (error) {
      Logger.error('Error handling webview message:', error);
      
      const errorMessage: IWebviewMessage = {
        type: 'error',
        payload: {
          message: error instanceof Error ? error.message : 'Unknown error occurred'
        }
      };
      
      await this._view?.webview.postMessage(errorMessage);
    }
  }

  private async _handleSendMessage(data: { content: string }): Promise<void> {
    if (!this._currentSession) {
      this._initializeSession();
    }

    const userMessage: IChatMessage = {
      id: `msg-${Date.now()}`,
      type: 'user',
      content: data.content,
      timestamp: new Date()
    };

    this._currentSession!.messages.push(userMessage);
    this._currentSession!.updatedAt = new Date();

    // Send user message to webview
    await this._view?.webview.postMessage({
      type: 'addMessage',
      data: userMessage
    });

    // Show typing indicator
    await this._view?.webview.postMessage({
      type: 'setTyping',
      data: { isTyping: true }
    });

    try {
      // Search for relevant documents
      const searchResults = await this._documentRetriever.search(data.content, {
        limit: 5,
        threshold: 0.7
      });

      // Generate response using the model
      const response = await this._generateResponse(data.content, searchResults);

      const assistantMessage: IChatMessage = {
        id: `msg-${Date.now()}`,
        type: 'assistant',
        content: response,
        timestamp: new Date(),
        metadata: {
          sources: searchResults.map(r => r.document.metadata?.source || r.document.path),
          citations: searchResults.map(r => r.document.title),
          model: this._modelManager.currentModel?.name || 'unknown'
        }
      };

      this._currentSession!.messages.push(assistantMessage);
      this._currentSession!.updatedAt = new Date();

      // Send assistant message to webview
      await this._view?.webview.postMessage({
        type: 'addMessage',
        data: assistantMessage
      });
    } catch (error) {
      Logger.error('Error generating response:', error);
      
      const errorMessage: IChatMessage = {
        id: `msg-${Date.now()}`,
        type: 'system',
        content: `Error: ${error instanceof Error ? error.message : 'Unknown error occurred'}`,
        timestamp: new Date()
      };

      this._currentSession!.messages.push(errorMessage);
      
      await this._view?.webview.postMessage({
        type: 'addMessage',
        data: errorMessage
      });
    } finally {
      // Hide typing indicator
      await this._view?.webview.postMessage({
        type: 'setTyping',
        data: { isTyping: false }
      });
    }
  }

  private async _handleClearChat(): Promise<void> {
    this._initializeSession();
    
    await this._view?.webview.postMessage({
      type: 'clearMessages'
    });
  }

  private async _handleRegenerateResponse(): Promise<void> {
    if (!this._currentSession || this._currentSession.messages.length < 2) {
      return;
    }

    // Remove the last assistant message
    const lastMessage = this._currentSession.messages.pop();
    if (lastMessage?.type === 'assistant') {
      const previousUserMessage = this._currentSession.messages
        .slice()
        .reverse()
        .find((msg: IChatMessage) => msg.type === 'user');

      if (previousUserMessage) {
        await this._handleSendMessage({ content: previousUserMessage.content });
      }
    }
  }

  private async _handleWebviewReady(): Promise<void> {
    // Send current session to webview
    if (this._currentSession) {
      await this._view?.webview.postMessage({
        type: 'loadSession',
        data: this._currentSession
      });
    }

    // Send current model info
    const currentModel = this._modelManager.currentModel;
    if (currentModel) {
      await this._view?.webview.postMessage({
        type: 'modelInfo',
        data: {
          name: currentModel.name,
          provider: currentModel.provider,
          isLoaded: currentModel.loaded
        }
      });
    }
  }

  private async _generateResponse(query: string, searchResults: ISearchResult[]): Promise<string> {
    const currentModel = this._modelManager.currentModel;
    if (!currentModel) {
      throw new Error('No model loaded');
    }

    // Build context from search results
    const context = searchResults.map(result => 
      `Document: ${result.document.title}\nContent: ${result.snippet}\nSource: ${result.document.metadata?.source || result.document.path}\n`
    ).join('\n---\n');

    // Build prompt
    const prompt = `You are a helpful assistant that answers questions based on the provided document context. Use the context below to answer the user's question. If the context doesn't contain enough information, say so clearly.

Context:
${context}

Question: ${query}

Answer:`;

    // Generate response
    const response = await currentModel.generate?.(prompt, {
      maxTokens: 512,
      temperature: 0.7
    }) || 'Model does not support text generation';

    return response;
  }

  private _getHtmlForWebview(webview: vscode.Webview): string {
    // This is a basic HTML template - will be enhanced in Phase 4
    return `
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>PrismWeave RAG Assistant</title>
        <style>
          body {
            font-family: var(--vscode-font-family);
            color: var(--vscode-foreground);
            background-color: var(--vscode-sideBar-background);
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
          }
          
          .header {
            padding: 12px 16px;
            border-bottom: 1px solid var(--vscode-sideBar-border);
            background-color: var(--vscode-sideBarSectionHeader-background);
          }
          
          .header h3 {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
          }
          
          .messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
          }
          
          .message {
            max-width: 100%;
            word-wrap: break-word;
          }
          
          .message.user {
            align-self: flex-end;
            background-color: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            padding: 8px 12px;
            border-radius: 12px;
            margin-left: 20%;
          }
          
          .message.assistant {
            align-self: flex-start;
            background-color: var(--vscode-input-background);
            color: var(--vscode-input-foreground);
            padding: 8px 12px;
            border-radius: 12px;
            margin-right: 20%;
            border: 1px solid var(--vscode-input-border);
          }
          
          .message.system {
            align-self: center;
            background-color: var(--vscode-inputValidation-warningBackground);
            color: var(--vscode-inputValidation-warningForeground);
            padding: 8px 12px;
            border-radius: 12px;
            font-style: italic;
            border: 1px solid var(--vscode-inputValidation-warningBorder);
          }
          
          .input-container {
            padding: 16px;
            border-top: 1px solid var(--vscode-sideBar-border);
            background-color: var(--vscode-sideBar-background);
          }
          
          .input-row {
            display: flex;
            gap: 8px;
          }
          
          #messageInput {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid var(--vscode-input-border);
            border-radius: 6px;
            background-color: var(--vscode-input-background);
            color: var(--vscode-input-foreground);
            font-family: var(--vscode-font-family);
            font-size: 13px;
          }
          
          #messageInput:focus {
            outline: none;
            border-color: var(--vscode-focusBorder);
          }
          
          .button {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            background-color: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            cursor: pointer;
            font-size: 13px;
          }
          
          .button:hover {
            background-color: var(--vscode-button-hoverBackground);
          }
          
          .button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
          }
          
          .typing-indicator {
            display: none;
            padding: 8px 12px;
            font-style: italic;
            color: var(--vscode-descriptionForeground);
          }
          
          .typing-indicator.visible {
            display: block;
          }
          
          .model-info {
            font-size: 11px;
            color: var(--vscode-descriptionForeground);
            margin-top: 4px;
          }
        </style>
      </head>
      <body>
        <div class="header">
          <h3>RAG Assistant</h3>
          <div class="model-info" id="modelInfo">No model loaded</div>
        </div>
        
        <div class="messages" id="messages">
          <div class="message system">
            Welcome to PrismWeave RAG Assistant! Ask me anything about your documents.
          </div>
        </div>
        
        <div class="typing-indicator" id="typingIndicator">
          Assistant is typing...
        </div>
        
        <div class="input-container">
          <div class="input-row">
            <input type="text" id="messageInput" placeholder="Ask a question..." />
            <button class="button" id="sendButton">Send</button>
          </div>
          <div style="margin-top: 8px; display: flex; gap: 8px;">
            <button class="button" id="clearButton">Clear</button>
            <button class="button" id="regenerateButton">Regenerate</button>
          </div>
        </div>
        
        <script>
          const vscode = acquireVsCodeApi();
          const messagesContainer = document.getElementById('messages');
          const messageInput = document.getElementById('messageInput');
          const sendButton = document.getElementById('sendButton');
          const clearButton = document.getElementById('clearButton');
          const regenerateButton = document.getElementById('regenerateButton');
          const typingIndicator = document.getElementById('typingIndicator');
          const modelInfo = document.getElementById('modelInfo');
          
          let isTyping = false;
          
          // Send message
          function sendMessage() {
            const content = messageInput.value.trim();
            if (!content || isTyping) return;
            
            vscode.postMessage({
              type: 'sendMessage',
              data: { content }
            });
            
            messageInput.value = '';
            sendButton.disabled = true;
          }
          
          // Event listeners
          sendButton.addEventListener('click', sendMessage);
          
          messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              sendMessage();
            }
          });
          
          clearButton.addEventListener('click', () => {
            vscode.postMessage({ type: 'clearChat' });
          });
          
          regenerateButton.addEventListener('click', () => {
            vscode.postMessage({ type: 'regenerateResponse' });
          });
          
          // Handle messages from extension
          window.addEventListener('message', (event) => {
            const message = event.data;
            
            switch (message.type) {
              case 'addMessage':
                addMessage(message.data);
                break;
              case 'clearMessages':
                messagesContainer.innerHTML = '<div class="message system">Chat cleared. Ask me anything!</div>';
                break;
              case 'setTyping':
                setTyping(message.data.isTyping);
                break;
              case 'modelInfo':
                updateModelInfo(message.data);
                break;
              case 'loadSession':
                loadSession(message.data);
                break;
              case 'error':
                showError(message.data.message);
                break;
            }
          });
          
          function addMessage(message) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message ' + message.type;
            messageDiv.textContent = message.content;
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            sendButton.disabled = false;
          }
          
          function setTyping(typing) {
            isTyping = typing;
            typingIndicator.classList.toggle('visible', typing);
            sendButton.disabled = typing;
          }
          
          function updateModelInfo(info) {
            modelInfo.textContent = info.name ? 
              \`Model: \${info.name} (\${info.provider})\` : 
              'No model loaded';
          }
          
          function loadSession(session) {
            messagesContainer.innerHTML = '';
            session.messages.forEach(message => addMessage(message));
          }
          
          function showError(errorMessage) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'message system';
            errorDiv.textContent = 'Error: ' + errorMessage;
            messagesContainer.appendChild(errorDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            sendButton.disabled = false;
            setTyping(false);
          }
          
          // Initialize
          vscode.postMessage({ type: 'ready' });
        </script>
      </body>
      </html>
    `;
  }
}
