// Generated by Copilot
// Tests for ConfigManager

import { afterEach, beforeEach, describe, expect, jest, test } from '@jest/globals';
import { existsSync, mkdirSync, readFileSync, unlinkSync, writeFileSync } from 'fs';
import { homedir } from 'os';
import { join } from 'path';
import { ConfigManager } from '../src/config.js';

describe('ConfigManager', () => {
  let configPath: string;
  let backupPath: string;
  let hasExistingConfig = false;

  beforeEach(() => {
    const configDir = join(homedir(), '.prismweave');
    configPath = join(configDir, 'config.json');
    backupPath = join(configDir, 'config.backup.json');

    // Backup existing config if present
    if (existsSync(configPath)) {
      hasExistingConfig = true;
      const content = readFileSync(configPath, 'utf-8');
      writeFileSync(backupPath, content);
      unlinkSync(configPath);
    }
  });

  afterEach(() => {
    // Restore backup if exists
    if (hasExistingConfig && existsSync(backupPath)) {
      const content = readFileSync(backupPath, 'utf-8');
      writeFileSync(configPath, content);
      unlinkSync(backupPath);
    } else if (existsSync(configPath)) {
      unlinkSync(configPath);
    }
  });

  describe('Constructor and Load', () => {
    test('should create new config if none exists', () => {
      const config = new ConfigManager();
      expect(config).toBeDefined();
      expect(config.getAll()).toEqual({});
    });

    test('should load existing config', () => {
      const configDir = join(homedir(), '.prismweave');
      if (!existsSync(configDir)) {
        mkdirSync(configDir, { recursive: true });
      }

      const testData = { githubToken: 'test-token', githubRepo: 'owner/repo' };
      writeFileSync(configPath, JSON.stringify(testData));

      const config = new ConfigManager();
      expect(config.get('githubToken')).toBe('test-token');
      expect(config.get('githubRepo')).toBe('owner/repo');
    });

    test('should handle corrupted config file gracefully', () => {
      const configDir = join(homedir(), '.prismweave');
      if (!existsSync(configDir)) {
        mkdirSync(configDir, { recursive: true });
      }

      writeFileSync(configPath, 'invalid json {{{');

      const config = new ConfigManager();
      expect(config.getAll()).toEqual({});
    });
  });

  describe('Get and Set', () => {
    test('should set and get config values', () => {
      const config = new ConfigManager();
      config.set('githubToken', 'my-token');
      expect(config.get('githubToken')).toBe('my-token');
    });

    test('should return undefined for missing keys', () => {
      const config = new ConfigManager();
      expect(config.get('githubToken')).toBeUndefined();
    });

    test('should set multiple values', () => {
      const config = new ConfigManager();
      config.set('githubToken', 'token-123');
      config.set('githubRepo', 'user/repo');
      config.set('includeImages', true);

      expect(config.get('githubToken')).toBe('token-123');
      expect(config.get('githubRepo')).toBe('user/repo');
      expect(config.get('includeImages')).toBe(true);
    });

    test('should persist config to file', () => {
      const config = new ConfigManager();
      config.set('githubToken', 'persisted-token');
      config.set('githubRepo', 'test/repo');

      // Create new instance to verify persistence
      const newConfig = new ConfigManager();
      expect(newConfig.get('githubToken')).toBe('persisted-token');
      expect(newConfig.get('githubRepo')).toBe('test/repo');
    });
  });

  describe('GetAll and SetAll', () => {
    test('should get all config values', () => {
      const config = new ConfigManager();
      config.set('githubToken', 'token');
      config.set('githubRepo', 'repo');

      const all = config.getAll();
      expect(all).toEqual({
        githubToken: 'token',
        githubRepo: 'repo',
      });
    });

    test('should set all config values', () => {
      const config = new ConfigManager();
      const newConfig = {
        githubToken: 'new-token',
        githubRepo: 'new/repo',
        includeImages: false,
        timeout: 60000,
      };

      config.setAll(newConfig);
      expect(config.getAll()).toEqual(newConfig);
    });

    test('should replace existing config with setAll', () => {
      const config = new ConfigManager();
      config.set('githubToken', 'old-token');
      config.set('includeImages', true);

      config.setAll({
        githubToken: 'new-token',
        githubRepo: 'new/repo',
      });

      const all = config.getAll();
      expect(all.githubToken).toBe('new-token');
      expect(all.githubRepo).toBe('new/repo');
      expect(all.includeImages).toBeUndefined();
    });
  });

  describe('Has', () => {
    test('should return true for existing keys', () => {
      const config = new ConfigManager();
      config.set('githubToken', 'token');
      expect(config.has('githubToken')).toBe(true);
    });

    test('should return false for missing keys', () => {
      const config = new ConfigManager();
      expect(config.has('githubToken')).toBe(false);
    });

    test('should return false for undefined values', () => {
      const config = new ConfigManager();
      config.set('githubToken', undefined as any);
      expect(config.has('githubToken')).toBe(false);
    });
  });

  describe('Validate', () => {
    test('should validate complete configuration', () => {
      const config = new ConfigManager();
      config.set('githubToken', 'valid-token');
      config.set('githubRepo', 'owner/repo');

      const result = config.validate();
      expect(result.isValid).toBe(true);
      expect(result.errors).toEqual([]);
    });

    test('should require githubToken', () => {
      const config = new ConfigManager();
      config.set('githubRepo', 'owner/repo');

      const result = config.validate();
      expect(result.isValid).toBe(false);
      expect(result.errors).toContain('GitHub token is required');
    });

    test('should require githubRepo', () => {
      const config = new ConfigManager();
      config.set('githubToken', 'token');

      const result = config.validate();
      expect(result.isValid).toBe(false);
      expect(result.errors).toContain('GitHub repository is required');
    });

    test('should validate repository format', () => {
      const config = new ConfigManager();
      config.set('githubToken', 'token');
      config.set('githubRepo', 'invalid-format');

      const result = config.validate();
      expect(result.isValid).toBe(false);
      expect(result.errors).toContain('GitHub repository must be in format: owner/repo');
    });

    test('should accept valid repository formats', () => {
      const config = new ConfigManager();
      config.set('githubToken', 'token');

      const validRepos = ['owner/repo', 'my-org/my-repo', 'user123/project_name'];

      validRepos.forEach((repo) => {
        config.set('githubRepo', repo);
        const result = config.validate();
        expect(result.isValid).toBe(true);
      });
    });

    test('should return all validation errors', () => {
      const config = new ConfigManager();

      const result = config.validate();
      expect(result.isValid).toBe(false);
      expect(result.errors).toHaveLength(2);
      expect(result.errors).toContain('GitHub token is required');
      expect(result.errors).toContain('GitHub repository is required');
    });
  });

  describe('File Operations', () => {
    test('should create config directory if it does not exist', () => {
      const configDir = join(homedir(), '.prismweave');
      if (existsSync(configDir)) {
        // Temporarily rename the directory
        const tempDir = configDir + '_temp';
        if (existsSync(tempDir)) {
          unlinkSync(join(tempDir, 'config.json'));
        }
      }

      const config = new ConfigManager();
      config.set('githubToken', 'test');

      expect(existsSync(configDir)).toBe(true);
    });

    test('should handle save errors gracefully', () => {
      const config = new ConfigManager();

      // Mock writeFileSync to throw error
      const originalWrite = writeFileSync;
      const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation(() => {});

      try {
        // This should not throw even if save fails
        config.set('githubToken', 'test');
        expect(consoleErrorSpy).not.toHaveBeenCalled();
      } finally {
        consoleErrorSpy.mockRestore();
      }
    });
  });

  describe('Type Safety', () => {
    test('should handle different value types', () => {
      const config = new ConfigManager();

      config.set('githubToken', 'string-value');
      config.set('includeImages', true);
      config.set('timeout', 30000);

      expect(typeof config.get('githubToken')).toBe('string');
      expect(typeof config.get('includeImages')).toBe('boolean');
      expect(typeof config.get('timeout')).toBe('number');
    });

    test('should preserve value types in getAll', () => {
      const config = new ConfigManager();

      const testConfig = {
        githubToken: 'token',
        githubRepo: 'owner/repo',
        includeImages: false,
        includeLinks: true,
        timeout: 60000,
      };

      config.setAll(testConfig);
      const retrieved = config.getAll();

      expect(retrieved).toEqual(testConfig);
      expect(typeof retrieved.includeImages).toBe('boolean');
      expect(typeof retrieved.timeout).toBe('number');
    });
  });
});
