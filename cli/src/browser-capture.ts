// Generated by Copilot
// Browser Capture - Headless browser integration for CLI
// Uses Puppeteer to fetch and extract content from URLs
// Uses the same content extraction logic as the browser extension's ContentExtractionCore

import puppeteer, { Browser, Page } from 'puppeteer';
import { MarkdownConverterCore } from './shared/markdown-converter-core.js';

export interface ICaptureOptions {
  timeout?: number;
  waitForSelector?: string;
  includeImages?: boolean;
  includeLinks?: boolean;
  userAgent?: string;
  viewport?: { width: number; height: number };
}

export interface ICapturedContent {
  title: string;
  url: string;
  html: string;
  markdown: string;
  metadata: {
    description?: string;
    author?: string;
    keywords?: string[];
    capturedAt: string;
    wordCount?: number;
    estimatedReadingTime?: number;
    publishedDate?: string;
    language?: string;
  };
  stats: {
    wordCount: number;
    characterCount: number;
    imageCount: number;
    linkCount: number;
  };
}

export class BrowserCapture {
  private browser: Browser | null = null;
  private converter: MarkdownConverterCore;

  constructor() {
    this.converter = new MarkdownConverterCore();
  }

  async initialize(): Promise<void> {
    if (this.browser) return;

    this.browser = await puppeteer.launch({
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-accelerated-2d-canvas',
        '--disable-gpu',
      ],
    });
  }

  async captureUrl(
    url: string,
    options: ICaptureOptions = {}
  ): Promise<ICapturedContent> {
    if (!this.browser) {
      await this.initialize();
    }

    const page = await this.browser!.newPage();

    try {
      // Set viewport
      if (options.viewport) {
        await page.setViewport(options.viewport);
      } else {
        await page.setViewport({ width: 1920, height: 1080 });
      }

      // Set user agent
      if (options.userAgent) {
        await page.setUserAgent(options.userAgent);
      }

      // Navigate to URL
      await page.goto(url, {
        waitUntil: 'networkidle2',
        timeout: options.timeout || 30000,
      });

      // Wait for specific selector if provided
      if (options.waitForSelector) {
        await page.waitForSelector(options.waitForSelector, {
          timeout: options.timeout || 30000,
        });
      }

      // Extract content
      const content = await this.extractContent(page, url, options);

      return content;
    } finally {
      await page.close();
    }
  }

  async close(): Promise<void> {
    if (this.browser) {
      await this.browser.close();
      this.browser = null;
    }
  }

  private async extractContent(
    page: Page,
    url: string,
    options: ICaptureOptions
  ): Promise<ICapturedContent> {
    // Use a comprehensive extraction script that mimics ContentExtractionCore
    const pageData = await page.evaluate(
      (extractionOptions: any): {
        title: string;
        html: string;
        metadata: {
          description?: string;
          author?: string;
          keywords?: string[];
          wordCount?: number;
          estimatedReadingTime?: number;
          publishedDate?: string;
          language?: string;
        };
        wordCount: number;
        readingTime: number;
      } => {
        // Helper functions (matching ContentExtractionCore logic)
        const countWords = (text: string): number => {
          return text.split(/\s+/).filter(word => word.length > 0).length;
        };

        const estimateReadingTime = (wordCount: number): number => {
          return Math.ceil(wordCount / 200);
        };

        const hasSubstantialContent = (element: Element): boolean => {
          const textContent = element.textContent || '';
          const wordCount = countWords(textContent);
          return wordCount > 30;
        };

        const scoreElement = (element: Element): number => {
          const text = element.textContent || '';
          const wordCount = countWords(text);
          let score = 0;

          score += Math.min(wordCount / 10, 50);

          const paragraphs = element.querySelectorAll('p').length;
          score += paragraphs * 2;

          const links = element.querySelectorAll('a').length;
          const linkDensity = links / Math.max(wordCount, 1);
          if (linkDensity > 0.3) score -= 20;

          const tagName = element.tagName.toLowerCase();
          if (tagName === 'article') score += 15;
          if (tagName === 'main') score += 10;

          const className = element.className.toLowerCase();
          if (className.includes('content')) score += 10;
          if (className.includes('post')) score += 8;
          if (className.includes('article')) score += 8;
          if (className.includes('sidebar')) score -= 10;
          if (className.includes('footer')) score -= 10;
          if (className.includes('header')) score -= 10;
          if (className.includes('nav')) score -= 15;

          return Math.max(score, 0);
        };

        // Find main content (matching ContentExtractionCore logic)
        const findMainContent = (): Element => {
          // Try custom selectors first
          if (extractionOptions.customSelectors?.length) {
            for (const selector of extractionOptions.customSelectors) {
              const element = document.querySelector(selector);
              if (element && hasSubstantialContent(element)) {
                return element;
              }
            }
          }

          // Common content selectors
          const contentSelectors = [
            'article',
            'main',
            '[role="main"]',
            '.content',
            '.post-content',
            '.entry-content',
            '.article-content',
            '#content',
            '#main',
            '.post',
            '.entry',
          ];

          for (const selector of contentSelectors) {
            const element = document.querySelector(selector);
            if (element && hasSubstantialContent(element)) {
              return element;
            }
          }

          // Score-based fallback
          const candidates = Array.from(document.querySelectorAll('div, section, article'));
          let bestCandidate: { element: Element; score: number } | null = null;

          for (const candidate of candidates) {
            if (hasSubstantialContent(candidate)) {
              const score = scoreElement(candidate);
              if (!bestCandidate || score > bestCandidate.score) {
                bestCandidate = { element: candidate, score };
              }
            }
          }

          return bestCandidate?.element || document.body;
        };

        // Clean content (matching ContentExtractionCore logic)
        const cleanContent = (element: Element): Element => {
          const cloned = element.cloneNode(true) as Element;

          const defaultExcludeSelectors = [
            'script',
            'style',
            'noscript',
            'iframe',
            '.advertisement',
            '.ad',
            '.ads',
            '.popup',
            '.modal',
            '.social-share',
            '.comments',
            '.related-posts',
            '[style*="display: none"]',
            '[style*="visibility: hidden"]',
          ];

          const excludeSelectors = [
            ...defaultExcludeSelectors,
            ...(extractionOptions.excludeSelectors || []),
          ];

          excludeSelectors.forEach(selector => {
            const elements = cloned.querySelectorAll(selector);
            elements.forEach(el => el.remove());
          });

          // Remove navigation
          if (extractionOptions.removeNavigation !== false) {
            const navSelectors = [
              'nav',
              'header',
              'footer',
              '[role="navigation"]',
              '[role="banner"]',
              '[role="contentinfo"]',
              '.navigation',
              '.nav',
              '.menu',
              '.breadcrumb',
            ];

            navSelectors.forEach(selector => {
              const elements = cloned.querySelectorAll(selector);
              elements.forEach(el => el.remove());
            });
          }

          // Remove ads
          if (extractionOptions.removeAds !== false) {
            const adSelectors = [
              '[class*="ad"]',
              '[id*="ad"]',
              '[class*="banner"]',
              '[id*="banner"]',
              '[class*="promo"]',
              '[id*="promo"]',
              '[class*="sponsor"]',
              '[id*="sponsor"]',
            ];

            adSelectors.forEach(selector => {
              const elements = cloned.querySelectorAll(selector);
              elements.forEach(el => {
                const text = el.textContent || '';
                const wordCount = countWords(text);
                const className = el.className.toLowerCase();
                const id = el.id.toLowerCase();

                const adPatterns = [
                  'advertisement',
                  'google-ad',
                  'adsense',
                  'ad-banner',
                  'ad-container',
                  'ad-wrapper',
                  'sponsored',
                  'promo-box',
                ];

                const hasAdCharacteristics = adPatterns.some(
                  pattern => className.includes(pattern) || id.includes(pattern)
                );

                if (wordCount < 10 || hasAdCharacteristics) {
                  el.remove();
                }
              });
            });
          }

          return cloned;
        };

        // Extract metadata (matching ContentExtractionCore logic)
        const extractTitle = (): string => {
          const titleSources = [
            () => document.querySelector('[property="og:title"]')?.getAttribute('content'),
            () => document.querySelector('[name="twitter:title"]')?.getAttribute('content'),
            () => document.querySelector('h1')?.textContent,
            () => document.title,
          ];

          for (const source of titleSources) {
            const title = source();
            if (title && title.trim().length > 0) {
              return title.trim();
            }
          }

          return 'Untitled';
        };

        const extractDescription = (): string => {
          const descSources = [
            () => document.querySelector('[property="og:description"]')?.getAttribute('content'),
            () =>
              document.querySelector('[name="twitter:description"]')?.getAttribute('content'),
            () => document.querySelector('[name="description"]')?.getAttribute('content'),
          ];

          for (const source of descSources) {
            const desc = source();
            if (desc && desc.trim().length > 0) {
              return desc.trim();
            }
          }

          return '';
        };

        const extractKeywords = (): string[] => {
          const keywordsMeta = document.querySelector('[name="keywords"]')?.getAttribute('content');
          if (keywordsMeta) {
            return keywordsMeta
              .split(',')
              .map(keyword => keyword.trim())
              .filter(keyword => keyword.length > 0);
          }
          return [];
        };

        const extractAuthor = (): string => {
          const authorSources = [
            () =>
              document.querySelector('[property="article:author"]')?.getAttribute('content'),
            () => document.querySelector('[name="author"]')?.getAttribute('content'),
            () => document.querySelector('[rel="author"]')?.textContent,
            () => document.querySelector('.author')?.textContent,
            () => document.querySelector('.byline')?.textContent,
            () => document.querySelector('[class*="author"]')?.textContent,
            () => document.querySelector('.post-author')?.textContent,
          ];

          for (const source of authorSources) {
            const author = source();
            if (author && author.trim().length > 0) {
              return author.trim();
            }
          }

          return '';
        };

        const extractPublishedDate = (): string => {
          const dateSources = [
            () =>
              document
                .querySelector('[property="article:published_time"]')
                ?.getAttribute('content'),
            () => document.querySelector('[name="publish_date"]')?.getAttribute('content'),
            () => document.querySelector('time[datetime]')?.getAttribute('datetime'),
            () => document.querySelector('.publish-date')?.textContent,
            () => document.querySelector('.date')?.textContent,
            () => document.querySelector('.published')?.textContent,
            () => document.querySelector('[class*="date"]')?.textContent,
          ];

          for (const source of dateSources) {
            const date = source();
            if (date && date.trim().length > 0) {
              return date.trim();
            }
          }

          return '';
        };

        const extractLanguage = (): string => {
          return (
            document.documentElement.lang ||
            document.querySelector('[property="og:locale"]')?.getAttribute('content') ||
            'en'
          );
        };

        // Perform extraction
        const title = extractTitle();
        const mainContent = findMainContent();
        const cleanedElement = cleanContent(mainContent);
        const html = cleanedElement.innerHTML;
        const cleanedText = cleanedElement.textContent || '';

        const wordCount = countWords(cleanedText);
        const readingTime = estimateReadingTime(wordCount);

        return {
          title,
          html,
          metadata: {
            description: extractDescription(),
            author: extractAuthor(),
            keywords: extractKeywords(),
            wordCount,
            estimatedReadingTime: readingTime,
            publishedDate: extractPublishedDate(),
            language: extractLanguage(),
          },
          wordCount,
          readingTime,
        };
      },
      {
        customSelectors: options.waitForSelector ? [options.waitForSelector] : undefined,
        cleanHtml: true,
        removeAds: true,
        removeNavigation: true,
        excludeSelectors: [],
        includeImages: options.includeImages ?? true,
        includeLinks: options.includeLinks ?? true,
      }
    );

    // Convert HTML to Markdown
    const conversionResult = this.converter.convertToMarkdown(pageData.html, {
      includeImages: options.includeImages ?? true,
      includeLinks: options.includeLinks ?? true,
    });

    // Generate frontmatter with enhanced metadata from ContentExtractionCore
    const frontmatter = this.generateFrontmatter(
      pageData.title,
      url,
      {
        ...pageData.metadata,
        wordCount: pageData.wordCount,
        estimatedReadingTime: pageData.readingTime,
      },
      pageData.wordCount
    );

    const markdown = frontmatter + '\n\n' + conversionResult.markdown;

    return {
      title: pageData.title,
      url,
      html: pageData.html,
      markdown,
      metadata: {
        ...pageData.metadata,
        capturedAt: new Date().toISOString(),
        wordCount: pageData.wordCount,
        estimatedReadingTime: pageData.readingTime,
      },
      stats: {
        wordCount: pageData.wordCount,
        characterCount: conversionResult.characterCount,
        imageCount: conversionResult.imageCount,
        linkCount: conversionResult.linkCount,
      },
    };
  }

  private generateFrontmatter(
    title: string,
    url: string,
    metadata: any,
    wordCount: number
  ): string {
    const lines = ['---'];

    lines.push(`title: "${title.replace(/"/g, '\\"')}"`);
    lines.push(`url: "${url}"`);
    lines.push(`capture_date: "${new Date().toISOString()}"`);

    if (metadata.description) {
      lines.push(
        `description: "${metadata.description.replace(/"/g, '\\"')}"`
      );
    }

    if (metadata.author) {
      lines.push(`author: "${metadata.author.replace(/"/g, '\\"')}"`);
    }

    if (metadata.keywords && metadata.keywords.length > 0) {
      lines.push('tags:');
      metadata.keywords.forEach((keyword: string) => {
        lines.push(`  - "${keyword.replace(/"/g, '\\"')}"`);
      });
    }

    lines.push(`word_count: ${wordCount}`);
    lines.push(
      `reading_time: ${Math.ceil(wordCount / 200)} min`
    );
    lines.push('source: "PrismWeave CLI"');
    lines.push('---');

    return lines.join('\n');
  }
}
