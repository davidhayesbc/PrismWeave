// Generated by Copilot
// Browser Capture - Headless browser integration for CLI
// Uses Puppeteer to fetch and extract content from URLs
// Uses the same content extraction logic as the browser extension's ContentExtractionCore

import puppeteer, { Browser, Page } from 'puppeteer';
import { MarkdownConverterCore } from './shared/markdown-converter-core.js';

export interface ICaptureOptions {
  timeout?: number;
  waitForSelector?: string;
  includeImages?: boolean;
  includeLinks?: boolean;
  userAgent?: string;
  viewport?: { width: number; height: number };
}

export interface ICapturedContent {
  title: string;
  url: string;
  html: string;
  markdown: string;
  httpStatus?: number;
  isPDF?: boolean;
  pdfBase64?: string;
  metadata: {
    description?: string;
    author?: string;
    keywords?: string[];
    capturedAt: string;
    wordCount?: number;
    estimatedReadingTime?: number;
    publishedDate?: string;
    language?: string;
    fileSize?: number;
    mimeType?: string;
  };
  stats: {
    wordCount: number;
    characterCount: number;
    imageCount: number;
    linkCount: number;
  };
}

export class BrowserCapture {
  private browser: Browser | null = null;
  private converter: MarkdownConverterCore;
  private static readonly MAX_PDF_SIZE = 25 * 1024 * 1024; // 25MB GitHub file limit

  constructor() {
    this.converter = new MarkdownConverterCore();
  }

  async initialize(): Promise<void> {
    if (this.browser) return;

    this.browser = await puppeteer.launch({
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-accelerated-2d-canvas',
        '--disable-gpu',
      ],
    });
  }

  async captureUrl(
    url: string,
    options: ICaptureOptions = {}
  ): Promise<ICapturedContent> {
    // Check if this is a PDF URL first (before launching browser)
    if (this.isPDFUrl(url)) {
      return await this.capturePDF(url);
    }

    if (!this.browser) {
      await this.initialize();
    }

    const page = await this.browser!.newPage();

    try {
      // Set viewport
      if (options.viewport) {
        await page.setViewport(options.viewport);
      } else {
        await page.setViewport({ width: 1920, height: 1080 });
      }

      // Set user agent
      if (options.userAgent) {
        await page.setUserAgent(options.userAgent);
      }

      // Navigate to URL and capture response status
      const response = await page.goto(url, {
        waitUntil: 'networkidle2',
        timeout: options.timeout || 30000,
      });

      const httpStatus = response?.status();

      // Wait for specific selector if provided
      if (options.waitForSelector) {
        await page.waitForSelector(options.waitForSelector, {
          timeout: options.timeout || 30000,
        });
      }

      // Extract content
      const content = await this.extractContent(page, url, options);

      // Add HTTP status to content
      content.httpStatus = httpStatus;

      return content;
    } finally {
      await page.close();
    }
  }

  async close(): Promise<void> {
    if (this.browser) {
      await this.browser.close();
      this.browser = null;
    }
  }

  private async extractContent(
    page: Page,
    url: string,
    options: ICaptureOptions
  ): Promise<ICapturedContent> {
    // Use a comprehensive extraction script that mimics ContentExtractionCore
    const pageData = await page.evaluate(
      (extractionOptions: any): {
        title: string;
        html: string;
        metadata: {
          description?: string;
          author?: string;
          keywords?: string[];
          wordCount?: number;
          estimatedReadingTime?: number;
          publishedDate?: string;
          language?: string;
        };
        wordCount: number;
        readingTime: number;
      } => {
        // Helper functions (matching ContentExtractionCore logic)
        const countWords = (text: string): number => {
          return text.split(/\s+/).filter(word => word.length > 0).length;
        };

        const estimateReadingTime = (wordCount: number): number => {
          return Math.ceil(wordCount / 200);
        };

        const hasSubstantialContent = (element: Element): boolean => {
          const textContent = element.textContent || '';
          const wordCount = countWords(textContent);
          return wordCount > 30;
        };

        const scoreElement = (element: Element): number => {
          const text = element.textContent || '';
          const wordCount = countWords(text);
          let score = 0;

          score += Math.min(wordCount / 10, 50);

          const paragraphs = element.querySelectorAll('p').length;
          score += paragraphs * 2;

          const links = element.querySelectorAll('a').length;
          const linkDensity = links / Math.max(wordCount, 1);
          if (linkDensity > 0.3) score -= 20;

          const tagName = element.tagName.toLowerCase();
          if (tagName === 'article') score += 15;
          if (tagName === 'main') score += 10;

          const className = element.className.toLowerCase();
          if (className.includes('content')) score += 10;
          if (className.includes('post')) score += 8;
          if (className.includes('article')) score += 8;
          if (className.includes('sidebar')) score -= 10;
          if (className.includes('footer')) score -= 10;
          if (className.includes('header')) score -= 10;
          if (className.includes('nav')) score -= 15;

          return Math.max(score, 0);
        };

        // Find main content (matching ContentExtractionCore logic)
        const findMainContent = (): Element => {
          // Try custom selectors first
          if (extractionOptions.customSelectors?.length) {
            for (const selector of extractionOptions.customSelectors) {
              const element = document.querySelector(selector);
              if (element && hasSubstantialContent(element)) {
                return element;
              }
            }
          }

          // Common content selectors
          const contentSelectors = [
            'article',
            'main',
            '[role="main"]',
            '.content',
            '.post-content',
            '.entry-content',
            '.article-content',
            '#content',
            '#main',
            '.post',
            '.entry',
          ];

          for (const selector of contentSelectors) {
            const element = document.querySelector(selector);
            if (element && hasSubstantialContent(element)) {
              return element;
            }
          }

          // Score-based fallback
          const candidates = Array.from(document.querySelectorAll('div, section, article'));
          let bestCandidate: { element: Element; score: number } | null = null;

          for (const candidate of candidates) {
            if (hasSubstantialContent(candidate)) {
              const score = scoreElement(candidate);
              if (!bestCandidate || score > bestCandidate.score) {
                bestCandidate = { element: candidate, score };
              }
            }
          }

          return bestCandidate?.element || document.body;
        };

        // Clean content (matching ContentExtractionCore logic)
        const cleanContent = (element: Element): Element => {
          const cloned = element.cloneNode(true) as Element;

          const defaultExcludeSelectors = [
            'script',
            'style',
            'noscript',
            'iframe',
            '.advertisement',
            '.ad',
            '.ads',
            '.popup',
            '.modal',
            '.social-share',
            '.comments',
            '.related-posts',
            '[style*="display: none"]',
            '[style*="visibility: hidden"]',
          ];

          const excludeSelectors = [
            ...defaultExcludeSelectors,
            ...(extractionOptions.excludeSelectors || []),
          ];

          excludeSelectors.forEach(selector => {
            const elements = cloned.querySelectorAll(selector);
            elements.forEach(el => el.remove());
          });

          // Remove navigation
          if (extractionOptions.removeNavigation !== false) {
            const navSelectors = [
              'nav',
              'header',
              'footer',
              '[role="navigation"]',
              '[role="banner"]',
              '[role="contentinfo"]',
              '.navigation',
              '.nav',
              '.menu',
              '.breadcrumb',
            ];

            navSelectors.forEach(selector => {
              const elements = cloned.querySelectorAll(selector);
              elements.forEach(el => el.remove());
            });
          }

          // Remove ads
          if (extractionOptions.removeAds !== false) {
            const adSelectors = [
              '[class*="ad"]',
              '[id*="ad"]',
              '[class*="banner"]',
              '[id*="banner"]',
              '[class*="promo"]',
              '[id*="promo"]',
              '[class*="sponsor"]',
              '[id*="sponsor"]',
            ];

            adSelectors.forEach(selector => {
              const elements = cloned.querySelectorAll(selector);
              elements.forEach(el => {
                const text = el.textContent || '';
                const wordCount = countWords(text);
                const className = el.className.toLowerCase();
                const id = el.id.toLowerCase();

                const adPatterns = [
                  'advertisement',
                  'google-ad',
                  'adsense',
                  'ad-banner',
                  'ad-container',
                  'ad-wrapper',
                  'sponsored',
                  'promo-box',
                ];

                const hasAdCharacteristics = adPatterns.some(
                  pattern => className.includes(pattern) || id.includes(pattern)
                );

                if (wordCount < 10 || hasAdCharacteristics) {
                  el.remove();
                }
              });
            });
          }

          return cloned;
        };

        // Extract metadata (matching ContentExtractionCore logic)
        const extractTitle = (): string => {
          const titleSources = [
            () => document.querySelector('[property="og:title"]')?.getAttribute('content'),
            () => document.querySelector('[name="twitter:title"]')?.getAttribute('content'),
            () => document.querySelector('h1')?.textContent,
            () => document.title,
          ];

          for (const source of titleSources) {
            const title = source();
            if (title && title.trim().length > 0) {
              return title.trim();
            }
          }

          return 'Untitled';
        };

        const extractDescription = (): string => {
          const descSources = [
            () => document.querySelector('[property="og:description"]')?.getAttribute('content'),
            () =>
              document.querySelector('[name="twitter:description"]')?.getAttribute('content'),
            () => document.querySelector('[name="description"]')?.getAttribute('content'),
          ];

          for (const source of descSources) {
            const desc = source();
            if (desc && desc.trim().length > 0) {
              return desc.trim();
            }
          }

          return '';
        };

        const extractKeywords = (): string[] => {
          const keywordsMeta = document.querySelector('[name="keywords"]')?.getAttribute('content');
          if (keywordsMeta) {
            return keywordsMeta
              .split(',')
              .map(keyword => keyword.trim())
              .filter(keyword => keyword.length > 0);
          }
          return [];
        };

        const extractAuthor = (): string => {
          const authorSources = [
            () =>
              document.querySelector('[property="article:author"]')?.getAttribute('content'),
            () => document.querySelector('[name="author"]')?.getAttribute('content'),
            () => document.querySelector('[rel="author"]')?.textContent,
            () => document.querySelector('.author')?.textContent,
            () => document.querySelector('.byline')?.textContent,
            () => document.querySelector('[class*="author"]')?.textContent,
            () => document.querySelector('.post-author')?.textContent,
          ];

          for (const source of authorSources) {
            const author = source();
            if (author && author.trim().length > 0) {
              return author.trim();
            }
          }

          return '';
        };

        const extractPublishedDate = (): string => {
          const dateSources = [
            () =>
              document
                .querySelector('[property="article:published_time"]')
                ?.getAttribute('content'),
            () => document.querySelector('[name="publish_date"]')?.getAttribute('content'),
            () => document.querySelector('time[datetime]')?.getAttribute('datetime'),
            () => document.querySelector('.publish-date')?.textContent,
            () => document.querySelector('.date')?.textContent,
            () => document.querySelector('.published')?.textContent,
            () => document.querySelector('[class*="date"]')?.textContent,
          ];

          for (const source of dateSources) {
            const date = source();
            if (date && date.trim().length > 0) {
              return date.trim();
            }
          }

          return '';
        };

        const extractLanguage = (): string => {
          return (
            document.documentElement.lang ||
            document.querySelector('[property="og:locale"]')?.getAttribute('content') ||
            'en'
          );
        };

        // Perform extraction
        const title = extractTitle();
        const mainContent = findMainContent();
        const cleanedElement = cleanContent(mainContent);
        const html = cleanedElement.innerHTML;
        const cleanedText = cleanedElement.textContent || '';

        const wordCount = countWords(cleanedText);
        const readingTime = estimateReadingTime(wordCount);

        return {
          title,
          html,
          metadata: {
            description: extractDescription(),
            author: extractAuthor(),
            keywords: extractKeywords(),
            wordCount,
            estimatedReadingTime: readingTime,
            publishedDate: extractPublishedDate(),
            language: extractLanguage(),
          },
          wordCount,
          readingTime,
        };
      },
      {
        customSelectors: options.waitForSelector ? [options.waitForSelector] : undefined,
        cleanHtml: true,
        removeAds: true,
        removeNavigation: true,
        excludeSelectors: [],
        includeImages: options.includeImages ?? true,
        includeLinks: options.includeLinks ?? true,
      }
    );

    // Convert HTML to Markdown
    const conversionResult = this.converter.convertToMarkdown(pageData.html, {
      includeImages: options.includeImages ?? true,
      includeLinks: options.includeLinks ?? true,
    });

    // Generate frontmatter with enhanced metadata from ContentExtractionCore
    const frontmatter = this.generateFrontmatter(
      pageData.title,
      url,
      {
        ...pageData.metadata,
        wordCount: pageData.wordCount,
        estimatedReadingTime: pageData.readingTime,
      },
      pageData.wordCount
    );

    const markdown = frontmatter + '\n\n' + conversionResult.markdown;

    return {
      title: pageData.title,
      url,
      html: pageData.html,
      markdown,
      metadata: {
        ...pageData.metadata,
        capturedAt: new Date().toISOString(),
        wordCount: pageData.wordCount,
        estimatedReadingTime: pageData.readingTime,
      },
      stats: {
        wordCount: pageData.wordCount,
        characterCount: conversionResult.characterCount,
        imageCount: conversionResult.imageCount,
        linkCount: conversionResult.linkCount,
      },
    };
  }

  private generateFrontmatter(
    title: string,
    url: string,
    metadata: any,
    wordCount: number
  ): string {
    const lines = ['---'];

    lines.push(`title: "${title.replace(/"/g, '\\"')}"`);
    lines.push(`url: "${url}"`);
    lines.push(`capture_date: "${new Date().toISOString()}"`);

    if (metadata.description) {
      lines.push(
        `description: "${metadata.description.replace(/"/g, '\\"')}"`
      );
    }

    if (metadata.author) {
      lines.push(`author: "${metadata.author.replace(/"/g, '\\"')}"`);
    }

    if (metadata.keywords && metadata.keywords.length > 0) {
      lines.push('tags:');
      metadata.keywords.forEach((keyword: string) => {
        lines.push(`  - "${keyword.replace(/"/g, '\\"')}"`);
      });
    }

    lines.push(`word_count: ${wordCount}`);
    lines.push(
      `reading_time: ${Math.ceil(wordCount / 200)} min`
    );
    lines.push('source: "PrismWeave CLI"');
    lines.push('---');

    return lines.join('\n');
  }

  // =================================================================
  // PDF CAPTURE METHODS
  // =================================================================

  /**
   * Check if a URL points to a PDF document
   */
  private isPDFUrl(url: string): boolean {
    try {
      const urlObj = new URL(url);

      // Check if URL ends with .pdf
      if (urlObj.pathname.toLowerCase().endsWith('.pdf')) {
        return true;
      }

      // Check for PDF viewer URLs
      if (url.includes('blob:') && url.includes('pdf')) {
        return true;
      }

      // Check for common PDF viewer patterns
      const pdfPatterns = [/\.pdf$/i, /\/pdf\//i, /viewer\.html.*\.pdf/i, /pdfjs/i];
      return pdfPatterns.some(pattern => pattern.test(url));
    } catch {
      return false;
    }
  }

  /**
   * Capture a PDF document
   */
  private async capturePDF(url: string): Promise<ICapturedContent> {
    // Note: Progress messages handled by spinner in index.ts

    try {
      // Download PDF using fetch (matches browser extension behavior)
      const response = await fetch(url, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
          Accept: 'application/pdf,*/*',
        },
      });

      const httpStatus = response.status;

      if (!response.ok) {
        throw new Error(`Failed to download PDF: ${response.status} ${response.statusText}`);
      }

      // Validate content type
      const contentType = response.headers.get('content-type');
      if (contentType && !contentType.includes('pdf')) {
        console.warn('Warning: Content-Type may not be PDF:', contentType);
      }

      // Get PDF as buffer
      const arrayBuffer = await response.arrayBuffer();
      const buffer = Buffer.from(arrayBuffer);

      if (buffer.length === 0) {
        throw new Error('Downloaded PDF is empty');
      }

      // Validate size (matches browser extension MAX_PDF_SIZE)
      if (buffer.length > BrowserCapture.MAX_PDF_SIZE) {
        throw new Error(
          `PDF file too large (${this.formatFileSize(buffer.length)}). Maximum allowed: ${this.formatFileSize(BrowserCapture.MAX_PDF_SIZE)}`
        );
      }

      // Validate it's actually a PDF (check magic number: %PDF)
      if (buffer.length < 4 || buffer.toString('utf-8', 0, 4) !== '%PDF') {
        throw new Error('Downloaded file is not a valid PDF (missing PDF header)');
      }

      // Convert to base64 for storage
      const pdfBase64 = buffer.toString('base64');

      // Extract title from URL
      const urlObj = new URL(url);
      const pathname = urlObj.pathname;
      const filename = pathname.split('/').pop() || 'document.pdf';
      const title = filename.replace(/\.pdf$/i, '') || 'PDF Document';

      // Extract domain
      const domain = urlObj.hostname.replace(/^www\./, '');

      // Note: File size logging handled by spinner in index.ts

      return {
        title,
        url,
        html: '',
        markdown: '',
        httpStatus,
        isPDF: true,
        pdfBase64,
        metadata: {
          capturedAt: new Date().toISOString(),
          fileSize: buffer.length,
          mimeType: 'application/pdf',
        },
        stats: {
          wordCount: 0,
          characterCount: 0,
          imageCount: 0,
          linkCount: 0,
        },
      };
    } catch (error) {
      throw new Error(`PDF capture failed: ${(error as Error).message}`);
    }
  }

  /**
   * Format file size in human-readable format
   */
  private formatFileSize(bytes: number): string {
    if (bytes === 0) return '0 Bytes';

    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));

    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }
}
