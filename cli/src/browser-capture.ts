// Generated by Copilot
// Browser Capture - Headless browser integration for CLI
// Uses Puppeteer to fetch and extract content from URLs

import puppeteer, { Browser, Page } from 'puppeteer';
import { MarkdownConverterCore } from './shared/markdown-converter-core.js';

export interface ICaptureOptions {
  timeout?: number;
  waitForSelector?: string;
  includeImages?: boolean;
  includeLinks?: boolean;
  userAgent?: string;
  viewport?: { width: number; height: number };
}

export interface ICapturedContent {
  title: string;
  url: string;
  html: string;
  markdown: string;
  metadata: {
    description?: string;
    author?: string;
    keywords?: string[];
    capturedAt: string;
  };
  stats: {
    wordCount: number;
    characterCount: number;
    imageCount: number;
    linkCount: number;
  };
}

export class BrowserCapture {
  private browser: Browser | null = null;
  private converter: MarkdownConverterCore;

  constructor() {
    this.converter = new MarkdownConverterCore();
  }

  async initialize(): Promise<void> {
    if (this.browser) return;

    this.browser = await puppeteer.launch({
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-accelerated-2d-canvas',
        '--disable-gpu',
      ],
    });
  }

  async captureUrl(
    url: string,
    options: ICaptureOptions = {}
  ): Promise<ICapturedContent> {
    if (!this.browser) {
      await this.initialize();
    }

    const page = await this.browser!.newPage();

    try {
      // Set viewport
      if (options.viewport) {
        await page.setViewport(options.viewport);
      } else {
        await page.setViewport({ width: 1920, height: 1080 });
      }

      // Set user agent
      if (options.userAgent) {
        await page.setUserAgent(options.userAgent);
      }

      // Navigate to URL
      await page.goto(url, {
        waitUntil: 'networkidle2',
        timeout: options.timeout || 30000,
      });

      // Wait for specific selector if provided
      if (options.waitForSelector) {
        await page.waitForSelector(options.waitForSelector, {
          timeout: options.timeout || 30000,
        });
      }

      // Extract content
      const content = await this.extractContent(page, url, options);

      return content;
    } finally {
      await page.close();
    }
  }

  async close(): Promise<void> {
    if (this.browser) {
      await this.browser.close();
      this.browser = null;
    }
  }

  private async extractContent(
    page: Page,
    url: string,
    options: ICaptureOptions
  ): Promise<ICapturedContent> {
    // Extract data from the page
    const pageData = await page.evaluate((): {
      title: string;
      html: string;
      metadata: {
        description?: string;
        author?: string;
        keywords?: string[];
      };
    } => {
      // Extract title
      const title =
        document.querySelector('title')?.textContent ||
        document.querySelector('h1')?.textContent ||
        'Untitled';

      // Extract metadata
      const metaTags = Array.from(document.querySelectorAll('meta'));
      const metadata: Record<string, string> = {};

      metaTags.forEach((meta: any) => {
        const name =
          meta.getAttribute('name') || meta.getAttribute('property');
        const content = meta.getAttribute('content');
        if (name && content) {
          metadata[name] = content;
        }
      });

      // Extract main content
      const contentSelectors = [
        'article',
        'main',
        '[role="main"]',
        '.content',
        '.post',
        '.entry',
        '#content',
        '#main',
      ];

      let contentElement: any = null;
      for (const selector of contentSelectors) {
        contentElement = document.querySelector(selector);
        if (
          contentElement &&
          contentElement.textContent &&
          contentElement.textContent.trim().length > 100
        ) {
          break;
        }
      }

      if (!contentElement) {
        contentElement = document.body;
      }

      // Clone and clean content
      const clone = contentElement.cloneNode(true) as any;

      // Remove unwanted elements
      const unwantedSelectors = [
        'script',
        'style',
        'noscript',
        'iframe',
        'nav',
        'header',
        'footer',
        '.advertisement',
        '.ad',
        '.ads',
        '.popup',
        '.modal',
      ];

      unwantedSelectors.forEach((selector) => {
        const elements = clone.querySelectorAll(selector);
        elements.forEach((el: any) => el.remove());
      });

      return {
        title: title.trim(),
        html: clone.innerHTML,
        metadata: {
          description: metadata['description'] || metadata['og:description'],
          author: metadata['author'] || metadata['article:author'],
          keywords: metadata['keywords']?.split(',').map((k) => k.trim()),
        },
      };
    });

    // Convert HTML to Markdown
    const conversionResult = this.converter.convertToMarkdown(pageData.html, {
      includeImages: options.includeImages ?? true,
      includeLinks: options.includeLinks ?? true,
    });

    // Generate frontmatter
    const frontmatter = this.generateFrontmatter(
      pageData.title,
      url,
      pageData.metadata,
      conversionResult.wordCount
    );

    const markdown = frontmatter + '\n\n' + conversionResult.markdown;

    return {
      title: pageData.title,
      url,
      html: pageData.html,
      markdown,
      metadata: {
        ...pageData.metadata,
        capturedAt: new Date().toISOString(),
      },
      stats: {
        wordCount: conversionResult.wordCount,
        characterCount: conversionResult.characterCount,
        imageCount: conversionResult.imageCount,
        linkCount: conversionResult.linkCount,
      },
    };
  }

  private generateFrontmatter(
    title: string,
    url: string,
    metadata: any,
    wordCount: number
  ): string {
    const lines = ['---'];

    lines.push(`title: "${title.replace(/"/g, '\\"')}"`);
    lines.push(`url: "${url}"`);
    lines.push(`capture_date: "${new Date().toISOString()}"`);

    if (metadata.description) {
      lines.push(
        `description: "${metadata.description.replace(/"/g, '\\"')}"`
      );
    }

    if (metadata.author) {
      lines.push(`author: "${metadata.author.replace(/"/g, '\\"')}"`);
    }

    if (metadata.keywords && metadata.keywords.length > 0) {
      lines.push('tags:');
      metadata.keywords.forEach((keyword: string) => {
        lines.push(`  - "${keyword.replace(/"/g, '\\"')}"`);
      });
    }

    lines.push(`word_count: ${wordCount}`);
    lines.push(
      `reading_time: ${Math.ceil(wordCount / 200)} min`
    );
    lines.push('source: "PrismWeave CLI"');
    lines.push('---');

    return lines.join('\n');
  }
}
