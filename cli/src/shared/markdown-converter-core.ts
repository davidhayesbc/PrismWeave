// Generated by Copilot
// Shared Markdown Converter Core - Copied from browser-extension for CLI use
// This is a standalone version that doesn't depend on browser APIs

import TurndownService from 'turndown';

export interface IConversionOptions {
  includeImages?: boolean;
  includeLinks?: boolean;
  preserveFormatting?: boolean;
  customSelectors?: string[];
  excludeSelectors?: string[];
}

export interface IConversionResult {
  markdown: string;
  wordCount: number;
  characterCount: number;
  imageCount: number;
  linkCount: number;
}

/**
 * Core Markdown conversion logic (environment-agnostic)
 */
export class MarkdownConverterCore {
  protected turndownService: TurndownService | null = null;
  protected _isInitialized: boolean = false;

  constructor() {
    this.initializeTurndown();
  }

  private initializeTurndown(): void {
    try {
      const options = {
        headingStyle: 'atx' as const,
        bulletListMarker: '-' as const,
        codeBlockStyle: 'fenced' as const,
        emDelimiter: '*' as const,
        strongDelimiter: '**' as const,
        linkStyle: 'inlined' as const,
        linkReferenceStyle: 'full' as const,
        preformattedCode: true,
      };
      this.turndownService = new TurndownService(options);
      this.setupTurndownService();
      this._isInitialized = true;
    } catch (error) {
      console.warn('Failed to initialize TurndownService:', error);
      this.turndownService = null;
      this._isInitialized = true;
    }
  }

  protected setupTurndownService(): void {
    if (!this.turndownService) return;

    // Custom rules for better markdown conversion
    this.turndownService.addRule('strikethrough', {
      filter: ['del', 's', 'strike'] as any, // 'strike' is deprecated but still used in some content
      replacement: (content) => `~~${content}~~`,
    });

    this.turndownService.addRule('taskList', {
      filter: (node) => {
        return (
          node.nodeName === 'INPUT' &&
          node.getAttribute('type') === 'checkbox'
        );
      },
      replacement: (content, node) => {
        const element = node as any;
        return element.checked ? '[x] ' : '[ ] ';
      },
    });
  }

  convertToMarkdown(
    html: string,
    options: IConversionOptions = {}
  ): IConversionResult {
    if (!this._isInitialized) {
      throw new Error('Markdown converter not initialized');
    }

    let cleanedHtml = html;

    // Apply content filtering based on options
    if (options.excludeSelectors && options.excludeSelectors.length > 0) {
      cleanedHtml = this.removeElements(cleanedHtml, options.excludeSelectors);
    }

    // Convert to markdown
    const markdown = this.turndownService
      ? this.turndownService.turndown(cleanedHtml)
      : this.fallbackConversion(cleanedHtml);

    // Calculate statistics
    const stats = this.calculateStats(markdown);

    return {
      markdown,
      ...stats,
    };
  }

  private removeElements(html: string, selectors: string[]): string {
    // Simple regex-based removal for CLI context
    let cleaned = html;
    selectors.forEach((selector) => {
      // This is a simplified approach for CLI
      // In a real implementation, you'd parse the HTML properly
      const tagMatch = selector.match(/^([a-zA-Z]+)$/);
      if (tagMatch) {
        const tag = tagMatch[1];
        const regex = new RegExp(`<${tag}[^>]*>.*?</${tag}>`, 'gis');
        cleaned = cleaned.replace(regex, '');
      }
    });
    return cleaned;
  }

  private fallbackConversion(html: string): string {
    // Basic HTML to Markdown fallback
    let markdown = html;

    // Headers
    markdown = markdown.replace(
      /<h([1-6])[^>]*>(.*?)<\/h[1-6]>/gi,
      (match, level, content) => {
        const headerLevel = '#'.repeat(parseInt(level));
        return `\n${headerLevel} ${this.stripHtml(content)}\n`;
      }
    );

    // Paragraphs
    markdown = markdown.replace(/<p[^>]*>(.*?)<\/p>/gi, '\n$1\n');

    // Strong/Bold
    markdown = markdown.replace(
      /<(strong|b)[^>]*>(.*?)<\/(strong|b)>/gi,
      '**$2**'
    );

    // Emphasis/Italic
    markdown = markdown.replace(/<(em|i)[^>]*>(.*?)<\/(em|i)>/gi, '*$2*');

    // Links
    markdown = markdown.replace(
      /<a[^>]*href=["']([^"']*)["'][^>]*>(.*?)<\/a>/gi,
      '[$2]($1)'
    );

    // Images
    markdown = markdown.replace(
      /<img[^>]*src=["']([^"']*)["'][^>]*alt=["']([^"']*)["'][^>]*>/gi,
      '![$2]($1)'
    );

    // Lists
    markdown = markdown.replace(/<ul[^>]*>(.*?)<\/ul>/gis, (match, content) => {
      const items = content.replace(/<li[^>]*>(.*?)<\/li>/gi, '- $1\n');
      return `\n${items}\n`;
    });

    // Code blocks
    markdown = markdown.replace(
      /<pre[^>]*><code[^>]*>(.*?)<\/code><\/pre>/gis,
      '\n```\n$1\n```\n'
    );
    markdown = markdown.replace(/<code[^>]*>(.*?)<\/code>/gi, '`$1`');

    // Line breaks
    markdown = markdown.replace(/<br[^>]*>/gi, '\n');

    // Strip remaining HTML
    markdown = this.stripHtml(markdown);

    // Clean up whitespace
    markdown = markdown.replace(/\n\s*\n\s*\n/g, '\n\n');
    markdown = markdown.trim();

    return markdown;
  }

  private stripHtml(html: string): string {
    return html.replace(/<[^>]*>/g, '').trim();
  }

  private calculateStats(markdown: string): {
    wordCount: number;
    characterCount: number;
    imageCount: number;
    linkCount: number;
  } {
    const wordCount = markdown
      .split(/\s+/)
      .filter((word) => word.length > 0).length;
    const characterCount = markdown.length;
    const imageCount = (markdown.match(/!\[.*?\]\(.*?\)/g) || []).length;
    const linkCount = (markdown.match(/\[.*?\]\(.*?\)/g) || []).length;

    return {
      wordCount,
      characterCount,
      imageCount,
      linkCount,
    };
  }
}
