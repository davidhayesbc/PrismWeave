// Generated by Copilot
// Shared File Manager - Adapted from browser-extension for CLI use
// Handles GitHub operations and file naming/organization

export interface IDocumentMetadata {
  title: string;
  url: string;
  captureDate: string;
  tags: string[];
  author?: string;
  wordCount?: number;
  estimatedReadingTime?: number;
}

export interface IGitHubSettings {
  token: string;
  repository: string;
  branch?: string;
}

export interface IFileOperationResult {
  success: boolean;
  filePath?: string;
  error?: string;
  size?: number;
  sha?: string;
  url?: string;
}

interface IRepositoryInfo {
  owner: string;
  repo: string;
}

export class FileManager {
  private static readonly API_BASE = 'https://api.github.com';
  private static readonly USER_AGENT = 'PrismWeave-CLI/1.0';

  private readonly folderMapping: Record<string, string[]> = {
    tech: [
      'programming',
      'software',
      'coding',
      'development',
      'technology',
      'tech',
      'javascript',
      'python',
      'react',
      'node',
      'github',
      'stackoverflow',
      'developer',
    ],
    business: [
      'business',
      'marketing',
      'finance',
      'startup',
      'entrepreneur',
    ],
    tutorial: ['tutorial', 'guide', 'how-to', 'learn', 'course'],
    news: ['news', 'article', 'blog', 'opinion', 'analysis'],
    research: ['research', 'study', 'paper', 'academic', 'journal'],
    design: ['design', 'ui', 'ux', 'css', 'figma'],
    tools: ['tool', 'utility', 'software', 'app', 'service'],
    reference: ['reference', 'documentation', 'manual', 'spec', 'docs'],
  };

  generateFilename(metadata: IDocumentMetadata): string {
    const date = this.formatDate(new Date(metadata.captureDate));
    const domain = this.extractDomain(metadata.url);
    const title = this.sanitizeTitle(metadata.title);

    return `${date}-${domain}-${title}.md`;
  }

  determineFolder(metadata: IDocumentMetadata): string {
    const searchText = [
      metadata.title.toLowerCase(),
      metadata.url.toLowerCase(),
      ...metadata.tags.map((tag) => tag.toLowerCase()),
    ].join(' ');

    const folderScores: Record<string, number> = {};

    Object.entries(this.folderMapping).forEach(([folder, keywords]) => {
      let score = 0;
      keywords.forEach((keyword) => {
        const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
        const matches = searchText.match(regex);
        if (matches) {
          score += matches.length;
        }
      });

      if (score > 0) {
        folderScores[folder] = score;
      }
    });

    const sortedFolders = Object.entries(folderScores).sort(
      ([, a], [, b]) => b - a
    );
    return sortedFolders[0] ? sortedFolders[0][0] : 'unsorted';
  }

  generateFilePath(metadata: IDocumentMetadata): string {
    const folder = this.determineFolder(metadata);
    const filename = this.generateFilename(metadata);
    return `documents/${folder}/${filename}`;
  }

  async saveToGitHub(
    content: string,
    metadata: IDocumentMetadata,
    githubSettings: IGitHubSettings
  ): Promise<IFileOperationResult> {
    try {
      const filePath = this.generateFilePath(metadata);
      const commitMessage = this.generateCommitMessage(metadata);

      const repoInfo = this.parseRepositoryPath(githubSettings.repository);
      const existingFile = await this.getFileInfo(
        githubSettings.token,
        repoInfo,
        filePath
      );

      const result = await this.createOrUpdateFile(
        githubSettings.token,
        repoInfo,
        filePath,
        content,
        commitMessage,
        existingFile?.sha
      );

      return {
        success: true,
        filePath,
        sha: result.content?.sha,
        url: result.content?.html_url,
      };
    } catch (error) {
      return {
        success: false,
        filePath: '',
        error: (error as Error).message,
      };
    }
  }

  async testConnection(
    token: string,
    repo: string
  ): Promise<{ success: boolean; error?: string; details?: any }> {
    try {
      const repoInfo = this.parseRepositoryPath(repo);
      const response = await fetch(
        `${FileManager.API_BASE}/repos/${repoInfo.owner}/${repoInfo.repo}`,
        {
          headers: this.getAuthHeaders(token),
        }
      );

      if (!response.ok) {
        throw new Error(`Repository access failed: ${response.status}`);
      }

      const data = await response.json() as { full_name: string; private: boolean };
      return {
        success: true,
        details: {
          name: data.full_name,
          private: data.private,
        },
      };
    } catch (error) {
      return {
        success: false,
        error: (error as Error).message,
      };
    }
  }

  private formatDate(date: Date): string {
    return date.toISOString().split('T')[0];
  }

  private extractDomain(url: string): string {
    try {
      const urlObj = new URL(url);
      return urlObj.hostname.replace(/^www\./, '').replace(/\./g, '-');
    } catch {
      return 'unknown-site';
    }
  }

  private sanitizeTitle(title: string): string {
    return title
      .toLowerCase()
      .replace(/[^\w\s-]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-')
      .substring(0, 50);
  }

  private generateCommitMessage(metadata: IDocumentMetadata): string {
    const domain = this.extractDomain(metadata.url);
    return `Add captured content: ${metadata.title} (${domain})`;
  }

  private parseRepositoryPath(repoPath: string): IRepositoryInfo {
    const cleanPath = repoPath
      .replace(/^https?:\/\/github\.com\//, '')
      .replace(/\.git$/, '');
    const parts = cleanPath.split('/');

    if (parts.length < 2) {
      throw new Error('Invalid repository path format');
    }

    return { owner: parts[0], repo: parts[1] };
  }

  private async getFileInfo(
    token: string,
    repoInfo: IRepositoryInfo,
    path: string
  ): Promise<{ sha: string } | null> {
    try {
      const response = await fetch(
        `${FileManager.API_BASE}/repos/${repoInfo.owner}/${repoInfo.repo}/contents/${path}`,
        {
          method: 'GET',
          headers: this.getAuthHeaders(token),
        }
      );

      if (response.status === 404) {
        return null;
      }

      if (!response.ok) {
        throw new Error(`GitHub API error: ${response.status}`);
      }

      const data = await response.json() as { sha: string };
      return { sha: data.sha };
    } catch (error) {
      if ((error as Error).message.includes('404')) {
        return null;
      }
      throw error;
    }
  }

  private async createOrUpdateFile(
    token: string,
    repoInfo: IRepositoryInfo,
    path: string,
    content: string,
    message: string,
    existingSha?: string
  ): Promise<any> {
    const requestBody: any = {
      message,
      content: Buffer.from(content, 'utf-8').toString('base64'),
      branch: 'main',
    };

    if (existingSha) {
      requestBody.sha = existingSha;
    }

    const response = await fetch(
      `${FileManager.API_BASE}/repos/${repoInfo.owner}/${repoInfo.repo}/contents/${path}`,
      {
        method: 'PUT',
        headers: {
          ...this.getAuthHeaders(token),
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody),
      }
    );

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({})) as { message?: string };
      throw new Error(
        `GitHub API error: ${response.status} - ${errorData.message || 'Unknown error'}`
      );
    }

    return await response.json();
  }

  private getAuthHeaders(token: string): Record<string, string> {
    return {
      Authorization: `token ${token}`,
      Accept: 'application/vnd.github.v3+json',
      'User-Agent': FileManager.USER_AGENT,
    };
  }
}
