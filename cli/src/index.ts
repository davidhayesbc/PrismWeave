#!/usr/bin/env node

// Generated by Copilot
// PrismWeave CLI - Main entry point
// Command-line tool for capturing web pages as markdown and syncing to Git

import chalk from 'chalk';
import { Command } from 'commander';
import { readFileSync } from 'fs';
import ora from 'ora';
import { BrowserCapture } from './browser-capture.js';
import { ConfigManager } from './config.js';
import { FileManager, IDocumentMetadata, IGitHubSettings } from './shared/file-manager.js';

// Helper function to format file sizes
function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

// Helper function to truncate URLs for display
function truncateUrl(url: string, maxLength: number = 70): string {
  if (url.length <= maxLength) return url;
  const start = url.substring(0, maxLength - 15);
  const end = url.substring(url.length - 12);
  return `${start}...${end}`;
}

const program = new Command();

program
  .name('prismweave')
  .description('Capture web pages as markdown and sync to Git')
  .version('1.0.0');

// Capture command
program
  .command('capture')
  .description('Capture a URL or list of URLs')
  .argument('[url]', 'URL to capture')
  .option('-f, --file <path>', 'File containing URLs (one per line)')
  .option('-t, --token <token>', 'GitHub personal access token')
  .option('-r, --repo <repo>', 'GitHub repository (owner/repo)')
  .option('--no-images', 'Exclude images from capture')
  .option('--no-links', 'Convert links to plain text')
  .option('--timeout <ms>', 'Page load timeout in milliseconds', '30000')
  .option('--dry-run', 'Preview without saving to GitHub')
  .action(async (url: string | undefined, options: any) => {
    await captureCommand(url, options);
  });

// Config command
program
  .command('config')
  .description('Manage configuration')
  .option('--set <key=value>', 'Set a configuration value')
  .option('--get <key>', 'Get a configuration value')
  .option('--list', 'List all configuration')
  .option('--test', 'Test GitHub connection')
  .action(async (options: any) => {
    await configCommand(options);
  });

async function captureCommand(url: string | undefined, options: any) {
  const config = new ConfigManager();
  const spinner = ora();

  try {
    // Determine URLs to capture
    const urls: string[] = [];

    if (url) {
      // Check if user accidentally passed a file path as a URL
      if (url.endsWith('.txt') || url.endsWith('.md') || url.includes('\\') || url.includes('./')) {
        console.error(chalk.red(`Error: It looks like you passed a file path as a URL: ${url}`));
        console.log(chalk.yellow('Did you mean to use: --file ' + url + ' or -f ' + url + ' ?'));
        process.exit(1);
      }
      urls.push(url);
    } else if (options.file) {
      try {
        const fileContent = readFileSync(options.file, 'utf-8');
        const lines = fileContent
          .split('\n')
          .map((line) => line.trim())
          .filter((line) => line && !line.startsWith('#'));
        urls.push(...lines);
      } catch (error) {
        console.error(chalk.red(`Error reading file: ${(error as Error).message}`));
        process.exit(1);
      }
    } else {
      console.error(chalk.red('Error: Please provide a URL or file with URLs'));
      program.help();
      process.exit(1);
    }

    if (urls.length === 0) {
      console.error(chalk.red('Error: No URLs to capture'));
      process.exit(1);
    }

    // Get GitHub settings
    const githubToken = options.token || config.get('githubToken');
    const githubRepo = options.repo || config.get('githubRepo');

    if (!options.dryRun && (!githubToken || !githubRepo)) {
      console.error(
        chalk.red('Error: GitHub token and repository are required')
      );
      console.log(
        chalk.yellow(
          '\nSet them using:\n  prismweave config --set githubToken=<token>\n  prismweave config --set githubRepo=<owner/repo>'
        )
      );
      process.exit(1);
    }

    // Initialize services
    const capture = new BrowserCapture();
    const fileManager = new FileManager();

    console.log(chalk.bold.blue(`\n${'='.repeat(80)}`));
    console.log(chalk.bold.blue(`  Capturing ${urls.length} URL(s)`));
    console.log(chalk.bold.blue(`${'='.repeat(80)}\n`));

    let successCount = 0;
    let failCount = 0;

    for (let i = 0; i < urls.length; i++) {
      const currentUrl = urls[i];
      const progress = chalk.gray(`[${i + 1}/${urls.length}]`);
      const displayUrl = truncateUrl(currentUrl);
      
      spinner.start(`${progress} ${chalk.dim(displayUrl)}`);

      try {
        // Capture content
        const content = await capture.captureUrl(currentUrl, {
          timeout: parseInt(options.timeout),
          includeImages: options.images !== false,
          includeLinks: options.links !== false,
        });

        // Check for HTTP error status codes (4xx, 5xx)
        if (content.httpStatus && content.httpStatus >= 400) {
          const statusMessage = content.httpStatus >= 500 
            ? 'Server Error' 
            : content.httpStatus === 404 
              ? 'Not Found' 
              : content.httpStatus === 403 
                ? 'Forbidden' 
                : 'Client Error';
          
          spinner.fail(
            chalk.red.bold(`${progress} ✗ HTTP ${content.httpStatus} - ${statusMessage}`) + '\n' +
            chalk.red(`   Cannot save page with error status code`) + '\n' +
            chalk.gray(`   URL: ${currentUrl}`)
          );
          failCount++;
          
          // Add delay before next URL
          if (i < urls.length - 1) {
            await new Promise((resolve) => setTimeout(resolve, 1000));
          }
          continue;
        }

        // Handle PDF content
        if (content.isPDF && content.pdfBase64) {
          if (options.dryRun) {
            const filePath = fileManager.generatePDFFilePath(content.title, content.url);
            spinner.succeed(
              chalk.green.bold(`${progress} ✓ PDF Captured`) + '\n' +
              chalk.white(`   ${chalk.bold('Title:')}   ${content.title}`) + '\n' +
              chalk.blue(`   ${chalk.bold('URL:')}     ${currentUrl}`) + '\n' +
              chalk.yellow(`   ${chalk.bold('Status:')}  ${content.httpStatus || 'N/A'}`) + '\n' +
              chalk.white(`   ${chalk.bold('Type:')}    PDF Document`) + '\n' +
              chalk.white(`   ${chalk.bold('Size:')}    ${content.metadata.fileSize ? formatFileSize(content.metadata.fileSize) : 'Unknown'}`) + '\n' +
              chalk.gray(`   ${chalk.bold('Path:')}    ${filePath}`)
            );
          } else {
            // Save PDF to GitHub
            const githubSettings: IGitHubSettings = {
              token: githubToken,
              repository: githubRepo,
            };

            const result = await fileManager.savePDFToGitHub(
              content.pdfBase64,
              content.title,
              content.url,
              githubSettings
            );

            if (result.success) {
              spinner.succeed(
                chalk.green.bold(`${progress} ✓ PDF Saved to GitHub`) + '\n' +
                chalk.white(`   ${chalk.bold('Title:')}    ${content.title}`) + '\n' +
                chalk.blue(`   ${chalk.bold('URL:')}      ${currentUrl}`) + '\n' +
                chalk.yellow(`   ${chalk.bold('Status:')}   ${content.httpStatus || 'N/A'}`) + '\n' +
                chalk.white(`   ${chalk.bold('Type:')}     PDF Document`) + '\n' +
                chalk.white(`   ${chalk.bold('Size:')}     ${content.metadata.fileSize ? formatFileSize(content.metadata.fileSize) : 'Unknown'}`) + '\n' +
                chalk.cyan(`   ${chalk.bold('Saved:')}    ${result.filePath}`) + '\n' +
                chalk.gray(`   ${chalk.bold('GitHub:')}   ${result.url || 'N/A'}`)
              );
              successCount++;
            } else {
              spinner.fail(
                chalk.red.bold(`${progress} ✗ Failed`) + '\n' +
                chalk.red(`   Error: ${result.error}`)
              );
              failCount++;
            }
          }
          continue;
        }

        // Create metadata for regular web pages
        const metadata: IDocumentMetadata = {
          title: content.title,
          url: content.url,
          captureDate: new Date().toISOString(),
          tags: content.metadata.keywords || [],
          author: content.metadata.author,
          wordCount: content.stats.wordCount,
          estimatedReadingTime: Math.ceil(content.stats.wordCount / 200),
        };

        if (options.dryRun) {
          const filePath = fileManager.generateFilePath(metadata);
          spinner.succeed(
            chalk.green.bold(`${progress} ✓ Web Page Captured`) + '\n' +
            chalk.white(`   ${chalk.bold('Title:')}    ${content.title}`) + '\n' +
            chalk.blue(`   ${chalk.bold('URL:')}      ${currentUrl}`) + '\n' +
            chalk.yellow(`   ${chalk.bold('Status:')}   ${content.httpStatus || 'N/A'}`) + '\n' +
            chalk.white(`   ${chalk.bold('Words:')}    ${content.stats.wordCount.toLocaleString()}`) + '\n' +
            chalk.gray(`   ${chalk.bold('Path:')}     ${filePath}`)
          );
        } else {
          // Save to GitHub
          const githubSettings: IGitHubSettings = {
            token: githubToken,
            repository: githubRepo,
          };

          const result = await fileManager.saveToGitHub(
            content.markdown,
            metadata,
            githubSettings
          );

          if (result.success) {
            spinner.succeed(
              chalk.green.bold(`${progress} ✓ Web Page Saved to GitHub`) + '\n' +
              chalk.white(`   ${chalk.bold('Title:')}    ${content.title}`) + '\n' +
              chalk.blue(`   ${chalk.bold('URL:')}      ${currentUrl}`) + '\n' +
              chalk.yellow(`   ${chalk.bold('Status:')}   ${content.httpStatus || 'N/A'}`) + '\n' +
              chalk.white(`   ${chalk.bold('Words:')}    ${content.stats.wordCount.toLocaleString()}`) + '\n' +
              chalk.cyan(`   ${chalk.bold('Saved:')}    ${result.filePath}`) + '\n' +
              chalk.gray(`   ${chalk.bold('GitHub:')}   ${result.url || 'N/A'}`)
            );
            successCount++;
          } else {
            spinner.fail(
              chalk.red.bold(`${progress} ✗ Failed`) + '\n' +
              chalk.red(`   Error: ${result.error}`)
            );
            failCount++;
          }
        }
      } catch (error) {
        spinner.fail(
          chalk.red.bold(`${progress} ✗ Capture Failed`) + '\n' +
          chalk.red(`   ${(error as Error).message}`) + '\n' +
          chalk.gray(`   URL: ${currentUrl}`)
        );
        failCount++;
      }

      // Add a small delay between captures
      if (i < urls.length - 1) {
        await new Promise((resolve) => setTimeout(resolve, 1000));
      }
    }

    // Close browser
    await capture.close();

    // Summary
    console.log(chalk.bold.blue(`\n${'='.repeat(80)}`));
    console.log(chalk.bold.blue('  Capture Summary'));
    console.log(chalk.bold.blue(`${'='.repeat(80)}`));
    console.log(chalk.green.bold(`  ✓ Successful:  ${successCount.toString().padStart(3)}`));
    if (failCount > 0) {
      console.log(chalk.red.bold(`  ✗ Failed:      ${failCount.toString().padStart(3)}`));
    }
    console.log(chalk.gray(`  • Total URLs:  ${urls.length.toString().padStart(3)}`));
    console.log(chalk.bold.blue(`${'='.repeat(80)}\n`));

    if (failCount > 0) {
      process.exit(1);
    }
  } catch (error) {
    spinner.fail(chalk.red(`Error: ${(error as Error).message}`));
    process.exit(1);
  }
}

async function configCommand(options: any) {
  const config = new ConfigManager();

  if (options.set) {
    const [key, value] = options.set.split('=');
    if (!key || !value) {
      console.error(chalk.red('Error: Invalid format. Use: --set key=value'));
      process.exit(1);
    }

    config.set(key as any, value);
    console.log(chalk.green(`✓ Set ${key} = ${value}`));
  } else if (options.get) {
    const value = config.get(options.get as any);
    if (value !== undefined) {
      console.log(chalk.cyan(`${options.get} = ${value}`));
    } else {
      console.log(chalk.yellow(`${options.get} is not set`));
    }
  } else if (options.list) {
    const allConfig = config.getAll();
    console.log(chalk.blue('\nConfiguration:'));
    Object.entries(allConfig).forEach(([key, value]) => {
      // Mask token for security
      const displayValue =
        key === 'githubToken' && value
          ? `${value.substring(0, 4)}...${value.substring(value.length - 4)}`
          : value;
      console.log(chalk.cyan(`  ${key}: ${displayValue}`));
    });
    console.log();
  } else if (options.test) {
    const spinner = ora('Testing GitHub connection...').start();

    const token = config.get('githubToken');
    const repo = config.get('githubRepo');

    if (!token || !repo) {
      spinner.fail(
        chalk.red('GitHub token and repository must be configured')
      );
      process.exit(1);
    }

    try {
      const fileManager = new FileManager();
      const result = await fileManager.testConnection(token, repo);

      if (result.success) {
        spinner.succeed(chalk.green('✓ GitHub connection successful'));
        if (result.details) {
          console.log(chalk.cyan(`  Repository: ${result.details.name}`));
          console.log(
            chalk.cyan(
              `  Private: ${result.details.private ? 'Yes' : 'No'}`
            )
          );
        }
      } else {
        spinner.fail(chalk.red(`✗ Connection failed: ${result.error}`));
        process.exit(1);
      }
    } catch (error) {
      spinner.fail(chalk.red(`✗ Error: ${(error as Error).message}`));
      process.exit(1);
    }
  } else {
    program.help();
  }
}

program.parse();
