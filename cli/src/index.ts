#!/usr/bin/env node

// Generated by Copilot
// PrismWeave CLI - Main entry point
// Command-line tool for capturing web pages as markdown and syncing to Git

import chalk from 'chalk';
import { Command } from 'commander';
import { readFileSync } from 'fs';
import ora from 'ora';
import { BrowserCapture } from './browser-capture.js';
import { ConfigManager } from './config.js';
import { FileManager, IDocumentMetadata, IGitHubSettings } from './shared/file-manager.js';

const program = new Command();

program
  .name('prismweave')
  .description('Capture web pages as markdown and sync to Git')
  .version('1.0.0');

// Capture command
program
  .command('capture')
  .description('Capture a URL or list of URLs')
  .argument('[url]', 'URL to capture')
  .option('-f, --file <path>', 'File containing URLs (one per line)')
  .option('-t, --token <token>', 'GitHub personal access token')
  .option('-r, --repo <repo>', 'GitHub repository (owner/repo)')
  .option('--no-images', 'Exclude images from capture')
  .option('--no-links', 'Convert links to plain text')
  .option('--timeout <ms>', 'Page load timeout in milliseconds', '30000')
  .option('--dry-run', 'Preview without saving to GitHub')
  .action(async (url: string | undefined, options: any) => {
    await captureCommand(url, options);
  });

// Config command
program
  .command('config')
  .description('Manage configuration')
  .option('--set <key=value>', 'Set a configuration value')
  .option('--get <key>', 'Get a configuration value')
  .option('--list', 'List all configuration')
  .option('--test', 'Test GitHub connection')
  .action(async (options: any) => {
    await configCommand(options);
  });

async function captureCommand(url: string | undefined, options: any) {
  const config = new ConfigManager();
  const spinner = ora();

  try {
    // Determine URLs to capture
    const urls: string[] = [];

    if (url) {
      // Check if user accidentally passed a file path as a URL
      if (url.endsWith('.txt') || url.endsWith('.md') || url.includes('\\') || url.includes('./')) {
        console.error(chalk.red(`Error: It looks like you passed a file path as a URL: ${url}`));
        console.log(chalk.yellow('Did you mean to use: --file ' + url + ' or -f ' + url + ' ?'));
        process.exit(1);
      }
      urls.push(url);
    } else if (options.file) {
      try {
        const fileContent = readFileSync(options.file, 'utf-8');
        const lines = fileContent
          .split('\n')
          .map((line) => line.trim())
          .filter((line) => line && !line.startsWith('#'));
        urls.push(...lines);
      } catch (error) {
        console.error(chalk.red(`Error reading file: ${(error as Error).message}`));
        process.exit(1);
      }
    } else {
      console.error(chalk.red('Error: Please provide a URL or file with URLs'));
      program.help();
      process.exit(1);
    }

    if (urls.length === 0) {
      console.error(chalk.red('Error: No URLs to capture'));
      process.exit(1);
    }

    // Get GitHub settings
    const githubToken = options.token || config.get('githubToken');
    const githubRepo = options.repo || config.get('githubRepo');

    if (!options.dryRun && (!githubToken || !githubRepo)) {
      console.error(
        chalk.red('Error: GitHub token and repository are required')
      );
      console.log(
        chalk.yellow(
          '\nSet them using:\n  prismweave config --set githubToken=<token>\n  prismweave config --set githubRepo=<owner/repo>'
        )
      );
      process.exit(1);
    }

    // Initialize services
    const capture = new BrowserCapture();
    const fileManager = new FileManager();

    console.log(chalk.blue(`\nCapturing ${urls.length} URL(s)...\n`));

    let successCount = 0;
    let failCount = 0;

    for (let i = 0; i < urls.length; i++) {
      const currentUrl = urls[i];
      spinner.start(
        `[${i + 1}/${urls.length}] Capturing ${chalk.cyan(currentUrl)}`
      );

      try {
        // Capture content
        const content = await capture.captureUrl(currentUrl, {
          timeout: parseInt(options.timeout),
          includeImages: options.images !== false,
          includeLinks: options.links !== false,
        });

        spinner.text = `[${i + 1}/${urls.length}] Processing ${chalk.cyan(currentUrl)}`;

        // Create metadata
        const metadata: IDocumentMetadata = {
          title: content.title,
          url: content.url,
          captureDate: new Date().toISOString(),
          tags: content.metadata.keywords || [],
          author: content.metadata.author,
          wordCount: content.stats.wordCount,
          estimatedReadingTime: Math.ceil(content.stats.wordCount / 200),
        };

        if (options.dryRun) {
          const filePath = fileManager.generateFilePath(metadata);
          spinner.succeed(
            `[${i + 1}/${urls.length}] ${chalk.green('✓')} ${chalk.cyan(currentUrl)}\n` +
              `  Title: ${content.title}\n` +
              `  Words: ${content.stats.wordCount}\n` +
              `  Path: ${filePath}`
          );
        } else {
          // Save to GitHub
          const githubSettings: IGitHubSettings = {
            token: githubToken,
            repository: githubRepo,
          };

          const result = await fileManager.saveToGitHub(
            content.markdown,
            metadata,
            githubSettings
          );

          if (result.success) {
            spinner.succeed(
              `[${i + 1}/${urls.length}] ${chalk.green('✓')} ${chalk.cyan(currentUrl)}\n` +
                `  Title: ${content.title}\n` +
                `  Words: ${content.stats.wordCount}\n` +
                `  Saved: ${result.filePath}\n` +
                `  URL: ${result.url || 'N/A'}`
            );
            successCount++;
          } else {
            spinner.fail(
              `[${i + 1}/${urls.length}] ${chalk.red('✗')} ${chalk.cyan(currentUrl)}\n` +
                `  Error: ${result.error}`
            );
            failCount++;
          }
        }
      } catch (error) {
        spinner.fail(
          `[${i + 1}/${urls.length}] ${chalk.red('✗')} ${chalk.cyan(currentUrl)}\n` +
            `  Error: ${(error as Error).message}`
        );
        failCount++;
      }

      // Add a small delay between captures
      if (i < urls.length - 1) {
        await new Promise((resolve) => setTimeout(resolve, 1000));
      }
    }

    // Close browser
    await capture.close();

    // Summary
    console.log(chalk.blue('\n' + '='.repeat(60)));
    console.log(chalk.blue('Summary:'));
    console.log(chalk.green(`  ✓ Successful: ${successCount}`));
    if (failCount > 0) {
      console.log(chalk.red(`  ✗ Failed: ${failCount}`));
    }
    console.log(chalk.blue('='.repeat(60) + '\n'));

    if (failCount > 0) {
      process.exit(1);
    }
  } catch (error) {
    spinner.fail(chalk.red(`Error: ${(error as Error).message}`));
    process.exit(1);
  }
}

async function configCommand(options: any) {
  const config = new ConfigManager();

  if (options.set) {
    const [key, value] = options.set.split('=');
    if (!key || !value) {
      console.error(chalk.red('Error: Invalid format. Use: --set key=value'));
      process.exit(1);
    }

    config.set(key as any, value);
    console.log(chalk.green(`✓ Set ${key} = ${value}`));
  } else if (options.get) {
    const value = config.get(options.get as any);
    if (value !== undefined) {
      console.log(chalk.cyan(`${options.get} = ${value}`));
    } else {
      console.log(chalk.yellow(`${options.get} is not set`));
    }
  } else if (options.list) {
    const allConfig = config.getAll();
    console.log(chalk.blue('\nConfiguration:'));
    Object.entries(allConfig).forEach(([key, value]) => {
      // Mask token for security
      const displayValue =
        key === 'githubToken' && value
          ? `${value.substring(0, 4)}...${value.substring(value.length - 4)}`
          : value;
      console.log(chalk.cyan(`  ${key}: ${displayValue}`));
    });
    console.log();
  } else if (options.test) {
    const spinner = ora('Testing GitHub connection...').start();

    const token = config.get('githubToken');
    const repo = config.get('githubRepo');

    if (!token || !repo) {
      spinner.fail(
        chalk.red('GitHub token and repository must be configured')
      );
      process.exit(1);
    }

    try {
      const fileManager = new FileManager();
      const result = await fileManager.testConnection(token, repo);

      if (result.success) {
        spinner.succeed(chalk.green('✓ GitHub connection successful'));
        if (result.details) {
          console.log(chalk.cyan(`  Repository: ${result.details.name}`));
          console.log(
            chalk.cyan(
              `  Private: ${result.details.private ? 'Yes' : 'No'}`
            )
          );
        }
      } else {
        spinner.fail(chalk.red(`✗ Connection failed: ${result.error}`));
        process.exit(1);
      }
    } catch (error) {
      spinner.fail(chalk.red(`✗ Error: ${(error as Error).message}`));
      process.exit(1);
    }
  } else {
    program.help();
  }
}

program.parse();
