// Generated by Copilot
// Bookmarklet Content Extractor - Adapter for PrismWeave shared ContentExtractor
// Uses browser DOM APIs directly for content extraction

import { ContentExtractorCore, IContentResult, IDOMProvider, IExtractorOptions } from '../../shared/core/content-extractor-core.js';
import { MarkdownConverter } from '../../shared/core/markdown-converter.js';
import { LocalStorageProvider } from './local-storage-provider.js';

/**
 * DOM provider for bookmarklet environment
 * Provides direct access to browser DOM APIs
 */
class BookmarkletDOMProvider implements IDOMProvider {
  getDocument(): Document {
    return document;
  }

  getWindow(): Window {
    return window;
  }
}

/**
 * Content extractor for bookmarklet environment
 * Uses shared ContentExtractorCore with browser DOM provider
 */
export class BookmarkletContentExtractor {
  private core: ContentExtractorCore;
  private markdownConverter: MarkdownConverter;
  private storageProvider: LocalStorageProvider;

  constructor() {
    const domProvider = new BookmarkletDOMProvider();
    this.core = new ContentExtractorCore(domProvider);
    this.storageProvider = new LocalStorageProvider();
    
    // Initialize markdown converter for bookmarklet environment
    this.markdownConverter = new MarkdownConverter();
  }

  async initialize(): Promise<void> {
    await this.storageProvider.initialize?.();
    await this.markdownConverter.initialize();
  }

  /**
   * Extract and convert content from current page
   */
  async extractContent(options: IExtractorOptions = {}): Promise<{
    success: boolean;
    data?: IContentResult & { markdown: string };
    error?: string;
  }> {
    try {
      // Use default options suitable for bookmarklet
      const extractOptions: IExtractorOptions = {
        customSelectors: ['article', 'main', '.content', '.post'],
        cleanHtml: true,
        preserveFormatting: true,
        waitForDynamicContent: false,
        removeAds: true,
        removeNavigation: true,
        excludeSelectors: [
          'nav', 'header', 'footer', '.sidebar', '.menu',
          '.advertisement', '.ad', '.ads', '.popup', '.modal',
          '.social-share', '.comments', '.related'
        ],
        ...options
      };

      // Extract content using core
      const result = await this.core.extractContent(extractOptions);
      
      // Convert to markdown
      const markdown = await this.markdownConverter.convertToMarkdown(result.content);
      
      // Enhanced result with markdown
      const enhancedResult = {
        ...result,
        markdown,
        metadata: {
          ...result.metadata,
          title: result.metadata.title || document.title,
          url: result.metadata.url || window.location.href,
          domain: window.location.hostname,
          extractedAt: new Date().toISOString()
        }
      };

      return {
        success: true,
        data: enhancedResult
      };

    } catch (error) {
      console.error('BookmarkletContentExtractor: Content extraction failed:', error);
      return {
        success: false,
        error: (error as Error).message
      };
    }
  }

  /**
   * Get page metadata
   */
  async getPageMetadata(): Promise<Record<string, unknown>> {
    const metadata: Record<string, unknown> = {
      title: document.title,
      url: window.location.href,
      domain: window.location.hostname,
      timestamp: new Date().toISOString()
    };

    // Extract meta tags
    const metaTags = document.querySelectorAll('meta');
    metaTags.forEach(meta => {
      const name = meta.getAttribute('name') || meta.getAttribute('property');
      const content = meta.getAttribute('content');
      
      if (name && content) {
        metadata[name] = content;
      }
    });

    // Extract Open Graph data
    const ogTags = document.querySelectorAll('meta[property^="og:"]');
    ogTags.forEach(meta => {
      const property = meta.getAttribute('property');
      const content = meta.getAttribute('content');
      
      if (property && content) {
        metadata[property] = content;
      }
    });

    // Extract Twitter Card data
    const twitterTags = document.querySelectorAll('meta[name^="twitter:"]');
    twitterTags.forEach(meta => {
      const name = meta.getAttribute('name');
      const content = meta.getAttribute('content');
      
      if (name && content) {
        metadata[name] = content;
      }
    });

    // Extract structured data (JSON-LD)
    const jsonLdScripts = document.querySelectorAll('script[type="application/ld+json"]');
    const structuredData: any[] = [];
    
    jsonLdScripts.forEach(script => {
      try {
        const data = JSON.parse(script.textContent || '');
        structuredData.push(data);
      } catch (error) {
        // Ignore invalid JSON-LD
      }
    });
    
    if (structuredData.length > 0) {
      metadata['structured-data'] = structuredData;
    }

    return metadata;
  }

  /**
   * Extract main content selectors
   */
  private extractMainContent(): HTMLElement | null {
    const selectors = [
      'article',
      '[role="main"]',
      'main',
      '.content',
      '.post',
      '.entry',
      '#content',
      '#main',
      '.main-content',
      '.post-content',
      '.entry-content'
    ];

    for (const selector of selectors) {
      const element = document.querySelector(selector);
      if (element && this.hasSubstantialContent(element as HTMLElement)) {
        return element as HTMLElement;
      }
    }

    // Fallback to body with content filtering
    return document.body;
  }

  /**
   * Check if element has substantial content
   */
  private hasSubstantialContent(element: HTMLElement): boolean {
    const text = element.textContent || '';
    const wordCount = text.split(/\s+/).filter(word => word.length > 2).length;
    
    return wordCount > 50 && element.offsetHeight > 100;
  }

  /**
   * Clean up extracted content
   */
  private cleanContent(content: HTMLElement): HTMLElement {
    const cloned = content.cloneNode(true) as HTMLElement;

    // Remove unwanted elements
    const unwantedSelectors = [
      'script', 'style', 'noscript', 'iframe',
      '.advertisement', '.ad', '.ads', '.popup', '.modal',
      '.social-share', '.comments', '.related-posts',
      '[style*="display: none"]', '[style*="visibility: hidden"]',
      '.sidebar', '.menu', 'nav:not([role="navigation"][aria-label*="breadcrumb"])'
    ];

    unwantedSelectors.forEach(selector => {
      const elements = cloned.querySelectorAll(selector);
      elements.forEach(el => el.remove());
    });

    // Remove empty paragraphs and containers
    const emptyElements = cloned.querySelectorAll('p:empty, div:empty, span:empty');
    emptyElements.forEach(el => {
      if (!el.querySelector('img, video, audio')) {
        el.remove();
      }
    });

    return cloned;
  }

  /**
   * Extract images from content
   */
  private extractImages(): string[] {
    const images: string[] = [];
    const imgElements = document.querySelectorAll('img');

    imgElements.forEach(img => {
      const src = img.src;
      if (src && !src.startsWith('data:') && src.length > 0) {
        try {
          const absoluteUrl = new URL(src, window.location.href).href;
          if (!images.includes(absoluteUrl)) {
            images.push(absoluteUrl);
          }
        } catch (error) {
          // Invalid URL, skip
        }
      }
    });

    return images;
  }
}
