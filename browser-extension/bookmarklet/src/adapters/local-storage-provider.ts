// Generated by Copilot
// Local Storage Provider for PrismWeave Bookmarklet
// Implements IStorageProvider using browser localStorage API

import type { IStorageProvider } from '../../shared/interfaces/storage-provider.js';

/**
 * Local storage provider for bookmarklet environments
 * Uses browser localStorage API for data persistence
 */
export class LocalStorageProvider implements IStorageProvider {
  private prefix = 'prismweave_';

  async initialize?(): Promise<void> {
    // Check if localStorage is available
    if (!this.isLocalStorageAvailable()) {
      throw new Error('localStorage is not available in this environment');
    }
  }

  async get<T>(key: string): Promise<T | null> {
    try {
      const item = localStorage.getItem(this.prefix + key);
      return item ? JSON.parse(item) : null;
    } catch (error) {
      console.error('LocalStorageProvider: Error getting item:', error);
      return null;
    }
  }

  async set<T>(key: string, value: T): Promise<void> {
    try {
      localStorage.setItem(this.prefix + key, JSON.stringify(value));
    } catch (error) {
      console.error('LocalStorageProvider: Error setting item:', error);
      throw error;
    }
  }

  async remove(key: string): Promise<void> {
    try {
      localStorage.removeItem(this.prefix + key);
    } catch (error) {
      console.error('LocalStorageProvider: Error removing item:', error);
      throw error;
    }
  }

  async clear(): Promise<void> {
    try {
      // Remove only PrismWeave keys
      const keysToRemove: string[] = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith(this.prefix)) {
          keysToRemove.push(key);
        }
      }
      
      keysToRemove.forEach(key => localStorage.removeItem(key));
    } catch (error) {
      console.error('LocalStorageProvider: Error clearing storage:', error);
      throw error;
    }
  }

  async has(key: string): Promise<boolean> {
    return localStorage.getItem(this.prefix + key) !== null;
  }

  async keys(): Promise<string[]> {
    const keys: string[] = [];
    try {
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith(this.prefix)) {
          keys.push(key.substring(this.prefix.length));
        }
      }
    } catch (error) {
      console.error('LocalStorageProvider: Error getting keys:', error);
    }
    return keys;
  }

  async getStorageInfo(): Promise<{
    used: number;
    total: number;
    available: number;
  }> {
    // localStorage quota is typically ~5-10MB, but there's no standard API to check
    // Return estimated values
    const used = this.getUsedStorage();
    const total = 5 * 1024 * 1024; // Assume 5MB total
    
    return {
      used,
      total,
      available: total - used
    };
  }

  /**
   * Check if localStorage is available
   */
  private isLocalStorageAvailable(): boolean {
    try {
      const test = '__prismweave_test__';
      localStorage.setItem(test, 'test');
      localStorage.removeItem(test);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Get approximate storage used by PrismWeave
   */
  private getUsedStorage(): number {
    let totalSize = 0;
    try {
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith(this.prefix)) {
          const value = localStorage.getItem(key);
          if (value) {
            totalSize += key.length + value.length;
          }
        }
      }
    } catch (error) {
      console.error('Error calculating storage usage:', error);
    }
    return totalSize * 2; // Approximate UTF-16 encoding overhead
  }
}
