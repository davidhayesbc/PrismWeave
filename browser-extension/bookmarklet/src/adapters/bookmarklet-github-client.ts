// Generated by Copilot
// Bookmarklet GitHub Client - CORS-compatible GitHub API client for bookmarklet
// Uses direct fetch API without Chrome extension dependencies

import { GitHubAPICore, IGitHubCommitParams, IGitHubCommitResult, IGitHubConnectionTest } from '../../shared/core/github-api-core.js';

/**
 * HTTP provider for bookmarklet environment using fetch API
 */
class BookmarkletHttpProvider {
  async fetch(url: string, options?: RequestInit): Promise<Response> {
    // Use standard fetch API - works in bookmarklet environment
    return fetch(url, {
      ...options,
      headers: {
        'User-Agent': 'PrismWeave-Bookmarklet/1.0',
        ...options?.headers
      }
    });
  }
}

/**
 * Logger for bookmarklet environment
 */
class BookmarkletLogger {
  info(msg: string, ...args: any[]): void {
    console.log('[PrismWeave GitHub]', msg, ...args);
  }

  debug(msg: string, ...args: any[]): void {
    console.debug('[PrismWeave GitHub]', msg, ...args);
  }

  warn(msg: string, ...args: any[]): void {
    console.warn('[PrismWeave GitHub]', msg, ...args);
  }

  error(msg: string, ...args: any[]): void {
    console.error('[PrismWeave GitHub]', msg, ...args);
  }
}

/**
 * GitHub API client for bookmarklet environment
 * Provides CORS-compatible GitHub operations using direct fetch API
 */
export class BookmarkletGitHubClient {
  private core: GitHubAPICore;
  private httpProvider: BookmarkletHttpProvider;
  private logger: BookmarkletLogger;

  constructor() {
    this.httpProvider = new BookmarkletHttpProvider();
    this.logger = new BookmarkletLogger();
    this.core = new GitHubAPICore(this.logger, this.httpProvider);
  }

  async initialize(): Promise<void> {
    // No special initialization needed for bookmarklet
    this.logger.info('BookmarkletGitHubClient initialized');
  }

  /**
   * Commit content to GitHub repository
   */
  async commitToGitHub(params: IGitHubCommitParams): Promise<IGitHubCommitResult> {
    try {
      this.logger.info('Committing to GitHub:', { 
        repo: params.repo, 
        filePath: params.filePath,
        messageLength: params.message.length 
      });

      const result = await this.core.commitToGitHub(params);
      
      if (result.success) {
        this.logger.info('Successfully committed to GitHub:', result.data?.html_url);
      } else {
        this.logger.error('GitHub commit failed:', result.error);
      }

      return result;
    } catch (error) {
      this.logger.error('GitHub commit error:', error);
      return {
        success: false,
        error: (error as Error).message
      };
    }
  }

  /**
   * Test GitHub connection and permissions
   */
  async testConnection(token: string, repo: string): Promise<IGitHubConnectionTest> {
    try {
      this.logger.info('Testing GitHub connection:', { repo });
      
      const result = await this.core.testConnection(token, repo);
      
      if (result.success) {
        this.logger.info('GitHub connection test successful');
      } else {
        this.logger.warn('GitHub connection test failed:', result.error);
      }

      return result;
    } catch (error) {
      this.logger.error('GitHub connection test error:', error);
      return {
        success: false,
        error: (error as Error).message,
        status: 'error'
      };
    }
  }

  /**
   * Validate GitHub repository access
   */
  async validateRepository(token: string, repo: string): Promise<{
    valid: boolean;
    permissions: {
      read: boolean;
      write: boolean;
      admin: boolean;
    };
    error?: string;
  }> {
    try {
      const response = await this.httpProvider.fetch(`https://api.github.com/repos/${repo}`, {
        headers: {
          'Authorization': `token ${token}`,
          'Accept': 'application/vnd.github.v3+json'
        }
      });

      if (!response.ok) {
        if (response.status === 404) {
          return {
            valid: false,
            permissions: { read: false, write: false, admin: false },
            error: 'Repository not found or no access'
          };
        }
        
        return {
          valid: false,
          permissions: { read: false, write: false, admin: false },
          error: `HTTP ${response.status}: ${response.statusText}`
        };
      }

      const data = await response.json();
      
      return {
        valid: true,
        permissions: {
          read: true,
          write: data.permissions?.push || false,
          admin: data.permissions?.admin || false
        }
      };

    } catch (error) {
      return {
        valid: false,
        permissions: { read: false, write: false, admin: false },
        error: (error as Error).message
      };
    }
  }

  /**
   * Get repository information
   */
  async getRepositoryInfo(token: string, repo: string): Promise<{
    name: string;
    fullName: string;
    description: string;
    isPrivate: boolean;
    defaultBranch: string;
    url: string;
  } | null> {
    try {
      const response = await this.httpProvider.fetch(`https://api.github.com/repos/${repo}`, {
        headers: {
          'Authorization': `token ${token}`,
          'Accept': 'application/vnd.github.v3+json'
        }
      });

      if (!response.ok) {
        return null;
      }

      const data = await response.json();
      
      return {
        name: data.name,
        fullName: data.full_name,
        description: data.description || '',
        isPrivate: data.private,
        defaultBranch: data.default_branch,
        url: data.html_url
      };

    } catch (error) {
      this.logger.error('Error getting repository info:', error);
      return null;
    }
  }

  /**
   * List recent commits
   */
  async getRecentCommits(token: string, repo: string, limit: number = 10): Promise<Array<{
    sha: string;
    message: string;
    author: string;
    date: string;
    url: string;
  }>> {
    try {
      const response = await this.httpProvider.fetch(
        `https://api.github.com/repos/${repo}/commits?per_page=${limit}`, 
        {
          headers: {
            'Authorization': `token ${token}`,
            'Accept': 'application/vnd.github.v3+json'
          }
        }
      );

      if (!response.ok) {
        return [];
      }

      const commits = await response.json();
      
      return commits.map((commit: any) => ({
        sha: commit.sha.substring(0, 8),
        message: commit.commit.message.split('\n')[0],
        author: commit.commit.author.name,
        date: commit.commit.author.date,
        url: commit.html_url
      }));

    } catch (error) {
      this.logger.error('Error getting recent commits:', error);
      return [];
    }
  }

  /**
   * Check if file exists in repository
   */
  async fileExists(token: string, repo: string, filePath: string): Promise<boolean> {
    try {
      const response = await this.httpProvider.fetch(
        `https://api.github.com/repos/${repo}/contents/${filePath}`,
        {
          headers: {
            'Authorization': `token ${token}`,
            'Accept': 'application/vnd.github.v3+json'
          }
        }
      );

      return response.ok;
    } catch (error) {
      return false;
    }
  }
}
