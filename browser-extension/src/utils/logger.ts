// Generated by Copilot
// PrismWeave Logging Utility
// Simple logging system with configurable levels and easy on/off toggle

import { getGlobalScope } from './global-types';

type LogLevel = 0 | 1 | 2 | 3 | 4;

interface ILogStyles {
  error: string;
  warn: string;
  info: string;
  debug: string;
  trace: string;
}

class Logger {
  public component: string;
  public enabled: boolean;
  public level: LogLevel;
  private styles: ILogStyles;

  static readonly LEVELS = {
    ERROR: 0 as const,
    WARN: 1 as const,
    INFO: 2 as const,
    DEBUG: 3 as const,
    TRACE: 4 as const,
  };

  static readonly LEVEL_NAMES = ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE'] as const;

  constructor(component: string = 'PrismWeave') {
    this.component = component;
    // Automatically disable verbose logging during tests
    this.enabled = !this._isTestEnvironment();
    this.level = this._isTestEnvironment() ? Logger.LEVELS.ERROR : Logger.LEVELS.DEBUG;
    this.styles = {
      error: 'color: #ff4444; font-weight: bold;',
      warn: 'color: #ffaa00; font-weight: bold;',
      info: 'color: #4444ff; font-weight: bold;',
      debug: 'color: #888888;',
      trace: 'color: #cccccc;',
    };
  }

  private _shouldLog(level: LogLevel): boolean {
    return this.enabled && level <= this.level;
  }

  private _isTestEnvironment(): boolean {
    return (
      typeof process !== 'undefined' &&
      (process.env.NODE_ENV === 'test' || process.env.JEST_WORKER_ID !== undefined)
    );
  }

  private _formatMessage(level: LogLevel, message: unknown, ...args: unknown[]): unknown[] {
    const levelName = Logger.LEVEL_NAMES[level];
    const timestamp = new Date().toISOString().substr(11, 12);
    const prefix = `[${timestamp}] [${this.component}] [${levelName}]`;

    if (typeof message === 'string') {
      return [
        `%c${prefix} ${message}`,
        this.styles[levelName.toLowerCase() as keyof ILogStyles],
        ...args,
      ];
    } else {
      return [
        `%c${prefix}`,
        this.styles[levelName.toLowerCase() as keyof ILogStyles],
        message,
        ...args,
      ];
    }
  }

  error(message: unknown, ...args: unknown[]): void {
    if (this._shouldLog(Logger.LEVELS.ERROR)) {
      console.error(...this._formatMessage(Logger.LEVELS.ERROR, message, ...args));
    }
  }

  warn(message: unknown, ...args: unknown[]): void {
    if (this._shouldLog(Logger.LEVELS.WARN)) {
      console.warn(...this._formatMessage(Logger.LEVELS.WARN, message, ...args));
    }
  }

  info(message: unknown, ...args: unknown[]): void {
    if (this._shouldLog(Logger.LEVELS.INFO)) {
      console.info(...this._formatMessage(Logger.LEVELS.INFO, message, ...args));
    }
  }

  debug(message: unknown, ...args: unknown[]): void {
    if (this._shouldLog(Logger.LEVELS.DEBUG)) {
      console.log(...this._formatMessage(Logger.LEVELS.DEBUG, message, ...args));
    }
  }

  trace(message: unknown, ...args: unknown[]): void {
    if (this._shouldLog(Logger.LEVELS.TRACE)) {
      console.log(...this._formatMessage(Logger.LEVELS.TRACE, message, ...args));
    }
  }
  // Utility methods
  group(label?: string, collapsed: boolean = false): void {
    if (this.enabled) {
      const groupLabel = label ? `[${this.component}] ${label}` : `[${this.component}]`;
      if (collapsed) {
        console.groupCollapsed(groupLabel);
      } else {
        console.group(groupLabel);
      }
    }
  }

  groupEnd(): void {
    if (this.enabled) {
      console.groupEnd();
    }
  }

  table(data: unknown, columns?: string[]): void {
    if (this.enabled && this._shouldLog(Logger.LEVELS.DEBUG)) {
      console.table(data, columns);
    }
  }

  time(label: string): void {
    if (this.enabled && this._shouldLog(Logger.LEVELS.DEBUG)) {
      console.time(`[${this.component}] ${label}`);
    }
  }

  timeEnd(label: string): void {
    if (this.enabled && this._shouldLog(Logger.LEVELS.DEBUG)) {
      console.timeEnd(`[${this.component}] ${label}`);
    }
  }

  // Configuration methods
  setLevel(level: LogLevel): void {
    this.level = level;
    this.info('Log level set to:', Logger.LEVEL_NAMES[level]);
  }

  enable(): void {
    this.enabled = true;
    console.log(`%c[${this.component}] Logging enabled`, this.styles.info);
  }

  disable(): void {
    console.log(`%c[${this.component}] Logging disabled`, this.styles.warn);
    this.enabled = false;
  }
  // Global configuration methods
  static setGlobalLevel(level: LogLevel): void {
    (typeof window !== 'undefined' ? (window as any) : (self as any)).PRISMWEAVE_LOG_LEVEL = level;
  }

  static setGlobalEnabled(enabled: boolean): void {
    (typeof window !== 'undefined' ? (window as any) : (self as any)).PRISMWEAVE_LOG_ENABLED =
      enabled;
  }
}

// Global logger factory
function createLogger(component: string): Logger {
  const logger = new Logger(component);

  // Check for global overrides
  const globalScope = typeof window !== 'undefined' ? (window as any) : (self as any);
  if (globalScope.PRISMWEAVE_LOG_ENABLED !== undefined) {
    logger.enabled = globalScope.PRISMWEAVE_LOG_ENABLED;
  }
  if (globalScope.PRISMWEAVE_LOG_LEVEL !== undefined) {
    logger.level = globalScope.PRISMWEAVE_LOG_LEVEL;
  }

  return logger;
}

// Export for use in other modules
export { createLogger, Logger };
export type { ILogStyles, LogLevel };

// Export to global scope
const globalScope = getGlobalScope();
globalScope.PrismWeaveLogger = { createLogger };
