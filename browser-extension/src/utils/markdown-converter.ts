// Generated by Copilot
// PrismWeave Markdown Converter - TypeScript version
// Enhanced HTML to Markdown conversion with high-fidelity preservation

import { IDocumentMetadata, IImageAsset } from '../types/index.js';

interface IConversionOptions {
  preserveFormatting?: boolean;
  includeMetadata?: boolean;
  generateFrontmatter?: boolean;
  customRules?: Record<string, unknown>;
  headingStyle?: 'atx' | 'setext';
  bulletListMarker?: '-' | '*' | '+';
  codeBlockStyle?: 'fenced' | 'indented';
  linkStyle?: 'inlined' | 'referenced';
}

interface IConversionResult {
  markdown: string;
  frontmatter: string;
  metadata: IDocumentMetadata;
  images: IImageAsset[];
  wordCount: number;
}

interface ITurndownService {
  turndown(html: string): string;
  addRule(key: string, rule: any): void;
  remove(filter: string | string[]): void;
  use(plugin: any): void;
}

interface ISemanticSelectors {
  callouts: string[];
  quotes: string[];
  highlights: string[];
  captions: string[];
  metadata: string[];
  codeElements: string[];
}

declare global {
  interface Window {
    TurndownService?: new (options?: any) => ITurndownService;
  }
}

export class MarkdownConverter {
  private turndownService: ITurndownService | null = null;
  private readonly semanticSelectors: ISemanticSelectors;
  private _isInitialized: boolean = false;
  constructor() {
    this.semanticSelectors = {
      callouts: ['.callout', '.note', '.warning', '.info', '.alert', '.notice', '[role="note"]'],
      quotes: ['blockquote', '.quote', '.pullquote', '[role="blockquote"]'],
      highlights: ['.highlight', '.featured', '.important', 'mark', '.marker'],
      captions: ['figcaption', '.caption', '.image-caption', '.photo-caption'],
      metadata: ['.byline', '.author', '.date', '.timestamp', '.published', '.updated'],
      codeElements: ['code', 'pre', '.code', '.highlight', '.syntax'],
    };

    // Initialize TurndownService
    this.initializeTurndown();
  }
  private initializeTurndown(): void {
    // Service worker context check - TurndownService should never be loaded here
    const isServiceWorker =
      typeof (globalThis as any).importScripts === 'function' && typeof window === 'undefined';
    if (isServiceWorker) {
      console.info(
        'MarkdownConverter: Running in service worker context, TurndownService not available'
      );
      this.turndownService = null;
      this._isInitialized = true;
      return;
    } // Check if document is available (content script context)
    if (typeof document === 'undefined') {
      console.warn(
        'MarkdownConverter: Document not available, TurndownService cannot be initialized'
      );
      this.turndownService = null;
      this._isInitialized = true;
      return;
    }

    // Get TurndownService constructor from window or globalThis
    const TurndownService =
      (typeof window !== 'undefined' && window.TurndownService) ||
      (typeof globalThis !== 'undefined' && (globalThis as any).TurndownService); // Check if TurndownService is available
    if (!TurndownService) {
      console.warn('MarkdownConverter: TurndownService not available, cannot initialize');
      this.turndownService = null;
      this._isInitialized = true;
      return;
    } // TurndownService is available - initialize it
    this.setupTurndownService();
    this._isInitialized = true;
    console.info('MarkdownConverter: TurndownService initialized successfully');
  }

  private setupTurndownService(): void {
    const TurndownService = window.TurndownService;
    if (!TurndownService) {
      this.turndownService = null;
      return;
    }

    console.info('MarkdownConverter: Initializing TurndownService with enhanced rules');

    // Initialize Turndown service with enhanced custom rules
    this.turndownService = new TurndownService({
      headingStyle: 'atx',
      bulletListMarker: '-',
      codeBlockStyle: 'fenced',
      emDelimiter: '*',
      strongDelimiter: '**',
      linkStyle: 'inlined',
      linkReferenceStyle: 'full',
      preformattedCode: true,
      blankReplacement: function (content: string, node: any): string {
        return node.isBlock ? '\n\n' : '';
      },
      keepReplacement: function (content: string, node: any): string {
        return node.isBlock ? '\n\n' + node.outerHTML + '\n\n' : node.outerHTML;
      },
    });

    this.addCustomTurndownRules();
  }

  private addCustomTurndownRules(): void {
    if (!this.turndownService) return;

    // Line number removal rule - handle HTML structures with line numbers
    this.turndownService.addRule('removeLineNumbers', {
      filter: (node: any): boolean => {
        // Remove elements that are clearly line numbers
        if (node.nodeType === 1) { // Element node
          const className = (node.className || '').toLowerCase();
          const id = (node.id || '').toLowerCase();
          
          // Common line number class patterns
          const lineNumberPatterns = [
            'line-number', 'linenumber', 'line-num', 'linenum',
            'gutter', 'line-gutter', 'code-line-number',
            'hljs-ln-numbers', 'hljs-ln-line', 'prism-line-number'
          ];
          
          // Check if class name indicates line numbers
          if (lineNumberPatterns.some(pattern => 
            className.includes(pattern) || id.includes(pattern)
          )) {
            return true;
          }
          
          // Check for table cells that contain only numbers (likely line numbers)
          if (node.nodeName === 'TD' || node.nodeName === 'TH') {
            const text = (node.textContent || '').trim();
            // If cell contains only a number (1-4 digits), likely a line number
            if (/^\d{1,4}$/.test(text)) {
              return true;
            }
          }
          
          // Check for spans/divs that contain only sequential numbers
          if (node.nodeName === 'SPAN' || node.nodeName === 'DIV') {
            const text = (node.textContent || '').trim();
            // Pattern for standalone line numbers
            if (/^\d{1,4}$/.test(text)) {
              // Additional check: if this element is in a code context
              let parent = node.parentNode;
              while (parent && parent.nodeType === 1) {
                const parentTag = parent.nodeName.toLowerCase();
                const parentClass = (parent.className || '').toLowerCase();
                
                if (parentTag === 'pre' || parentTag === 'code' || 
                    parentClass.includes('code') || parentClass.includes('highlight')) {
                  return true;
                }
                parent = parent.parentNode;
              }
            }
          }
        }
        
        return false;
      },
      replacement: (): string => {
        // Remove line number elements entirely
        return '';
      },
    });

    // Code table rule - handle tables used for displaying code with line numbers
    this.turndownService.addRule('codeTable', {
      filter: (node: any): boolean => {
        // Look for tables that seem to be used for code display
        if (node.nodeName === 'TABLE') {
          const className = (node.className || '').toLowerCase();
          
          // Common patterns for code tables
          if (className.includes('code') || className.includes('highlight') || 
              className.includes('hljs') || className.includes('prism')) {
            return true;
          }
          
          // Check if table has typical code table structure
          const rows = node.querySelectorAll('tr');
          if (rows.length > 0) {
            const firstRow = rows[0];
            const cells = firstRow.querySelectorAll('td, th');
            
            // If table has exactly 2 columns and first column looks like line numbers
            if (cells.length === 2) {
              const firstCellText = (cells[0].textContent || '').trim();
              // Check if first cell contains a number (potential line number)
              if (/^\d{1,4}$/.test(firstCellText)) {
                return true;
              }
            }
          }
        }
        
        return false;
      },
      replacement: (content: string, node: any): string => {
        // Extract only the code content from the second column
        const rows = node.querySelectorAll('tr');
        const codeLines: string[] = [];
        
        rows.forEach((row: any) => {
          const cells = row.querySelectorAll('td, th');
          if (cells.length >= 2) {
            // Take content from second column (index 1), which should be the code
            const codeCell = cells[1];
            const codeLine = (codeCell.textContent || '').replace(/\n+$/, ''); // Remove trailing newlines
            if (codeLine.trim()) {
              codeLines.push(codeLine);
            }
          }
        });
        
        if (codeLines.length > 0) {
          // Try to detect language from class names
          const className = (node.className || '').toLowerCase();
          let language = '';
          
          // Simple language detection from class names
          const langPatterns = {
            'javascript': 'javascript', 'js': 'javascript',
            'typescript': 'typescript', 'ts': 'typescript',
            'python': 'python', 'py': 'python',
            'bash': 'bash', 'shell': 'bash', 'sh': 'bash',
            'html': 'html', 'css': 'css', 'json': 'json'
          };
          
          for (const [pattern, lang] of Object.entries(langPatterns)) {
            if (className.includes(pattern)) {
              language = lang;
              break;
            }
          }
          
          return '\n\n```' + language + '\n' + codeLines.join('\n') + '\n```\n\n';
        }
        
        // Fallback to normal table processing
        return '\n\n' + content + '\n\n';
      },
    });

    // Enhanced table rule with better formatting
    this.turndownService.addRule('enhancedTable', {
      filter: 'table',
      replacement: (content: string, node: any): string => {
        return '\n\n' + content + '\n\n';
      },
    });

    // Table cell rule
    this.turndownService.addRule('tableCell', {
      filter: ['th', 'td'],
      replacement: (content: string, node: any): string => {
        const tag = node.nodeName.toLowerCase();
        const isHeader = tag === 'th';
        let cellContent = content.trim().replace(/\n/g, ' ').replace(/\|/g, '\\|');

        if (!cellContent) cellContent = ' ';

        return '| ' + cellContent + ' ';
      },
    });

    // Table row rule with header detection
    this.turndownService.addRule('tableRow', {
      filter: 'tr',
      replacement: (content: string, node: any): string => {
        const hasHeaders = node.querySelectorAll('th').length > 0;
        let row = content + '|\n';

        if (hasHeaders) {
          const headerSeparator = content.replace(/[^|]/g, '').replace(/\|/g, '|---') + '|\n';
          row += headerSeparator;
        }

        return row;
      },
    });

    // Enhanced blockquote rule
    this.turndownService.addRule('enhancedBlockquote', {
      filter: 'blockquote',
      replacement: (content: string): string => {
        const lines = content.trim().split('\n');
        const quotedLines = lines.map(line => '> ' + line);
        return '\n\n' + quotedLines.join('\n') + '\n\n';
      },
    }); // Code block rule with language detection and improved content preservation
    this.turndownService.addRule('enhancedCodeBlock', {
      filter: (node: any): boolean => {
        return node.nodeName === 'PRE' && node.firstChild && node.firstChild.nodeName === 'CODE';
      },
      replacement: (content: string, node: any): string => {
        const codeElement = node.firstChild;
        const language = this.extractLanguageFromClass(codeElement.className);

        // Get raw text content to preserve formatting and special characters
        let code = codeElement.textContent || '';        // Preserve HTML entities that should be decoded in code blocks
        code = code
          .replace(/&lt;/g, '<')
          .replace(/&gt;/g, '>')
          .replace(/&amp;/g, '&')
          .replace(/&quot;/g, '"')
          .replace(/&#39;/g, "'")
          .replace(/&nbsp;/g, ' ');

        // Line numbers should already be removed by HTML structure rules
        // Determine appropriate number of backticks to escape the code block
        // Find the longest sequence of consecutive backticks in the code
        const backtickMatches = code.match(/`+/g) || [];
        const maxBackticks = backtickMatches.reduce(
          (max: number, match: string) => Math.max(max, match.length),
          0
        );

        // Use at least 3 backticks, but if the code contains backticks, use one more than the longest sequence
        const fenceLength = Math.max(3, maxBackticks + 1);
        const fence = '`'.repeat(fenceLength);

        return '\n\n' + fence + language + '\n' + code + '\n' + fence + '\n\n';
      },
    });

    // Inline code rule with better escaping
    this.turndownService.addRule('enhancedInlineCode', {
      filter: (node: any): boolean => {
        return node.nodeName === 'CODE' && (!node.parentNode || node.parentNode.nodeName !== 'PRE');
      },
      replacement: (content: string, node: any): string => {
        let code = node.textContent || content;

        // Decode HTML entities for inline code
        code = code
          .replace(/&lt;/g, '<')
          .replace(/&gt;/g, '>')
          .replace(/&amp;/g, '&')
          .replace(/&quot;/g, '"')
          .replace(/&#39;/g, "'")
          .replace(/&nbsp;/g, ' ');

        // Escape backticks in inline code
        code = code.replace(/`/g, '\\`');

        return '`' + code + '`';
      },
    });

    // Image rule with alt text and title preservation
    this.turndownService.addRule('enhancedImage', {
      filter: 'img',
      replacement: (content: string, node: any): string => {
        const alt = node.getAttribute('alt') || '';
        const src = node.getAttribute('src') || '';
        const title = node.getAttribute('title');

        if (!src) return '';

        let markdown = '![' + alt + '](' + src;
        if (title) {
          markdown += ' "' + title + '"';
        }
        markdown += ')';

        return markdown;
      },
    });

    // Enhanced link rule with title preservation
    this.turndownService.addRule('enhancedLink', {
      filter: 'a',
      replacement: (content: string, node: any): string => {
        const href = node.getAttribute('href');
        const title = node.getAttribute('title');

        if (!href) return content;

        let markdown = '[' + content + '](' + href;
        if (title) {
          markdown += ' "' + title + '"';
        }
        markdown += ')';

        return markdown;
      },
    });

    // Callout/Note box rule
    this.turndownService.addRule('callouts', {
      filter: (node: any): boolean => {
        return this.semanticSelectors.callouts.some(
          selector => node.matches && node.matches(selector)
        );
      },
      replacement: (content: string, node: any): string => {
        const type = this.getCalloutType(node);
        return '\n\n> **' + type + ':** ' + content.trim() + '\n\n';
      },
    });

    // Highlight rule
    this.turndownService.addRule('highlights', {
      filter: (node: any): boolean => {
        return this.semanticSelectors.highlights.some(
          selector => node.matches && node.matches(selector)
        );
      },
      replacement: (content: string): string => {
        return '==' + content + '==';
      },
    });

    // Figure and caption rule
    this.turndownService.addRule('figureWithCaption', {
      filter: 'figure',
      replacement: (content: string, node: any): string => {
        const img = node.querySelector('img');
        const caption = node.querySelector('figcaption');

        if (!img) return content;

        const alt = img.getAttribute('alt') || '';
        const src = img.getAttribute('src') || '';
        const captionText = caption ? caption.textContent?.trim() : '';

        let markdown = '\n\n![' + alt + '](' + src + ')';
        if (captionText) {
          markdown += '\n*' + captionText + '*';
        }
        markdown += '\n\n';

        return markdown;
      },
    }); // Line break rule
    this.turndownService.addRule('lineBreak', {
      filter: 'br',
      replacement: (): string => '  \n',
    });

    // Horizontal rule
    this.turndownService.addRule('horizontalRule', {
      filter: 'hr',
      replacement: (): string => '\n\n---\n\n',
    });
  } /**
   * Ensures that the MarkdownConverter is fully initialized before proceeding with conversion
   */
  private async ensureInitialized(): Promise<void> {
    if (this._isInitialized) {
      return;
    }

    console.log('MarkdownConverter: Waiting for initialization to complete...');

    // TurndownService should be available immediately via manifest injection
    // If not already initialized, try once more
    if (!this._isInitialized) {
      console.warn('MarkdownConverter: Not initialized, attempting to initialize now');
      this.initializeTurndown();
    }
    if (!this._isInitialized) {
      console.error(
        'MarkdownConverter: Initialization failed - TurndownService required for conversion'
      );
      this.turndownService = null;
      this._isInitialized = true;
    }
  }
  async convertToMarkdown(
    html: string,
    metadata: IDocumentMetadata,
    options: IConversionOptions = {}
  ): Promise<IConversionResult> {
    try {
      console.log('MarkdownConverter: Starting conversion');
      console.log('MarkdownConverter: Input HTML length:', html.length);

      // Ensure initialization is complete before proceeding
      await this.ensureInitialized();

      // Preprocess HTML for better conversion
      const preprocessedHtml = this.preprocessHtml(html, options);
      console.log('MarkdownConverter: Preprocessed HTML length:', preprocessedHtml.length); // Convert to markdown using TurndownService
      let markdown: string;
      if (this.turndownService) {
        console.log('MarkdownConverter: Using TurndownService for conversion');
        markdown = this.turndownService.turndown(preprocessedHtml);
      } else {
        console.warn(
          'MarkdownConverter: TurndownService not available - cannot convert HTML to markdown'
        );
        throw new Error(
          'TurndownService not initialized - HTML to markdown conversion not available'
        );
      }

      console.log('MarkdownConverter: Raw markdown length:', markdown.length);

      // Post-process markdown
      markdown = this.postprocessMarkdown(markdown, options);
      console.log('MarkdownConverter: Final markdown length:', markdown.length);

      // Extract images
      const images = this.extractImages(html);

      // Generate frontmatter if requested
      const frontmatter = options.generateFrontmatter ? this.generateFrontmatter(metadata) : '';

      // Calculate word count
      const wordCount = this.countWords(markdown);

      console.log('MarkdownConverter: Conversion complete');

      return {
        markdown,
        frontmatter,
        metadata: {
          ...metadata,
          wordCount,
          estimatedReadingTime: Math.ceil(wordCount / 225),
        },
        images,
        wordCount,
      };
    } catch (error) {
      console.error('MarkdownConverter: Conversion failed:', error);
      throw error;
    }
  }

  private preprocessHtml(html: string, options: IConversionOptions): string {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = html;

    // Remove unwanted elements
    this.removeUnwantedElements(tempDiv);

    // Normalize whitespace
    this.normalizeWhitespace(tempDiv);

    // Enhance semantic structure
    this.enhanceSemanticStructure(tempDiv);

    return tempDiv.innerHTML;
  }

  private removeUnwantedElements(element: Element): void {
    const unwantedSelectors = [
      'script',
      'style',
      'noscript',
      '[style*="display: none"]',
      '[style*="visibility: hidden"]',
      '.screen-reader-text',
      '.visually-hidden',
      '.sr-only',
      'iframe[src*="ads"]',
      'iframe[src*="advertisement"]',
    ];

    const unwanted = element.querySelectorAll(unwantedSelectors.join(','));
    unwanted.forEach(el => el.remove());
  }

  private normalizeWhitespace(element: Element): void {
    const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT);

    const textNodes: Text[] = [];
    let node;
    while ((node = walker.nextNode())) {
      textNodes.push(node as Text);
    }

    textNodes.forEach(textNode => {
      if (textNode.textContent) {
        // Normalize whitespace but preserve intentional line breaks
        textNode.textContent = textNode.textContent
          .replace(/[ \t]+/g, ' ')
          .replace(/\n\s*\n/g, '\n\n');
      }
    });
  }

  private enhanceSemanticStructure(element: Element): void {
    // Convert div elements with specific classes to semantic elements
    const divs = element.querySelectorAll('div');

    divs.forEach(div => {
      const className = div.className.toLowerCase();

      if (className.includes('quote') || className.includes('blockquote')) {
        const blockquote = document.createElement('blockquote');
        blockquote.innerHTML = div.innerHTML;
        div.parentNode?.replaceChild(blockquote, div);
      } else if (className.includes('code') || className.includes('highlight')) {
        const pre = document.createElement('pre');
        const code = document.createElement('code');
        code.textContent = div.textContent || '';
        pre.appendChild(code);
        div.parentNode?.replaceChild(pre, div);
      }
    });
  }

  private postprocessMarkdown(markdown: string, options: IConversionOptions): string {
    let processed = markdown;

    // Clean up excessive line breaks
    processed = processed.replace(/\n{3,}/g, '\n\n');

    // Fix spacing around headers
    processed = processed.replace(/\n+(#{1,6})/g, '\n\n$1');
    processed = processed.replace(/(#{1,6}.*)\n+/g, '$1\n\n');

    // Fix list formatting
    processed = processed.replace(/\n+(\s*[-*+])/g, '\n$1');
    processed = processed.replace(/\n+(\s*\d+\.)/g, '\n$1');

    // Fix blockquote formatting
    processed = processed.replace(/\n+(>)/g, '\n\n$1');
    processed = processed.replace(/(>\s.*)\n+/g, '$1\n\n');

    // Fix code block formatting
    processed = processed.replace(/\n+(```)/g, '\n\n$1');
    processed = processed.replace(/(```.*?```)\n+/gs, '$1\n\n');

    // Clean up beginning and end
    processed = processed.trim();

    return processed;
  }

  private extractLanguageFromClass(className: string): string {
    if (!className) return '';

    const languageMap: Record<string, string> = {
      javascript: 'javascript',
      js: 'javascript',
      typescript: 'typescript',
      ts: 'typescript',
      python: 'python',
      py: 'python',
      java: 'java',
      csharp: 'csharp',
      cs: 'csharp',
      html: 'html',
      css: 'css',
      json: 'json',
      xml: 'xml',
      sql: 'sql',
      bash: 'bash',
      shell: 'bash',
      sh: 'bash',
      zsh: 'zsh',
      powershell: 'powershell',
      ps1: 'powershell',
      php: 'php',
      ruby: 'ruby',
      rb: 'ruby',
      go: 'go',
      rust: 'rust',
      rs: 'rust',
      cpp: 'cpp',
      'c++': 'cpp',
      c: 'c',
      haskell: 'haskell',
      hs: 'haskell',
      scala: 'scala',
      kotlin: 'kotlin',
      kt: 'kotlin',
      swift: 'swift',
      dockerfile: 'dockerfile',
      docker: 'dockerfile',
      yaml: 'yaml',
      yml: 'yaml',
      toml: 'toml',
      ini: 'ini',
      markdown: 'markdown',
      md: 'markdown',
      tex: 'latex',
      latex: 'latex',
      r: 'r',
      matlab: 'matlab',
      perl: 'perl',
      pl: 'perl',
      lua: 'lua',
      vim: 'vim',
      makefile: 'makefile',
      make: 'makefile',
      cmake: 'cmake',
      diff: 'diff',
      patch: 'diff',
      console: 'console',
      terminal: 'bash',
      cmd: 'batch',
      batch: 'batch',
      apache: 'apache',
      nginx: 'nginx',
      // Unison language (from the blog post)
      unison: 'unison',
      ucm: 'unison',
    };

    const classes = className.toLowerCase().split(/\s+/);

    for (const cls of classes) {
      // Check for language- prefix
      if (cls.startsWith('language-')) {
        const lang = cls.substring(9);
        return languageMap[lang] || lang;
      }

      // Check for highlight- prefix
      if (cls.startsWith('highlight-')) {
        const lang = cls.substring(10);
        return languageMap[lang] || lang;
      }

      // Check for hljs- prefix (highlight.js)
      if (cls.startsWith('hljs-')) {
        const lang = cls.substring(5);
        return languageMap[lang] || lang;
      }

      // Check for prism- prefix
      if (cls.startsWith('prism-')) {
        const lang = cls.substring(6);
        return languageMap[lang] || lang;
      }

      // Check direct language match
      if (languageMap[cls]) {
        return languageMap[cls];
      }
    }

    return '';
  }

  private getCalloutType(node: Element): string {
    const className = node.className.toLowerCase();

    if (className.includes('warning') || className.includes('alert')) return 'Warning';
    if (className.includes('info') || className.includes('note')) return 'Note';
    if (className.includes('error') || className.includes('danger')) return 'Error';
    if (className.includes('success') || className.includes('tip')) return 'Tip';

    return 'Note';
  }

  private extractImages(html: string): IImageAsset[] {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = html;

    const images = tempDiv.querySelectorAll('img');

    return Array.from(images)
      .map((img, index) => ({
        originalUrl: img.src,
        localPath: '', // Will be set during image processing
        filename: this.generateImageFilename(img.src, index),
        size: 0, // Will be determined during download
        mimeType: this.getMimeTypeFromUrl(img.src),
      }))
      .filter(img => img.originalUrl && !img.originalUrl.startsWith('data:'));
  }

  private generateImageFilename(url: string, index: number): string {
    try {
      const urlObj = new URL(url);
      const pathname = urlObj.pathname;
      const filename = pathname.split('/').pop() || `image-${index}`;

      // Ensure filename has an extension
      if (!filename.includes('.')) {
        return `${filename}.jpg`;
      }

      return filename;
    } catch {
      return `image-${index}.jpg`;
    }
  }

  private getMimeTypeFromUrl(url: string): string {
    const extension = url.split('.').pop()?.toLowerCase();

    const mimeTypes: Record<string, string> = {
      jpg: 'image/jpeg',
      jpeg: 'image/jpeg',
      png: 'image/png',
      gif: 'image/gif',
      webp: 'image/webp',
      svg: 'image/svg+xml',
      bmp: 'image/bmp',
      ico: 'image/x-icon',
    };

    return mimeTypes[extension || ''] || 'image/jpeg';
  }

  private generateFrontmatter(metadata: IDocumentMetadata): string {
    const frontmatterData = {
      title: metadata.title,
      url: metadata.url,
      date: metadata.captureDate,
      tags: metadata.tags,
      ...(metadata.author && { author: metadata.author }),
      ...(metadata.wordCount && { wordCount: metadata.wordCount }),
      ...(metadata.estimatedReadingTime && { readingTime: metadata.estimatedReadingTime }),
    };

    let frontmatter = '---\n';

    Object.entries(frontmatterData).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        frontmatter += `${key}:\n`;
        value.forEach(item => {
          frontmatter += `  - ${item}\n`;
        });
      } else {
        frontmatter += `${key}: ${value}\n`;
      }
    });

    frontmatter += '---\n\n';

    return frontmatter;
  }

  private countWords(text: string): number {
    return text
      .replace(/[^\w\s]/g, ' ')
      .split(/\s+/)
      .filter(word => word.length > 0).length;
  }

  // Public utility methods
  cleanMarkdown(markdown: string): string {
    return this.postprocessMarkdown(markdown, {});
  }

  validateMarkdown(markdown: string): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Check for malformed links
    const malformedLinks = markdown.match(/\[([^\]]*)\]\([^)]*$/gm);
    if (malformedLinks) {
      errors.push(`Malformed links found: ${malformedLinks.length}`);
    }

    // Check for malformed images
    const malformedImages = markdown.match(/!\[([^\]]*)\]\([^)]*$/gm);
    if (malformedImages) {
      errors.push(`Malformed images found: ${malformedImages.length}`);
    }

    // Check for unbalanced code blocks
    const codeBlocks = markdown.match(/```/g);
    if (codeBlocks && codeBlocks.length % 2 !== 0) {
      errors.push('Unbalanced code blocks detected');
    }

    // Check for unbalanced emphasis
    const boldMatches = markdown.match(/\*\*/g);
    if (boldMatches && boldMatches.length % 2 !== 0) {
      errors.push('Unbalanced bold formatting detected');
    }

    const italicMatches = markdown.match(/(?<!\*)\*(?!\*)/g);
    if (italicMatches && italicMatches.length % 2 !== 0) {
      errors.push('Unbalanced italic formatting detected');
    }

    return {
      isValid: errors.length === 0,
      errors,
    };
  }

  getMarkdownStats(markdown: string): {
    words: number;
    characters: number;
    headings: number;
    links: number;
    images: number;
    codeBlocks: number;
  } {
    return {
      words: this.countWords(markdown),
      characters: markdown.length,
      headings: (markdown.match(/^#+\s/gm) || []).length,
      links: (markdown.match(/\[([^\]]*)\]\([^)]*\)/g) || []).length,
      images: (markdown.match(/!\[([^\]]*)\]\([^)]*\)/g) || []).length,
      codeBlocks: (markdown.match(/```/g) || []).length / 2,
    };
  }
}
