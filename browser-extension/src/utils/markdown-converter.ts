// Generated by Copilot
// PrismWeave Markdown Converter - TypeScript version
// Enhanced HTML to Markdown conversion with high-fidelity preservation

import { IDocumentMetadata, IImageAsset } from '../types/index.js';

interface IConversionOptions {
  preserveFormatting?: boolean;
  includeMetadata?: boolean;
  generateFrontmatter?: boolean;
  customRules?: Record<string, unknown>;
  headingStyle?: 'atx' | 'setext';
  bulletListMarker?: '-' | '*' | '+';
  codeBlockStyle?: 'fenced' | 'indented';
  linkStyle?: 'inlined' | 'referenced';
}

interface IConversionResult {
  markdown: string;
  frontmatter: string;
  metadata: IDocumentMetadata;
  images: IImageAsset[];
  wordCount: number;
}

interface ITurndownService {
  turndown(html: string): string;
  addRule(key: string, rule: any): void;
  remove(filter: string | string[]): void;
  use(plugin: any): void;
}

interface ISemanticSelectors {
  callouts: string[];
  quotes: string[];
  highlights: string[];
  captions: string[];
  metadata: string[];
  codeElements: string[];
}

declare global {
  interface Window {
    TurndownService?: new (options?: any) => ITurndownService;
  }
}

export class MarkdownConverter {
  private turndownService: ITurndownService | null = null;
  private readonly semanticSelectors: ISemanticSelectors;
  private _initializationPromise: Promise<void> | null = null;
  private _isInitialized: boolean = false;
  constructor() {
    this.semanticSelectors = {
      callouts: ['.callout', '.note', '.warning', '.info', '.alert', '.notice', '[role="note"]'],
      quotes: ['blockquote', '.quote', '.pullquote', '[role="blockquote"]'],
      highlights: ['.highlight', '.featured', '.important', 'mark', '.marker'],
      captions: ['figcaption', '.caption', '.image-caption', '.photo-caption'],
      metadata: ['.byline', '.author', '.date', '.timestamp', '.published', '.updated'],
      codeElements: ['code', 'pre', '.code', '.highlight', '.syntax'],
    };

    // Initialize synchronously for service worker, async for others
    this.initializeTurndown();
  }  private initializeTurndown(): void {
    // Service worker context check - TurndownService should never be loaded here
    const isServiceWorker =
      typeof (globalThis as any).importScripts === 'function' && typeof window === 'undefined';

    if (isServiceWorker) {
      console.info(
        'MarkdownConverter: Running in service worker context, using enhanced fallback conversion'
      );
      this.turndownService = null;
      this._isInitialized = true;
      return;
    }

    // Check if document is available (content script context)
    if (typeof document === 'undefined') {
      console.warn('MarkdownConverter: Document not available, using fallback conversion');
      this.turndownService = null;
      this._isInitialized = true;
      return;
    }

    // Get TurndownService constructor from window or globalThis
    const TurndownService =
      (typeof window !== 'undefined' && window.TurndownService) ||
      (typeof globalThis !== 'undefined' && (globalThis as any).TurndownService);

    // Check if TurndownService is available
    if (!TurndownService) {
      console.warn('MarkdownConverter: TurndownService not available, attempting to load library dynamically');

      // Store the initialization promise to avoid multiple concurrent loads
      if (!this._initializationPromise) {
        this._initializationPromise = this.loadTurndownService()
          .then(() => {
            this.setupTurndownService();
            this._isInitialized = true;
            console.info('MarkdownConverter: TurndownService initialization completed successfully');
          })
          .catch((error: Error) => {
            console.warn('MarkdownConverter: Failed to load TurndownService dynamically, trying alternative methods:', error.message);
            
            // Try alternative loading strategy
            return this.tryAlternativeLoading()
              .then(() => {
                this.setupTurndownService();
                this._isInitialized = true;
                console.info('MarkdownConverter: TurndownService loaded via alternative method');
              })
              .catch((altError: Error) => {
                console.warn('MarkdownConverter: All loading methods failed, using fallback conversion:', altError.message);
                this.turndownService = null;
                this._isInitialized = true; // Mark as initialized even with fallback
              });
          });
      }
      return;
    }

    // TurndownService is already available
    this.setupTurndownService();
    this._isInitialized = true;
    console.info('MarkdownConverter: TurndownService initialized from existing global');
  }

  private async tryAlternativeLoading(): Promise<void> {
    return new Promise((resolve, reject) => {
      // Try to request the library content via message passing
      if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.sendMessage) {
        console.log('MarkdownConverter: Trying alternative loading via messaging');
        
        chrome.runtime.sendMessage(
          { type: 'GET_TURNDOWN_LIBRARY' },
          (response) => {
            if (chrome.runtime.lastError) {
              reject(new Error(`Message passing failed: ${chrome.runtime.lastError.message}`));
              return;
            }
            
            if (response && response.success && response.content) {
              try {
                // Execute the library code in global context
                const script = document.createElement('script');
                script.textContent = response.content;
                script.type = 'text/javascript';
                
                document.head.appendChild(script);
                
                setTimeout(() => {
                  if (window.TurndownService) {
                    console.info('MarkdownConverter: TurndownService loaded via message passing');
                    resolve();
                  } else {
                    reject(new Error('TurndownService not available after alternative loading'));
                  }
                }, 100);
              } catch (error) {
                reject(new Error(`Failed to execute library content: ${error}`));
              }
            } else {
              reject(new Error('Invalid response from background script'));
            }
          }
        );
        
        // Timeout for message passing
        setTimeout(() => {
          reject(new Error('Alternative loading timed out'));
        }, 3000);
      } else {
        reject(new Error('Chrome runtime messaging not available'));
      }
    });
  }private async loadTurndownService(): Promise<void> {
    return new Promise((resolve, reject) => {
      // Check if already loaded
      if (window.TurndownService) {
        resolve();
        return;
      }

      console.log('MarkdownConverter: Attempting to load TurndownService dynamically');

      // Verify we're in the right context for chrome.runtime
      if (typeof chrome === 'undefined' || !chrome.runtime) {
        console.warn('MarkdownConverter: Chrome runtime not available, cannot load TurndownService');
        reject(new Error('Chrome runtime not available'));
        return;
      }

      // Ensure DOM is ready before injecting script
      const injectScript = () => {
        try {
          const script = document.createElement('script');
          const scriptUrl = chrome.runtime.getURL('libs/turndown.min.js');
          
          console.log('MarkdownConverter: Loading TurndownService from:', scriptUrl);
          
          script.src = scriptUrl;
          script.type = 'text/javascript';
          script.async = true;
          
          let resolved = false;
          
          script.onload = () => {
            if (resolved) return;
            
            // Give a small delay for the script to fully initialize
            setTimeout(() => {
              if (window.TurndownService) {
                console.info('MarkdownConverter: TurndownService loaded successfully via dynamic injection');
                resolved = true;
                resolve();
              } else {
                console.warn('MarkdownConverter: TurndownService script loaded but constructor not available');
                resolved = true;
                reject(new Error('TurndownService not available after loading script'));
              }
            }, 100);
          };
          
          script.onerror = (error) => {
            if (resolved) return;
            console.error('MarkdownConverter: Failed to load TurndownService script:', error);
            resolved = true;
            reject(new Error('Failed to load TurndownService script'));
          };

          // Set a timeout as fallback
          setTimeout(() => {
            if (!resolved) {
              console.warn('MarkdownConverter: TurndownService loading timed out');
              resolved = true;
              reject(new Error('TurndownService loading timed out'));
            }
          }, 5000);

          // Add to document with error handling
          const targetElement = document.head || document.documentElement;
          if (targetElement) {
            targetElement.appendChild(script);
          } else {
            resolved = true;
            reject(new Error('No suitable element found to inject script'));
          }
        } catch (error) {
          console.error('MarkdownConverter: Exception while creating script element:', error);
          reject(error);
        }
      };

      // Check if DOM is ready
      if (document.readyState === 'loading') {
        // DOM is still loading, wait for it
        console.log('MarkdownConverter: Waiting for DOM to be ready before loading TurndownService');
        const onDOMReady = () => {
          document.removeEventListener('DOMContentLoaded', onDOMReady);
          setTimeout(injectScript, 100); // Small delay after DOM ready
        };
        document.addEventListener('DOMContentLoaded', onDOMReady);
      } else {
        // DOM is already ready
        injectScript();
      }
    });
  }

  private setupTurndownService(): void {
    const TurndownService = window.TurndownService;
    if (!TurndownService) {
      this.turndownService = null;
      return;
    }

    console.info('MarkdownConverter: Initializing TurndownService with enhanced rules');

    // Initialize Turndown service with enhanced custom rules
    this.turndownService = new TurndownService({
      headingStyle: 'atx',
      bulletListMarker: '-',
      codeBlockStyle: 'fenced',
      emDelimiter: '*',
      strongDelimiter: '**',
      linkStyle: 'inlined',
      linkReferenceStyle: 'full',
      preformattedCode: true,
      blankReplacement: function (content: string, node: any): string {
        return node.isBlock ? '\n\n' : '';
      },
      keepReplacement: function (content: string, node: any): string {
        return node.isBlock ? '\n\n' + node.outerHTML + '\n\n' : node.outerHTML;
      },
    });

    this.addCustomTurndownRules();
  }

  private addCustomTurndownRules(): void {
    if (!this.turndownService) return;

    // Enhanced table rule with better formatting
    this.turndownService.addRule('enhancedTable', {
      filter: 'table',
      replacement: (content: string, node: any): string => {
        return '\n\n' + content + '\n\n';
      },
    });

    // Table cell rule
    this.turndownService.addRule('tableCell', {
      filter: ['th', 'td'],
      replacement: (content: string, node: any): string => {
        const tag = node.nodeName.toLowerCase();
        const isHeader = tag === 'th';
        let cellContent = content.trim().replace(/\n/g, ' ').replace(/\|/g, '\\|');

        if (!cellContent) cellContent = ' ';

        return '| ' + cellContent + ' ';
      },
    });

    // Table row rule with header detection
    this.turndownService.addRule('tableRow', {
      filter: 'tr',
      replacement: (content: string, node: any): string => {
        const hasHeaders = node.querySelectorAll('th').length > 0;
        let row = content + '|\n';

        if (hasHeaders) {
          const headerSeparator = content.replace(/[^|]/g, '').replace(/\|/g, '|---') + '|\n';
          row += headerSeparator;
        }

        return row;
      },
    });

    // Enhanced blockquote rule
    this.turndownService.addRule('enhancedBlockquote', {
      filter: 'blockquote',
      replacement: (content: string): string => {
        const lines = content.trim().split('\n');
        const quotedLines = lines.map(line => '> ' + line);
        return '\n\n' + quotedLines.join('\n') + '\n\n';
      },
    });

    // Code block rule with language detection
    this.turndownService.addRule('enhancedCodeBlock', {
      filter: (node: any): boolean => {
        return node.nodeName === 'PRE' && node.firstChild && node.firstChild.nodeName === 'CODE';
      },
      replacement: (content: string, node: any): string => {
        const codeElement = node.firstChild;
        const language = this.extractLanguageFromClass(codeElement.className);
        const code = codeElement.textContent || content;

        return '\n\n```' + language + '\n' + code + '\n```\n\n';
      },
    });

    // Inline code rule
    this.turndownService.addRule('enhancedInlineCode', {
      filter: (node: any): boolean => {
        return node.nodeName === 'CODE' && (!node.parentNode || node.parentNode.nodeName !== 'PRE');
      },
      replacement: (content: string): string => {
        return '`' + content + '`';
      },
    });

    // Image rule with alt text and title preservation
    this.turndownService.addRule('enhancedImage', {
      filter: 'img',
      replacement: (content: string, node: any): string => {
        const alt = node.getAttribute('alt') || '';
        const src = node.getAttribute('src') || '';
        const title = node.getAttribute('title');

        if (!src) return '';

        let markdown = '![' + alt + '](' + src;
        if (title) {
          markdown += ' "' + title + '"';
        }
        markdown += ')';

        return markdown;
      },
    });

    // Enhanced link rule with title preservation
    this.turndownService.addRule('enhancedLink', {
      filter: 'a',
      replacement: (content: string, node: any): string => {
        const href = node.getAttribute('href');
        const title = node.getAttribute('title');

        if (!href) return content;

        let markdown = '[' + content + '](' + href;
        if (title) {
          markdown += ' "' + title + '"';
        }
        markdown += ')';

        return markdown;
      },
    });

    // Callout/Note box rule
    this.turndownService.addRule('callouts', {
      filter: (node: any): boolean => {
        return this.semanticSelectors.callouts.some(
          selector => node.matches && node.matches(selector)
        );
      },
      replacement: (content: string, node: any): string => {
        const type = this.getCalloutType(node);
        return '\n\n> **' + type + ':** ' + content.trim() + '\n\n';
      },
    });

    // Highlight rule
    this.turndownService.addRule('highlights', {
      filter: (node: any): boolean => {
        return this.semanticSelectors.highlights.some(
          selector => node.matches && node.matches(selector)
        );
      },
      replacement: (content: string): string => {
        return '==' + content + '==';
      },
    });

    // Figure and caption rule
    this.turndownService.addRule('figureWithCaption', {
      filter: 'figure',
      replacement: (content: string, node: any): string => {
        const img = node.querySelector('img');
        const caption = node.querySelector('figcaption');

        if (!img) return content;

        const alt = img.getAttribute('alt') || '';
        const src = img.getAttribute('src') || '';
        const captionText = caption ? caption.textContent?.trim() : '';

        let markdown = '\n\n![' + alt + '](' + src + ')';
        if (captionText) {
          markdown += '\n*' + captionText + '*';
        }
        markdown += '\n\n';

        return markdown;
      },
    }); // Line break rule
    this.turndownService.addRule('lineBreak', {
      filter: 'br',
      replacement: (): string => '  \n',
    });

    // Horizontal rule
    this.turndownService.addRule('horizontalRule', {
      filter: 'hr',
      replacement: (): string => '\n\n---\n\n',
    });
  }
  /**
   * Ensures that the MarkdownConverter is fully initialized before proceeding with conversion
   */
  private async ensureInitialized(): Promise<void> {
    if (this._isInitialized) {
      return;
    }

    console.log('MarkdownConverter: Waiting for initialization to complete...');

    if (this._initializationPromise) {
      try {
        await this._initializationPromise;
        console.log('MarkdownConverter: Initialization completed via promise');
        return;
      } catch (error) {
        console.warn('MarkdownConverter: Initialization promise failed:', error);
        // Continue with fallback
      }
    }

    // If no initialization promise exists and not initialized, something went wrong
    console.warn(
      'MarkdownConverter: Initialization was not properly started, attempting to initialize now'
    );
    
    try {
      this.initializeTurndown();

      if (this._initializationPromise) {
        await this._initializationPromise;
        console.log('MarkdownConverter: Late initialization completed');
      }
    } catch (error) {
      console.error('MarkdownConverter: Late initialization failed:', error);
      // Mark as initialized with fallback
      this._isInitialized = true;
    }
  }

  async convertToMarkdown(
    html: string,
    metadata: IDocumentMetadata,
    options: IConversionOptions = {}
  ): Promise<IConversionResult> {
    try {
      console.log('MarkdownConverter: Starting conversion');

      // Ensure initialization is complete before proceeding
      await this.ensureInitialized();

      // Preprocess HTML for better conversion
      const preprocessedHtml = this.preprocessHtml(html, options);

      // Convert to markdown
      let markdown: string;
      if (this.turndownService) {
        console.log('MarkdownConverter: Using TurndownService for conversion');
        markdown = this.turndownService.turndown(preprocessedHtml);
      } else {
        console.log('MarkdownConverter: Using enhanced fallback conversion');
        markdown = this.fallbackConversion(preprocessedHtml);
      }

      // Post-process markdown
      markdown = this.postprocessMarkdown(markdown, options);

      // Extract images
      const images = this.extractImages(html);

      // Generate frontmatter if requested
      const frontmatter = options.generateFrontmatter ? this.generateFrontmatter(metadata) : '';

      // Calculate word count
      const wordCount = this.countWords(markdown);

      console.log('MarkdownConverter: Conversion complete');

      return {
        markdown,
        frontmatter,
        metadata: {
          ...metadata,
          wordCount,
          estimatedReadingTime: Math.ceil(wordCount / 225),
        },
        images,
        wordCount,
      };
    } catch (error) {
      console.error('MarkdownConverter: Conversion failed:', error);
      throw error;
    }
  }

  private preprocessHtml(html: string, options: IConversionOptions): string {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = html;

    // Remove unwanted elements
    this.removeUnwantedElements(tempDiv);

    // Normalize whitespace
    this.normalizeWhitespace(tempDiv);

    // Enhance semantic structure
    this.enhanceSemanticStructure(tempDiv);

    return tempDiv.innerHTML;
  }

  private removeUnwantedElements(element: Element): void {
    const unwantedSelectors = [
      'script',
      'style',
      'noscript',
      '[style*="display: none"]',
      '[style*="visibility: hidden"]',
      '.screen-reader-text',
      '.visually-hidden',
      '.sr-only',
      'iframe[src*="ads"]',
      'iframe[src*="advertisement"]',
    ];

    const unwanted = element.querySelectorAll(unwantedSelectors.join(','));
    unwanted.forEach(el => el.remove());
  }

  private normalizeWhitespace(element: Element): void {
    const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT);

    const textNodes: Text[] = [];
    let node;
    while ((node = walker.nextNode())) {
      textNodes.push(node as Text);
    }

    textNodes.forEach(textNode => {
      if (textNode.textContent) {
        // Normalize whitespace but preserve intentional line breaks
        textNode.textContent = textNode.textContent
          .replace(/[ \t]+/g, ' ')
          .replace(/\n\s*\n/g, '\n\n');
      }
    });
  }

  private enhanceSemanticStructure(element: Element): void {
    // Convert div elements with specific classes to semantic elements
    const divs = element.querySelectorAll('div');

    divs.forEach(div => {
      const className = div.className.toLowerCase();

      if (className.includes('quote') || className.includes('blockquote')) {
        const blockquote = document.createElement('blockquote');
        blockquote.innerHTML = div.innerHTML;
        div.parentNode?.replaceChild(blockquote, div);
      } else if (className.includes('code') || className.includes('highlight')) {
        const pre = document.createElement('pre');
        const code = document.createElement('code');
        code.textContent = div.textContent || '';
        pre.appendChild(code);
        div.parentNode?.replaceChild(pre, div);
      }
    });
  }

  private postprocessMarkdown(markdown: string, options: IConversionOptions): string {
    let processed = markdown;

    // Clean up excessive line breaks
    processed = processed.replace(/\n{3,}/g, '\n\n');

    // Fix spacing around headers
    processed = processed.replace(/\n+(#{1,6})/g, '\n\n$1');
    processed = processed.replace(/(#{1,6}.*)\n+/g, '$1\n\n');

    // Fix list formatting
    processed = processed.replace(/\n+(\s*[-*+])/g, '\n$1');
    processed = processed.replace(/\n+(\s*\d+\.)/g, '\n$1');

    // Fix blockquote formatting
    processed = processed.replace(/\n+(>)/g, '\n\n$1');
    processed = processed.replace(/(>\s.*)\n+/g, '$1\n\n');

    // Fix code block formatting
    processed = processed.replace(/\n+(```)/g, '\n\n$1');
    processed = processed.replace(/(```.*?```)\n+/gs, '$1\n\n');

    // Clean up beginning and end
    processed = processed.trim();

    return processed;
  }

  private fallbackConversion(html: string): string {
    console.log('MarkdownConverter: Using fallback conversion');

    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = html;

    return this.elementToMarkdown(tempDiv);
  }

  private elementToMarkdown(element: Element): string {
    let markdown = '';

    for (const child of Array.from(element.childNodes)) {
      if (child.nodeType === Node.TEXT_NODE) {
        const text = child.textContent?.trim();
        if (text) {
          markdown += text + ' ';
        }
      } else if (child.nodeType === Node.ELEMENT_NODE) {
        const el = child as Element;
        const tagName = el.tagName.toLowerCase();

        switch (tagName) {
          case 'h1':
            markdown += '\n\n# ' + el.textContent + '\n\n';
            break;
          case 'h2':
            markdown += '\n\n## ' + el.textContent + '\n\n';
            break;
          case 'h3':
            markdown += '\n\n### ' + el.textContent + '\n\n';
            break;
          case 'h4':
            markdown += '\n\n#### ' + el.textContent + '\n\n';
            break;
          case 'h5':
            markdown += '\n\n##### ' + el.textContent + '\n\n';
            break;
          case 'h6':
            markdown += '\n\n###### ' + el.textContent + '\n\n';
            break;
          case 'p':
            markdown += '\n\n' + this.elementToMarkdown(el) + '\n\n';
            break;
          case 'br':
            markdown += '  \n';
            break;
          case 'strong':
          case 'b':
            markdown += '**' + el.textContent + '**';
            break;
          case 'em':
          case 'i':
            markdown += '*' + el.textContent + '*';
            break;
          case 'code':
            if (el.parentElement?.tagName.toLowerCase() === 'pre') {
              markdown += el.textContent;
            } else {
              markdown += '`' + el.textContent + '`';
            }
            break;
          case 'pre':
            markdown += '\n\n```\n' + el.textContent + '\n```\n\n';
            break;
          case 'blockquote':
            const quotedLines = (el.textContent || '')
              .split('\n')
              .map(line => '> ' + line.trim())
              .join('\n');
            markdown += '\n\n' + quotedLines + '\n\n';
            break;
          case 'ul':
          case 'ol':
            markdown += '\n\n' + this.listToMarkdown(el) + '\n\n';
            break;
          case 'a':
            const href = el.getAttribute('href');
            if (href) {
              markdown += '[' + el.textContent + '](' + href + ')';
            } else {
              markdown += el.textContent;
            }
            break;
          case 'img':
            const src = el.getAttribute('src');
            const alt = el.getAttribute('alt') || '';
            if (src) {
              markdown += '![' + alt + '](' + src + ')';
            }
            break;
          case 'hr':
            markdown += '\n\n---\n\n';
            break;
          default:
            markdown += this.elementToMarkdown(el);
            break;
        }
      }
    }

    return markdown;
  }

  private listToMarkdown(listElement: Element): string {
    const isOrdered = listElement.tagName.toLowerCase() === 'ol';
    let markdown = '';
    let counter = 1;

    const items = listElement.querySelectorAll(':scope > li');

    items.forEach(item => {
      const prefix = isOrdered ? `${counter}. ` : '- ';
      const content = this.elementToMarkdown(item).trim();

      markdown += prefix + content + '\n';

      if (isOrdered) counter++;
    });

    return markdown;
  }

  private extractLanguageFromClass(className: string): string {
    if (!className) return '';

    const languageMap: Record<string, string> = {
      javascript: 'javascript',
      js: 'javascript',
      typescript: 'typescript',
      ts: 'typescript',
      python: 'python',
      py: 'python',
      java: 'java',
      csharp: 'csharp',
      cs: 'csharp',
      html: 'html',
      css: 'css',
      json: 'json',
      xml: 'xml',
      sql: 'sql',
      bash: 'bash',
      shell: 'bash',
      powershell: 'powershell',
      php: 'php',
      ruby: 'ruby',
      go: 'go',
      rust: 'rust',
    };

    const classes = className.toLowerCase().split(/\s+/);

    for (const cls of classes) {
      // Check for language- prefix
      if (cls.startsWith('language-')) {
        const lang = cls.substring(9);
        return languageMap[lang] || lang;
      }

      // Check for highlight- prefix
      if (cls.startsWith('highlight-')) {
        const lang = cls.substring(10);
        return languageMap[lang] || lang;
      }

      // Check direct language match
      if (languageMap[cls]) {
        return languageMap[cls];
      }
    }

    return '';
  }

  private getCalloutType(node: Element): string {
    const className = node.className.toLowerCase();

    if (className.includes('warning') || className.includes('alert')) return 'Warning';
    if (className.includes('info') || className.includes('note')) return 'Note';
    if (className.includes('error') || className.includes('danger')) return 'Error';
    if (className.includes('success') || className.includes('tip')) return 'Tip';

    return 'Note';
  }

  private extractImages(html: string): IImageAsset[] {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = html;

    const images = tempDiv.querySelectorAll('img');

    return Array.from(images)
      .map((img, index) => ({
        originalUrl: img.src,
        localPath: '', // Will be set during image processing
        filename: this.generateImageFilename(img.src, index),
        size: 0, // Will be determined during download
        mimeType: this.getMimeTypeFromUrl(img.src),
      }))
      .filter(img => img.originalUrl && !img.originalUrl.startsWith('data:'));
  }

  private generateImageFilename(url: string, index: number): string {
    try {
      const urlObj = new URL(url);
      const pathname = urlObj.pathname;
      const filename = pathname.split('/').pop() || `image-${index}`;

      // Ensure filename has an extension
      if (!filename.includes('.')) {
        return `${filename}.jpg`;
      }

      return filename;
    } catch {
      return `image-${index}.jpg`;
    }
  }

  private getMimeTypeFromUrl(url: string): string {
    const extension = url.split('.').pop()?.toLowerCase();

    const mimeTypes: Record<string, string> = {
      jpg: 'image/jpeg',
      jpeg: 'image/jpeg',
      png: 'image/png',
      gif: 'image/gif',
      webp: 'image/webp',
      svg: 'image/svg+xml',
      bmp: 'image/bmp',
      ico: 'image/x-icon',
    };

    return mimeTypes[extension || ''] || 'image/jpeg';
  }

  private generateFrontmatter(metadata: IDocumentMetadata): string {
    const frontmatterData = {
      title: metadata.title,
      url: metadata.url,
      date: metadata.captureDate,
      tags: metadata.tags,
      ...(metadata.author && { author: metadata.author }),
      ...(metadata.wordCount && { wordCount: metadata.wordCount }),
      ...(metadata.estimatedReadingTime && { readingTime: metadata.estimatedReadingTime }),
    };

    let frontmatter = '---\n';

    Object.entries(frontmatterData).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        frontmatter += `${key}:\n`;
        value.forEach(item => {
          frontmatter += `  - ${item}\n`;
        });
      } else {
        frontmatter += `${key}: ${value}\n`;
      }
    });

    frontmatter += '---\n\n';

    return frontmatter;
  }

  private countWords(text: string): number {
    return text
      .replace(/[^\w\s]/g, ' ')
      .split(/\s+/)
      .filter(word => word.length > 0).length;
  }

  // Public utility methods
  cleanMarkdown(markdown: string): string {
    return this.postprocessMarkdown(markdown, {});
  }

  validateMarkdown(markdown: string): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Check for malformed links
    const malformedLinks = markdown.match(/\[([^\]]*)\]\([^)]*$/gm);
    if (malformedLinks) {
      errors.push(`Malformed links found: ${malformedLinks.length}`);
    }

    // Check for malformed images
    const malformedImages = markdown.match(/!\[([^\]]*)\]\([^)]*$/gm);
    if (malformedImages) {
      errors.push(`Malformed images found: ${malformedImages.length}`);
    }

    // Check for unbalanced code blocks
    const codeBlocks = markdown.match(/```/g);
    if (codeBlocks && codeBlocks.length % 2 !== 0) {
      errors.push('Unbalanced code blocks detected');
    }

    // Check for unbalanced emphasis
    const boldMatches = markdown.match(/\*\*/g);
    if (boldMatches && boldMatches.length % 2 !== 0) {
      errors.push('Unbalanced bold formatting detected');
    }

    const italicMatches = markdown.match(/(?<!\*)\*(?!\*)/g);
    if (italicMatches && italicMatches.length % 2 !== 0) {
      errors.push('Unbalanced italic formatting detected');
    }

    return {
      isValid: errors.length === 0,
      errors,
    };
  }

  getMarkdownStats(markdown: string): {
    words: number;
    characters: number;
    headings: number;
    links: number;
    images: number;
    codeBlocks: number;
  } {
    return {
      words: this.countWords(markdown),
      characters: markdown.length,
      headings: (markdown.match(/^#+\s/gm) || []).length,
      links: (markdown.match(/\[([^\]]*)\]\([^)]*\)/g) || []).length,
      images: (markdown.match(/!\[([^\]]*)\]\([^)]*\)/g) || []).length,
      codeBlocks: (markdown.match(/```/g) || []).length / 2,
    };
  }
}
