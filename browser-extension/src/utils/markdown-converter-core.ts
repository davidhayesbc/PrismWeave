// Generated by Copilot
// PrismWeave Markdown Converter Core - Shared conversion logic
// Environment-agnostic core that can be used in both browser and Node.js

import { IDocumentMetadata, IImageAsset } from '../types/index.js';

interface IConversionOptions {
  preserveFormatting?: boolean;
  includeMetadata?: boolean;
  generateFrontmatter?: boolean;
  customRules?: Record<string, unknown>;
  headingStyle?: 'atx' | 'setext';
  bulletListMarker?: '-' | '*' | '+';
  codeBlockStyle?: 'fenced' | 'indented';
  linkStyle?: 'inlined' | 'referenced';
}

interface IConversionResult {
  markdown: string;
  frontmatter: string;
  metadata: IDocumentMetadata;
  images: IImageAsset[];
  wordCount: number;
}

interface ITurndownService {
  turndown(html: string): string;
  addRule(key: string, rule: any): void;
  remove(filter: string | string[]): void;
  use(plugin: any): void;
}

interface ISemanticSelectors {
  callouts: string[];
  quotes: string[];
  highlights: string[];
  captions: string[];
  metadata: string[];
  codeElements: string[];
}

export class MarkdownConverterCore {
  protected turndownService: ITurndownService | null = null;
  protected readonly semanticSelectors: ISemanticSelectors;
  protected _isInitialized: boolean = false;

  constructor() {
    this.semanticSelectors = {
      callouts: ['.callout', '.note', '.warning', '.info', '.alert', '.notice', '[role="note"]'],
      quotes: ['blockquote', '.quote', '.pullquote', '[role="blockquote"]'],
      highlights: ['.highlight', '.featured', '.important', 'mark', '.marker'],
      captions: ['figcaption', '.caption', '.image-caption', '.photo-caption'],
      metadata: ['.byline', '.author', '.date', '.timestamp', '.published', '.updated'],
      codeElements: ['code', 'pre', '.code', '.highlight', '.syntax'],
    };
  }

  // This method should be called by environment-specific wrappers
  protected setupTurndownService(): void {
    if (!this.turndownService) {
      throw new Error('TurndownService not initialized');
    }

    // Configure basic options
    const options = {
      headingStyle: 'atx' as const,
      bulletListMarker: '-' as const,
      codeBlockStyle: 'fenced' as const,
      emDelimiter: '*',
      strongDelimiter: '**',
      linkStyle: 'inlined' as const,
      linkReferenceStyle: 'full' as const,
      preformattedCode: true,
    };

    // Apply configuration to TurndownService
    Object.assign(this.turndownService, options);

    // Remove unnecessary elements first
    this.turndownService.remove(['script', 'style', 'head', 'noscript']);

    // Add all custom rules
    this.addAllCustomRules();
  }

  private addAllCustomRules(): void {
    if (!this.turndownService) return;

    // Line number removal rule
    this.turndownService.addRule('removeLineNumbers', {
      filter: (node: any) => {
        if (node.nodeType === 1) {
          const className = (node.className || '').toLowerCase();
          const id = (node.id || '').toLowerCase();
          const lineNumberPatterns = [
            'line-number',
            'linenumber',
            'line-num',
            'linenum',
            'gutter',
            'line-gutter',
            'hljs-ln-numbers',
            'hljs-ln-line',
            'code-line-number',
          ];
          return lineNumberPatterns.some(
            pattern => className.includes(pattern) || id.includes(pattern)
          );
        }
        return false;
      },
      replacement: () => '',
    });

    // Copy button removal rule
    this.turndownService.addRule('removeCopyButtons', {
      filter: (node: any) => {
        if (node.nodeType === 1) {
          const className = (node.className || '').toLowerCase();
          const id = (node.id || '').toLowerCase();
          const text = (node.textContent || '').toLowerCase().trim();
          const copyButtonPatterns = ['copy', 'clipboard'];

          return (
            copyButtonPatterns.some(
              pattern => className.includes(pattern) || id.includes(pattern) || text === pattern
            ) &&
            (node.tagName === 'BUTTON' || className.includes('button') || className.includes('btn'))
          );
        }
        return false;
      },
      replacement: () => '',
    });

    // Navigation and UI element removal
    this.turndownService.addRule('removeNavigation', {
      filter: ['nav', '.nav', '.navbar', '.navigation', '.menu', '.header', '.footer', '.sidebar'],
      replacement: () => '',
    });

    // Advertisement removal
    this.turndownService.addRule('removeAds', {
      filter: (node: any) => {
        if (node.nodeType === 1) {
          const className = (node.className || '').toLowerCase();
          const id = (node.id || '').toLowerCase();
          const adPatterns = ['ad', 'advertisement', 'promo', 'sponsor', 'banner'];
          return adPatterns.some(pattern => className.includes(pattern) || id.includes(pattern));
        }
        return false;
      },
      replacement: () => '',
    });

    // Social media elements removal
    this.turndownService.addRule('removeSocial', {
      filter: (node: any) => {
        if (node.nodeType === 1) {
          const className = (node.className || '').toLowerCase();
          const id = (node.id || '').toLowerCase();
          const socialPatterns = [
            'social',
            'share',
            'twitter',
            'facebook',
            'linkedin',
            'pinterest',
          ];
          return socialPatterns.some(
            pattern => className.includes(pattern) || id.includes(pattern)
          );
        }
        return false;
      },
      replacement: () => '',
    });

    // Enhanced code block handling
    this.turndownService.addRule('enhancedCodeBlocks', {
      filter: (node: any) => {
        return node.nodeName === 'PRE' && node.querySelector('code');
      },
      replacement: (content: string, node: any) => {
        const codeElement = node.querySelector('code');
        if (!codeElement) return `\n\`\`\`\n${content}\n\`\`\`\n`;

        // Extract language from class
        let language = '';
        const classNames = codeElement.className || '';
        const langMatch = classNames.match(/(?:language-|lang-)([a-zA-Z0-9-_]+)/);
        if (langMatch) {
          language = langMatch[1];
        }

        // Clean content - remove line numbers and copy buttons
        const cleanContent = this.cleanCodeContent(codeElement.textContent || content);

        return `\n\`\`\`${language}\n${cleanContent}\n\`\`\`\n`;
      },
    });

    // Enhanced inline code handling
    this.turndownService.addRule('enhancedInlineCode', {
      filter: (node: any) => {
        return node.nodeName === 'CODE' && !node.closest('pre');
      },
      replacement: (content: string) => {
        return `\`${content.trim()}\``;
      },
    });

    // Image handling with alt text preservation
    this.turndownService.addRule('enhancedImages', {
      filter: 'img',
      replacement: (content: string, node: any) => {
        const alt = node.getAttribute('alt') || '';
        const src = node.getAttribute('src') || '';
        const title = node.getAttribute('title') || '';

        if (!src) return '';

        // Handle relative URLs
        const absoluteSrc = this.makeAbsoluteUrl(src);

        if (title) {
          return `![${alt}](${absoluteSrc} "${title}")`;
        }
        return `![${alt}](${absoluteSrc})`;
      },
    });

    // Table handling with proper formatting
    this.turndownService.addRule('enhancedTables', {
      filter: 'table',
      replacement: (content: string, node: any) => {
        const rows = Array.from(node.querySelectorAll('tr'));
        if (rows.length === 0) return '';

        let markdown = '\n';
        let hasHeader = false;

        rows.forEach((row: any, index: number) => {
          const cells = Array.from(row.querySelectorAll('td, th'));
          if (cells.length === 0) return;

          // Check if this row contains header cells
          const isHeaderRow = cells.some((cell: any) => cell.tagName === 'TH');
          if (isHeaderRow && !hasHeader) {
            hasHeader = true;
          }

          // Build row
          const cellContents = cells.map((cell: any) => {
            return (cell.textContent || '').trim().replace(/\|/g, '\\|');
          });

          markdown += `| ${cellContents.join(' | ')} |\n`;

          // Add separator row after header
          if (isHeaderRow && !hasHeader) {
            const separatorCells = cells.map(() => '---');
            markdown += `| ${separatorCells.join(' | ')} |\n`;
            hasHeader = true;
          }
        });

        return markdown + '\n';
      },
    });

    // List handling improvements
    this.turndownService.addRule('enhancedLists', {
      filter: ['ul', 'ol'],
      replacement: (content: string, node: any) => {
        const isOrdered = node.tagName === 'OL';
        const items = Array.from(node.children).filter((child: any) => child.tagName === 'LI');

        if (items.length === 0) return '';

        let markdown = '\n';
        items.forEach((item: any, index: number) => {
          const prefix = isOrdered ? `${index + 1}. ` : '- ';
          const itemContent = this.getListItemContent(item);
          markdown += `${prefix}${itemContent}\n`;
        });

        return markdown + '\n';
      },
    });

    // Blockquote handling
    this.turndownService.addRule('enhancedBlockquotes', {
      filter: 'blockquote',
      replacement: (content: string) => {
        const lines = content.trim().split('\n');
        const quotedLines = lines.map(line => `> ${line}`);
        return `\n${quotedLines.join('\n')}\n\n`;
      },
    });

    // Heading handling with ID preservation
    this.turndownService.addRule('enhancedHeadings', {
      filter: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],
      replacement: (content: string, node: any) => {
        const level = parseInt(node.tagName.charAt(1));
        const hashes = '#'.repeat(level);
        const id = node.getAttribute('id');

        let heading = `\n${hashes} ${content.trim()}\n\n`;

        // Add ID as anchor if present
        if (id) {
          heading = `\n${hashes} ${content.trim()} {#${id}}\n\n`;
        }

        return heading;
      },
    });

    // Link handling with title preservation
    this.turndownService.addRule('enhancedLinks', {
      filter: 'a',
      replacement: (content: string, node: any) => {
        const href = node.getAttribute('href');
        const title = node.getAttribute('title');

        if (!href) return content;

        const absoluteHref = this.makeAbsoluteUrl(href);

        if (title) {
          return `[${content}](${absoluteHref} "${title}")`;
        }
        return `[${content}](${absoluteHref})`;
      },
    });

    // Semantic content preservation
    this.turndownService.addRule('semanticContent', {
      filter: (node: any) => {
        if (node.nodeType !== 1) return false;

        const className = (node.className || '').toLowerCase();
        const semanticClasses = [
          'article',
          'main',
          'content',
          'post',
          'entry',
          'callout',
          'note',
          'warning',
          'info',
          'alert',
          'highlight',
          'important',
          'featured',
        ];

        return semanticClasses.some(cls => className.includes(cls));
      },
      replacement: (content: string, node: any) => {
        // Preserve semantic content but clean up extra whitespace
        return content.replace(/\n\s*\n\s*\n/g, '\n\n');
      },
    });
  }

  private cleanCodeContent(content: string): string {
    if (!content) return '';

    // Split into lines and clean each line
    const lines = content.split('\n');
    const cleanedLines = lines.map(line => {
      // Remove line numbers at the beginning of lines
      return line.replace(/^\s*\d+\s*/, '').replace(/^\s*\|\s*/, '');
    });

    // Remove empty lines at the beginning and end
    while (cleanedLines.length > 0 && cleanedLines[0].trim() === '') {
      cleanedLines.shift();
    }
    while (cleanedLines.length > 0 && cleanedLines[cleanedLines.length - 1].trim() === '') {
      cleanedLines.pop();
    }

    return cleanedLines.join('\n');
  }

  private makeAbsoluteUrl(url: string): string {
    if (!url) return '';

    // Already absolute
    if (url.startsWith('http://') || url.startsWith('https://') || url.startsWith('//')) {
      return url;
    }

    // Get base URL from current page (browser context) or use empty string (Node.js context)
    const baseUrl = typeof window !== 'undefined' ? window.location.origin : '';

    if (url.startsWith('/')) {
      return `${baseUrl}${url}`;
    }

    // Relative URL - handle with base URL if available
    if (baseUrl) {
      return `${baseUrl}/${url}`;
    }

    return url;
  }

  private getListItemContent(item: any): string {
    if (!item) return '';

    // Get text content and clean up
    let content = '';
    for (const child of item.childNodes) {
      if (child.nodeType === 3) {
        // Text node
        content += child.textContent;
      } else if (child.nodeType === 1) {
        // Element node
        if (child.tagName === 'UL' || child.tagName === 'OL') {
          // Nested list - handle recursively
          const nestedList = this.turndownService?.turndown(child.outerHTML) || '';
          content +=
            '\n' +
            nestedList
              .split('\n')
              .map(line => `  ${line}`)
              .join('\n');
        } else {
          content += child.textContent;
        }
      }
    }

    return content.trim();
  }

  public convertToMarkdown(html: string, options: IConversionOptions = {}): IConversionResult {
    if (!this._isInitialized || !this.turndownService) {
      throw new Error('MarkdownConverter not properly initialized');
    }

    try {
      // Pre-process HTML
      const cleanedHtml = this.preprocessHtml(html);

      // Convert to markdown
      const markdown = this.turndownService.turndown(cleanedHtml);

      // Post-process markdown
      const processedMarkdown = this.postprocessMarkdown(markdown);

      // Extract metadata
      const metadata = this.extractMetadata(html);

      // Generate frontmatter if requested
      const frontmatter = options.generateFrontmatter ? this.generateFrontmatter(metadata) : '';

      // Extract images
      const images = this.extractImages(html);

      // Calculate word count
      const wordCount = this.calculateWordCount(processedMarkdown);

      return {
        markdown: processedMarkdown,
        frontmatter,
        metadata,
        images,
        wordCount,
      };
    } catch (error) {
      console.error('MarkdownConverter: Conversion failed:', error);
      throw error;
    }
  }

  private preprocessHtml(html: string): string {
    // Create a temporary DOM for processing
    let doc: Document;

    if (typeof document !== 'undefined') {
      // Browser environment
      const parser = new DOMParser();
      doc = parser.parseFromString(html, 'text/html');
    } else {
      // Node.js environment - this should be handled by the wrapper
      throw new Error('Document parsing not available in this environment');
    }

    // Remove unwanted elements
    const unwantedSelectors = [
      'script',
      'style',
      'noscript',
      'iframe',
      '.advertisement',
      '.ad',
      '.promo',
      '.sponsor',
      '.social-share',
      '.social-buttons',
      '.share-buttons',
      '.newsletter-signup',
      '.popup',
      '.modal',
      '.cookie-notice',
      '.gdpr-notice',
      '.line-numbers',
      '.line-number',
      '.gutter',
      'button[class*="copy"]',
      'button[class*="clipboard"]',
    ];

    unwantedSelectors.forEach(selector => {
      const elements = doc.querySelectorAll(selector);
      elements.forEach(el => el.remove());
    });

    return doc.body.innerHTML;
  }

  private postprocessMarkdown(markdown: string): string {
    // Clean up excessive whitespace
    let processed = markdown
      .replace(/\n\s*\n\s*\n/g, '\n\n') // Remove triple+ newlines
      .replace(/^\s+|\s+$/g, '') // Trim start/end
      .replace(/\t/g, '    '); // Convert tabs to spaces

    // Fix common formatting issues
    processed = processed
      .replace(/\*\*\s+/g, '**') // Fix bold formatting
      .replace(/\s+\*\*/g, '**')
      .replace(/\*\s+/g, '*') // Fix italic formatting
      .replace(/\s+\*/g, '*')
      .replace(/`\s+/g, '`') // Fix inline code formatting
      .replace(/\s+`/g, '`');

    return processed;
  }

  private extractMetadata(html: string): IDocumentMetadata {
    // This would need document parsing - should be implemented in wrapper
    return {
      title: '',
      url: '',
      captureDate: new Date().toISOString(),
      tags: [],
      author: '',
      wordCount: 0,
      estimatedReadingTime: 0,
    };
  }

  private generateFrontmatter(metadata: IDocumentMetadata): string {
    const entries = Object.entries(metadata)
      .filter(([, value]) => value && value !== '')
      .map(([key, value]) => {
        if (Array.isArray(value)) {
          return `${key}: [${value.map(v => `"${v}"`).join(', ')}]`;
        }
        return `${key}: "${value}"`;
      });

    if (entries.length === 0) return '';

    return `---\n${entries.join('\n')}\n---\n\n`;
  }

  private extractImages(html: string): IImageAsset[] {
    // This would need document parsing - should be implemented in wrapper
    return [];
  }

  private calculateWordCount(markdown: string): number {
    // Remove markdown syntax and count words
    const plainText = markdown
      .replace(/```[\s\S]*?```/g, '') // Remove code blocks
      .replace(/`[^`]*`/g, '') // Remove inline code
      .replace(/[#*`_~\[\]()]/g, '') // Remove markdown syntax
      .replace(/\s+/g, ' ') // Normalize whitespace
      .trim();

    return plainText ? plainText.split(' ').length : 0;
  }

  get isInitialized(): boolean {
    return this._isInitialized;
  }
}

export { IConversionOptions, IConversionResult };
