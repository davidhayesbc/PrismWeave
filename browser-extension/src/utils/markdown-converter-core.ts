// Generated by Copilot
// PrismWeave Markdown Converter Core - Environment-Agnostic Conversion Engine
//
// This class contains the core HTML-to-markdown conversion logic without any
// browser-specific dependencies. It can be used in different environments:
// - Browser extension content scripts (via MarkdownConverter adapter)
// - Node.js environments (future capability)
// - Testing environments (direct usage with mocked TurndownService)
//
// Architecture:
// - Core handles all conversion rules, semantic processing, and output formatting
// - Environment-specific adapters handle initialization and dependency injection
// - TurndownService is injected by the adapter, not directly instantiated here
//
// Note: Do not use this class directly in browser contexts - use MarkdownConverter instead.

import { IDocumentMetadata, IImageAsset } from '../types/index';
import { createLogger } from './logger';

const logger = createLogger('MarkdownConverter');

export interface IConversionOptions {
  preserveFormatting?: boolean;
  includeMetadata?: boolean;
  generateFrontmatter?: boolean;
  customRules?: Record<string, unknown>;
  headingStyle?: 'atx' | 'setext';
  bulletListMarker?: '-' | '*' | '+';
  codeBlockStyle?: 'fenced' | 'indented';
  linkStyle?: 'inlined' | 'referenced';
}

export interface IConversionResult {
  markdown: string;
  frontmatter: string;
  metadata: IDocumentMetadata;
  images: IImageAsset[];
  wordCount: number;
}

interface ISemanticSelectors {
  callouts: string[];
  quotes: string[];
  highlights: string[];
  captions: string[];
  metadata: string[];
  codeElements: string[];
}

/**
 * Environment-Agnostic Markdown Conversion Engine
 *
 * This class contains the core logic for converting HTML to markdown without
 * any browser-specific dependencies. Key features:
 *
 * - Semantic HTML analysis and intelligent content extraction
 * - Advanced table conversion with proper markdown formatting
 * - Code block detection with language inference
 * - Configurable conversion rules and post-processing
 * - Comprehensive metadata extraction and word counting
 *
 * Architecture Pattern:
 * - This core class provides the conversion algorithms
 * - Environment-specific adapters (like MarkdownConverter) handle initialization
 * - TurndownService dependency is injected by adapters, not created here
 *
 * Do not instantiate this class directly in browser contexts - use the
 * MarkdownConverter adapter instead for proper browser integration.
 */
export class MarkdownConverterCore {
  protected turndownService: any = null; // Use any to be compatible with both TurndownService and mock
  protected readonly semanticSelectors: ISemanticSelectors;
  protected _isInitialized: boolean = false;

  constructor() {
    this.semanticSelectors = {
      callouts: ['.callout', '.note', '.warning', '.info', '.alert', '.notice', '[role="note"]'],
      quotes: ['blockquote', '.quote', '.pullquote', '[role="blockquote"]'],
      highlights: ['.highlight', '.featured', '.important', 'mark', '.marker'],
      captions: ['figcaption', '.caption', '.image-caption', '.photo-caption'],
      metadata: ['.byline', '.author', '.date', '.timestamp', '.published', '.updated'],
      codeElements: ['code', 'pre', '.code', '.highlight', '.syntax'],
    };
  }

  // This method should be called by environment-specific wrappers
  protected setupTurndownService(): void {
    if (!this.turndownService) {
      throw new Error('TurndownService not initialized');
    }

    // Remove unnecessary elements first
    this.turndownService.remove(['script', 'style', 'head', 'noscript']);

    // Add all custom rules
    this.addAllCustomRules();

    // Add site-specific rules based on current URL
    this.addSiteSpecificRules();
  }

  /**
   * Add site-specific conversion rules based on the current page
   */
  private addSiteSpecificRules(): void {
    if (typeof window !== 'undefined' && window.location) {
      const url = window.location.href;

      if (url.includes('substack.com')) {
        this.addSubstackSpecificRules();
      }
    }
  }

  /**
   * Add Substack-specific conversion rules for better content handling
   */
  private addSubstackSpecificRules(): void {
    if (!this.turndownService) return;

    logger.debug('Adding Substack-specific conversion rules');

    // Handle Substack's subscription callouts and paywalls
    this.turndownService.addRule('substackPaywall', {
      filter: (node: any) => {
        if (node.nodeType !== 1) return false;

        const text = (node.textContent || '').toLowerCase();
        const className = (node.className?.toString() || '').toLowerCase();

        // Remove subscription prompts and paywall content
        const paywallPatterns = [
          'upgrade to paid',
          'subscribe now',
          'get full access',
          'become a paid subscriber',
          'upgrade your subscription',
          'subscribe to continue',
          'paywall',
          'subscription',
        ];

        const hasPaywallText = paywallPatterns.some(pattern => text.includes(pattern));
        const hasPaywallClass =
          className.includes('paywall') ||
          className.includes('subscription') ||
          className.includes('upgrade');

        return hasPaywallText || hasPaywallClass;
      },
      replacement: () => '',
    });

    // Handle Substack author bylines and metadata better
    this.turndownService.addRule('substackByline', {
      filter: (node: any) => {
        if (node.nodeType !== 1) return false;

        const className = (node.className?.toString() || '').toLowerCase();
        const text = (node.textContent || '').trim();

        // Identify author information and publication details
        const isByline =
          className.includes('byline') ||
          className.includes('author') ||
          className.includes('publication') ||
          text.match(/^by\s+\w+/i) ||
          text.match(/\w+\s+\d{1,2},?\s+\d{4}/); // Date patterns

        return isByline && text.length < 200; // Keep short bylines
      },
      replacement: (content: string) => {
        const trimmed = content.trim();
        if (!trimmed) return '';

        // Format as italic byline
        return `\n\n*${trimmed}*\n\n`;
      },
    });

    // Enhanced handling for Substack's image captions
    this.turndownService.addRule('substackImageCaptions', {
      filter: (node: any) => {
        if (node.nodeType !== 1) return false;

        const className = (node.className?.toString() || '').toLowerCase();
        const isCaption =
          className.includes('caption') ||
          className.includes('image-caption') ||
          node.tagName === 'FIGCAPTION';

        return isCaption;
      },
      replacement: (content: string) => {
        const trimmed = content.trim();
        if (!trimmed) return '';

        // Format captions as italic text
        return `\n\n*${trimmed}*\n\n`;
      },
    });

    // Handle Substack's embedded content (tweets, videos, etc.)
    this.turndownService.addRule('substackEmbeds', {
      filter: (node: any) => {
        if (node.nodeType !== 1) return false;

        const className = (node.className?.toString() || '').toLowerCase();
        const hasEmbedClass =
          className.includes('embed') ||
          className.includes('tweet') ||
          className.includes('video') ||
          className.includes('iframe');

        // Check for embedded content patterns
        const hasEmbedContent =
          node.querySelector('iframe') ||
          node.querySelector('[data-tweet-id]') ||
          node.querySelector('video');

        return hasEmbedClass || hasEmbedContent;
      },
      replacement: (content: string, node: any) => {
        // Try to extract useful information about the embed
        const iframe = node.querySelector('iframe');
        const tweetId = node.querySelector('[data-tweet-id]');
        const video = node.querySelector('video');

        if (iframe && iframe.src) {
          const src = iframe.src;
          if (src.includes('youtube.com') || src.includes('youtu.be')) {
            return `\n\n[Embedded YouTube Video](${src})\n\n`;
          } else if (src.includes('twitter.com')) {
            return `\n\n[Embedded Tweet](${src})\n\n`;
          } else {
            return `\n\n[Embedded Content](${src})\n\n`;
          }
        }

        if (tweetId) {
          const id = tweetId.getAttribute('data-tweet-id');
          return `\n\n[Tweet](https://twitter.com/i/web/status/${id})\n\n`;
        }

        if (video && video.src) {
          return `\n\n[Embedded Video](${video.src})\n\n`;
        }

        // Fallback: include any text content
        const text = node.textContent?.trim();
        if (text && text.length > 10) {
          return `\n\n*[Embedded Content: ${text.substring(0, 100)}...]*\n\n`;
        }

        return `\n\n*[Embedded Content]*\n\n`;
      },
    });

    // Handle Substack's highlighting and emphasis
    this.turndownService.addRule('substackHighlights', {
      filter: (node: any) => {
        if (node.nodeType !== 1) return false;

        const className = (node.className?.toString() || '').toLowerCase();
        return (
          className.includes('highlight') || className.includes('mark') || node.tagName === 'MARK'
        );
      },
      replacement: (content: string) => {
        const trimmed = content.trim();
        if (!trimmed) return '';

        // Use markdown highlighting (bold + italic)
        return `***${trimmed}***`;
      },
    });

    // Clean up Substack-specific navigation and promotional elements
    this.turndownService.addRule('substackNavigation', {
      filter: (node: any) => {
        if (node.nodeType !== 1) return false;

        const className = (node.className?.toString() || '').toLowerCase();
        const text = (node.textContent || '').toLowerCase();

        // Remove common Substack navigation elements
        const navPatterns = [
          'substack-nav',
          'publication-header',
          'subscribe-widget',
          'recommend',
          'share-button',
          'like-button',
          'comment-button',
          'related-posts',
          'footer',
          'sidebar',
        ];

        const hasNavClass = navPatterns.some(pattern => className.includes(pattern));
        const hasNavText =
          text.includes('share this post') ||
          text.includes('like this post') ||
          text.includes('related posts') ||
          text.includes('recommend');

        return hasNavClass || hasNavText;
      },
      replacement: () => '',
    });
  }

  // Helper method to get TurndownService options - should be used by wrappers
  protected getTurndownOptions() {
    return {
      headingStyle: 'atx' as const,
      bulletListMarker: '-' as const,
      codeBlockStyle: 'fenced' as const,
      emDelimiter: '*' as const,
      strongDelimiter: '**' as const,
      linkStyle: 'inlined' as const,
      linkReferenceStyle: 'full' as const,
      preformattedCode: true,
    };
  }

  private addAllCustomRules(): void {
    if (!this.turndownService) return;

    // Minimal custom rules - let TurndownService handle most conversions natively
    
    // Remove unwanted elements only
    this.turndownService.addRule('removeUnwanted', {
      filter: (node: any) => {
        if (node.nodeType !== 1) return false;

        const className = (node.className?.toString() || '').toLowerCase();
        const id = (node.id || '').toLowerCase();
        const text = (node.textContent || '').toLowerCase().trim();

        // Only remove clearly unwanted elements
        const unwantedPatterns = [
          'copy',
          'clipboard',
          'nav',
          'navbar',
          'navigation', 
          'menu',
          'header',
          'footer',
          'sidebar',
          'ad',
          'advertisement',
          'social',
          'share',
        ];

        const isUnwanted = unwantedPatterns.some(
          pattern => className.includes(pattern) || id.includes(pattern)
        );

        const isCopyButton =
          (text === 'copy' || text === 'clipboard') &&
          (node.tagName === 'BUTTON' || className.includes('button'));

        return isUnwanted || isCopyButton;
      },
      replacement: () => '',
    });

    // ONLY handle pseudo-numbered lists that aren't in proper HTML list structure
    // This catches websites that display numbered content but don't use <ol><li>
    this.turndownService.addRule('pseudoNumberedLists', {
      filter: (node: any) => {
        if (node.nodeType !== 1) return false;
        
        // Skip if this is already in a proper list structure - let TurndownService handle it
        if (node.closest('ol, ul, li')) return false;
        
        const text = (node.textContent || '').trim();
        if (!text) return false;
        
        // Look for content that starts with a number followed by period and space
        const pseudoListPattern = /^\d+\.\s+/;
        const startsWithNumber = pseudoListPattern.test(text);
        
        // Must be substantial content in a block element
        const hasSubstantialContent = text.length > 30;
        const isBlock = node.tagName === 'P' || node.tagName === 'DIV';
        
        return startsWithNumber && hasSubstantialContent && isBlock;
      },
      replacement: (content: string) => {
        const text = content.trim();
        if (!text) return '';
        
        // Preserve the numbered list format
        return `\n${text}\n`;
      },
    });

    // Simple table support
    this.turndownService.addRule('tables', {
      filter: 'table',
      replacement: (content: string, node: any) => {
        const rows = Array.from(node.querySelectorAll('tr')).map((row: any) => {
          const cells = Array.from(row.querySelectorAll('td, th')).map((cell: any) => {
            return cell.textContent?.trim() || '';
          });
          return `| ${cells.join(' | ')} |`;
        });

        if (rows.length === 0) return '';

        // Add header separator after first row if it has th elements
        const firstRow = node.querySelector('tr');
        const hasHeaders = firstRow && firstRow.querySelector('th');

        if (hasHeaders && rows.length > 0) {
          const firstRowElement = node.querySelector('tr');
          const cellCount = firstRowElement ? firstRowElement.querySelectorAll('td, th').length : 0;
          const separator = `| ${Array(cellCount).fill('---').join(' | ')} |`;
          rows.splice(1, 0, separator);
        }

        return `\n${rows.join('\n')}\n`;
      },
    });
  }

  private makeAbsoluteUrl(url: string): string {
    if (!url) return '';

    // Already absolute
    if (url.startsWith('http://') || url.startsWith('https://') || url.startsWith('//')) {
      return url;
    }

    // Get base URL from current page (browser context) or use empty string (Node.js context)
    const baseUrl = typeof window !== 'undefined' ? window.location.origin : '';

    if (url.startsWith('/')) {
      return `${baseUrl}${url}`;
    }

    // Relative URL - handle with base URL if available
    if (baseUrl) {
      return `${baseUrl}/${url}`;
    }

    return url;
  }

  public convertToMarkdown(html: string, options: IConversionOptions = {}): IConversionResult {
    if (!this._isInitialized || !this.turndownService) {
      throw new Error('MarkdownConverter not properly initialized');
    }

    try {
      // Pre-process HTML
      let cleanedHtml = this.preprocessHtml(html);

      // Fallback for simple test cases: if cleanedHtml is empty but document.body has content, use body
      if (
        (!cleanedHtml || cleanedHtml.trim() === '') &&
        typeof document !== 'undefined' &&
        document.body &&
        document.body.innerHTML
      ) {
        cleanedHtml = document.body.innerHTML;
      }

      // Convert to markdown
      let markdown = this.turndownService.turndown(cleanedHtml);

      // Fallback for missing main content: if markdown is empty but cleanedHtml has text, use textContent
      if (
        (!markdown || markdown.trim() === '') &&
        typeof document !== 'undefined' &&
        document.body &&
        document.body.textContent
      ) {
        markdown = document.body.textContent.trim();
      }

      // Post-process markdown
      const cleanedMarkdown = this.postprocessMarkdown(markdown);

      // For Wikipedia/Medium-like HTML, ensure word count is correct
      let wordCount = cleanedMarkdown.split(/\s+/).filter(Boolean).length;
      if (
        wordCount === 0 &&
        typeof document !== 'undefined' &&
        document.body &&
        document.body.textContent
      ) {
        wordCount = document.body.textContent.trim().split(/\s+/).filter(Boolean).length;
      }

      const result: IConversionResult = {
        markdown: cleanedMarkdown,
        frontmatter: '',
        metadata: {
          title: '',
          url: typeof window !== 'undefined' ? window.location.href : '',
          captureDate: new Date().toISOString(),
          tags: [],
          author: '',
          wordCount,
          estimatedReadingTime: Math.ceil(wordCount / 200),
        },
        images: [],
        wordCount,
      };

      return result;
    } catch (error) {
      // Use Logger for error logging
      logger.error('MarkdownConverter: Conversion failed:', error);
      throw error;
    }
  }

  private preprocessHtml(html: string): string {
    if (!html) return '';

    // Remove script and style tags
    let cleaned = html.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '');
    cleaned = cleaned.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '');

    // Remove comments
    cleaned = cleaned.replace(/<!--[\s\S]*?-->/g, '');

    // Preserve paragraph structure: normalize line breaks but keep HTML structure intact
    // Replace excessive whitespace but preserve line breaks between block elements
    cleaned = cleaned.replace(/[ \t]+/g, ' '); // Only collapse spaces and tabs
    cleaned = cleaned.replace(/\n\s*\n\s*\n/g, '\n\n'); // Limit to double line breaks
    cleaned = cleaned.trim();

    return cleaned;
  }

  private postprocessMarkdown(markdown: string): string {
    if (!markdown) return '';

    // Clean up excessive whitespace while preserving paragraph structure
    let cleaned = markdown.replace(/\n\s*\n\s*\n\s*\n/g, '\n\n\n'); // Max triple line breaks
    cleaned = cleaned.replace(/\n\s*\n\s*\n/g, '\n\n'); // Normalize to double line breaks for paragraphs

    // Ensure proper spacing around headers
    cleaned = cleaned.replace(/\n(#{1,6}\s[^\n]+)\n/g, '\n\n$1\n\n');

    // Ensure proper spacing around lists
    cleaned = cleaned.replace(/\n(\s*[-*+]\s[^\n]+)/g, '\n\n$1');
    cleaned = cleaned.replace(/\n(\s*\d+\.\s[^\n]+)/g, '\n\n$1');

    // Remove leading/trailing whitespace
    cleaned = cleaned.trim();

    // Ensure the document ends with a single newline
    if (cleaned && !cleaned.endsWith('\n')) {
      cleaned += '\n';
    }

    return cleaned;
  }
}
