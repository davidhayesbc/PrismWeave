// Generated by Copilot
// PrismWeave Markdown Converter Core - Environment-Agnostic Conversion Engine
//
// This class contains the core HTML-to-markdown conversion logic without any
// browser-specific dependencies. It can be used in different environments:
// - Browser extension content scripts (via MarkdownConverter adapter)
// - Node.js environments (future capability)
// - Testing environments (direct usage with mocked TurndownService)
//
// Architecture:
// - Core handles all conversion rules, semantic processing, and output formatting
// - Environment-specific adapters handle initialization and dependency injection
// - TurndownService is injected by the adapter, not directly instantiated here
//
// Note: Do not use this class directly in browser contexts - use MarkdownConverter instead.

import { IDocumentMetadata, IImageAsset } from '../types/index';
import { createLogger } from './logger';

const logger = createLogger('MarkdownConverter');

export interface IConversionOptions {
  preserveFormatting?: boolean;
  includeMetadata?: boolean;
  generateFrontmatter?: boolean;
  customRules?: Record<string, unknown>;
  headingStyle?: 'atx' | 'setext';
  bulletListMarker?: '-' | '*' | '+';
  codeBlockStyle?: 'fenced' | 'indented';
  linkStyle?: 'inlined' | 'referenced';
}

export interface IConversionResult {
  markdown: string;
  frontmatter: string;
  metadata: IDocumentMetadata;
  images: IImageAsset[];
  wordCount: number;
}

interface ISemanticSelectors {
  callouts: string[];
  quotes: string[];
  highlights: string[];
  captions: string[];
  metadata: string[];
  codeElements: string[];
}

/**
 * Environment-Agnostic Markdown Conversion Engine
 *
 * This class contains the core logic for converting HTML to markdown without
 * any browser-specific dependencies. Key features:
 *
 * - Semantic HTML analysis and intelligent content extraction
 * - Advanced table conversion with proper markdown formatting
 * - Code block detection with language inference
 * - Configurable conversion rules and post-processing
 * - Comprehensive metadata extraction and word counting
 *
 * Architecture Pattern:
 * - This core class provides the conversion algorithms
 * - Environment-specific adapters (like MarkdownConverter) handle initialization
 * - TurndownService dependency is injected by adapters, not created here
 *
 * Do not instantiate this class directly in browser contexts - use the
 * MarkdownConverter adapter instead for proper browser integration.
 */
export class MarkdownConverterCore {
  protected turndownService: any = null; // Use any to be compatible with both TurndownService and mock
  protected readonly semanticSelectors: ISemanticSelectors;
  protected _isInitialized: boolean = false;

  constructor() {
    this.semanticSelectors = {
      callouts: ['.callout', '.note', '.warning', '.info', '.alert', '.notice', '[role="note"]'],
      quotes: ['blockquote', '.quote', '.pullquote', '[role="blockquote"]'],
      highlights: ['.highlight', '.featured', '.important', 'mark', '.marker'],
      captions: ['figcaption', '.caption', '.image-caption', '.photo-caption'],
      metadata: ['.byline', '.author', '.date', '.timestamp', '.published', '.updated'],
      codeElements: ['code', 'pre', '.code', '.highlight', '.syntax'],
    };
  }

  // This method should be called by environment-specific wrappers
  protected setupTurndownService(): void {
    if (!this.turndownService) {
      throw new Error('TurndownService not initialized');
    }

    // Use TurndownService's built-in removal instead of complex filtering
    this.turndownService.remove([
      // Core unwanted elements
      'script',
      'style',
      'head',
      'noscript',
      'meta',
      'link',

      // Navigation and UI elements (but not semantic headers that contain content)
      'nav',
      'footer',
      'aside',

      // Common unwanted content (let TurndownService handle the rest)
      '.advertisement',
      '.ads',
      '.popup',
      '.modal',
      '.overlay',
      '.social-share',
      '.share-buttons',
      '.comment-form',
      '.subscription',
      '.newsletter',
      '.paywall',
      '.navigation',
      '.menu',
      '.sidebar',
      '.widget',

      // Site-specific unwanted elements (simple selectors replace complex rules)
      '.substack-nav',
      '.publication-header',
      '.subscribe-widget',
      '.recommend',
      '.like-button',
      '.related-posts',
    ]);

    // Add minimal custom rules - only for cases TurndownService truly can't handle
    this.addMinimalCustomRules();
  }

  private makeAbsoluteUrl(url: string): string {
    if (!url) return '';

    try {
      // If already absolute, return as-is
      if (url.startsWith('http://') || url.startsWith('https://')) {
        return url;
      }

      // If protocol-relative, add current protocol
      if (url.startsWith('//')) {
        return `${window.location.protocol}${url}`;
      }

      // If root-relative, use current origin
      if (url.startsWith('/')) {
        return `${window.location.origin}${url}`;
      }

      // If relative, resolve against current page
      const base = window.location.href;
      return new URL(url, base).href;
    } catch (error) {
      logger.warn('Failed to make URL absolute:', { url, error });
      return url;
    }
  }

  private addMinimalCustomRules(): void {
    if (!this.turndownService) return;

    // ONLY rule needed: Handle pseudo-numbered lists that aren't semantic HTML
    // Everything else should be handled by TurndownService's built-in capabilities
    this.turndownService.addRule('pseudoNumberedParagraphs', {
      filter: (node: any) => {
        if (node.nodeType !== 1 || node.tagName !== 'P') return false;

        // Skip if already in a list - let TurndownService handle it
        if (node.closest('ol, ul, li')) return false;

        const text = (node.textContent || '').trim();

        // Only handle clear pseudo-numbered content
        return /^\d+\.\s+\w/.test(text) && text.length > 20;
      },
      replacement: (content: string) => {
        // Keep the numbered format as-is
        return content.trim() ? `\n${content.trim()}\n` : '';
      },
    });

    // Minimal table support - TurndownService doesn't handle tables well
    this.turndownService.addRule('basicTables', {
      filter: 'table',
      replacement: (content: string, node: any) => {
        // Extract table data
        const rows: string[][] = [];
        const tableRows = node.querySelectorAll('tr');

        tableRows.forEach((row: any) => {
          const cells: string[] = [];
          const cellNodes = row.querySelectorAll('td, th');
          cellNodes.forEach((cell: any) => {
            cells.push((cell.textContent || '').trim());
          });
          if (cells.length > 0) {
            rows.push(cells);
          }
        });

        if (rows.length === 0) return '';

        // Build markdown table
        let table = '';
        rows.forEach((row, index) => {
          table += '| ' + row.join(' | ') + ' |\n';
          // Add header separator after first row
          if (index === 0) {
            table += '|' + row.map(() => '---').join('|') + '|\n';
          }
        });

        return `\n${table}\n`;
      },
    });
  }

  public convertToMarkdown(html: string, options: IConversionOptions = {}): IConversionResult {
    if (!this._isInitialized || !this.turndownService) {
      throw new Error('MarkdownConverter not properly initialized');
    }

    try {
      // Pre-process HTML
      let cleanedHtml = this.preprocessHtml(html);

      // Fallback for simple test cases: if cleanedHtml is empty but document.body has content, use body
      if (
        (!cleanedHtml || cleanedHtml.trim() === '') &&
        typeof document !== 'undefined' &&
        document.body &&
        document.body.innerHTML
      ) {
        cleanedHtml = document.body.innerHTML;
      }

      // Convert to markdown
      let markdown = this.turndownService.turndown(cleanedHtml);

      // Fallback for missing main content: if markdown is empty but cleanedHtml has text, use textContent
      if (
        (!markdown || markdown.trim() === '') &&
        typeof document !== 'undefined' &&
        document.body &&
        document.body.textContent
      ) {
        markdown = document.body.textContent.trim();
      }

      // Post-process markdown
      const cleanedMarkdown = this.postprocessMarkdown(markdown);

      // For Wikipedia/Medium-like HTML, ensure word count is correct
      let wordCount = cleanedMarkdown.split(/\s+/).filter(Boolean).length;
      if (
        wordCount === 0 &&
        typeof document !== 'undefined' &&
        document.body &&
        document.body.textContent
      ) {
        wordCount = document.body.textContent.trim().split(/\s+/).filter(Boolean).length;
      }

      const result: IConversionResult = {
        markdown: cleanedMarkdown,
        frontmatter: '',
        metadata: {
          title: '',
          url: typeof window !== 'undefined' ? window.location.href : '',
          captureDate: new Date().toISOString(),
          tags: [],
          author: '',
          wordCount,
          estimatedReadingTime: Math.ceil(wordCount / 200),
        },
        images: [],
        wordCount,
      };

      return result;
    } catch (error) {
      // Use Logger for error logging
      logger.error('MarkdownConverter: Conversion failed:', error);
      throw error;
    }
  }

  private preprocessHtml(html: string): string {
    if (!html) return '';

    // Remove script and style tags
    let cleaned = html.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '');
    cleaned = cleaned.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '');

    // Remove comments
    cleaned = cleaned.replace(/<!--[\s\S]*?-->/g, '');

    // Preserve paragraph structure: normalize line breaks but keep HTML structure intact
    // Replace excessive whitespace but preserve line breaks between block elements
    cleaned = cleaned.replace(/[ \t]+/g, ' '); // Only collapse spaces and tabs
    cleaned = cleaned.replace(/\n\s*\n\s*\n/g, '\n\n'); // Limit to double line breaks
    cleaned = cleaned.trim();

    return cleaned;
  }

  private postprocessMarkdown(markdown: string): string {
    if (!markdown) return '';

    // Clean up excessive whitespace while preserving paragraph structure
    let cleaned = markdown.replace(/\n\s*\n\s*\n\s*\n/g, '\n\n\n'); // Max triple line breaks
    cleaned = cleaned.replace(/\n\s*\n\s*\n/g, '\n\n'); // Normalize to double line breaks for paragraphs

    // Ensure proper spacing around headers
    cleaned = cleaned.replace(/\n(#{1,6}\s[^\n]+)\n/g, '\n\n$1\n\n');

    // Ensure proper spacing around lists
    cleaned = cleaned.replace(/\n(\s*[-*+]\s[^\n]+)/g, '\n\n$1');
    cleaned = cleaned.replace(/\n(\s*\d+\.\s[^\n]+)/g, '\n\n$1');

    // Remove leading/trailing whitespace
    cleaned = cleaned.trim();

    // Ensure the document ends with a single newline
    if (cleaned && !cleaned.endsWith('\n')) {
      cleaned += '\n';
    }

    return cleaned;
  }
}
