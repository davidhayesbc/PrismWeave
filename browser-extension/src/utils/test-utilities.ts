// Generated by Copilot
// Consolidated Test Utilities for PrismWeave Browser Extension
// Combines markdown conversion, test environment detection, and test logging
// Consolidated from: test-utilities.ts, test-utils.ts, and test-logger.ts

import { createLogger } from './logger';

const logger = createLogger('TestUtilities');

// ========================
// TEST LOGGING TYPES AND INTERFACES
// ========================

type TestLogLevel = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG' | 'TRACE';

interface ITestLogConfig {
  enabled: boolean;
  level: TestLogLevel;
  writeToFile: boolean;
  showTimestamps: boolean;
  showTestContext: boolean;
  maxLogLength: number;
}

interface ITestLogEntry {
  timestamp: string;
  level: TestLogLevel;
  testSuite?: string | undefined;
  testCase?: string | undefined;
  component: string;
  message: string;
  data?: unknown;
}

// ========================
// TEST LOGGER CLASS
// ========================

class TestLogger {
  private _config: ITestLogConfig;
  private _component: string;
  private _entries: ITestLogEntry[] = [];
  private _testContext: { suite?: string | undefined; case?: string | undefined } = {};
  private static _globalConfig: Partial<ITestLogConfig> = {};

  constructor(component: string, config?: Partial<ITestLogConfig>) {
    this._component = component;
    this._config = {
      enabled: this._isDebugMode(),
      level: this._getDefaultLevel(),
      writeToFile: false,
      showTimestamps: true,
      showTestContext: true,
      maxLogLength: 500,
      ...TestLogger._globalConfig,
      ...config,
    };
  }

  private _isDebugMode(): boolean {
    return (
      process.env.TEST_DEBUG === 'true' ||
      process.env.NODE_ENV === 'development' ||
      typeof (global as any).TEST_LOGGER_DEBUG !== 'undefined'
    );
  }

  private _getDefaultLevel(): TestLogLevel {
    const envLevel = process.env.TEST_LOG_LEVEL as TestLogLevel;
    if (envLevel && ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE'].includes(envLevel)) {
      return envLevel;
    }
    return this._isDebugMode() ? 'DEBUG' : 'ERROR';
  }

  private _shouldLog(level: TestLogLevel): boolean {
    if (!this._config.enabled) return false;

    const levels = ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE'];
    const currentLevelIndex = levels.indexOf(this._config.level);
    const messageLevelIndex = levels.indexOf(level);

    return messageLevelIndex <= currentLevelIndex;
  }

  private _formatMessage(level: TestLogLevel, message: string, data?: unknown): string {
    const parts: string[] = [];

    if (this._config.showTimestamps) {
      parts.push(`[${new Date().toISOString().substr(11, 12)}]`);
    }

    parts.push(`[TEST-${level}]`);
    parts.push(`[${this._component}]`);

    if (this._config.showTestContext) {
      if (this._testContext.suite) {
        parts.push(`[${this._testContext.suite}]`);
      }
      if (this._testContext.case) {
        parts.push(`[${this._testContext.case}]`);
      }
    }

    let fullMessage = `${parts.join(' ')} ${message}`;

    if (data !== undefined) {
      const dataStr = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
      const truncatedData =
        dataStr.length > this._config.maxLogLength
          ? dataStr.substring(0, this._config.maxLogLength) + '...[truncated]'
          : dataStr;
      fullMessage += `\nData: ${truncatedData}`;
    }

    return fullMessage;
  }

  private _log(level: TestLogLevel, message: string, data?: unknown): void {
    if (!this._shouldLog(level)) return;

    const entry: ITestLogEntry = {
      timestamp: new Date().toISOString(),
      level,
      testSuite: this._testContext.suite,
      testCase: this._testContext.case,
      component: this._component,
      message,
      data,
    };

    this._entries.push(entry);

    // Keep only last 1000 entries to prevent memory issues
    if (this._entries.length > 1000) {
      this._entries.shift();
    }

    const formattedMessage = this._formatMessage(level, message, data);

    // Only output to console in debug mode
    if (this._isDebugMode()) {
      switch (level) {
        case 'ERROR':
          console.error(formattedMessage);
          break;
        case 'WARN':
          console.warn(formattedMessage);
          break;
        case 'INFO':
          console.info(formattedMessage);
          break;
        case 'DEBUG':
        case 'TRACE':
          console.log(formattedMessage);
          break;
      }
    }
  }

  // Public logging methods
  error(message: string, error?: unknown): void {
    this._log('ERROR', message, error);
  }

  warn(message: string, data?: unknown): void {
    this._log('WARN', message, data);
  }

  info(message: string, data?: unknown): void {
    this._log('INFO', message, data);
  }

  debug(message: string, data?: unknown): void {
    this._log('DEBUG', message, data);
  }

  trace(message: string, data?: unknown): void {
    this._log('TRACE', message, data);
  }

  // Test context management
  setTestSuite(suiteName: string): void {
    this._testContext.suite = suiteName;
    this._testContext.case = undefined;
  }

  setTestCase(caseName: string): void {
    this._testContext.case = caseName;
  }

  clearTestContext(): void {
    this._testContext = {};
  }

  // Test-specific utilities
  logTestStart(testName: string, data?: unknown): void {
    this.info(`üß™ Test started: ${testName}`, data);
  }

  logTestEnd(testName: string, success: boolean, duration?: number): void {
    const status = success ? '‚úÖ PASS' : '‚ùå FAIL';
    const durationStr = duration ? ` (${duration}ms)` : '';
    this.info(`${status}: ${testName}${durationStr}`);
  }

  logAssertion(assertion: string, success: boolean, actual?: unknown, expected?: unknown): void {
    if (success) {
      this.debug(`‚úì ${assertion}`);
    } else {
      this.error(`‚úó ${assertion}`, { actual, expected });
    }
  }

  logMockCall(mockName: string, args?: unknown[], result?: unknown): void {
    this.debug(`üé≠ Mock called: ${mockName}`, { args, result });
  }

  logPerformance(operation: string, duration: number, threshold?: number): void {
    const level = threshold && duration > threshold ? 'WARN' : 'DEBUG';
    const warning = threshold && duration > threshold ? ' (‚ö†Ô∏è slow)' : '';
    this._log(level, `‚è±Ô∏è ${operation}: ${duration}ms${warning}`);
  }

  // Configuration methods
  setConfig(config: Partial<ITestLogConfig>): void {
    this._config = { ...this._config, ...config };
  }

  enable(): void {
    this._config.enabled = true;
    this.info('Test logging enabled');
  }

  disable(): void {
    this.info('Test logging disabled');
    this._config.enabled = false;
  }

  // Log retrieval and management
  getEntries(filter?: { level?: TestLogLevel; component?: string }): ITestLogEntry[] {
    if (!filter) return [...this._entries];

    return this._entries.filter(entry => {
      if (filter.level && entry.level !== filter.level) return false;
      if (filter.component && entry.component !== filter.component) return false;
      return true;
    });
  }

  getEntriesAsText(): string {
    return this._entries
      .map(entry => this._formatMessage(entry.level, entry.message, entry.data))
      .join('\n');
  }

  clearEntries(): void {
    this._entries = [];
  }

  // Static configuration methods
  static setGlobalConfig(config: Partial<ITestLogConfig>): void {
    TestLogger._globalConfig = { ...TestLogger._globalConfig, ...config };
  }

  static enableDebugMode(): void {
    (global as any).TEST_LOGGER_DEBUG = true;
    TestLogger._globalConfig.enabled = true;
    TestLogger._globalConfig.level = 'DEBUG';
    console.log('üß™ Test Logger Debug Mode Enabled');
  }

  static disableDebugMode(): void {
    delete (global as any).TEST_LOGGER_DEBUG;
    TestLogger._globalConfig.enabled = false;
    console.log('üß™ Test Logger Debug Mode Disabled');
  }

  static createLogger(component: string): TestLogger {
    return new TestLogger(component);
  }
}

// ========================
// TEST UTILITIES CLASS
// ========================

export class TestUtils {
  /**
   * Detect if code is running in a test environment
   */
  static isTestEnvironment(): boolean {
    return (
      typeof jest !== 'undefined' ||
      process.env.NODE_ENV === 'test' ||
      typeof (global as any).jasmine !== 'undefined'
    );
  }

  /**
   * Test-safe logging with test case prefix
   * Only logs in test environment with structured format
   */
  static testLog(testId: string, message: string, data?: any): void {
    if (this.isTestEnvironment()) {
      const prefix = `Test ${testId} -`;
      if (data) {
        logger.info(prefix, message, this.formatData(data));
      } else {
        logger.info(prefix, message);
      }
    }
  }

  /**
   * Production logging - suppressed in test environment
   * Use for regular operational logging that should not clutter test output
   */
  static productionLog(message: string, data?: any): void {
    if (!this.isTestEnvironment()) {
      logger.info(message, data);
    }
  }

  /**
   * Debug logging - only in non-test environments
   * Use for verbose debugging information
   */
  static debugLog(message: string, data?: any): void {
    if (!this.isTestEnvironment()) {
      logger.debug(`[DEBUG] ${message}`, data);
    }
  }

  /**
   * Error logging - always visible (critical errors should be seen in tests)
   */
  static errorLog(message: string, error?: any): void {
    logger.error(message, error);
  }

  /**
   * Warning logging - always visible
   */
  static warnLog(message: string, data?: any): void {
    logger.warn(message, data);
  }

  /**
   * Format data for logging, truncating long strings
   */
  private static formatData(data: any): any {
    if (typeof data === 'string' && data.length > 200) {
      return data.substring(0, 200) + '... (truncated)';
    }
    if (typeof data === 'object' && data !== null) {
      // Clone and truncate string properties
      const formatted = { ...data };
      Object.keys(formatted).forEach(key => {
        if (typeof formatted[key] === 'string' && formatted[key].length > 200) {
          formatted[key] = formatted[key].substring(0, 200) + '... (truncated)';
        }
      });
      return formatted;
    }
    return data;
  }

  /**
   * Create a test-aware logger for a specific component
   */
  static createLogger(componentName: string) {
    return {
      production: (message: string, data?: any) =>
        this.productionLog(`[${componentName}] ${message}`, data),
      debug: (message: string, data?: any) => this.debugLog(`[${componentName}] ${message}`, data),
      test: (testId: string, message: string, data?: any) =>
        this.testLog(`${testId}.${componentName}`, message, data),
      error: (message: string, error?: any) =>
        this.errorLog(`[${componentName}] ${message}`, error),
      warn: (message: string, data?: any) => this.warnLog(`[${componentName}] ${message}`, data),
    };
  }
}

// ========================
// FACTORY FUNCTIONS FOR BACKWARD COMPATIBILITY
// ========================

// Export factory function for TestLogger
export function createTestLogger(component: string): TestLogger {
  return new TestLogger(component);
}

// Create testLogger instance for existing markdown conversion functions
const testLogger = createTestLogger('TestUtilities');

// ========================
// MARKDOWN CONVERSION UTILITIES
// ========================

// Decode HTML entities
export function decodeHtmlEntities(str: string): string {
  if (!str) return str;

  return str
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&amp;/g, '&')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&nbsp;/g, ' ')
    .replace(/&#x27;/g, "'")
    .replace(/&#x2F;/g, '/');
}

// Extract language from code element class
export function extractLanguageFromClass(className: string): string {
  if (!className) return '';

  // Check for common language class patterns
  const patterns = [
    /(?:language|lang)-([a-zA-Z0-9_+-]+)/i,
    /highlight-([a-zA-Z0-9_+-]+)/i,
    /code-([a-zA-Z0-9_+-]+)/i,
    /([a-zA-Z0-9_+-]+)-code/i,
  ];

  for (const pattern of patterns) {
    const match = className.match(pattern);
    if (match) {
      return normalizeLanguage(match[1]);
    }
  }

  return '';
}

// Normalize language names
export function normalizeLanguage(lang: string): string {
  if (!lang) return '';

  const normalized = lang.toLowerCase();

  // Language mapping for common variations
  const languageMap: { [key: string]: string } = {
    js: 'javascript',
    ts: 'typescript',
    py: 'python',
    rb: 'ruby',
    sh: 'bash',
    shell: 'bash',
    zsh: 'bash',
    fish: 'bash',
    powershell: 'powershell',
    ps1: 'powershell',
    cmd: 'batch',
    bat: 'batch',
    dockerfile: 'docker',
    yml: 'yaml',
    xml: 'xml',
    html: 'html',
    css: 'css',
    scss: 'scss',
    sass: 'sass',
    less: 'less',
    json: 'json',
    yaml: 'yaml',
    toml: 'toml',
    ini: 'ini',
    cfg: 'ini',
    conf: 'ini',
    sql: 'sql',
    mysql: 'sql',
    postgresql: 'sql',
    sqlite: 'sql',
    markdown: 'markdown',
    md: 'markdown',
    tex: 'latex',
    latex: 'latex',
    r: 'r',
    matlab: 'matlab',
    octave: 'matlab',
    scala: 'scala',
    kotlin: 'kotlin',
    swift: 'swift',
    go: 'go',
    rust: 'rust',
    dart: 'dart',
    lua: 'lua',
    perl: 'perl',
    php: 'php',
    vim: 'vim',
    asm: 'assembly',
    assembly: 'assembly',
    c: 'c',
    cpp: 'cpp',
    'c++': 'cpp',
    cxx: 'cpp',
    cc: 'cpp',
    java: 'java',
    cs: 'csharp',
    csharp: 'csharp',
    vb: 'vb',
    vbnet: 'vb',
    fsharp: 'fsharp',
    fs: 'fsharp',
    clojure: 'clojure',
    lisp: 'lisp',
    scheme: 'scheme',
    haskell: 'haskell',
    elm: 'elm',
    erlang: 'erlang',
    elixir: 'elixir',
    prolog: 'prolog',
    fortran: 'fortran',
    cobol: 'cobol',
    pascal: 'pascal',
    ada: 'ada',
    unison: 'unison',
  };

  return languageMap[normalized] || normalized;
}

// Simplified markdown conversion for testing (mimics service worker logic)
export function simpleMarkdownConversion(
  htmlContent: string,
  title: string,
  url: string
): { content: string; title: string; url: string } {
  let markdown = '';

  // Check if DOMParser is available
  testLogger.debug('DOMParser available:', typeof DOMParser !== 'undefined');
  // Create a DOM parser for testing
  if (typeof DOMParser !== 'undefined') {
    const parser = new DOMParser();
    const doc = parser.parseFromString(htmlContent, 'text/html');

    // Process code blocks with improved extraction
    const codeBlocks = doc.querySelectorAll('pre code, pre, code');
    testLogger.debug('Found code blocks:', codeBlocks.length);

    codeBlocks.forEach((block, index) => {
      testLogger.debug(
        `Block ${index}: tagName=${block.tagName}, parentTag=${block.parentElement?.tagName}`
      );
      const isPreBlock = block.tagName === 'PRE' || block.parentElement?.tagName === 'PRE';
      testLogger.debug(`Block ${index}: isPreBlock=${isPreBlock}`);

      if (isPreBlock) {
        // Handle code blocks
        const codeElement = block.tagName === 'CODE' ? block : block.querySelector('code');
        const actualCodeElement = codeElement || block;

        // Extract language
        const className = actualCodeElement.className || '';
        const language = extractLanguageFromClass(className); // Get content and process it
        let content = actualCodeElement.textContent || '';
        content = decodeHtmlEntities(content);
        // Line numbers should be handled by HTML structure rules

        markdown += '\n```' + language + '\n' + content + '\n```\n\n';
      } else {
        // Handle inline code
        let content = block.textContent || '';
        content = decodeHtmlEntities(content);
        markdown += '`' + content.replace(/`/g, '\\`') + '`';
      }
    });

    // Add basic text content if no code blocks found
    if (!codeBlocks.length) {
      markdown = doc.body?.textContent || htmlContent;
    }
  } else {
    // Fallback for environments without DOMParser
    // Simple regex-based extraction for testing
    const codeBlockRegex =
      /<pre[^>]*>[\s\S]*?<code[^>]*(?:class="([^"]*)")?[^>]*>([\s\S]*?)<\/code>[\s\S]*?<\/pre>/gi;

    let match;
    while ((match = codeBlockRegex.exec(htmlContent)) !== null) {
      const className = match[1] || '';
      let content = match[2]; // Extract language and process content
      const language = extractLanguageFromClass(className);
      content = decodeHtmlEntities(content);
      // Line numbers should be handled by HTML structure rules

      markdown += '\n```' + language + '\n' + content + '\n```\n\n';
    }

    // Fallback text extraction
    if (!markdown.trim()) {
      markdown = htmlContent
        .replace(/<[^>]+>/g, '')
        .replace(/\s+/g, ' ')
        .trim();
    }
  }

  return {
    content: markdown.trim(),
    title: title,
    url: url,
  };
}

// ========================
// EXPORTS FOR BACKWARD COMPATIBILITY
// ========================

// Export main classes and types
export { ITestLogConfig, ITestLogEntry, TestLogger, TestLogLevel };
