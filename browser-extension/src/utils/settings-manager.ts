// Generated by Copilot
// PrismWeave Settings Manager - TypeScript version
// Centralized settings management with consistent schema and validation

// Type definitions for service worker compatibility
interface ISettingsManagerSettings {
  [key: string]: unknown;
}

interface ISettingsManagerStorageData {
  [key: string]: unknown;
}

type SettingsManagerStorageKeys = string | string[] | Record<string, unknown> | null;
type SettingsManagerStorageResult<T = Record<string, unknown>> = Promise<T>;

interface ISettingDefinition {
  type: 'string' | 'boolean' | 'number' | 'array';
  default: string | boolean | number | string[];
  required?: boolean;
  sensitive?: boolean;
  description: string;
  pattern?: RegExp;
  options?: string[];
  requires?: string[];
  min?: number;
  max?: number;
}

interface ISettingsSchema {
  [key: string]: ISettingDefinition;
}

class SettingsManager {
  private readonly STORAGE_KEY: string = 'prismWeaveSettings';
  private readonly schema: ISettingsSchema;

  constructor() {
    this.schema = this.getSettingsSchema();
  }
  private getSettingsSchema(): ISettingsSchema {
    return {
      // Core Extension Settings
      enabled: {
        type: 'boolean',
        default: true,
        description: 'Enable/disable the extension',
      },
      extractionRules: {
        type: 'array',
        default: [],
        description: 'Content extraction rules',
      },
      apiEndpoint: {
        type: 'string',
        default: '',
        required: false,
        description: 'API endpoint URL',
      },
      
      // Repository Configuration
      repositoryPath: {
        type: 'string',
        default: '',
        required: false,
        description: 'Local or remote repository path',
      },
      githubToken: {
        type: 'string',
        default: '',
        required: false,
        sensitive: true,
        description: 'GitHub personal access token',
      },
      githubRepo: {
        type: 'string',
        default: '',
        required: false,
        pattern: /^[a-zA-Z0-9._-]+\/[a-zA-Z0-9._-]+$/,
        description: 'GitHub repository in format owner/repo',
      },

      // File Organization
      defaultFolder: {
        type: 'string',
        default: 'unsorted',
        required: true,
        options: [
          'tech',
          'business',
          'research',
          'news',
          'tutorial',
          'reference',
          'blog',
          'social',
          'unsorted',
          'custom',
        ],
        description: 'Default folder for captured documents',
      },
      customFolder: {
        type: 'string',
        default: '',
        required: false,
        description: 'Custom folder name when defaultFolder is "custom"',
      },
      fileNamingPattern: {
        type: 'string',
        default: 'YYYY-MM-DD-domain-title',
        required: true,
        options: [
          'YYYY-MM-DD-domain-title',
          'YYYY-MM-DD-title',
          'domain-YYYY-MM-DD-title',
          'title-YYYY-MM-DD',
          'custom',
        ],
        description: 'Template for generated filenames',
      },
      customNamingPattern: {
        type: 'string',
        default: '',
        required: false,
        description: 'Custom naming pattern when fileNamingPattern is "custom"',
      },
      documentPath: {
        type: 'string',
        default: 'documents',
        description: 'Path within repository for documents',
      },
      defaultTags: {
        type: 'array',
        default: [],
        description: 'Default tags for captured documents',
      },

      // Automation Settings
      autoCapture: {
        type: 'boolean',
        default: false,
        description: 'Automatically capture pages when visiting',
      },
      autoCommit: {
        type: 'boolean',
        default: true,
        description: 'Automatically commit captured files to Git',
      },
      autoPush: {
        type: 'boolean',
        default: false,
        description: 'Automatically push commits to remote repository',
        requires: ['githubToken', 'githubRepo'],
      },

      // Content Processing
      captureImages: {
        type: 'boolean',
        default: true,
        description: 'Download and save images from captured pages',
      },
      removeAds: {
        type: 'boolean',
        default: true,
        description: 'Remove advertisements and promotional content',
      },
      removeNavigation: {
        type: 'boolean',
        default: true,
        description: 'Remove navigation menus and site headers/footers',
      },
      preserveFormatting: {
        type: 'boolean',
        default: true,
        description: 'Preserve original formatting and styling',
      },
      imageQuality: {
        type: 'number',
        default: 85,
        min: 1,
        max: 100,
        description: 'Image quality for compression (1-100)',
      },
      maxImageSize: {
        type: 'number',
        default: 5,
        min: 1,
        max: 50,
        description: 'Maximum image size in MB',
      },
      markdownFormat: {
        type: 'string',
        default: 'github',
        options: ['github', 'commonmark', 'custom'],
        description: 'Markdown format to use',
      },
      customMarkdownRules: {
        type: 'string', // Will be parsed as JSON
        default: '{}',
        description: 'Custom markdown conversion rules',
      },

      // Content Enhancement
      generateTags: {
        type: 'boolean',
        default: true,
        description: 'Automatically generate tags for captured content',
      },
      generateSummary: {
        type: 'boolean',
        default: false,
        description: 'Generate AI-powered content summaries',
      },
      enhanceMetadata: {
        type: 'boolean',
        default: true,
        description: 'Extract and enhance document metadata',
      },
      aiProcessing: {
        type: 'boolean',
        default: false,
        description: 'Enable AI processing features',
      },
      aiModel: {
        type: 'string',
        default: 'local',
        description: 'AI model to use for processing',
      },

      // Performance & Debugging
      debugMode: {
        type: 'boolean',
        default: false,
        description: 'Enable detailed logging and debug information',
      },
      performanceMonitoring: {
        type: 'boolean',
        default: false,
        description: 'Track and log performance metrics',
      },
      logLevel: {
        type: 'string',
        default: 'info',
        options: ['debug', 'info', 'warn', 'error'],
        description: 'Logging level',
      },

      // UI Preferences
      showNotifications: {
        type: 'boolean',
        default: true,
        description: 'Show completion notifications',
      },
      darkMode: {
        type: 'boolean',
        default: false,
        description: 'Use dark theme for extension UI',
      },    };
  }

  async getSettings(): Promise<Partial<ISettings>> {
    try {
      const result = await this.getFromStorage<Record<string, Partial<ISettings>>>([this.STORAGE_KEY]);
      return result[this.STORAGE_KEY] || {};
    } catch (error) {
      console.error('SettingsManager: Error getting settings:', error);
      return {};
    }
  }

  async getDefaults(): Promise<Partial<ISettings>> {
    const defaults: Partial<ISettings> = {};
    
    Object.entries(this.schema).forEach(([key, definition]) => {
      (defaults as any)[key] = definition.default;
    });
    
    return defaults;
  }

  async getSettingsWithDefaults(): Promise<Partial<ISettings>> {
    try {
      const [current, defaults] = await Promise.all([
        this.getSettings(),
        this.getDefaults()
      ]);
      
      return { ...defaults, ...current };
    } catch (error) {
      console.error('SettingsManager: Error getting settings with defaults:', error);
      return await this.getDefaults();
    }
  }

  async updateSettings(updates: Partial<ISettings>): Promise<boolean> {
    try {
      const validationResult = this.validateSettings(updates);
      if (!validationResult.isValid) {
        console.error('SettingsManager: Validation failed:', validationResult.errors);
        return false;
      }

      const current = await this.getSettings();
      const updated = { ...current, ...updates };
      
      await this.setToStorage({ [this.STORAGE_KEY]: updated });
      return true;
    } catch (error) {
      console.error('SettingsManager: Error updating settings:', error);
      return false;
    }
  }

  async resetSettings(): Promise<boolean> {
    try {
      const defaults = await this.getDefaults();
      await this.setToStorage({ [this.STORAGE_KEY]: defaults });
      return true;
    } catch (error) {
      console.error('SettingsManager: Error resetting settings:', error);
      return false;
    }
  }

  validateSettings(settings: Partial<ISettings>): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];
    
    Object.entries(settings).forEach(([key, value]) => {
      const definition = this.schema[key];
      if (!definition) {
        errors.push(`Unknown setting: ${key}`);
        return;
      }

      // Type validation
      if (typeof value !== definition.type) {
        errors.push(`Invalid type for ${key}: expected ${definition.type}, got ${typeof value}`);
        return;
      }

      // Pattern validation
      if (definition.pattern && typeof value === 'string' && !definition.pattern.test(value)) {
        errors.push(`Invalid format for ${key}: does not match required pattern`);
      }

      // Options validation
      if (definition.options && !definition.options.includes(value as string)) {
        errors.push(`Invalid value for ${key}: must be one of ${definition.options.join(', ')}`);
      }

      // Range validation for numbers
      if (definition.type === 'number' && typeof value === 'number') {
        if (definition.min !== undefined && value < definition.min) {
          errors.push(`Value for ${key} is below minimum: ${definition.min}`);
        }
        if (definition.max !== undefined && value > definition.max) {
          errors.push(`Value for ${key} is above maximum: ${definition.max}`);
        }
      }
    });

    return { isValid: errors.length === 0, errors };
  }

  async checkRequiredDependencies(settings: Partial<ISettings>): Promise<string[]> {
    const missingDependencies: string[] = [];
    
    Object.entries(settings).forEach(([key, value]) => {
      const definition = this.schema[key];
      if (definition?.requires && value) {
        definition.requires.forEach(required => {
          if (!settings[required as keyof ISettings]) {
            missingDependencies.push(`${key} requires ${required} to be set`);
          }
        });
      }
    });

    return missingDependencies;
  }

  getSettingDefinition(key: string): ISettingDefinition | null {
    return this.schema[key] || null;
  }

  getAllSettingDefinitions(): ISettingsSchema {
    return { ...this.schema };
  }

  async exportSettings(): Promise<string> {
    try {
      const settings = await this.getSettings();
      const sanitized = this.sanitizeForExport(settings);
      return JSON.stringify(sanitized, null, 2);
    } catch (error) {
      console.error('SettingsManager: Error exporting settings:', error);
      throw error;
    }
  }

  async importSettings(jsonString: string): Promise<boolean> {
    try {
      const imported = JSON.parse(jsonString) as Partial<ISettings>;
      return await this.updateSettings(imported);
    } catch (error) {
      console.error('SettingsManager: Error importing settings:', error);
      return false;
    }
  }

  private sanitizeForExport(settings: Partial<ISettings>): Partial<ISettings> {
    const sanitized = { ...settings };
    
    Object.entries(this.schema).forEach(([key, definition]) => {
      if (definition.sensitive && sanitized[key as keyof ISettings]) {
        (sanitized as any)[key] = '[REDACTED]';
      }
    });
    
    return sanitized;
  }
  private async getFromStorage<T = ISettingsManagerStorageData>(keys: SettingsManagerStorageKeys): SettingsManagerStorageResult<T> {
    return new Promise<T>((resolve, reject) => {
      chrome.storage.sync.get(keys as any, (result: T) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve(result);
        }
      });
    });
  }

  private async setToStorage(data: ISettingsManagerStorageData): Promise<void> {
    return new Promise<void>((resolve, reject) => {
      chrome.storage.sync.set(data, () => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve();
        }
      });
    });
  }
}

// Export for ES6 modules
export { SettingsManager };

// Make available globally for service worker importScripts compatibility
if (typeof globalThis !== 'undefined') {
  (globalThis as any).SettingsManager = SettingsManager;
} else if (typeof self !== 'undefined') {
  (self as any).SettingsManager = SettingsManager;
}
