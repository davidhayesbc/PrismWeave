// Generated by Copilot
// Bookmarklet management utilities for PrismWeave browser extension

import { IBookmarkletSettings, ISettings, extractBookmarkletSettings } from '../types/index.js';
import { BookmarkletGenerator } from './bookmarklet-generator.js';
import { createLogger } from './logger.js';
import { SettingsManager } from './settings-manager.js';

const logger = createLogger('BookmarkletManager');

export interface IBookmarkletTestResult {
  success: boolean;
  data?: {
    pageTitle: string;
    pageUrl: string;
    contentLength: number;
    wordCount: number;
    imageCount: number;
    extractionTime: number;
  };
  error?: string;
}

export interface IBookmarkletUsageStats {
  totalUses: number;
  lastUsed?: string;
  successfulCaptures: number;
  failedCaptures: number;
  averageContentLength: number;
  mostCapturedDomains: Array<{ domain: string; count: number }>;
}

export class BookmarkletManager {
  private _settingsManager: SettingsManager;

  constructor() {
    this._settingsManager = new SettingsManager();
  }

  /**
   * Get current bookmarklet configuration
   */
  async getBookmarkletSettings(): Promise<IBookmarkletSettings> {
    try {
      const settings = await this._settingsManager.getSettingsWithDefaults();
      return extractBookmarkletSettings(settings);
    } catch (error) {
      logger.error('Failed to get bookmarklet settings:', error);
      return extractBookmarkletSettings({});
    }
  }

  /**
   * Update bookmarklet settings
   */
  async updateBookmarkletSettings(updates: Partial<IBookmarkletSettings>): Promise<boolean> {
    try {
      // Build flat updates object with only defined values
      const flatUpdates: Partial<ISettings> = {};

      if (updates.enabled !== undefined) {
        flatUpdates['bookmarklet.enabled'] = updates.enabled;
      }
      if (updates.customDomain !== undefined) {
        flatUpdates['bookmarklet.customDomain'] = updates.customDomain;
      }
      if (updates.includeImages !== undefined) {
        flatUpdates['bookmarklet.includeImages'] = updates.includeImages;
      }
      if (updates.includeLinks !== undefined) {
        flatUpdates['bookmarklet.includeLinks'] = updates.includeLinks;
      }
      if (updates.cleanAds !== undefined) {
        flatUpdates['bookmarklet.cleanAds'] = updates.cleanAds;
      }
      if (updates.customSelectors !== undefined) {
        flatUpdates['bookmarklet.customSelectors'] = updates.customSelectors;
      }
      if (updates.excludeSelectors !== undefined) {
        flatUpdates['bookmarklet.excludeSelectors'] = updates.excludeSelectors;
      }
      if (updates.autoInstall !== undefined) {
        flatUpdates['bookmarklet.autoInstall'] = updates.autoInstall;
      }
      if (updates.version !== undefined) {
        flatUpdates['bookmarklet.version'] = updates.version;
      }

      const success = await this._settingsManager.updateSettings(flatUpdates);

      if (success) {
        logger.info('Bookmarklet settings updated successfully');
      } else {
        logger.error('Failed to update bookmarklet settings');
      }

      return success;
    } catch (error) {
      logger.error('Failed to update bookmarklet settings:', error);
      return false;
    }
  }

  /**
   * Generate a bookmarklet with current settings
   */
  async generateBookmarklet(customConfig?: Record<string, unknown>): Promise<{
    success: boolean;
    bookmarkletCode?: string;
    bookmarkletName?: string;
    installationInstructions?: string;
    error?: string;
  }> {
    try {
      const settings = await this._settingsManager.getSettingsWithDefaults();
      const bookmarkletSettings = extractBookmarkletSettings(settings);

      if (!bookmarkletSettings.enabled) {
        return {
          success: false,
          error: 'Bookmarklet is not enabled in settings',
        };
      }

      // Validate required GitHub settings
      if (!settings.githubToken || !settings.githubRepo) {
        return {
          success: false,
          error: 'GitHub token and repository must be configured',
        };
      }

      const config = {
        githubToken: settings.githubToken,
        githubRepo: settings.githubRepo,
        defaultFolder: settings.defaultFolder || 'unsorted',
        fileNamingPattern: settings.fileNamingPattern || 'YYYY-MM-DD-domain-title',
        commitMessageTemplate: settings.commitMessageTemplate || 'Add: {domain} - {title}',
        captureImages: settings.captureImages ?? true,
        removeAds: settings.removeAds ?? true,
        removeNavigation: settings.removeNavigation ?? true,
        ...customConfig,
      };

      const bookmarkletCode = BookmarkletGenerator.generateBookmarklet(config);
      const bookmarkletName = BookmarkletGenerator.generateBookmarkletName(config);
      const installationInstructions = BookmarkletGenerator.generateInstallationInstructions(
        bookmarkletCode,
        bookmarkletName
      );

      logger.info('Bookmarklet generated successfully');

      return {
        success: true,
        bookmarkletCode,
        bookmarkletName,
        installationInstructions,
      };
    } catch (error) {
      logger.error('Failed to generate bookmarklet:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  /**
   * Validate bookmarklet configuration
   */
  async validateBookmarkletConfig(): Promise<{
    isValid: boolean;
    errors: string[];
    warnings: string[];
    estimatedSize?: number;
  }> {
    try {
      const settings = await this._settingsManager.getSettingsWithDefaults();

      const config = {
        githubToken: settings.githubToken || '',
        githubRepo: settings.githubRepo || '',
        defaultFolder: settings.defaultFolder || 'unsorted',
        fileNamingPattern: settings.fileNamingPattern || 'YYYY-MM-DD-domain-title',
        commitMessageTemplate: settings.commitMessageTemplate || 'Add: {domain} - {title}',
        captureImages: settings.captureImages ?? true,
        removeAds: settings.removeAds ?? true,
        removeNavigation: settings.removeNavigation ?? true,
      };

      const validation = BookmarkletGenerator.validateConfig(config);
      const warnings: string[] = [];

      // Additional warnings
      if (
        config.githubToken &&
        !config.githubToken.startsWith('ghp_') &&
        !config.githubToken.startsWith('github_pat_')
      ) {
        warnings.push('GitHub token format may be invalid');
      }

      if (config.defaultFolder === 'custom' && !settings.customFolder) {
        warnings.push('Custom folder is selected but not specified');
      }

      // Estimate bookmarklet size
      let estimatedSize = 0;
      if (validation.isValid) {
        try {
          const bookmarkletCode = BookmarkletGenerator.generateBookmarklet(config);
          estimatedSize = bookmarkletCode.length;
        } catch (error) {
          logger.warn('Could not estimate bookmarklet size:', error);
        }
      }

      return {
        ...validation,
        warnings,
        estimatedSize,
      };
    } catch (error) {
      logger.error('Failed to validate bookmarklet config:', error);
      return {
        isValid: false,
        errors: ['Failed to validate configuration'],
        warnings: [],
      };
    }
  }

  /**
   * Test bookmarklet functionality
   */
  async testBookmarklet(): Promise<IBookmarkletTestResult> {
    try {
      const startTime = Date.now();

      // Get current page information
      const pageTitle = document.title || 'Test Page';
      const pageUrl = window.location.href;

      // Find content elements (simulate bookmarklet content detection)
      const contentSelectors = [
        'article',
        'main',
        '[role="main"]',
        '.content',
        '.post',
        '.entry',
        '#content',
        '#main',
        'body',
      ];

      let contentElement: Element | null = null;
      for (const selector of contentSelectors) {
        contentElement = document.querySelector(selector);
        if (
          contentElement &&
          contentElement.textContent &&
          contentElement.textContent.length > 100
        ) {
          break;
        }
      }

      if (!contentElement) {
        contentElement = document.body;
      }

      const textContent = contentElement.textContent || '';
      const wordCount = textContent
        .trim()
        .split(/\s+/)
        .filter(word => word.length > 0).length;
      const imageCount = document.querySelectorAll('img').length;
      const extractionTime = Date.now() - startTime;

      logger.debug('Bookmarklet test completed:', {
        pageTitle,
        pageUrl,
        contentLength: textContent.length,
        wordCount,
        imageCount,
        extractionTime,
      });

      return {
        success: true,
        data: {
          pageTitle,
          pageUrl,
          contentLength: textContent.length,
          wordCount,
          imageCount,
          extractionTime,
        },
      };
    } catch (error) {
      logger.error('Bookmarklet test failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  /**
   * Get bookmarklet usage statistics
   */
  async getUsageStats(): Promise<IBookmarkletUsageStats> {
    try {
      // For now, return mock data - in a real implementation,
      // this would read from storage where usage data is tracked
      return {
        totalUses: 0,
        successfulCaptures: 0,
        failedCaptures: 0,
        averageContentLength: 0,
        mostCapturedDomains: [],
      };
    } catch (error) {
      logger.error('Failed to get usage stats:', error);
      return {
        totalUses: 0,
        successfulCaptures: 0,
        failedCaptures: 0,
        averageContentLength: 0,
        mostCapturedDomains: [],
      };
    }
  }

  /**
   * Export bookmarklet configuration
   */
  async exportConfiguration(): Promise<{
    success: boolean;
    configData?: string;
    error?: string;
  }> {
    try {
      const bookmarkletSettings = await this.getBookmarkletSettings();
      const allSettings = await this._settingsManager.getSettingsWithDefaults();

      const exportData = {
        bookmarklet: bookmarkletSettings,
        relatedSettings: {
          githubRepo: allSettings.githubRepo, // Don't export token for security
          defaultFolder: allSettings.defaultFolder,
          fileNamingPattern: allSettings.fileNamingPattern,
          commitMessageTemplate: allSettings.commitMessageTemplate,
          captureImages: allSettings.captureImages,
          removeAds: allSettings.removeAds,
          removeNavigation: allSettings.removeNavigation,
          customSelectors: allSettings.customSelectors,
        },
        exported: new Date().toISOString(),
        version: '1.0.0',
      };

      const configData = JSON.stringify(exportData, null, 2);

      logger.info('Bookmarklet configuration exported');

      return {
        success: true,
        configData,
      };
    } catch (error) {
      logger.error('Failed to export configuration:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  /**
   * Import bookmarklet configuration
   */
  async importConfiguration(configData: string): Promise<{
    success: boolean;
    error?: string;
  }> {
    try {
      const importData = JSON.parse(configData);

      if (!importData.bookmarklet) {
        return {
          success: false,
          error: 'Invalid configuration file: missing bookmarklet settings',
        };
      }

      const bookmarkletSettings = importData.bookmarklet as IBookmarkletSettings;
      const success = await this.updateBookmarkletSettings(bookmarkletSettings);

      if (success) {
        logger.info('Bookmarklet configuration imported successfully');
        return { success: true };
      } else {
        return {
          success: false,
          error: 'Failed to update settings with imported configuration',
        };
      }
    } catch (error) {
      logger.error('Failed to import configuration:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Invalid configuration file format',
      };
    }
  }

  /**
   * Check if bookmarklet needs updating
   */
  async checkForUpdates(): Promise<{
    needsUpdate: boolean;
    currentVersion: string;
    latestVersion: string;
    updateAvailable?: boolean;
  }> {
    try {
      const bookmarkletSettings = await this.getBookmarkletSettings();
      const currentVersion = bookmarkletSettings.version;
      const latestVersion = '1.0.0'; // In a real implementation, this might come from a server

      return {
        needsUpdate: currentVersion !== latestVersion,
        currentVersion,
        latestVersion,
        updateAvailable: false, // Not implemented yet
      };
    } catch (error) {
      logger.error('Failed to check for updates:', error);
      return {
        needsUpdate: false,
        currentVersion: '1.0.0',
        latestVersion: '1.0.0',
      };
    }
  }
}
