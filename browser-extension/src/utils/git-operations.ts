// Generated by Copilot
// PrismWeave Git Operations - TypeScript version
// Handles Git repository management and synchronization

import { ISettings, IDocumentMetadata, IFileOperationResult, IGitCommitOptions } from '../types/index.js';

interface IGitHubApiResponse {
  sha?: string;
  content?: string;
  message?: string;
  commit?: {
    sha: string;
    html_url: string;
  };
}

interface IGitHubFileInfo {
  sha: string;
  content: string;
  encoding: string;
}

interface IRepositoryInfo {
  owner: string;
  repo: string;
}

interface IGitCommitResult {
  success: boolean;
  sha?: string;
  url?: string;
  error?: string;
}

export class GitOperations {
  private readonly apiBase: string = 'https://api.github.com';
  private settings: ISettings | null = null;

  constructor() {
    this.settings = null;
  }

  async initialize(settings: ISettings): Promise<void> {
    this.settings = settings;

    if (!this.settings.githubToken) {
      throw new Error('GitHub token not configured');
    }

    // Check for repository path in either githubRepo or repositoryPath
    const repoPath = this.settings.githubRepo || this.settings.repositoryPath;
    if (!repoPath) {
      throw new Error('Repository path not configured');
    }
    
    // Normalize the repository path
    this.settings.repositoryPath = repoPath;
    
    console.log('GitOperations initialized with:', {
      hasToken: !!this.settings.githubToken,
      repositoryPath: this.settings.repositoryPath,
      githubRepo: this.settings.githubRepo
    });
  }

  async saveToRepository(content: string, filename: string, metadata: IDocumentMetadata): Promise<IFileOperationResult> {
    try {
      if (!this.settings) {
        throw new Error('Git operations not initialized');
      }

      // For browser extension, we'll use GitHub API directly
      // since we can't run git commands in the browser
      const result = await this.saveToGitHub(content, filename, metadata);
      
      return {
        success: true,
        filePath: filename,
        size: content.length
      };
    } catch (error) {
      console.error('Failed to save to repository:', error);
      
      // Fallback to local download
      await this.downloadFile(content, filename);
      
      return {
        success: false,
        error: (error as Error).message
      };
    }
  }

  async saveToGitHub(content: string, filename: string, metadata: IDocumentMetadata): Promise<IGitCommitResult> {
    if (!this.settings) {
      throw new Error('Git operations not initialized');
    }

    try {
      const repoInfo = this.parseRepositoryPath(this.settings.repositoryPath);
      const fullPath = this.buildFilePath(filename);
      
      // Check if file already exists
      const existingFile = await this.getFileInfo(repoInfo, fullPath);
      
      // Prepare file content with metadata
      const fileContent = this.prepareFileContent(content, metadata);
        // Create commit options
      const commitOptions: IGitCommitOptions = {
        message: this.generateCommitMessage(metadata, existingFile !== null),
        timestamp: metadata.captureDate
      };

      if (metadata.author) {
        commitOptions.author = metadata.author;
      }      // Create or update the file
      const apiResult = await this.createOrUpdateFile(
        repoInfo,
        fullPath,
        fileContent,
        commitOptions,
        existingFile?.sha
      );

      const result: IGitCommitResult = {
        success: true
      };

      if (apiResult.commit?.sha) {
        result.sha = apiResult.commit.sha;
      }

      if (apiResult.commit?.html_url) {
        result.url = apiResult.commit.html_url;
      }

      return result;
    } catch (error) {
      console.error('GitHub API error:', error);
      return {
        success: false,
        error: (error as Error).message
      };
    }
  }

  private async getFileInfo(repoInfo: IRepositoryInfo, path: string): Promise<IGitHubFileInfo | null> {
    if (!this.settings?.githubToken) {
      throw new Error('GitHub token not available');
    }

    try {
      const response = await fetch(
        `${this.apiBase}/repos/${repoInfo.owner}/${repoInfo.repo}/contents/${path}`,
        {
          method: 'GET',
          headers: {
            'Authorization': `token ${this.settings.githubToken}`,
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'PrismWeave-Extension'
          }
        }
      );

      if (response.status === 404) {
        return null; // File doesn't exist
      }

      if (!response.ok) {
        throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json() as IGitHubFileInfo;
      return data;
    } catch (error) {
      if ((error as Error).message.includes('404')) {
        return null;
      }
      throw error;
    }
  }

  private async createOrUpdateFile(
    repoInfo: IRepositoryInfo,
    path: string,
    content: string,
    commitOptions: IGitCommitOptions,
    existingSha?: string
  ): Promise<IGitHubApiResponse> {
    if (!this.settings?.githubToken) {
      throw new Error('GitHub token not available');
    }

    const encodedContent = btoa(unescape(encodeURIComponent(content)));
    
    const requestBody: any = {
      message: commitOptions.message,
      content: encodedContent,
      branch: 'main' // Default to main branch
    };

    // Include SHA if updating existing file
    if (existingSha) {
      requestBody.sha = existingSha;
    }

    // Add author information if available
    if (commitOptions.author) {
      requestBody.author = {
        name: commitOptions.author,
        email: 'prismweave@example.com' // Default email
      };
    }

    const response = await fetch(
      `${this.apiBase}/repos/${repoInfo.owner}/${repoInfo.repo}/contents/${path}`,
      {
        method: 'PUT',
        headers: {
          'Authorization': `token ${this.settings.githubToken}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json',
          'User-Agent': 'PrismWeave-Extension'
        },
        body: JSON.stringify(requestBody)
      }
    );

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`GitHub API error: ${response.status} ${response.statusText} - ${errorText}`);
    }

    return await response.json() as IGitHubApiResponse;
  }

  private parseRepositoryPath(repoPath: string): IRepositoryInfo {
    // Handle different repository path formats
    let cleanPath = repoPath;
    
    // Remove GitHub URL prefixes if present
    cleanPath = cleanPath.replace(/^https?:\/\/github\.com\//, '');
    cleanPath = cleanPath.replace(/\.git$/, '');
    
    const parts = cleanPath.split('/');
    
    if (parts.length < 2) {
      throw new Error('Invalid repository path format. Expected: owner/repo');
    }
    
    return {
      owner: parts[0],
      repo: parts[1]
    };
  }

  private buildFilePath(filename: string): string {
    if (!this.settings) {
      throw new Error('Settings not initialized');
    }

    const documentPath = this.settings.documentPath || 'documents';
    
    // Ensure proper path separators
    const cleanDocumentPath = documentPath.replace(/^\/+|\/+$/g, '');
    const cleanFilename = filename.replace(/^\/+/, '');
    
    return cleanDocumentPath ? `${cleanDocumentPath}/${cleanFilename}` : cleanFilename;
  }

  private prepareFileContent(content: string, metadata: IDocumentMetadata): string {
    // Add frontmatter with metadata
    const frontmatter = this.generateFrontmatter(metadata);
    
    return `${frontmatter}\n${content}`;
  }

  private generateFrontmatter(metadata: IDocumentMetadata): string {
    const frontmatterData: Record<string, any> = {
      title: metadata.title,
      url: metadata.url,
      captured: metadata.captureDate,
      tags: metadata.tags
    };

    if (metadata.author) {
      frontmatterData.author = metadata.author;
    }

    if (metadata.wordCount) {
      frontmatterData.wordCount = metadata.wordCount;
    }

    if (metadata.estimatedReadingTime) {
      frontmatterData.readingTime = `${metadata.estimatedReadingTime} min`;
    }

    let frontmatter = '---\n';
    
    Object.entries(frontmatterData).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        frontmatter += `${key}:\n`;
        value.forEach(item => {
          frontmatter += `  - ${item}\n`;
        });
      } else {
        frontmatter += `${key}: ${JSON.stringify(value)}\n`;
      }
    });
    
    frontmatter += '---';
    
    return frontmatter;
  }

  private generateCommitMessage(metadata: IDocumentMetadata, isUpdate: boolean): string {
    const action = isUpdate ? 'Update' : 'Add';
    const domain = this.extractDomain(metadata.url);
    
    return `${action} captured content: ${metadata.title} (${domain})`;
  }

  private extractDomain(url: string): string {
    try {
      const urlObj = new URL(url);
      return urlObj.hostname.replace(/^www\./, '');
    } catch {
      return 'unknown';
    }
  }

  private async downloadFile(content: string, filename: string): Promise<void> {
    try {
      const blob = new Blob([content], { type: 'text/markdown' });
      const url = URL.createObjectURL(blob);
      
      // Create a temporary download link
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.style.display = 'none';
      
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      // Clean up the object URL
      URL.revokeObjectURL(url);
      
      console.log('File downloaded as fallback:', filename);
    } catch (error) {
      console.error('Failed to download file:', error);
      throw error;
    }
  }

  // Public utility methods
  async testConnection(): Promise<{ success: boolean; error?: string }> {
    if (!this.settings) {
      return { success: false, error: 'Git operations not initialized' };
    }

    try {
      const repoInfo = this.parseRepositoryPath(this.settings.repositoryPath);
      
      const response = await fetch(
        `${this.apiBase}/repos/${repoInfo.owner}/${repoInfo.repo}`,
        {
          method: 'GET',
          headers: {
            'Authorization': `token ${this.settings.githubToken}`,
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'PrismWeave-Extension'
          }
        }
      );

      if (response.ok) {
        return { success: true };
      } else {
        return { 
          success: false, 
          error: `GitHub API error: ${response.status} ${response.statusText}` 
        };
      }
    } catch (error) {
      return { 
        success: false, 
        error: (error as Error).message 
      };
    }
  }

  async listFiles(path: string = ''): Promise<Array<{ name: string; type: 'file' | 'dir'; size?: number }>> {
    if (!this.settings) {
      throw new Error('Git operations not initialized');
    }

    try {
      const repoInfo = this.parseRepositoryPath(this.settings.repositoryPath);
      const fullPath = this.buildFilePath(path);
      
      const response = await fetch(
        `${this.apiBase}/repos/${repoInfo.owner}/${repoInfo.repo}/contents/${fullPath}`,
        {
          method: 'GET',
          headers: {
            'Authorization': `token ${this.settings.githubToken}`,
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'PrismWeave-Extension'
          }
        }
      );

      if (!response.ok) {
        throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      
      if (Array.isArray(data)) {
        return data.map(item => ({
          name: item.name,
          type: item.type === 'dir' ? 'dir' : 'file',
          size: item.size
        }));
      } else {
        // Single file
        return [{
          name: data.name,
          type: 'file',
          size: data.size
        }];
      }
    } catch (error) {
      console.error('Failed to list files:', error);
      throw error;
    }
  }

  getRepositoryUrl(): string | null {
    if (!this.settings?.repositoryPath) {
      return null;
    }

    try {
      const repoInfo = this.parseRepositoryPath(this.settings.repositoryPath);
      return `https://github.com/${repoInfo.owner}/${repoInfo.repo}`;
    } catch {
      return null;
    }
  }

  async createRepository(name: string, description?: string): Promise<IGitCommitResult> {
    if (!this.settings?.githubToken) {
      throw new Error('GitHub token not available');
    }

    try {
      const requestBody = {
        name,
        description: description || 'PrismWeave document repository',
        private: false,
        auto_init: true,
        gitignore_template: 'Node'
      };

      const response = await fetch(
        `${this.apiBase}/user/repos`,
        {
          method: 'POST',
          headers: {
            'Authorization': `token ${this.settings.githubToken}`,
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json',
            'User-Agent': 'PrismWeave-Extension'
          },
          body: JSON.stringify(requestBody)
        }
      );

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`GitHub API error: ${response.status} ${response.statusText} - ${errorText}`);
      }

      const data = await response.json();
      
      return {
        success: true,
        url: data.html_url
      };
    } catch (error) {
      return {
        success: false,
        error: (error as Error).message
      };
    }
  }
}
