// Generated by Copilot
// PrismWeave Git Operations - TypeScript version
// Handles Git repository management and synchronization

import { createLogger } from './logger';
const logger = createLogger('GitOperations');

import {
  IDocumentMetadata,
  IFileOperationResult,
  IGitCommitOptions,
  ISettings,
} from '../types/index.js';

interface IGitHubApiResponse {
  sha?: string;
  content?: string;
  message?: string;
  commit?: {
    sha: string;
    html_url: string;
  };
}

interface IGitHubFileInfo {
  sha: string;
  content: string;
  encoding: string;
}

interface IRepositoryInfo {
  owner: string;
  repo: string;
}

interface IGitCommitResult {
  success: boolean;
  sha?: string;
  url?: string;
  error?: string;
}

export class GitOperations {
  private readonly apiBase: string = 'https://api.github.com';
  private settings: ISettings | null = null;

  private readonly folderMapping: Record<string, string[]> = {
    tech: [
      'programming',
      'software',
      'coding',
      'development',
      'technology',
      'tech',
      'javascript',
      'python',
      'react',
      'node',
      'github',
      'stackoverflow',
      'dev.to',
      'css',
      'html',
      'typescript',
      'api',
      'framework',
      'library',
    ],
    business: [
      'business',
      'marketing',
      'finance',
      'startup',
      'entrepreneur',
      'sales',
      'management',
      'strategy',
      'linkedin',
      'enterprise',
      'corporate',
      'economics',
      'market',
      'revenue',
      'profit',
    ],
    tutorial: [
      'tutorial',
      'guide',
      'how-to',
      'learn',
      'course',
      'lesson',
      'walkthrough',
      'step-by-step',
      'instructions',
      'tips',
      'howto',
      'example',
    ],
    news: [
      'news',
      'article',
      'blog',
      'opinion',
      'analysis',
      'update',
      'announcement',
      'breaking',
      'report',
      'current',
      'events',
    ],
    research: [
      'research',
      'study',
      'paper',
      'academic',
      'journal',
      'thesis',
      'analysis',
      'data',
      'science',
      'experiment',
      'findings',
      'methodology',
    ],
    design: [
      'design',
      'ui',
      'ux',
      'css',
      'figma',
      'adobe',
      'creative',
      'visual',
      'art',
      'layout',
      'typography',
      'color',
      'interface',
    ],
    tools: [
      'tool',
      'utility',
      'software',
      'app',
      'service',
      'platform',
      'extension',
      'plugin',
      'resource',
      'toolkit',
    ],
    personal: [
      'personal',
      'diary',
      'journal',
      'thoughts',
      'reflection',
      'life',
      'experience',
      'blog',
      'opinion',
    ],
    reference: [
      'reference',
      'documentation',
      'manual',
      'spec',
      'api',
      'docs',
      'wiki',
      'handbook',
      'guide',
    ],
  };

  constructor() {
    this.settings = null;
  }

  async initialize(settings: ISettings): Promise<void> {
    logger.info('Starting initialization...');
    this.settings = settings;

    if (!this.settings.githubToken) {
      logger.error('GitHub token not configured');
      throw new Error('GitHub token not configured');
    }

    // Check for repository path
    if (!this.settings.githubRepo) {
      logger.error('GitHub repository not configured');
      throw new Error('GitHub repository not configured');
    }

    logger.info('Initialized with:', {
      hasToken: !!this.settings.githubToken,
      tokenLength: this.settings.githubToken?.length || 0,
      githubRepo: this.settings.githubRepo,
      defaultFolder: this.settings.defaultFolder,
    });
  }

  async saveToRepository(
    content: string,
    filename: string,
    metadata: IDocumentMetadata
  ): Promise<IFileOperationResult> {
    try {
      if (!this.settings) {
        throw new Error('Git operations not initialized');
      }

      // For browser extension, we'll use GitHub API directly
      // since we can't run git commands in the browser
      const result = await this.saveToGitHub(content, filename, metadata);

      return {
        success: true,
        filePath: filename,
        size: content.length,
      };
    } catch (error) {
      logger.error('Failed to save to repository:', error);

      // Fallback to local download
      await this.downloadFile(content, filename);

      return {
        success: false,
        error: (error as Error).message,
      };
    }
  }
  async saveToGitHub(
    content: string,
    filename: string,
    metadata: IDocumentMetadata
  ): Promise<IGitCommitResult> {
    logger.info('saveToGitHub: Starting save operation:', {
      filename,
      contentLength: content.length,
      title: metadata.title,
      url: metadata.url,
    });

    if (!this.settings) {
      logger.error('saveToGitHub: Git operations not initialized');
      throw new Error('Git operations not initialized');
    }

    try {
      const repoInfo = this.parseRepositoryPath(this.settings.githubRepo);
      logger.debug('saveToGitHub: Parsed repository info:', repoInfo);

      // Use FileManager to determine folder and build proper path
      const folder = this.determineFolder(metadata);
      const fullPath = this.buildFilePathWithFolder(filename, folder);
      logger.debug('saveToGitHub: Determined path:', {
        folder,
        fullPath,
        filename,
      });

      // Check if file already exists
      logger.debug('saveToGitHub: Checking if file exists at:', fullPath);
      const existingFile = await this.getFileInfo(repoInfo, fullPath);

      // Prepare file content with metadata
      const fileContent = this.prepareFileContent(content, metadata);
      logger.debug('saveToGitHub: Prepared file content:', {
        originalLength: content.length,
        withFrontmatterLength: fileContent.length,
        hasExistingFile: !!existingFile,
        existingFileSha: existingFile?.sha,
      });

      // Create commit options
      const commitOptions: IGitCommitOptions = {
        message: this.generateCommitMessage(metadata, existingFile !== null),
        timestamp: metadata.captureDate,
      };

      if (metadata.author) {
        commitOptions.author = metadata.author;
      }

      logger.debug('saveToGitHub: Commit options:', commitOptions);

      // Debug logging for file overwrite
      if (existingFile) {
        logger.info('Updating existing file with SHA:', existingFile.sha);
        logger.info('File exists - will perform UPDATE operation');
      } else {
        logger.info('Creating new file at path:', fullPath);
        logger.info('File does not exist - will perform CREATE operation');
      }

      // Create or update the file
      logger.debug('saveToGitHub: Calling createOrUpdateFile...');
      const apiResult = await this.createOrUpdateFile(
        repoInfo,
        fullPath,
        fileContent,
        commitOptions,
        existingFile?.sha
      );

      logger.debug('saveToGitHub: API result received:', {
        hasCommit: !!apiResult.commit,
        commitSha: apiResult.commit?.sha,
        commitUrl: apiResult.commit?.html_url,
      });

      const result: IGitCommitResult = {
        success: true,
      };

      if (apiResult.commit?.sha) {
        result.sha = apiResult.commit.sha;
      }

      if (apiResult.commit?.html_url) {
        result.url = apiResult.commit.html_url;
      }

      logger.info('saveToGitHub: Operation completed successfully:', result);
      return result;
    } catch (error) {
      logger.error('saveToGitHub: Error occurred:', error);

      // Provide more specific error messages for common issues
      const errorMessage = (error as Error).message;
      logger.debug('saveToGitHub: Analyzing error message:', errorMessage);

      if (errorMessage.includes('409') || errorMessage.includes('Conflict')) {
        logger.warn('saveToGitHub: File update conflict detected');
        return {
          success: false,
          error: `File update conflict: ${errorMessage}. This usually means the file was modified since we last checked it.`,
        };
      } else if (errorMessage.includes('422')) {
        logger.warn('saveToGitHub: Invalid request detected');
        return {
          success: false,
          error: `Invalid request: ${errorMessage}. Check your GitHub token permissions and repository access.`,
        };
      } else if (errorMessage.includes('404')) {
        logger.warn('saveToGitHub: Repository not found');
        return {
          success: false,
          error: `Repository not found: ${errorMessage}. Verify the repository path and permissions.`,
        };
      }

      logger.error('saveToGitHub: Unhandled error type');
      return {
        success: false,
        error: (error as Error).message,
      };
    }
  }

  private async getFileInfo(
    repoInfo: IRepositoryInfo,
    path: string
  ): Promise<IGitHubFileInfo | null> {
    logger.debug('getFileInfo: Fetching file info for:', {
      owner: repoInfo.owner,
      repo: repoInfo.repo,
      path,
    });

    if (!this.settings?.githubToken) {
      logger.error('getFileInfo: GitHub token not available');
      throw new Error('GitHub token not available');
    }

    try {
      logger.debug('getFileInfo: Making API request to GitHub...');
      const response = await fetch(
        `${this.apiBase}/repos/${repoInfo.owner}/${repoInfo.repo}/contents/${path}`,
        {
          method: 'GET',
          headers: {
            Authorization: `token ${this.settings.githubToken}`,
            Accept: 'application/vnd.github.v3+json',
            'User-Agent': 'PrismWeave-Extension',
          },
        }
      );

      logger.debug('getFileInfo: GitHub API response status:', response.status);

      if (response.status === 404) {
        logger.debug('getFileInfo: File not found (404), returning null');
        return null; // File doesn't exist
      }

      if (!response.ok) {
        logger.error('getFileInfo: API error response:', {
          status: response.status,
          statusText: response.statusText,
        });
        throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
      }

      const data = (await response.json()) as IGitHubFileInfo;
      logger.debug('getFileInfo: File info retrieved successfully:', {
        sha: data.sha,
        hasContent: !!data.content,
        encoding: data.encoding,
        contentLength: data.content ? data.content.length : 0,
      });

      // Validate that we have the required SHA for file updates
      if (!data.sha) {
        logger.warn('getFileInfo: GitHub API returned file info without SHA:', data);
        throw new Error('Invalid file info from GitHub: missing SHA');
      }

      logger.debug('getFileInfo: Validation passed, SHA available for file updates');
      return data;
    } catch (error) {
      logger.error('getFileInfo: Error during operation:', error);

      if ((error as Error).message.includes('404')) {
        logger.debug('getFileInfo: Treating 404 error as file not found');
        return null;
      }
      throw error;
    }
  }

  private async createOrUpdateFile(
    repoInfo: IRepositoryInfo,
    path: string,
    content: string,
    commitOptions: IGitCommitOptions,
    existingSha?: string
  ): Promise<IGitHubApiResponse> {
    logger.debug('createOrUpdateFile: Starting operation:', {
      owner: repoInfo.owner,
      repo: repoInfo.repo,
      path,
      contentLength: content.length,
      commitMessage: commitOptions.message,
      hasExistingSha: !!existingSha,
      existingSha: existingSha || 'none',
      operation: existingSha ? 'UPDATE' : 'CREATE',
    });

    if (!this.settings?.githubToken) {
      logger.error('createOrUpdateFile: GitHub token not available');
      throw new Error('GitHub token not available');
    }

    logger.debug('createOrUpdateFile: Encoding content for GitHub API...');
    const encodedContent = btoa(unescape(encodeURIComponent(content)));
    logger.debug('createOrUpdateFile: Content encoded successfully:', {
      originalLength: content.length,
      encodedLength: encodedContent.length,
    });

    const requestBody: any = {
      message: commitOptions.message,
      content: encodedContent,
      branch: 'main', // Default to main branch
    };

    // Include SHA if updating existing file
    if (existingSha) {
      requestBody.sha = existingSha;
      logger.info('createOrUpdateFile: Including SHA for file update:', existingSha);
      logger.info('createOrUpdateFile: This will OVERWRITE the existing file');
    } else {
      logger.info('createOrUpdateFile: Creating new file (no SHA provided)');
      logger.info('createOrUpdateFile: This will CREATE a new file');
    }

    // Add author information if available
    if (commitOptions.author) {
      requestBody.author = {
        name: commitOptions.author,
        email: 'prismweave@example.com', // Default email
      };
      logger.debug('createOrUpdateFile: Added author info:', commitOptions.author);
    }

    logger.debug('createOrUpdateFile: Prepared request body:', {
      hasMessage: !!requestBody.message,
      hasContent: !!requestBody.content,
      hasSha: !!requestBody.sha,
      hasAuthor: !!requestBody.author,
      branch: requestBody.branch,
    });

    logger.debug('createOrUpdateFile: Making PUT request to GitHub API...');
    const response = await fetch(
      `${this.apiBase}/repos/${repoInfo.owner}/${repoInfo.repo}/contents/${path}`,
      {
        method: 'PUT',
        headers: {
          Authorization: `token ${this.settings.githubToken}`,
          Accept: 'application/vnd.github.v3+json',
          'Content-Type': 'application/json',
          'User-Agent': 'PrismWeave-Extension',
        },
        body: JSON.stringify(requestBody),
      }
    );

    logger.debug('createOrUpdateFile: GitHub API response received:', {
      status: response.status,
      statusText: response.statusText,
      ok: response.ok,
    });

    if (!response.ok) {
      const errorText = await response.text();
      logger.error('createOrUpdateFile: GitHub API error details:', {
        status: response.status,
        statusText: response.statusText,
        error: errorText,
        requestPath: path,
        hasSha: !!existingSha,
        operation: existingSha ? 'UPDATE' : 'CREATE',
      });
      throw new Error(`GitHub API error: ${response.status} ${response.statusText} - ${errorText}`);
    }

    logger.debug('createOrUpdateFile: Request successful, parsing response...');
    const result = (await response.json()) as IGitHubApiResponse;
    logger.info('createOrUpdateFile: Operation completed successfully:', {
      hasCommit: !!result.commit,
      commitSha: result.commit?.sha,
      commitUrl: result.commit?.html_url,
      operation: existingSha ? 'FILE_UPDATED' : 'FILE_CREATED',
    });

    return result;
  }

  private parseRepositoryPath(repoPath: string): IRepositoryInfo {
    // Handle different repository path formats
    let cleanPath = repoPath;

    // Remove GitHub URL prefixes if present
    cleanPath = cleanPath.replace(/^https?:\/\/github\.com\//, '');
    cleanPath = cleanPath.replace(/\.git$/, '');

    const parts = cleanPath.split('/');

    if (parts.length < 2) {
      throw new Error('Invalid repository path format. Expected: owner/repo');
    }

    return {
      owner: parts[0],
      repo: parts[1],
    };
  }
  private buildFilePath(filename: string): string {
    if (!this.settings) {
      throw new Error('Settings not initialized');
    }

    const documentPath = 'documents';

    // Ensure proper path separators
    const cleanDocumentPath = documentPath.replace(/^\/+|\/+$/g, '');
    const cleanFilename = filename.replace(/^\/+/, '');

    return cleanDocumentPath ? `${cleanDocumentPath}/${cleanFilename}` : cleanFilename;
  }

  private prepareFileContent(content: string, metadata: IDocumentMetadata): string {
    // Add frontmatter with metadata
    const frontmatter = this.generateFrontmatter(metadata);

    return `${frontmatter}\n${content}`;
  }

  private generateFrontmatter(metadata: IDocumentMetadata): string {
    const frontmatterData: Record<string, any> = {
      title: metadata.title,
      url: metadata.url,
      captured: metadata.captureDate,
      tags: metadata.tags,
    };

    if (metadata.author) {
      frontmatterData.author = metadata.author;
    }

    if (metadata.wordCount) {
      frontmatterData.wordCount = metadata.wordCount;
    }

    if (metadata.estimatedReadingTime) {
      frontmatterData.readingTime = `${metadata.estimatedReadingTime} min`;
    }

    let frontmatter = '---\n';

    Object.entries(frontmatterData).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        frontmatter += `${key}:\n`;
        value.forEach(item => {
          frontmatter += `  - ${item}\n`;
        });
      } else {
        frontmatter += `${key}: ${JSON.stringify(value)}\n`;
      }
    });

    frontmatter += '---';

    return frontmatter;
  }

  private generateCommitMessage(metadata: IDocumentMetadata, isUpdate: boolean): string {
    const action = isUpdate ? 'Update' : 'Add';
    const domain = this.extractDomain(metadata.url);

    return `${action} captured content: ${metadata.title} (${domain})`;
  }

  private extractDomain(url: string): string {
    try {
      const urlObj = new URL(url);
      return urlObj.hostname.replace(/^www\./, '');
    } catch {
      return 'unknown';
    }
  }

  private async downloadFile(content: string, filename: string): Promise<void> {
    try {
      const blob = new Blob([content], { type: 'text/markdown' });
      const url = URL.createObjectURL(blob);

      // Create a temporary download link
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.style.display = 'none';

      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);

      // Clean up the object URL
      URL.revokeObjectURL(url);

      console.log('File downloaded as fallback:', filename);
    } catch (error) {
      console.error('Failed to download file:', error);
      throw error;
    }
  }

  // Folder classification logic integrated into GitOperations
  private determineFolder(metadata: IDocumentMetadata): string {
    console.log('GitOperations.determineFolder: Determining folder for document:', {
      title: metadata.title,
      url: metadata.url,
      tags: metadata.tags,
      hasSettings: !!this.settings,
    });

    if (!this.settings) {
      console.log('GitOperations.determineFolder: No settings available, using "unsorted"');
      return 'unsorted';
    }

    console.log('GitOperations.determineFolder: Settings available:', {
      defaultFolder: this.settings.defaultFolder,
      hasCustomFolder: !!this.settings.customFolder,
    });

    // Use explicit folder setting if provided
    if (
      this.settings.defaultFolder &&
      this.settings.defaultFolder !== 'auto' &&
      this.settings.defaultFolder !== 'custom'
    ) {
      console.log(
        'GitOperations.determineFolder: Using explicit folder setting:',
        this.settings.defaultFolder
      );
      return this.settings.defaultFolder;
    }

    if (this.settings.defaultFolder === 'custom' && this.settings.customFolder) {
      const sanitizedFolder = this.sanitizeFolderName(this.settings.customFolder);
      console.log('GitOperations.determineFolder: Using custom folder:', {
        original: this.settings.customFolder,
        sanitized: sanitizedFolder,
      });
      return sanitizedFolder;
    }

    // Auto-detect folder based on content
    console.log('GitOperations.determineFolder: Auto-detecting folder based on content...');
    const detectedFolder = this.autoDetectFolder(metadata);
    const finalFolder = detectedFolder || 'unsorted';
    console.log('GitOperations.determineFolder: Final folder determined:', {
      detected: detectedFolder,
      final: finalFolder,
    });
    return finalFolder;
  }

  private autoDetectFolder(metadata: IDocumentMetadata): string | null {
    const searchText = [
      metadata.title.toLowerCase(),
      metadata.url.toLowerCase(),
      ...metadata.tags.map(tag => tag.toLowerCase()),
    ].join(' ');

    // Score each folder based on keyword matches
    const folderScores: Record<string, number> = {};

    Object.entries(this.folderMapping).forEach(([folder, keywords]) => {
      let score = 0;
      keywords.forEach(keyword => {
        const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
        const matches = searchText.match(regex);
        if (matches) {
          score += matches.length;
        }
      });

      if (score > 0) {
        folderScores[folder] = score;
      }
    });

    // Return folder with highest score
    const bestFolder = Object.entries(folderScores).sort(([, a], [, b]) => b - a)[0];

    return bestFolder ? bestFolder[0] : null;
  }

  private sanitizeFolderName(folderName: string): string {
    return folderName
      .toLowerCase()
      .replace(/[^\w\s-]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');
  }
  private buildFilePathWithFolder(filename: string, folder: string): string {
    console.log('GitOperations.buildFilePathWithFolder: Building file path:', {
      filename,
      folder,
      hasSettings: !!this.settings,
    });

    if (!this.settings) {
      console.error('GitOperations.buildFilePathWithFolder: Settings not initialized');
      throw new Error('Settings not initialized');
    }

    const documentPath = 'documents';

    // Ensure proper path separators
    const cleanDocumentPath = documentPath.replace(/^\/+|\/+$/g, '');
    const cleanFolder = folder.replace(/^\/+|\/+$/g, '');
    const cleanFilename = filename.replace(/^\/+/, '');

    console.log('GitOperations.buildFilePathWithFolder: Path components cleaned:', {
      documentPath: cleanDocumentPath,
      folder: cleanFolder,
      filename: cleanFilename,
    });

    // Build: documents/folder/filename
    const fullPath = `${cleanDocumentPath}/${cleanFolder}/${cleanFilename}`;
    console.log('GitOperations.buildFilePathWithFolder: Final path constructed:', fullPath);

    return fullPath;
  }

  // Public utility methods
  async testConnection(): Promise<{ success: boolean; error?: string }> {
    if (!this.settings) {
      return { success: false, error: 'Git operations not initialized' };
    }
    try {
      const repoInfo = this.parseRepositoryPath(this.settings.githubRepo);

      const response = await fetch(`${this.apiBase}/repos/${repoInfo.owner}/${repoInfo.repo}`, {
        method: 'GET',
        headers: {
          Authorization: `token ${this.settings.githubToken}`,
          Accept: 'application/vnd.github.v3+json',
          'User-Agent': 'PrismWeave-Extension',
        },
      });

      if (response.ok) {
        return { success: true };
      } else {
        return {
          success: false,
          error: `GitHub API error: ${response.status} ${response.statusText}`,
        };
      }
    } catch (error) {
      return {
        success: false,
        error: (error as Error).message,
      };
    }
  }

  async listFiles(
    path: string = ''
  ): Promise<Array<{ name: string; type: 'file' | 'dir'; size?: number }>> {
    if (!this.settings) {
      throw new Error('Git operations not initialized');
    }
    try {
      const repoInfo = this.parseRepositoryPath(this.settings.githubRepo);
      const fullPath = this.buildFilePath(path);

      const response = await fetch(
        `${this.apiBase}/repos/${repoInfo.owner}/${repoInfo.repo}/contents/${fullPath}`,
        {
          method: 'GET',
          headers: {
            Authorization: `token ${this.settings.githubToken}`,
            Accept: 'application/vnd.github.v3+json',
            'User-Agent': 'PrismWeave-Extension',
          },
        }
      );

      if (!response.ok) {
        throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();

      if (Array.isArray(data)) {
        return data.map(item => ({
          name: item.name,
          type: item.type === 'dir' ? 'dir' : 'file',
          size: item.size,
        }));
      } else {
        // Single file
        return [
          {
            name: data.name,
            type: 'file',
            size: data.size,
          },
        ];
      }
    } catch (error) {
      console.error('Failed to list files:', error);
      throw error;
    }
  }
  getRepositoryUrl(): string | null {
    if (!this.settings?.githubRepo) {
      return null;
    }

    try {
      const repoInfo = this.parseRepositoryPath(this.settings.githubRepo);
      return `https://github.com/${repoInfo.owner}/${repoInfo.repo}`;
    } catch {
      return null;
    }
  }

  async createRepository(name: string, description?: string): Promise<IGitCommitResult> {
    if (!this.settings?.githubToken) {
      throw new Error('GitHub token not available');
    }

    try {
      const requestBody = {
        name,
        description: description || 'PrismWeave document repository',
        private: false,
        auto_init: true,
        gitignore_template: 'Node',
      };

      const response = await fetch(`${this.apiBase}/user/repos`, {
        method: 'POST',
        headers: {
          Authorization: `token ${this.settings.githubToken}`,
          Accept: 'application/vnd.github.v3+json',
          'Content-Type': 'application/json',
          'User-Agent': 'PrismWeave-Extension',
        },
        body: JSON.stringify(requestBody),
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(
          `GitHub API error: ${response.status} ${response.statusText} - ${errorText}`
        );
      }

      const data = await response.json();

      return {
        success: true,
        url: data.html_url,
      };
    } catch (error) {
      return {
        success: false,
        error: (error as Error).message,
      };
    }
  }
}
