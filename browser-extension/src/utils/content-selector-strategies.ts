// Generated by Copilot
// Content Selector Strategies - Separated content selection logic
// Implements different strategies for finding main content

export interface IContentSelector {
  readonly name: string;
  readonly selectors: string[];
}

export interface ISelectorStrategy {
  getSelectors(): IContentSelector[];
  isApplicable(url: string, document: Document): boolean;
}

/**
 * Base strategy for general content extraction
 */
export class GeneralContentStrategy implements ISelectorStrategy {
  isApplicable(): boolean {
    return true; // Always applicable as fallback
  }

  getSelectors(): IContentSelector[] {
    return [
      {
        name: 'main-content',
        selectors: [
          'article',
          'main',
          '[role="main"]',
          '.content',
          '.main-content',
          '.entry-content',
          '.post-content',
          '.article-content',
          '.blog-content',
        ],
      },
      {
        name: 'semantic-content',
        selectors: [
          '.article-body',
          '.post-body',
          '.entry-body',
          '.content-body',
          '.article-text',
          '.story-body',
        ],
      },
      {
        name: 'structured-content',
        selectors: [
          '[itemtype*="BlogPosting"]',
          '[itemtype*="Article"]',
          '[data-testid*="content"]',
          '[data-testid*="article"]',
          '[data-testid*="post"]',
        ],
      },
    ];
  }
}

/**
 * Strategy for blog platforms like Simon Willison's blog
 */
export class BlogPlatformStrategy implements ISelectorStrategy {
  isApplicable(url: string): boolean {
    const blogPatterns = [
      'simonwillison.net',
      'blog.',
      '/blog/',
      'medium.com',
      'dev.to',
      'hashnode.com',
      'substack.com',
    ];
    return blogPatterns.some(pattern => url.includes(pattern));
  }

  getSelectors(): IContentSelector[] {
    return [
      {
        name: 'blog-specific',
        selectors: [
          '.entry.entryPage [data-permalink-context]',
          '.entry.entryPage',
          '.entry [data-permalink-context]',
          '[data-permalink-context]',
        ],
      },
      {
        name: 'blog-generic',
        selectors: [
          '.post-content',
          '.blog-content',
          '.entry-content',
          '.article-content',
          '.post-body',
          '.blog-post-content',
        ],
      },
    ];
  }
}

/**
 * Strategy for documentation and technical sites
 */
export class DocumentationStrategy implements ISelectorStrategy {
  isApplicable(url: string): boolean {
    const docPatterns = [
      'docs.',
      '/docs/',
      'documentation',
      'guide',
      'tutorial',
      'docker.com',
      'github.com',
    ];
    return docPatterns.some(pattern => url.includes(pattern));
  }

  getSelectors(): IContentSelector[] {
    return [
      {
        name: 'documentation-specific',
        selectors: [
          '.documentation-content',
          '.tutorial-content',
          '.guide-content',
          '.DockerBlogPost',
          '.docs-content',
        ],
      },
      {
        name: 'technical-content',
        selectors: ['.prose', '.rich-text', '.markdown-body', '.content-wrapper', '.page-content'],
      },
    ];
  }
}

/**
 * Manages and applies content selection strategies
 */
export class ContentSelectorManager {
  private strategies: ISelectorStrategy[] = [
    new BlogPlatformStrategy(),
    new DocumentationStrategy(),
    new GeneralContentStrategy(), // Always last as fallback
  ];

  /**
   * Get prioritized selectors based on URL and document
   */
  getSelectorsForContent(url: string, document: Document): IContentSelector[] {
    for (const strategy of this.strategies) {
      if (strategy.isApplicable(url, document)) {
        const selectors = strategy.getSelectors();
        // Add general selectors as fallback
        if (!(strategy instanceof GeneralContentStrategy)) {
          selectors.push(...new GeneralContentStrategy().getSelectors());
        }
        return selectors;
      }
    }

    return new GeneralContentStrategy().getSelectors();
  }

  /**
   * Find the best content element using prioritized selectors
   */
  findContentElement(url: string, document: Document): Element | null {
    const selectorGroups = this.getSelectorsForContent(url, document);

    for (const group of selectorGroups) {
      for (const selector of group.selectors) {
        try {
          const elements = document.querySelectorAll(selector);
          for (const element of Array.from(elements)) {
            if (this.isValidContentElement(element)) {
              return element;
            }
          }
        } catch (error) {
          console.warn('ContentSelectorManager: Invalid selector:', selector, error);
        }
      }
    }

    return null;
  }

  /**
   * Basic validation for content elements
   */
  private isValidContentElement(element: Element): boolean {
    const text = element.textContent?.trim() || '';
    const minLength = 50;

    if (text.length < minLength) {
      return false;
    }

    // Check for navigation indicators
    const className = element.className.toLowerCase();
    const id = element.id.toLowerCase();
    const navTerms = ['recent', 'related', 'more', 'sidebar', 'navigation', 'nav', 'menu'];

    if (navTerms.some(term => className.includes(term) || id.includes(term))) {
      const paragraphs = element.querySelectorAll('p').length;
      return paragraphs >= 3; // Allow if it has substantial paragraphs
    }

    return true;
  }
}
