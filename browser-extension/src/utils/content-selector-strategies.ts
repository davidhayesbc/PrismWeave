// Generated by Copilot
// Content Selector Strategies - Separated content selection logic
// Implements different strategies for finding main content

import { createLogger } from '../utils/logger';

const logger = createLogger('ContentSelectorStrategies');

export interface IContentSelector {
  readonly name: string;
  readonly selectors: string[];
}

export interface ISelectorStrategy {
  getSelectors(): IContentSelector[];
  isApplicable(url: string, document: Document): boolean;
}

/**
 * Base strategy for general content extraction - Simplified and standardized
 */
export class GeneralContentStrategy implements ISelectorStrategy {
  isApplicable(): boolean {
    return true; // Always applicable as fallback
  }

  getSelectors(): IContentSelector[] {
    return [
      {
        name: 'semantic-html',
        selectors: ['article', 'main', '[role="main"]', '[role="article"]'],
      },
      {
        name: 'common-content-classes',
        selectors: [
          '.content',
          '.main-content',
          '.post-content',
          '.article-content',
          '.blog-content',
          '.entry-content',
          '.post-body',
          '.article-body',
          '.content-body',
        ],
      },
      {
        name: 'content-pattern-matching',
        selectors: [
          // Class-based patterns
          '[class*="content"]:not([class*="sidebar"]):not([class*="nav"]):not([class*="footer"])',
          '[class*="post"]:not([class*="nav"]):not([class*="related"]):not([class*="recent"])',
          '[class*="article"]:not([class*="nav"]):not([class*="related"]):not([class*="recent"])',
          '[class*="entry"]:not([class*="nav"]):not([class*="related"])',

          // ID-based patterns
          '#content',
          '#main-content',
          '#post-content',
          '#article-content',
          '#main',
        ],
      },
      {
        name: 'structured-data',
        selectors: [
          '[itemtype*="BlogPosting"]',
          '[itemtype*="Article"]',
          '[itemtype*="NewsArticle"]',
          '[data-testid*="content"]',
          '[data-testid*="article"]',
          '[data-testid*="post"]',
        ],
      },
    ];
  }
}

/**
 * Strategy for Substack newsletters and posts - Simplified for 2025
 */
export class SubstackStrategy implements ISelectorStrategy {
  isApplicable(url: string): boolean {
    return url.includes('substack.com');
  }

  getSelectors(): IContentSelector[] {
    return [
      {
        name: 'substack-primary',
        selectors: [
          // Primary 2025 Substack selectors (most reliable)
          '.available-content',
          '.available-content .body.markup',
          '.body.markup',
          '.markup',
        ],
      },
      {
        name: 'substack-article-structure',
        selectors: [
          'article .available-content',
          'article .body.markup',
          'article .markup',
          'main .available-content',
          'main .markup',
          '[role="main"] .available-content',
        ],
      },
      {
        name: 'substack-fallback',
        selectors: [
          '.post-content',
          '.post-body',
          '[data-testid="post-content"]',
          '[class*="available-content"]',
          '[class*="post-content"]',
          '.publication-content',
          '.newsletter-content',
        ],
      },
    ];
  }
}

/**
 * Strategy for modern blog platforms - Simplified and standardized
 */
export class ModernBlogStrategy implements ISelectorStrategy {
  isApplicable(url: string): boolean {
    const modernBlogPatterns = [
      // Modern blog platforms
      'sutro.sh',
      'vercel.com/blog',
      'nextjs.org/blog',
      '/blog/',
      'hashnode.com',
      'dev.to',
      'ghost.org',

      // Traditional blog platforms
      'simonwillison.net',
      'blog.',
      'medium.com',
      'wordpress.com',
    ];
    return modernBlogPatterns.some(pattern => url.includes(pattern));
  }

  getSelectors(): IContentSelector[] {
    return [
      {
        name: 'modern-blog-semantic',
        selectors: [
          // Semantic HTML (highest priority)
          'article',
          'main article',
          '[role="main"] article',
          'main',
          '[role="main"]',
        ],
      },
      {
        name: 'modern-blog-content',
        selectors: [
          // Standard content containers
          '.post-content',
          '.article-content',
          '.blog-content',
          '.entry-content',
          '.content',
          '.main-content',
          '.post-body',
          '.article-body',
        ],
      },
      {
        name: 'modern-framework-patterns',
        selectors: [
          // Tailwind CSS patterns (common in modern blogs)
          '.prose',
          '.prose-lg',
          '.prose-xl',
          '[class*="prose"]',
          '.max-w-4xl',
          '.max-w-3xl',
          '.max-w-2xl',
          '.mx-auto',

          // Next.js/React patterns
          '#__next main',
          '#__next article',
          '[data-reactroot] main',
          '[data-reactroot] article',
        ],
      },
      {
        name: 'blog-specific-legacy',
        selectors: [
          // Simon Willison's blog specific
          '.entry.entryPage [data-permalink-context]',
          '.entry.entryPage',
          '[data-permalink-context]',

          // Generic blog patterns
          '.blog-post-content',
          '.blog-article-body',
          '.entry-content-wrap',
          '.post-container',
          '.article-container',
          '.content-wrapper',
        ],
      },
    ];
  }
}

/**
 * Strategy for Stack Overflow blog and technical sites
 */
export class StackOverflowBlogStrategy implements ISelectorStrategy {
  isApplicable(url: string): boolean {
    return url.includes('stackoverflow.blog') || url.includes('stackoverflow.com/blog');
  }

  getSelectors(): IContentSelector[] {
    return [
      {
        name: 'stackoverflow-blog-specific',
        selectors: [
          // Stack Overflow blog uses these structures
          '.blog-post-content',
          '.post-content',
          '.entry-content',
          '.article-content',
          'article .content',
          'article main',
          '[data-testid="post-content"]',
          // Generic article selectors for SO blog
          'article',
          'main article',
          '.main-content article',
          // Fallback patterns
          '[class*="post"][class*="content"]',
          '[class*="article"][class*="content"]',
          '[id*="post"][id*="content"]',
        ],
      },
    ];
  }
}

/**
 * Strategy for research and AI company content - Simplified and focused
 */
export class ResearchContentStrategy implements ISelectorStrategy {
  isApplicable(url: string): boolean {
    const researchPatterns = [
      'anthropic.com',
      'openai.com',
      'deepmind.com',
      'research.',
      '/research/',
      'arxiv.org',
      'papers.',
    ];
    return researchPatterns.some(pattern => url.includes(pattern));
  }

  getSelectors(): IContentSelector[] {
    return [
      {
        name: 'research-semantic',
        selectors: ['main article', 'article', 'main', '[role="main"]'],
      },
      {
        name: 'research-content',
        selectors: [
          '.research-content',
          '.article-content',
          '.content',
          '.main-content',
          '.paper-content',
          '.study-content',
        ],
      },
      {
        name: 'modern-framework-research',
        selectors: [
          '#__next main',
          '#__next article',
          '[data-reactroot] main',
          '[data-reactroot] article',
          '.container main',
          '.wrapper main',
        ],
      },
      {
        name: 'research-structured',
        selectors: [
          '[data-testid*="content"]',
          '[data-testid*="article"]',
          '[data-testid*="research"]',
          '[itemtype*="Article"]',
          '[itemtype*="ScholarlyArticle"]',
        ],
      },
    ];
  }
}

/**
 * Strategy for documentation and technical sites - Simplified and focused
 */
export class DocumentationStrategy implements ISelectorStrategy {
  isApplicable(url: string): boolean {
    const docPatterns = [
      'docs.',
      '/docs/',
      'documentation',
      'guide',
      'tutorial',
      'docker.com',
      'github.com',
      '.md',
      'readme',
    ];
    return docPatterns.some(pattern => url.includes(pattern));
  }

  getSelectors(): IContentSelector[] {
    return [
      {
        name: 'documentation-semantic',
        selectors: [
          'article',
          'main',
          '[role="main"]',
          '.markdown-body', // GitHub and others
        ],
      },
      {
        name: 'documentation-content',
        selectors: [
          '.documentation-content',
          '.docs-content',
          '.tutorial-content',
          '.guide-content',
          '.content',
          '.main-content',
          '.prose', // Technical documentation often uses this
        ],
      },
      {
        name: 'platform-specific-docs',
        selectors: [
          // Docker blog specific
          '.DockerBlogPost',
          '.post-content',
          '.blog-content',

          // GitHub specific
          '.blob-wrapper',
          '.highlight',
          '.repository-content',

          // Generic technical content
          '.rich-text',
          '.content-wrapper',
          '.page-content',
        ],
      },
      {
        name: 'documentation-structured',
        selectors: [
          '[data-testid*="content"]',
          '[data-testid*="docs"]',
          '[data-testid*="documentation"]',
          '[data-testid*="tutorial"]',
        ],
      },
    ];
  }
}

/**
 * Manages and applies content selection strategies - Simplified and optimized
 */
export class ContentSelectorManager {
  private strategies: ISelectorStrategy[] = [
    new SubstackStrategy(), // Most specific first
    new ResearchContentStrategy(), // Research/AI content
    new ModernBlogStrategy(), // Modern blog platforms
    new StackOverflowBlogStrategy(), // Stack Overflow specific
    new DocumentationStrategy(), // Documentation sites
    new GeneralContentStrategy(), // Always last as fallback
  ];

  /**
   * Get prioritized selectors based on URL and document
   */
  getSelectorsForContent(url: string, document: Document): IContentSelector[] {
    for (const strategy of this.strategies) {
      if (strategy.isApplicable(url, document)) {
        const selectors = strategy.getSelectors();
        logger.debug('ContentSelectorManager: Using strategy:', strategy.constructor.name);
        return selectors;
      }
    }

    logger.debug('ContentSelectorManager: Using fallback strategy');
    return new GeneralContentStrategy().getSelectors();
  }

  /**
   * Find the best content element using prioritized selectors and scoring
   */
  findContentElement(url: string, document: Document): Element | null {
    const selectorGroups = this.getSelectorsForContent(url, document);
    const candidates: Array<{
      element: Element;
      score: number;
      selector: string;
      groupName: string;
    }> = [];

    // Collect all possible candidates with their scores
    for (const group of selectorGroups) {
      for (const selector of group.selectors) {
        try {
          const elements = document.querySelectorAll(selector);
          for (const element of Array.from(elements)) {
            if (this.isValidContentElement(element)) {
              const score = this.scoreContentElement(element, url);
              candidates.push({
                element,
                score,
                selector,
                groupName: group.name,
              });
            }
          }
        } catch (error) {
          logger.warn('ContentSelectorManager: Invalid selector:', selector, error);
        }
      }
    }

    // Return the highest-scoring candidate
    if (candidates.length > 0) {
      candidates.sort((a, b) => b.score - a.score);
      logger.debug('ContentSelectorManager: Best candidate:', {
        groupName: candidates[0].groupName,
        selector: candidates[0].selector,
        score: candidates[0].score,
        className: candidates[0].element.className,
        textLength: candidates[0].element.textContent?.length || 0,
      });
      return candidates[0].element;
    }

    logger.warn('ContentSelectorManager: No suitable content found');
    return null;
  }

  /**
   * Score content elements - Simplified and standardized
   */
  private scoreContentElement(element: Element, url: string): number {
    let score = 0;
    const text = element.textContent?.trim() || '';
    const className = element.className.toLowerCase();
    const id = element.id.toLowerCase();
    const tagName = element.tagName.toLowerCase();

    // Base score from text length (word count approximation)
    const wordCount = text.split(/\s+/).filter(Boolean).length;
    score += Math.min(wordCount / 5, 500); // Up to 500 points for word count

    // Structure bonuses
    const paragraphs = element.querySelectorAll('p').length;
    const headings = element.querySelectorAll('h1, h2, h3, h4, h5, h6').length;
    score += paragraphs * 20;
    score += headings * 30;

    // Semantic HTML bonuses
    const semanticBonuses: Record<string, number> = {
      article: 200,
      main: 150,
      section: 50,
    };
    score += semanticBonuses[tagName] || 0;

    // Role attribute bonuses
    const role = element.getAttribute('role');
    if (role === 'main' || role === 'article') {
      score += 200;
    }

    // Platform-specific scoring
    if (url.includes('substack.com')) {
      score += this.scoreSubstackElement(className);
    } else if (
      url.includes('anthropic.com') ||
      url.includes('research') ||
      url.includes('openai.com')
    ) {
      score += this.scoreResearchElement(className, text);
    } else if (url.includes('sutro.sh') || url.includes('/blog/')) {
      score += this.scoreModernBlogElement(className, tagName);
    }

    // Content quality indicators
    const contentTerms = ['content', 'article', 'post', 'entry', 'main', 'body'];
    contentTerms.forEach(term => {
      if (className.includes(term) || id.includes(term)) {
        score += 80;
      }
    });

    // Navigation/promotional content penalties
    const navTerms = [
      'nav',
      'menu',
      'sidebar',
      'footer',
      'header',
      'advertisement',
      'related',
      'recent',
    ];
    navTerms.forEach(term => {
      if (className.includes(term) || id.includes(term)) {
        score -= 150;
      }
    });

    // Link density penalty (high link-to-text ratio suggests navigation)
    const links = element.querySelectorAll('a').length;
    const linkDensity = links / Math.max(wordCount / 100, 1); // Links per 100 words
    if (linkDensity > 2) {
      // More than 2 links per 100 words
      score -= Math.min(linkDensity * 50, 200);
    }

    // Script/style penalty
    const scripts = element.querySelectorAll('script, style').length;
    score -= scripts * 50;

    return Math.max(0, score);
  }

  /**
   * Platform-specific scoring helpers
   */
  private scoreSubstackElement(className: string): number {
    let score = 0;
    if (className.includes('available-content')) score += 300;
    if (className.includes('body') && className.includes('markup')) score += 250;
    if (className.includes('markup')) score += 200;
    if (className.includes('post-content')) score += 150;
    return score;
  }

  private scoreResearchElement(className: string, text: string): number {
    let score = 0;
    if (className.includes('research')) score += 250;
    if (className.includes('article')) score += 200;
    if (className.includes('content')) score += 150;

    // Research content indicators
    const researchTerms = ['research', 'study', 'experiment', 'analysis', 'methodology'];
    researchTerms.forEach(term => {
      if (text.toLowerCase().includes(term)) score += 40;
    });

    return score;
  }

  private scoreModernBlogElement(className: string, tagName: string): number {
    let score = 0;
    if (className.includes('prose')) score += 150;
    if (className.includes('max-w-')) score += 80; // Tailwind patterns
    if (className.includes('mx-auto')) score += 60;
    if (tagName === 'article') score += 100;
    return score;
  }

  /**
   * Basic validation for content elements - Simplified
   */
  private isValidContentElement(element: Element): boolean {
    const text = element.textContent?.trim() || '';
    const className = element.className.toLowerCase();
    const id = element.id.toLowerCase();

    // Must have minimum content
    if (text.length < 100) return false;

    // Must have some structure (paragraphs or headings)
    const paragraphs = element.querySelectorAll('p').length;
    const headings = element.querySelectorAll('h1, h2, h3, h4, h5, h6').length;
    if (paragraphs < 1 && headings < 1) return false;

    // Reject obvious navigation elements
    const navTerms = ['recent-articles', 'more-recent', 'related-posts', 'navigation', 'menu'];
    if (navTerms.some(term => className.includes(term) || id.includes(term))) {
      return paragraphs >= 5; // Only allow if substantial content
    }

    return true;
  }

  /**
   * Simplified main content finder for backward compatibility
   */
  findMainContent(): Element | null {
    return this.findContentElement(window.location.href, document);
  }
}
