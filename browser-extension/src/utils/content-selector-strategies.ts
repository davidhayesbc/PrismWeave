// Generated by Copilot
// Content Selector Strategies - Separated content selection logic
// Implements different strategies for finding main content

import { createLogger } from '../utils/logger';

const logger = createLogger('ContentSelectorStrategies');

export interface IContentSelector {
  readonly name: string;
  readonly selectors: string[];
}

export interface ISelectorStrategy {
  getSelectors(): IContentSelector[];
  isApplicable(url: string, document: Document): boolean;
}

/**
 * Base strategy for general content extraction - Enhanced with readability selectors
 */
export class GeneralContentStrategy implements ISelectorStrategy {
  isApplicable(): boolean {
    return true; // Always applicable as fallback
  }

  getSelectors(): IContentSelector[] {
    return [
      {
        name: 'primary-content',
        selectors: [
          'article',
          'main',
          '[role="main"]',
          '.content',
          '.main-content',
          '.entry-content',
          '.post-content',
          '.article-content',
          '.blog-content',
        ],
      },
      {
        name: 'readability-selectors',
        selectors: [
          // Enhanced readability selectors from legacy implementation
          'div[class*="content"]',
          'div[class*="post"]',
          'div[class*="article"]',
          'div[class*="entry"]',
          'div[id*="content"]',
          'div[id*="post"]',
          'div[id*="article"]',
          'div[id*="entry"]',
          'section[class*="content"]',
          'section[class*="post"]',
          'section[class*="article"]',
          '.article-body',
          '.post-body',
          '.entry-body',
          '.content-body',
          '.article-text',
          '.story-body',
          '.post-container',
          '.article-container',
          '.blog-container',
          '.content-main',
          '.main-article',
          '.blog-article-body',
          '.entry-content-wrap',
        ],
      },
      {
        name: 'structured-content',
        selectors: [
          '[itemtype*="BlogPosting"]',
          '[itemtype*="Article"]',
          '[data-testid="post-content"]',
          '[data-testid="article-content"]',
          '[data-testid="blog-content"]',
          '[data-content]',
          '[data-article]',
        ],
      },
      {
        name: 'fallback-selectors',
        selectors: [
          '[id*="content"]',
          '[class*="content"]',
          '[class*="article"]',
          '[class*="post"]',
        ],
      },
    ];
  }
}

/**
 * Strategy for Substack newsletters and posts - Enhanced with 2025 structure analysis
 */
export class SubstackStrategy implements ISelectorStrategy {
  isApplicable(url: string): boolean {
    return url.includes('substack.com');
  }

  getSelectors(): IContentSelector[] {
    return [
      {
        name: 'substack-primary-2025',
        selectors: [
          // Primary 2025 Substack content selectors based on latest structure analysis
          '.available-content',
          '.available-content .body',
          '.available-content .body.markup',
          '.available-content .markup',
          // Main post content containers
          '.post-content .available-content',
          '.post .available-content',
          '.post-header + .available-content',
          // Direct content access
          '.body.markup',
          '.markup',
          '.post-body',
          '.post-content',
          // Article structure selectors
          'article .available-content',
          'article .body.markup',
          'article .markup',
          'article .post-content',
          // Specific Substack content patterns
          '[data-testid="post-content"]',
          '[data-testid="available-content"]',
          '[data-testid="post-body"]',
          '[data-component="post-content"]',
        ],
      },
      {
        name: 'substack-enhanced-fallback',
        selectors: [
          // Enhanced fallback patterns for complex Substack layouts
          '[class*="available-content"]',
          '[class*="post-content"]',
          '[class*="body"][class*="markup"]',
          '.post .body',
          '.post-preview .body',
          '.publication-content',
          '.newsletter-content',
          '.content-wrapper',
          // Main structure containers
          'main .available-content',
          'main .post-content',
          'main .markup',
          // Container patterns
          '[role="main"] .available-content',
          '[role="main"] .markup',
          '#main .available-content',
          // Broad content patterns
          '.content',
          '.main-content',
          'main',
          'article',
          // Substack-specific class patterns
          '[class*="frontend"][class*="components"] .available-content',
          '[class*="post"][class*="detail"]',
        ],
      },
      {
        name: 'substack-text-content',
        selectors: [
          // Focus on text-heavy containers for better content extraction
          '.available-content p',
          '.markup p',
          '.body.markup p',
          // Multiple paragraph containers
          'div:has(> p):has(> h1, > h2, > h3)',
          'section:has(> p):has(> h1, > h2, > h3)',
          // Content blocks with headings
          '[class*="content"]:has(h1, h2, h3)',
          '[class*="post"]:has(h1, h2, h3)',
          '[class*="article"]:has(h1, h2, h3)',
        ],
      },
    ];
  }
}

/**
 * Strategy for blog platforms like Simon Willison's blog - Enhanced with specific selectors
 */
export class BlogPlatformStrategy implements ISelectorStrategy {
  isApplicable(url: string): boolean {
    const blogPatterns = [
      'simonwillison.net',
      'blog.',
      '/blog/',
      'medium.com',
      'dev.to',
      'hashnode.com',
      'substack.com',
      'wordpress.com',
      'ghost.org',
    ];
    return blogPatterns.some(pattern => url.includes(pattern));
  }

  getSelectors(): IContentSelector[] {
    return [
      {
        name: 'substack-enhanced-specific',
        selectors: [
          // Enhanced 2025 Substack post content containers
          '.available-content',
          '.available-content .body',
          '.available-content .body.markup',
          '.available-content .markup',
          '.post-content .available-content',
          '.post .available-content',
          '.post-header + .available-content',
          '.body.markup',
          '.markup',
          '.post-body',
          '.post-content',
          '[class*="available-content"]',
          '[class*="post-content"]',
          '[class*="body"][class*="markup"]',
          '.post .body',
          '.available-content .body',
          '.post-preview .body',
          // Substack article structure
          'article .available-content',
          'article .post-content',
          'article .body.markup',
          'article .markup',
          // Alternative Substack patterns
          '[data-testid="post-content"]',
          '[data-testid="available-content"]',
          '[data-testid="article-body"]',
          '[data-component="post-content"]',
          '.publication-content',
          '.newsletter-content',
          '.post-body-content',
          '.content-wrapper',
          // Main structure
          'main .available-content',
          'main .post-content',
          'main .markup',
          '[role="main"] .available-content',
          '[role="main"] .markup',
        ],
      },
      {
        name: 'simon-willison-specific',
        selectors: [
          '.entry.entryPage [data-permalink-context]',
          '.entry.entryPage',
          '.entry [data-permalink-context]',
          '[data-permalink-context]',
        ],
      },
      {
        name: 'blog-generic',
        selectors: [
          '.post-content',
          '.blog-content',
          '.entry-content',
          '.article-content',
          '.post-body',
          '.blog-post-content',
          '.blog-article-body',
          '.entry-content-wrap',
        ],
      },
    ];
  }
}

/**
 * Strategy for Stack Overflow blog and technical sites
 */
export class StackOverflowBlogStrategy implements ISelectorStrategy {
  isApplicable(url: string): boolean {
    return url.includes('stackoverflow.blog') || url.includes('stackoverflow.com/blog');
  }

  getSelectors(): IContentSelector[] {
    return [
      {
        name: 'stackoverflow-blog-specific',
        selectors: [
          // Stack Overflow blog uses these structures
          '.blog-post-content',
          '.post-content',
          '.entry-content',
          '.article-content',
          'article .content',
          'article main',
          '[data-testid="post-content"]',
          // Generic article selectors for SO blog
          'article',
          'main article',
          '.main-content article',
          // Fallback patterns
          '[class*="post"][class*="content"]',
          '[class*="article"][class*="content"]',
          '[id*="post"][id*="content"]',
        ],
      },
    ];
  }
}

/**
 * Strategy for documentation and technical sites - Enhanced with Docker-specific patterns
 */
export class DocumentationStrategy implements ISelectorStrategy {
  isApplicable(url: string): boolean {
    const docPatterns = [
      'docs.',
      '/docs/',
      'documentation',
      'guide',
      'tutorial',
      'docker.com',
      'github.com',
    ];
    return docPatterns.some(pattern => url.includes(pattern));
  }

  getSelectors(): IContentSelector[] {
    return [
      {
        name: 'docker-specific',
        selectors: [
          '.DockerBlogPost',
          '.post-content',
          '.entry-content',
          '.article-content',
          '.blog-content',
          '[data-testid="post-content"]',
          '[data-testid="article-content"]',
          '[data-testid="blog-content"]',
        ],
      },
      {
        name: 'documentation-specific',
        selectors: [
          '.documentation-content',
          '.tutorial-content',
          '.guide-content',
          '.docs-content',
          '.content-wrapper',
          '.page-content',
        ],
      },
      {
        name: 'technical-content',
        selectors: ['.prose', '.rich-text', '.markdown-body', '.content-main', '.main-article'],
      },
    ];
  }
}

/**
 * Manages and applies content selection strategies
 */
export class ContentSelectorManager {
  private strategies: ISelectorStrategy[] = [
    new StackOverflowBlogStrategy(),
    new BlogPlatformStrategy(),
    new DocumentationStrategy(),
    new GeneralContentStrategy(), // Always last as fallback
  ];

  /**
   * Get prioritized selectors based on URL and document
   */
  getSelectorsForContent(url: string, document: Document): IContentSelector[] {
    for (const strategy of this.strategies) {
      if (strategy.isApplicable(url, document)) {
        const selectors = strategy.getSelectors();
        // Add general selectors as fallback
        if (!(strategy instanceof GeneralContentStrategy)) {
          selectors.push(...new GeneralContentStrategy().getSelectors());
        }
        return selectors;
      }
    }

    return new GeneralContentStrategy().getSelectors();
  }

  /**
   * Find the best content element using prioritized selectors and scoring
   */
  findContentElement(url: string, document: Document): Element | null {
    const selectorGroups = this.getSelectorsForContent(url, document);
    const candidates: Array<{ element: Element; score: number; selector: string }> = [];

    // Collect all possible candidates with their scores
    for (const group of selectorGroups) {
      for (const selector of group.selectors) {
        try {
          const elements = document.querySelectorAll(selector);
          for (const element of Array.from(elements)) {
            if (this.isValidContentElement(element)) {
              const score = this.scoreContentElement(element);
              candidates.push({ element, score, selector });
            }
          }
        } catch (error) {
          logger.warn('ContentSelectorManager: Invalid selector:', selector, error);
        }
      }
    }

    // Return the highest-scoring candidate
    if (candidates.length > 0) {
      candidates.sort((a, b) => b.score - a.score);
      logger.debug('ContentSelectorManager: Best candidate:', {
        selector: candidates[0].selector,
        score: candidates[0].score,
        className: candidates[0].element.className,
      });
      return candidates[0].element;
    }

    return null;
  }

  /**
   * Score content elements using sophisticated algorithm from legacy implementation
   * Enhanced with Substack-specific scoring
   */
  private scoreContentElement(element: Element): number {
    let score = 0;
    const text = element.textContent?.trim() || '';
    const html = element.innerHTML || '';
    const className = element.className.toLowerCase();
    const id = element.id.toLowerCase();

    // Base score from text length
    score += Math.min(text.length / 10, 500);

    // Bonus for paragraphs
    const paragraphs = element.querySelectorAll('p').length;
    score += paragraphs * 25;

    // Bonus for headings
    const headings = element.querySelectorAll('h1, h2, h3, h4, h5, h6').length;
    score += headings * 30;

    // Enhanced Substack-specific scoring
    if (window.location.href.includes('substack.com')) {
      // Major bonus for Substack-specific classes
      if (className.includes('available-content')) {
        score += 300; // High priority for main content container
      }
      if (className.includes('body') && className.includes('markup')) {
        score += 250; // High priority for marked up content
      }
      if (className.includes('markup')) {
        score += 200; // Good priority for markup content
      }
      if (className.includes('post-content')) {
        score += 150; // Medium-high priority
      }
      
      // Bonus for elements that contain actual article content indicators
      const substackContentIndicators = [
        'subtitle', 'description', 'article', 'story', 'newsletter'
      ];
      substackContentIndicators.forEach(indicator => {
        if (className.includes(indicator) || id.includes(indicator)) {
          score += 100;
        }
      });

      // Penalty for Substack-specific navigation/promotional elements
      const substackNavTerms = [
        'header', 'footer', 'subscribe', 'profile', 'navigation',
        'sidebar', 'recommendation', 'related', 'comments', 'discussion'
      ];
      substackNavTerms.forEach(term => {
        if (className.includes(term) || id.includes(term)) {
          score -= 150;
        }
      });

      // Bonus for having good paragraph-to-link ratio (indicates article content)
      const links = element.querySelectorAll('a').length;
      if (paragraphs > 3 && links / paragraphs < 0.5) {
        score += 100; // Good content-to-link ratio
      }
    }

    // Penalty for too many links (likely navigation)
    const links = element.querySelectorAll('a').length;
    if (links > paragraphs * 2) {
      score -= links * 10;
    }

    // Penalty for too many script/style tags
    const scripts = element.querySelectorAll('script, style').length;
    score -= scripts * 50;

    // Bonus for content-related class names
    const contentTerms = ['content', 'article', 'post', 'entry', 'main', 'body', 'text'];
    contentTerms.forEach(term => {
      if (className.includes(term) || id.includes(term)) {
        score += 100;
      }
    });

    // Penalty for navigation-related class names
    const navTerms = ['nav', 'menu', 'sidebar', 'footer', 'header', 'ad', 'banner'];
    navTerms.forEach(term => {
      if (className.includes(term) || id.includes(term)) {
        score -= 200;
      }
    });

    return Math.max(0, score);
  }

  /**
   * Basic validation for content elements
   */
  private isValidContentElement(element: Element): boolean {
    const text = element.textContent?.trim() || '';
    const minLength = 50;

    if (text.length < minLength) {
      return false;
    }

    // Check for navigation indicators
    const className = element.className.toLowerCase();
    const id = element.id.toLowerCase();
    const navTerms = ['recent', 'related', 'more', 'sidebar', 'navigation', 'nav', 'menu'];

    if (navTerms.some(term => className.includes(term) || id.includes(term))) {
      const paragraphs = element.querySelectorAll('p').length;
      return paragraphs >= 3; // Allow if it has substantial paragraphs
    }

    return true;
  }
}
