// Generated by Copilot
// PrismWeave Performance Monitor
// Tracks extension performance and provides optimization insights

import { getGlobalScope } from './global-types';
import { createLogger } from './logger';

interface IPerformanceMemory {
  usedJSHeapSize: number;
  totalJSHeapSize: number;
  jsHeapSizeLimit: number;
}

interface IExtendedPerformance extends Performance {
  memory?: IPerformanceMemory;
}

interface IPerformanceMetric {
  operation: string;
  startTime: number;
  endTime: number | null;
  duration: number | null;
  metadata: Record<string, unknown>;
}

interface IMemoryInfo {
  used: number;
  total: number;
  limit: number;
}

interface IOperationSummary {
  count: number;
  totalDuration: number;
  averageDuration: number;
  minDuration: number;
  maxDuration: number;
}

interface IMetricsSummary {
  operations: Record<string, IOperationSummary>;
  memory: IMemoryInfo | null;
  totalMetrics: number;
}

class PerformanceMonitor {
  private metrics: Map<string, IPerformanceMetric>;
  private isEnabled: boolean;
  private logger = createLogger('PerformanceMonitor');

  constructor() {
    this.metrics = new Map();
    this.isEnabled = true;
  }

  startTimer(operation: string): string | null {
    if (!this.isEnabled) return null;

    const startTime = performance.now();
    const timerId = `${operation}_${Date.now()}`;

    this.metrics.set(timerId, {
      operation,
      startTime,
      endTime: null,
      duration: null,
      metadata: {},
    });

    return timerId;
  }

  endTimer(
    timerId: string | null,
    metadata: Record<string, unknown> = {}
  ): IPerformanceMetric | null {
    if (!this.isEnabled || !timerId) return null;

    const metric = this.metrics.get(timerId);
    if (!metric) return null;

    const endTime = performance.now();
    const duration = endTime - metric.startTime;

    metric.endTime = endTime;
    metric.duration = duration;
    metric.metadata = metadata;

    this.logPerformance(metric);
    return metric;
  }

  private logPerformance(metric: IPerformanceMetric): void {
    const { operation, duration, metadata } = metric;

    if (duration === null) return;

    // Log slow operations
    if (duration > 1000) {
      this.logger.warn(
        `üêå Slow operation detected: ${operation} took ${duration.toFixed(2)}ms`,
        metadata
      );
    } else if (duration > 500) {
      this.logger.info(
        `‚ö†Ô∏è Moderate operation: ${operation} took ${duration.toFixed(2)}ms`,
        metadata
      );
    } else {
      this.logger.debug(`‚úÖ Fast operation: ${operation} took ${duration.toFixed(2)}ms`, metadata);
    }
  }
  measureMemory(): IMemoryInfo | null {
    const perf = performance as IExtendedPerformance;
    if (!perf.memory) return null;

    return {
      used: Math.round((perf.memory.usedJSHeapSize / 1024 / 1024) * 100) / 100,
      total: Math.round((perf.memory.totalJSHeapSize / 1024 / 1024) * 100) / 100,
      limit: Math.round((perf.memory.jsHeapSizeLimit / 1024 / 1024) * 100) / 100,
    };
  }

  getMetricsSummary(): IMetricsSummary {
    const operations: Record<string, IOperationSummary> = {};

    for (const [timerId, metric] of this.metrics) {
      if (!metric.duration) continue;

      if (!operations[metric.operation]) {
        operations[metric.operation] = {
          count: 0,
          totalDuration: 0,
          averageDuration: 0,
          minDuration: Infinity,
          maxDuration: 0,
        };
      }

      const op = operations[metric.operation];
      op.count++;
      op.totalDuration += metric.duration;
      op.minDuration = Math.min(op.minDuration, metric.duration);
      op.maxDuration = Math.max(op.maxDuration, metric.duration);
      op.averageDuration = op.totalDuration / op.count;
    }

    return {
      operations,
      memory: this.measureMemory(),
      totalMetrics: this.metrics.size,
    };
  }

  clearMetrics(): void {
    this.metrics.clear();
  }

  disable(): void {
    this.isEnabled = false;
  }

  enable(): void {
    this.isEnabled = true;
  }
}

// Create global instance
const perfMonitor = new PerformanceMonitor();

// Export for different contexts
const globalScope = getGlobalScope();
globalScope.PerformanceMonitor = {
  startTimer: perfMonitor.startTimer.bind(perfMonitor),
  endTimer: perfMonitor.endTimer.bind(perfMonitor),
  getMetrics: perfMonitor.getMetricsSummary.bind(perfMonitor),
};

export { PerformanceMonitor };
export default perfMonitor;
export type { IMemoryInfo, IMetricsSummary, IOperationSummary, IPerformanceMetric };
