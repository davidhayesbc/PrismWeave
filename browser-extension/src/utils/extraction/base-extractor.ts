// Generated by Copilot
// Base Content Extractor - Unified extraction framework
// Provides common functionality for all content extraction strategies

import { ContentCleaner, ICleaningOptions } from '../content-cleaner.js';
import { ContentQualityAnalyzer, IContentSignals } from '../content-quality-analyzer.js';
import { createLogger } from '../logger.js';

export interface IExtractionResult {
  success: boolean;
  element: Element | null;
  content: string | null;
  score: number;
  method: string;
  metadata: IExtractionMetadata;
  error?: string;
}

export interface IExtractionMetadata {
  textLength: number;
  wordCount: number;
  paragraphCount: number;
  headingCount: number;
  linkCount: number;
  selector?: string;
  confidence: number;
  extractionTime?: number;
  url?: string;
  domain?: string;
  timestamp?: string;
  qualitySignals?: IContentSignals;
  [key: string]: unknown;
}

export interface IExtractionOptions extends ICleaningOptions {
  customSelectors?: string[];
  waitForContent?: boolean;
  minContentLength?: number;
  maxRetries?: number;
}

/**
 * Base class for all content extractors
 * Provides common extraction functionality and plugin architecture
 */
export abstract class BaseContentExtractor {
  protected readonly logger = createLogger(this.constructor.name);
  protected readonly qualityAnalyzer = new ContentQualityAnalyzer();
  protected readonly cleaner = new ContentCleaner();

  abstract get name(): string;
  abstract get priority(): number;
  abstract isApplicable(url: string, document: Document): boolean;
  protected abstract getSelectors(): ISelectorGroup[];
  protected abstract scoreElement(element: Element, context: IExtractionContext): number;

  /**
   * Extract content with provided context (for compatibility with new strategy system)
   */
  async extractContent(context: IExtractionContext): Promise<IExtractionResult> {
    return this.extract(context.options);
  }

  /**
   * Main extraction method - template pattern
   */
  async extract(options: IExtractionOptions = {}): Promise<IExtractionResult> {
    try {
      this.logger.debug(`Starting extraction with ${this.name}`);

      // Wait for content if needed
      if (options.waitForContent) {
        await this.waitForContent();
      }

      // Find best content element
      const element = this.findBestContentElement(options);
      if (!element) {
        return this.createFailureResult('No suitable content element found');
      }

      // Extract and clean content
      const content = this.extractContentFromElement(element, options);
      const score = this.scoreElement(element, this.createExtractionContext(options));
      const metadata = this.createMetadata(element, content);

      this.logger.debug(`Extraction successful: ${content.length} chars, score: ${score}`);

      return {
        success: true,
        element,
        content,
        score,
        method: this.name,
        metadata,
      };
    } catch (error) {
      this.logger.error(`Extraction failed:`, error);
      return this.createFailureResult(error instanceof Error ? error.message : 'Unknown error');
    }
  }

  /**
   * Find the best content element using selector strategies
   */
  protected findBestContentElement(options: IExtractionOptions): Element | null {
    const candidates: IElementCandidate[] = [];

    // Try custom selectors first
    if (options.customSelectors?.length) {
      this.addCandidatesFromSelectors(candidates, options.customSelectors, 'custom');
    }

    // Try strategy-specific selectors
    const selectorGroups = this.getSelectors();
    for (const group of selectorGroups) {
      this.addCandidatesFromSelectors(candidates, group.selectors, group.name);
    }

    // Score and sort candidates
    const context = this.createExtractionContext(options);
    candidates.forEach(candidate => {
      candidate.score = this.scoreElement(candidate.element, context);
    });

    candidates.sort((a, b) => b.score - a.score);

    // Return best candidate if it meets minimum requirements
    if (candidates.length > 0 && candidates[0].score > this.getMinimumScore()) {
      this.logger.debug(
        `Best candidate: ${candidates[0].selector} (score: ${candidates[0].score})`
      );
      return candidates[0].element;
    }

    return null;
  }

  /**
   * Add candidates from a set of selectors
   */
  private addCandidatesFromSelectors(
    candidates: IElementCandidate[],
    selectors: string[],
    source: string
  ): void {
    for (const selector of selectors) {
      try {
        const elements = document.querySelectorAll(selector);
        for (const element of Array.from(elements)) {
          if (this.isValidContentElement(element)) {
            candidates.push({
              element,
              selector,
              source,
              score: 0,
            });
          }
        }
      } catch (error) {
        this.logger.warn(`Invalid selector: ${selector}`, error);
      }
    }
  }

  /**
   * Validate if element is suitable for content extraction
   */
  protected isValidContentElement(element: Element): boolean {
    const text = element.textContent?.trim() || '';
    const minLength = this.getMinimumContentLength();

    if (text.length < minLength) {
      return false;
    }

    // Check quality
    const quality = this.qualityAnalyzer.analyzeContent(element, {
      minTextLength: minLength,
    });

    return quality.isContent;
  }

  /**
   * Extract content from element with cleaning
   */
  protected extractContentFromElement(element: Element, options: IExtractionOptions): string {
    const cleaningOptions: ICleaningOptions = {
      ...options,
      domain: window.location.hostname,
    };

    const cleanedElement = this.cleaner.cleanContent(element, cleaningOptions);
    return cleanedElement.innerHTML || '';
  }

  /**
   * Create extraction context for scoring
   */
  protected createExtractionContext(options: IExtractionOptions): IExtractionContext {
    return {
      url: window.location.href,
      domain: window.location.hostname,
      pathname: window.location.pathname,
      document,
      timestamp: new Date(),
      options,
    };
  }

  /**
   * Create metadata from extracted content
   */
  protected createMetadata(element: Element, content: string): IExtractionMetadata {
    const text = element.textContent?.trim() || '';
    const words = text.split(/\s+/).filter(Boolean);

    return {
      textLength: text.length,
      wordCount: words.length,
      paragraphCount: element.querySelectorAll('p').length,
      headingCount: element.querySelectorAll('h1, h2, h3, h4, h5, h6').length,
      linkCount: element.querySelectorAll('a').length,
      confidence: this.calculateConfidence(element),
    };
  }

  /**
   * Calculate confidence score for extraction
   */
  protected calculateConfidence(element: Element): number {
    const quality = this.qualityAnalyzer.analyzeContent(element);
    return Math.min(quality.score / 100, 1.0);
  }

  /**
   * Wait for dynamic content to load
   */
  protected async waitForContent(): Promise<void> {
    if (document.readyState !== 'complete') {
      await new Promise<void>(resolve => {
        if (document.readyState === 'complete') {
          resolve();
        } else {
          window.addEventListener('load', () => resolve(), { once: true });
          setTimeout(() => resolve(), 3000);
        }
      });
    }

    // Additional wait for dynamic sites
    if (this.isDynamicSite()) {
      await this.waitForDynamicContent();
    }
  }

  /**
   * Wait for dynamic content stabilization
   */
  protected async waitForDynamicContent(): Promise<void> {
    const maxWait = 5000;
    const checkInterval = 500;
    const startTime = Date.now();
    let previousLength = 0;

    while (Date.now() - startTime < maxWait) {
      const currentLength = document.body.textContent?.length || 0;

      if (currentLength > previousLength) {
        previousLength = currentLength;
        await new Promise(resolve => setTimeout(resolve, checkInterval));
      } else if (previousLength > 1000) {
        break;
      } else {
        await new Promise(resolve => setTimeout(resolve, checkInterval));
      }
    }
  }

  /**
   * Check if current site uses dynamic content loading
   */
  protected isDynamicSite(): boolean {
    const hostname = window.location.hostname.toLowerCase();
    const dynamicSites = ['substack.com', 'medium.com', 'dev.to', 'anthropic.com'];

    return (
      dynamicSites.some(site => hostname.includes(site)) ||
      !!(
        document.querySelector('[data-reactroot], [data-vue]') ||
        (window as any).React ||
        (window as any).Vue
      )
    );
  }

  /**
   * Create failure result
   */
  protected createFailureResult(error: string): IExtractionResult {
    return {
      success: false,
      element: null,
      content: '',
      score: 0,
      method: this.name,
      metadata: {
        textLength: 0,
        wordCount: 0,
        paragraphCount: 0,
        headingCount: 0,
        linkCount: 0,
        confidence: 0,
      },
      error,
    };
  }

  // Abstract methods that subclasses can override
  protected getMinimumScore(): number {
    return 50;
  }

  protected getMinimumContentLength(): number {
    return 200;
  }
}

// Supporting interfaces
export interface ISelectorGroup {
  name: string;
  selectors: string[];
  priority?: number;
}

interface IElementCandidate {
  element: Element;
  selector: string;
  source: string;
  score: number;
}

export interface IExtractionContext {
  url: string;
  domain: string;
  pathname: string;
  document: Document;
  timestamp: Date;
  options: IExtractionOptions;
}
