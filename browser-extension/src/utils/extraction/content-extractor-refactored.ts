// Generated by Copilot
// Refactored Content Extractor - Uses the new plugin-based strategy system
// This is the main orchestrator that delegates to site-specific strategies

import { ContentCleaner } from '../content-cleaner.js';
import { ContentQualityAnalyzer } from '../content-quality-analyzer.js';
import { createLogger } from '../logger.js';
import { IExtractionContext, IExtractionResult } from './base-extractor.js';
import { SiteStrategy, StrategyManager } from './site-strategies.js';

const logger = createLogger('ContentExtractor');

/**
 * Main content extractor that orchestrates different extraction strategies
 */
export class ContentExtractor {
  private readonly strategyManager = new StrategyManager();
  private readonly qualityAnalyzer = new ContentQualityAnalyzer();
  private readonly contentCleaner = new ContentCleaner();

  /**
   * Extract content from the current page using the appropriate strategy
   */
  async extractContent(url: string = window.location.href): Promise<IExtractionResult> {
    const startTime = Date.now();

    try {
      logger.info('Starting content extraction for:', url);

      // Create extraction context
      const context = this.createExtractionContext(url);

      // Find the best strategy for this page
      const strategy = this.strategyManager.findBestStrategy(url, document);

      if (!strategy) {
        return this.createFailureResult(
          'No applicable extraction strategy found',
          startTime,
          context
        );
      }

      logger.debug(`Using extraction strategy: ${strategy.name}`);

      // Extract content using the selected strategy
      const result = await strategy.extractContent(context);

      if (!result.success) {
        logger.warn(`Strategy ${strategy.name} failed:`, result.error);
        return result;
      }

      // Apply additional quality analysis and cleaning
      const enhancedResult = await this.enhanceExtractionResult(result, context);

      logger.info(`Content extraction completed in ${Date.now() - startTime}ms`);
      return enhancedResult;
    } catch (error) {
      logger.error('Content extraction failed:', error);
      return this.createFailureResult(
        error instanceof Error ? error.message : 'Unknown error',
        startTime
      );
    }
  }

  /**
   * Extract content with a specific strategy (for testing/debugging)
   */
  async extractWithStrategy(
    strategyName: string,
    url: string = window.location.href
  ): Promise<IExtractionResult> {
    const context = this.createExtractionContext(url);
    const strategy = this.strategyManager.getStrategies().find(s => s.name === strategyName);

    if (!strategy) {
      return this.createFailureResult(`Strategy not found: ${strategyName}`);
    }

    return await strategy.extractContent(context);
  }

  /**
   * Get available strategies for the current page
   */
  getApplicableStrategies(url: string = window.location.href): SiteStrategy[] {
    return this.strategyManager
      .getStrategies()
      .filter(strategy => strategy.isApplicable(url, document))
      .sort((a, b) => b.priority - a.priority);
  }

  /**
   * Register a custom strategy
   */
  registerStrategy(strategy: SiteStrategy): void {
    this.strategyManager.registerStrategy(strategy);
  }

  /**
   * Create extraction context from URL and document
   */
  private createExtractionContext(url: string): IExtractionContext {
    const urlObj = new URL(url);

    return {
      url,
      domain: urlObj.hostname,
      pathname: urlObj.pathname,
      document,
      timestamp: new Date(),
      options: {}, // Default empty options
    };
  }

  /**
   * Enhance extraction result with additional quality analysis
   */
  private async enhanceExtractionResult(
    result: IExtractionResult,
    context: IExtractionContext
  ): Promise<IExtractionResult> {
    if (!result.success || !result.content || !result.element) {
      return result;
    }

    try {
      // Analyze content quality
      const qualityAnalysis = this.qualityAnalyzer.analyzeContent(result.element);

      // Apply final content cleaning
      const cleanedElement = this.contentCleaner.cleanContent(result.element, {
        domain: context.domain,
      });

      // Extract cleaned content as string
      const cleanedContent =
        cleanedElement.innerHTML || cleanedElement.textContent || result.content;

      // Extract metadata
      const metadata = this.extractMetadata(context);

      return {
        ...result,
        content: cleanedContent,
        metadata: {
          ...result.metadata,
          ...metadata,
          qualitySignals: qualityAnalysis.signals,
        },
      };
    } catch (error) {
      logger.warn('Enhancement failed, returning original result:', error);
      return result;
    }
  }

  /**
   * Extract page metadata
   */
  private extractMetadata(context: IExtractionContext): Record<string, unknown> {
    const metadata: Record<string, unknown> = {
      title: document.title,
      description: this.getMetaContent('description'),
      keywords: this.getMetaContent('keywords'),
      author: this.getMetaContent('author'),
      publishedTime: this.getMetaContent('article:published_time') || this.getMetaContent('date'),
      modifiedTime: this.getMetaContent('article:modified_time'),
      siteName: this.getMetaContent('og:site_name'),
      type: this.getMetaContent('og:type'),
      url: this.getMetaContent('og:url') || context.url,
      image: this.getMetaContent('og:image'),
      lang: document.documentElement.lang || 'en',
      extractedAt: context.timestamp.toISOString(),
    };

    // Remove empty values
    return Object.fromEntries(Object.entries(metadata).filter(([, value]) => value));
  }

  /**
   * Get meta tag content by name or property
   */
  private getMetaContent(name: string): string | null {
    const meta = document.querySelector(`meta[name="${name}"], meta[property="${name}"]`);
    return meta?.getAttribute('content') || null;
  }

  /**
   * Create a failure result with consistent structure
   */
  private createFailureResult(
    error: string,
    startTime?: number,
    context?: IExtractionContext
  ): IExtractionResult {
    return {
      success: false,
      error,
      content: null,
      element: null,
      score: 0,
      method: 'ContentExtractor',
      metadata: {
        textLength: 0,
        wordCount: 0,
        paragraphCount: 0,
        headingCount: 0,
        linkCount: 0,
        confidence: 0,
        extractionTime: startTime ? Date.now() - startTime : 0,
        url: context?.url || window.location.href,
        domain: context?.domain || window.location.hostname,
        timestamp: (context?.timestamp || new Date()).toISOString(),
      },
    };
  }

  // Legacy methods for backward compatibility with existing code

  /**
   * @deprecated Use extractContent() instead
   */
  async findContent(): Promise<{ content: string | null; element: Element | null }> {
    logger.warn('findContent() is deprecated, use extractContent() instead');

    const result = await this.extractContent();
    return {
      content: result.content,
      element: result.element,
    };
  }

  /**
   * @deprecated Use extractContent() instead
   */
  async findAnthropicContent(): Promise<{ content: string | null; element: Element | null }> {
    logger.warn('findAnthropicContent() is deprecated, use extractContent() instead');

    const result = await this.extractWithStrategy('Anthropic Research');
    return {
      content: result.content,
      element: result.element,
    };
  }

  /**
   * @deprecated Use extractContent() instead
   */
  async findSubstackContent(): Promise<{ content: string | null; element: Element | null }> {
    logger.warn('findSubstackContent() is deprecated, use extractContent() instead');

    const result = await this.extractWithStrategy('Substack Newsletter');
    return {
      content: result.content,
      element: result.element,
    };
  }

  /**
   * @deprecated Use extractContent() instead
   */
  async findGitHubContent(): Promise<{ content: string | null; element: Element | null }> {
    logger.warn('findGitHubContent() is deprecated, use extractContent() instead');

    const result = await this.extractWithStrategy('GitHub Documentation');
    return {
      content: result.content,
      element: result.element,
    };
  }

  /**
   * Test extraction with debug information
   */
  async debugExtraction(url: string = window.location.href): Promise<{
    strategies: Array<{ name: string; applicable: boolean; priority: number }>;
    selectedStrategy: string | null;
    result: IExtractionResult;
    timing: { total: number; strategy: number; enhancement: number };
  }> {
    const startTime = Date.now();

    // Get strategy information
    const allStrategies = this.strategyManager.getStrategies().map(strategy => ({
      name: strategy.name,
      applicable: strategy.isApplicable(url, document),
      priority: strategy.priority,
    }));

    const context = this.createExtractionContext(url);
    const selectedStrategy = this.strategyManager.findBestStrategy(url, document);

    let result: IExtractionResult;
    let strategyTime = 0;
    let enhancementTime = 0;

    if (selectedStrategy) {
      const strategyStart = Date.now();
      result = await selectedStrategy.extractContent(context);
      strategyTime = Date.now() - strategyStart;

      if (result.success) {
        const enhancementStart = Date.now();
        result = await this.enhanceExtractionResult(result, context);
        enhancementTime = Date.now() - enhancementStart;
      }
    } else {
      result = this.createFailureResult('No applicable strategy found', startTime, context);
    }

    return {
      strategies: allStrategies,
      selectedStrategy: selectedStrategy?.name || null,
      result,
      timing: {
        total: Date.now() - startTime,
        strategy: strategyTime,
        enhancement: enhancementTime,
      },
    };
  }
}
