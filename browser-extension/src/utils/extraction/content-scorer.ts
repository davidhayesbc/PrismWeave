// Generated by Copilot
// Content Scorer - Unified scoring system for content elements
// Provides configurable scoring algorithms for different site types

import { createLogger } from '../logger.js';

const logger = createLogger('ContentScorer');

export interface IScoringConfig {
  textLengthWeight: number;
  structureWeight: number;
  classWeight: number;
  semanticWeight: number;
  penaltyWeight: number;
  bonusRules: IBonusRule[];
  penaltyRules: IPenaltyRule[];
}

export interface IBonusRule {
  name: string;
  condition: (element: Element, context: IScoringContext) => boolean;
  points: number;
}

export interface IPenaltyRule {
  name: string;
  condition: (element: Element, context: IScoringContext) => boolean;
  points: number;
}

export interface IScoringContext {
  url: string;
  domain: string;
  isResearchSite: boolean;
  isBlogSite: boolean;
  isDocumentationSite: boolean;
}

export interface IScoringResult {
  totalScore: number;
  breakdown: IScoringBreakdown;
  reasons: string[];
}

export interface IScoringBreakdown {
  textLength: number;
  structure: number;
  classNames: number;
  semantic: number;
  bonuses: number;
  penalties: number;
}

/**
 * Unified content scoring system with configurable rules
 */
export class ContentScorer {
  private readonly defaultConfig: IScoringConfig = {
    textLengthWeight: 1.0,
    structureWeight: 1.0,
    classWeight: 1.0,
    semanticWeight: 1.0,
    penaltyWeight: 1.0,
    bonusRules: this.getDefaultBonusRules(),
    penaltyRules: this.getDefaultPenaltyRules(),
  };

  /**
   * Score an element with optional custom configuration
   */
  scoreElement(
    element: Element,
    context: IScoringContext,
    config: Partial<IScoringConfig> = {}
  ): IScoringResult {
    const finalConfig = { ...this.defaultConfig, ...config };
    const breakdown: IScoringBreakdown = {
      textLength: 0,
      structure: 0,
      classNames: 0,
      semantic: 0,
      bonuses: 0,
      penalties: 0,
    };
    const reasons: string[] = [];

    // Text length scoring
    breakdown.textLength = this.scoreTextLength(element) * finalConfig.textLengthWeight;
    if (breakdown.textLength > 0) {
      reasons.push(`Text length: ${breakdown.textLength.toFixed(1)} points`);
    }

    // Structure scoring (paragraphs, headings)
    breakdown.structure = this.scoreStructure(element) * finalConfig.structureWeight;
    if (breakdown.structure > 0) {
      reasons.push(`Structure: ${breakdown.structure.toFixed(1)} points`);
    }

    // Class name scoring
    breakdown.classNames = this.scoreClassNames(element) * finalConfig.classWeight;
    if (breakdown.classNames > 0) {
      reasons.push(`Class names: ${breakdown.classNames.toFixed(1)} points`);
    }

    // Semantic HTML scoring
    breakdown.semantic = this.scoreSemanticHtml(element) * finalConfig.semanticWeight;
    if (breakdown.semantic > 0) {
      reasons.push(`Semantic HTML: ${breakdown.semantic.toFixed(1)} points`);
    }

    // Apply bonus rules
    breakdown.bonuses = this.applyBonusRules(element, context, finalConfig.bonusRules, reasons);

    // Apply penalty rules
    breakdown.penalties =
      this.applyPenaltyRules(element, context, finalConfig.penaltyRules, reasons) *
      finalConfig.penaltyWeight;

    const totalScore = Math.max(
      0,
      breakdown.textLength +
        breakdown.structure +
        breakdown.classNames +
        breakdown.semantic +
        breakdown.bonuses -
        breakdown.penalties
    );

    logger.debug('Element scored:', {
      totalScore,
      breakdown,
      className: element.className,
      tagName: element.tagName,
    });

    return {
      totalScore,
      breakdown,
      reasons,
    };
  }

  /**
   * Score based on text content length
   */
  private scoreTextLength(element: Element): number {
    const text = element.textContent?.trim() || '';
    const length = text.length;

    // Optimal range is 1000-5000 characters
    if (length < 100) return 0;
    if (length < 500) return length / 10; // 0-50 points
    if (length < 2000) return 50 + (length - 500) / 30; // 50-100 points
    if (length < 5000) return 100 + (length - 2000) / 60; // 100-150 points

    // Diminishing returns for very long content
    return Math.min(200, 150 + (length - 5000) / 200);
  }

  /**
   * Score based on content structure
   */
  private scoreStructure(element: Element): number {
    let score = 0;

    // Paragraph scoring
    const paragraphs = element.querySelectorAll('p').length;
    score += Math.min(paragraphs * 25, 200); // Max 200 points for paragraphs

    // Heading scoring
    const headings = element.querySelectorAll('h1, h2, h3, h4, h5, h6').length;
    score += Math.min(headings * 30, 150); // Max 150 points for headings

    // List scoring
    const listItems = element.querySelectorAll('li').length;
    score += Math.min(listItems * 5, 50); // Max 50 points for lists

    // Code block scoring (valuable for technical content)
    const codeBlocks = element.querySelectorAll('pre, code').length;
    score += Math.min(codeBlocks * 15, 100); // Max 100 points for code

    return score;
  }

  /**
   * Score based on CSS class and ID names
   */
  private scoreClassNames(element: Element): number {
    let score = 0;
    const className = element.className.toLowerCase();
    const id = element.id.toLowerCase();
    const combined = className + ' ' + id;

    // Content-related class bonuses
    const contentTerms = [
      { term: 'content', bonus: 100 },
      { term: 'article', bonus: 90 },
      { term: 'post', bonus: 80 },
      { term: 'entry', bonus: 70 },
      { term: 'main', bonus: 60 },
      { term: 'body', bonus: 50 },
      { term: 'text', bonus: 40 },
      { term: 'prose', bonus: 30 },
    ];

    for (const { term, bonus } of contentTerms) {
      if (combined.includes(term)) {
        score += bonus;
      }
    }

    // Navigation-related class penalties
    const navTerms = [
      { term: 'nav', penalty: 150 },
      { term: 'menu', penalty: 120 },
      { term: 'sidebar', penalty: 100 },
      { term: 'footer', penalty: 100 },
      { term: 'header', penalty: 80 },
      { term: 'advertisement', penalty: 200 },
      { term: 'ad', penalty: 150 },
    ];

    for (const { term, penalty } of navTerms) {
      if (combined.includes(term)) {
        score -= penalty;
      }
    }

    return score;
  }

  /**
   * Score based on semantic HTML usage
   */
  private scoreSemanticHtml(element: Element): number {
    let score = 0;
    const tagName = element.tagName.toLowerCase();

    // Semantic element bonuses
    const semanticBonuses: Record<string, number> = {
      article: 150,
      main: 120,
      section: 80,
      aside: 40,
    };

    if (semanticBonuses[tagName]) {
      score += semanticBonuses[tagName];
    }

    return score;
  }

  /**
   * Apply bonus rules to element
   */
  private applyBonusRules(
    element: Element,
    context: IScoringContext,
    rules: IBonusRule[],
    reasons: string[]
  ): number {
    let totalBonus = 0;

    for (const rule of rules) {
      if (rule.condition(element, context)) {
        totalBonus += rule.points;
        reasons.push(`Bonus - ${rule.name}: +${rule.points} points`);
      }
    }

    return totalBonus;
  }

  /**
   * Apply penalty rules to element
   */
  private applyPenaltyRules(
    element: Element,
    context: IScoringContext,
    rules: IPenaltyRule[],
    reasons: string[]
  ): number {
    let totalPenalty = 0;

    for (const rule of rules) {
      if (rule.condition(element, context)) {
        totalPenalty += rule.points;
        reasons.push(`Penalty - ${rule.name}: -${rule.points} points`);
      }
    }

    return totalPenalty;
  }

  /**
   * Get default bonus rules
   */
  private getDefaultBonusRules(): IBonusRule[] {
    return [
      {
        name: 'Research Content',
        condition: (element, context) => {
          const text = element.textContent?.toLowerCase() || '';
          const researchTerms = ['research', 'study', 'analysis', 'findings', 'methodology'];
          return context.isResearchSite && researchTerms.some(term => text.includes(term));
        },
        points: 150,
      },
      {
        name: 'Blog Post Structure',
        condition: (element, context) => {
          const paragraphs = element.querySelectorAll('p').length;
          const headings = element.querySelectorAll('h1, h2, h3').length;
          return context.isBlogSite && paragraphs > 3 && headings > 1;
        },
        points: 100,
      },
      {
        name: 'Technical Documentation',
        condition: (element, context) => {
          const codeBlocks = element.querySelectorAll('pre, code').length;
          return context.isDocumentationSite && codeBlocks > 2;
        },
        points: 120,
      },
      {
        name: 'Substantial Content',
        condition: element => {
          const text = element.textContent?.trim() || '';
          return text.length > 2000;
        },
        points: 100,
      },
      {
        name: 'Good Link Ratio',
        condition: element => {
          const links = element.querySelectorAll('a').length;
          const paragraphs = element.querySelectorAll('p').length;
          return paragraphs > 0 && links / paragraphs < 0.3;
        },
        points: 50,
      },
    ];
  }

  /**
   * Get default penalty rules
   */
  private getDefaultPenaltyRules(): IPenaltyRule[] {
    return [
      {
        name: 'High Link Density',
        condition: element => {
          const links = element.querySelectorAll('a').length;
          const text = element.textContent?.trim() || '';
          const words = text.split(/\s+/).length;
          return words > 0 && links / words > 0.1;
        },
        points: 100,
      },
      {
        name: 'Navigation Content',
        condition: element => {
          const className = element.className.toLowerCase();
          const navTerms = ['nav', 'menu', 'navigation', 'breadcrumb'];
          return navTerms.some(term => className.includes(term));
        },
        points: 150,
      },
      {
        name: 'Too Many Scripts',
        condition: element => {
          const scripts = element.querySelectorAll('script, style').length;
          return scripts > 5;
        },
        points: 200,
      },
      {
        name: 'Promotional Content',
        condition: element => {
          const text = element.textContent?.toLowerCase() || '';
          const promoTerms = ['subscribe', 'buy now', 'sign up', 'advertisement'];
          const matches = promoTerms.filter(term => text.includes(term)).length;
          return matches > 2;
        },
        points: 150,
      },
      {
        name: 'Short Content',
        condition: element => {
          const text = element.textContent?.trim() || '';
          return text.length < 200;
        },
        points: 100,
      },
    ];
  }

  /**
   * Create site-specific scoring configurations
   */
  static createSiteConfig(
    siteType: 'research' | 'blog' | 'documentation' | 'news'
  ): Partial<IScoringConfig> {
    const configs: Record<string, Partial<IScoringConfig>> = {
      research: {
        structureWeight: 1.5, // Research articles need good structure
        bonusRules: [
          {
            name: 'Academic Structure',
            condition: element => {
              const text = element.textContent?.toLowerCase() || '';
              const academicTerms = ['abstract', 'methodology', 'conclusion', 'references'];
              return academicTerms.filter(term => text.includes(term)).length >= 2;
            },
            points: 200,
          },
        ],
      },
      blog: {
        textLengthWeight: 1.2, // Blog posts should be substantial
        classWeight: 1.3, // Class names are important for blogs
      },
      documentation: {
        structureWeight: 1.8, // Documentation needs excellent structure
        bonusRules: [
          {
            name: 'Code Examples',
            condition: element => element.querySelectorAll('pre, code').length > 5,
            points: 150,
          },
        ],
      },
      news: {
        textLengthWeight: 0.8, // News articles can be shorter
        penaltyWeight: 1.5, // Be strict about navigation/ads
      },
    };

    return configs[siteType] || {};
  }
}
