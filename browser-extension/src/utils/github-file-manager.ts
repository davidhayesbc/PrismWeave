// Generated by Copilot
// GitHub File Manager - Handles GitHub API operations for file management
// Extracted from service worker for better testability and reusability

import { createLogger } from './logger.js';

const logger = createLogger('GitHubFileManager');

export interface IGitHubCommitParams {
  token: string;
  repo: string;
  filePath: string;
  content: string;
  message: string;
  url?: string;
}

export interface IGitHubCommitResult {
  success: boolean;
  data?: {
    html_url?: string;
    sha?: string;
    [key: string]: unknown;
  };
  error?: string;
}

export interface IGitHubFileInfo {
  sha: string;
  content: string;
  encoding: string;
}

export interface IRepositoryInfo {
  owner: string;
  repo: string;
}

export class GitHubFileManager {
  private static readonly API_BASE = 'https://api.github.com';
  private static readonly USER_AGENT = 'PrismWeave-Extension/1.0';

  /**
   * Commit content to GitHub repository with automatic file creation/update
   */
  async commitToGitHub(params: IGitHubCommitParams): Promise<IGitHubCommitResult> {
    try {
      const { token, repo, filePath, content, message } = params;

      logger.info('Starting GitHub commit process:', {
        repo,
        filePath,
        messageLength: message.length,
        contentLength: content.length,
      });

      // Validate and parse repository
      const repoInfo = this.parseRepositoryPath(repo);
      logger.debug('Parsed repository:', repoInfo);

      // Check if file already exists
      const existingFile = await this.getFileInfo(token, repoInfo, filePath);
      logger.debug('File existence check:', {
        exists: !!existingFile,
        sha: existingFile?.sha,
      });

      // Create or update the file
      const result = await this.createOrUpdateFile(
        token,
        repoInfo,
        filePath,
        content,
        message,
        existingFile?.sha
      );

      logger.info('Successfully committed to GitHub:', result.content?.html_url);

      return {
        success: true,
        data: result.content,
      };
    } catch (error) {
      logger.error('GitHub commit failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  /**
   * Test GitHub connection and permissions
   */
  async testConnection(
    token: string,
    repo: string
  ): Promise<{
    success: boolean;
    status: string;
    message?: string;
    details?: Record<string, unknown>;
    error?: string;
  }> {
    try {
      logger.info('Testing GitHub connection...');

      // Validate inputs
      if (!token || !repo) {
        return {
          success: false,
          status: 'failed',
          error: 'GitHub token and repository are required',
        };
      }

      // Parse repository
      const repoInfo = this.parseRepositoryPath(repo);

      // Test 1: Validate GitHub token
      const userData = await this.validateToken(token);

      // Test 2: Check repository access
      const repoData = await this.validateRepository(token, repoInfo);

      // Test 3: Check write permissions
      const hasWriteAccess = await this.checkWritePermissions(token, repoInfo);

      return {
        success: true,
        status: 'connected',
        message: 'GitHub connection test successful',
        details: {
          user: userData.login,
          userType: userData.type,
          repository: repoData.full_name,
          repositoryPrivate: repoData.private,
          hasWriteAccess,
          permissions: repoData.permissions || { admin: false, push: false, pull: true },
        },
      };
    } catch (error) {
      logger.error('GitHub connection test failed:', error);
      return {
        success: false,
        status: 'failed',
        error: error instanceof Error ? error.message : 'Unknown error occurred',
      };
    }
  }

  /**
   * Parse repository path into owner and repo components
   */
  private parseRepositoryPath(repoPath: string): IRepositoryInfo {
    if (!repoPath) {
      throw new Error('Repository path is required');
    }

    // Handle different repository path formats
    let cleanPath = repoPath;

    // Remove GitHub URL prefixes if present
    cleanPath = cleanPath.replace(/^https?:\/\/github\.com\//, '');
    cleanPath = cleanPath.replace(/\.git$/, '');

    const parts = cleanPath.split('/');

    if (parts.length < 2) {
      throw new Error('Invalid repository path format. Expected: owner/repo');
    }

    return {
      owner: parts[0],
      repo: parts[1],
    };
  }

  /**
   * Get file information from GitHub if it exists
   */
  private async getFileInfo(
    token: string,
    repoInfo: IRepositoryInfo,
    path: string
  ): Promise<IGitHubFileInfo | null> {
    logger.debug('Fetching file info for:', {
      owner: repoInfo.owner,
      repo: repoInfo.repo,
      path,
    });

    try {
      const response = await fetch(
        `${GitHubFileManager.API_BASE}/repos/${repoInfo.owner}/${repoInfo.repo}/contents/${path}`,
        {
          method: 'GET',
          headers: this.getAuthHeaders(token),
        }
      );

      if (response.status === 404) {
        logger.debug('File not found (404), returning null');
        return null;
      }

      if (!response.ok) {
        throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
      }

      const data = (await response.json()) as IGitHubFileInfo;

      if (!data.sha) {
        throw new Error('Invalid file info from GitHub: missing SHA');
      }

      return data;
    } catch (error) {
      if ((error as Error).message.includes('404')) {
        return null;
      }
      throw error;
    }
  }

  /**
   * Create or update a file in the GitHub repository
   */
  private async createOrUpdateFile(
    token: string,
    repoInfo: IRepositoryInfo,
    path: string,
    content: string,
    message: string,
    existingSha?: string
  ): Promise<any> {
    logger.debug('Creating or updating file:', {
      owner: repoInfo.owner,
      repo: repoInfo.repo,
      path,
      contentLength: content.length,
      operation: existingSha ? 'UPDATE' : 'CREATE',
    });

    const requestBody: any = {
      message,
      content: btoa(unescape(encodeURIComponent(content))),
      branch: 'main',
    };

    if (existingSha) {
      requestBody.sha = existingSha;
      logger.info('Including SHA for file update:', existingSha);
    }

    const response = await fetch(
      `${GitHubFileManager.API_BASE}/repos/${repoInfo.owner}/${repoInfo.repo}/contents/${path}`,
      {
        method: 'PUT',
        headers: {
          ...this.getAuthHeaders(token),
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody),
      }
    );

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      const errorMessage = `GitHub API error: ${response.status} - ${errorData.message || 'Unknown error'}`;
      throw new Error(errorMessage);
    }

    return await response.json();
  }

  /**
   * Validate GitHub token by fetching user info
   */
  private async validateToken(token: string): Promise<any> {
    logger.debug('Validating GitHub token...');

    const response = await fetch(`${GitHubFileManager.API_BASE}/user`, {
      headers: this.getAuthHeaders(token),
    });

    if (!response.ok) {
      throw new Error(`Invalid GitHub token (${response.status})`);
    }

    const userData = await response.json();
    logger.debug('GitHub user validated:', userData.login);
    return userData;
  }

  /**
   * Validate repository access
   */
  private async validateRepository(token: string, repoInfo: IRepositoryInfo): Promise<any> {
    logger.debug('Validating repository access...');

    const response = await fetch(
      `${GitHubFileManager.API_BASE}/repos/${repoInfo.owner}/${repoInfo.repo}`,
      {
        headers: this.getAuthHeaders(token),
      }
    );

    if (!response.ok) {
      const errorMsg =
        response.status === 404
          ? 'Repository not found or no access'
          : `Repository access failed (${response.status})`;
      throw new Error(errorMsg);
    }

    const repoData = await response.json();
    logger.debug('Repository access confirmed:', repoData.full_name);
    return repoData;
  }

  /**
   * Check write permissions by testing contents API
   */
  private async checkWritePermissions(token: string, repoInfo: IRepositoryInfo): Promise<boolean> {
    logger.debug('Testing write permissions...');

    try {
      const response = await fetch(
        `${GitHubFileManager.API_BASE}/repos/${repoInfo.owner}/${repoInfo.repo}/contents`,
        {
          headers: this.getAuthHeaders(token),
        }
      );

      const hasAccess = response.ok;
      if (!hasAccess) {
        logger.warn('Limited repository access - may not have write permissions');
      }

      return hasAccess;
    } catch (error) {
      logger.warn('Write permission check failed:', error);
      return false;
    }
  }

  /**
   * Get standard authentication headers for GitHub API
   */
  private getAuthHeaders(token: string): Record<string, string> {
    return {
      Authorization: `token ${token}`,
      Accept: 'application/vnd.github.v3+json',
      'User-Agent': GitHubFileManager.USER_AGENT,
    };
  }
}
