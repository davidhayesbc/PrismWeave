// Generated by Copilot
// Core bookmarklet functionality without Chrome extension dependencies

export interface IBookmarkletContentData {
  title: string;
  url: string;
  markdown: string;
  frontmatter: string;
  content: string;
  wordCount: number;
  extractedAt: string;
}

export interface IBookmarkletExtractionOptions {
  includeImages?: boolean;
  includeLinks?: boolean;
  cleanAds?: boolean;
  customSelectors?: string[];
  excludeSelectors?: string[];
}

export class BookmarkletCore {
  /**
   * Extract content from the current page using DOM-based approach
   */
  static extractPageContent(options: IBookmarkletExtractionOptions = {}): IBookmarkletContentData {
    const title = this.extractTitle();
    const url = window.location.href;
    const contentElement = this.findMainContent(options.customSelectors);
    const cleanedElement = this.cleanContent(contentElement, options);
    const markdown = this.htmlToMarkdown(cleanedElement.innerHTML, options);
    const frontmatter = this.generateFrontmatter(title, url);
    const content = frontmatter + '\n\n' + markdown;
    const wordCount = this.countWords(markdown);

    return {
      title,
      url,
      markdown,
      frontmatter,
      content,
      wordCount,
      extractedAt: new Date().toISOString(),
    };
  }

  /**
   * Extract page title using multiple strategies
   */
  private static extractTitle(): string {
    // Try different title sources in order of preference
    const titleSources = [
      () => document.querySelector('h1')?.textContent?.trim(),
      () => document.querySelector('[property="og:title"]')?.getAttribute('content')?.trim(),
      () => document.querySelector('[name="twitter:title"]')?.getAttribute('content')?.trim(),
      () => document.title?.trim(),
      () => document.querySelector('title')?.textContent?.trim(),
    ];

    for (const getTitle of titleSources) {
      const title = getTitle();
      if (title && title.length > 0) {
        return title;
      }
    }

    return 'Untitled Page';
  }

  /**
   * Find main content element using semantic selectors
   */
  private static findMainContent(customSelectors: string[] = []): Element {
    const allSelectors = [
      ...customSelectors,
      'article',
      'main',
      '[role="main"]',
      '.content',
      '.post',
      '.entry',
      '.article',
      '#content',
      '#main',
      '.main-content',
      '.post-content',
      '.entry-content',
    ];

    // Try each selector and score the elements
    let bestElement: Element = document.body;
    let bestScore = 0;

    for (const selector of allSelectors) {
      try {
        const elements = document.querySelectorAll(selector);
        for (let i = 0; i < elements.length; i++) {
          const element = elements[i];
          const score = this.scoreContentElement(element);
          if (score > bestScore) {
            bestScore = score;
            bestElement = element;
          }
        }
      } catch (error) {
        console.warn('Invalid selector:', selector, error);
      }
    }

    return bestElement;
  }

  /**
   * Score content element based on text content and structure
   */
  private static scoreContentElement(element: Element): number {
    const text = element.textContent || '';
    const wordCount = text.split(/\s+/).filter(word => word.length > 2).length;

    if (wordCount < 20) return 0; // Too little content

    let score = Math.min(wordCount / 10, 50); // Base score from word count

    // Bonus for semantic elements
    const tagName = element.tagName.toLowerCase();
    if (tagName === 'article') score += 15;
    if (tagName === 'main') score += 10;

    // Bonus for good class names
    const className = element.className.toLowerCase();
    if (className.includes('content')) score += 10;
    if (className.includes('post')) score += 8;
    if (className.includes('article')) score += 8;
    if (className.includes('entry')) score += 5;

    // Penalty for bad class names
    if (className.includes('sidebar')) score -= 10;
    if (className.includes('footer')) score -= 10;
    if (className.includes('header')) score -= 10;
    if (className.includes('nav')) score -= 15;

    // Penalty for high link density (likely navigation)
    const links = element.querySelectorAll('a').length;
    const linkDensity = links / Math.max(wordCount, 1);
    if (linkDensity > 0.3) score -= 20;

    return Math.max(score, 0);
  }

  /**
   * Clean content by removing unwanted elements
   */
  private static cleanContent(element: Element, options: IBookmarkletExtractionOptions): Element {
    const cleaned = element.cloneNode(true) as Element;

    // Default unwanted selectors
    const unwantedSelectors = [
      'script',
      'style',
      'noscript',
      'iframe',
      'object',
      'embed',
      'form',
      'input',
      'button',
      'select',
      'textarea',
      ...(options.excludeSelectors || []),
    ];

    // Add ad-blocking selectors if enabled
    if (options.cleanAds !== false) {
      unwantedSelectors.push(
        '.advertisement',
        '.ad',
        '.ads',
        '.sponsored',
        '.popup',
        '.modal',
        '.overlay',
        '.banner',
        '[class*="ad-"]',
        '[id*="ad-"]',
        '[class*="ads-"]'
      );
    }

    // Remove unwanted elements
    unwantedSelectors.forEach(selector => {
      try {
        const elements = cleaned.querySelectorAll(selector);
        elements.forEach(el => el.remove());
      } catch (error) {
        console.warn('Invalid selector:', selector, error);
      }
    });

    // Remove empty elements
    const emptyElements = cleaned.querySelectorAll('div, span, p');
    emptyElements.forEach(el => {
      if (!el.textContent?.trim() && !el.querySelector('img, video, audio')) {
        el.remove();
      }
    });

    return cleaned;
  }

  /**
   * Convert HTML to Markdown with configurable options
   */
  private static htmlToMarkdown(html: string, options: IBookmarkletExtractionOptions): string {
    let markdown = html;

    // Headers (h1-h6)
    markdown = markdown.replace(/<h([1-6])[^>]*>(.*?)<\/h[1-6]>/gi, (match, level, content) => {
      const headerLevel = '#'.repeat(parseInt(level));
      const cleanContent = this.stripHtml(content).trim();
      return `\n${headerLevel} ${cleanContent}\n`;
    });

    // Paragraphs
    markdown = markdown.replace(/<p[^>]*>(.*?)<\/p>/gi, '\n$1\n');

    // Line breaks
    markdown = markdown.replace(/<br[^>]*\/?>/gi, '\n');

    // Bold/Strong
    markdown = markdown.replace(/<(strong|b)[^>]*>(.*?)<\/(strong|b)>/gi, '**$2**');

    // Italic/Emphasis
    markdown = markdown.replace(/<(em|i)[^>]*>(.*?)<\/(em|i)>/gi, '*$2*');

    // Code blocks
    markdown = markdown.replace(/<pre[^>]*><code[^>]*>(.*?)<\/code><\/pre>/gis, '\n```\n$1\n```\n');
    markdown = markdown.replace(/<code[^>]*>(.*?)<\/code>/gi, '`$1`');

    // Blockquotes
    markdown = markdown.replace(/<blockquote[^>]*>(.*?)<\/blockquote>/gis, (match, content) => {
      const cleanContent = this.stripHtml(content).trim();
      const lines = cleanContent.split('\n');
      return '\n' + lines.map(line => `> ${line.trim()}`).join('\n') + '\n';
    });

    // Lists
    markdown = markdown.replace(/<ul[^>]*>(.*?)<\/ul>/gis, (match, content) => {
      const items = content.replace(/<li[^>]*>(.*?)<\/li>/gi, '- $1\n');
      return `\n${items}\n`;
    });

    markdown = markdown.replace(/<ol[^>]*>(.*?)<\/ol>/gis, (match, content) => {
      let counter = 1;
      const items = content.replace(/<li[^>]*>(.*?)<\/li>/gi, () => `${counter++}. $1\n`);
      return `\n${items}\n`;
    });

    // Links (if enabled)
    if (options.includeLinks !== false) {
      markdown = markdown.replace(/<a[^>]*href=["']([^"']*)["'][^>]*>(.*?)<\/a>/gi, '[$2]($1)');
    }

    // Images (if enabled)
    if (options.includeImages !== false) {
      markdown = markdown.replace(
        /<img[^>]*src=["']([^"']*)["'][^>]*alt=["']([^"']*)["'][^>]*>/gi,
        '![$2]($1)'
      );
      markdown = markdown.replace(
        /<img[^>]*alt=["']([^"']*)["'][^>]*src=["']([^"']*)["'][^>]*>/gi,
        '![$1]($2)'
      );
      markdown = markdown.replace(/<img[^>]*src=["']([^"']*)["'][^>]*>/gi, '![]($1)');
    }

    // Strip remaining HTML tags
    markdown = this.stripHtml(markdown);

    // Clean up whitespace
    markdown = markdown
      .replace(/\n\s*\n\s*\n/g, '\n\n') // Remove excessive blank lines
      .replace(/[ \t]+/g, ' ') // Normalize spaces
      .trim();

    return markdown;
  }

  /**
   * Strip HTML tags from text
   */
  private static stripHtml(html: string): string {
    const div = document.createElement('div');
    div.innerHTML = html;
    return div.textContent || div.innerText || '';
  }

  /**
   * Generate frontmatter for the captured content
   */
  private static generateFrontmatter(title: string, url: string): string {
    const now = new Date();
    const dateStr = now.toISOString().split('T')[0];
    const domain = this.extractDomain(url);

    // Extract meta description
    const description =
      document
        .querySelector('meta[name="description"]')
        ?.getAttribute('content')
        ?.trim()
        .substring(0, 160) || '';

    // Extract keywords
    const keywords =
      document
        .querySelector('meta[name="keywords"]')
        ?.getAttribute('content')
        ?.split(',')
        .map(k => k.trim()) || [];

    // Extract author
    const author =
      document.querySelector('meta[name="author"]')?.getAttribute('content')?.trim() || '';

    const frontmatter = [
      '---',
      `title: "${title.replace(/"/g, '\\"')}"`,
      `url: "${url}"`,
      `domain: "${domain}"`,
      `date: "${dateStr}"`,
      `captured: "${now.toISOString()}"`,
      ...(description ? [`description: "${description.replace(/"/g, '\\"')}"`] : []),
      ...(author ? [`author: "${author.replace(/"/g, '\\"')}"`] : []),
      ...(keywords.length > 0
        ? [`keywords: [${keywords.map(k => `"${k.replace(/"/g, '\\"')}"`).join(', ')}]`]
        : []),
      'tags: []',
      '---',
    ];

    return frontmatter.join('\n');
  }

  /**
   * Extract domain from URL
   */
  private static extractDomain(url: string): string {
    try {
      return new URL(url).hostname;
    } catch {
      return 'unknown';
    }
  }

  /**
   * Count words in text
   */
  private static countWords(text: string): number {
    return text
      .trim()
      .split(/\s+/)
      .filter(word => word.length > 0).length;
  }

  /**
   * Generate a SEO-friendly filename from title
   */
  static generateFilename(title: string, date?: Date): string {
    const dateStr = (date || new Date()).toISOString().split('T')[0];
    const slug = title
      .toLowerCase()
      .replace(/[^a-z0-9\s-]/g, '') // Remove special characters
      .replace(/\s+/g, '-') // Replace spaces with hyphens
      .replace(/-+/g, '-') // Replace multiple hyphens with single
      .replace(/^-+|-+$/g, '') // Remove leading/trailing hyphens
      .substring(0, 50); // Limit length

    return `${dateStr}-${slug}.md`;
  }

  /**
   * Validate if page is capturable
   */
  static isPageCapturable(): boolean {
    const url = window.location.href;
    const protocol = window.location.protocol;

    // Check for valid protocols
    if (!['http:', 'https:', 'file:'].includes(protocol)) {
      return false;
    }

    // Check for browser internal pages
    const restrictedPages = [
      'chrome://',
      'chrome-extension://',
      'edge://',
      'about:',
      'moz-extension://',
      'safari-extension://',
      'ms-browser-extension://',
    ];

    return !restrictedPages.some(prefix => url.startsWith(prefix));
  }

  /**
   * Check if current page is likely a PDF
   */
  static isPdfPage(): boolean {
    const url = window.location.href;
    const contentType = document.contentType || '';

    return (
      url.toLowerCase().includes('.pdf') ||
      contentType.includes('application/pdf') ||
      document.querySelector('embed[type="application/pdf"]') !== null
    );
  }

  /**
   * Get page statistics for debugging
   */
  static getPageStats(): {
    title: string;
    url: string;
    domain: string;
    wordCount: number;
    imageCount: number;
    linkCount: number;
    isCapturable: boolean;
    isPdf: boolean;
  } {
    const title = this.extractTitle();
    const content = this.findMainContent();
    const text = content.textContent || '';

    return {
      title,
      url: window.location.href,
      domain: this.extractDomain(window.location.href),
      wordCount: this.countWords(text),
      imageCount: document.querySelectorAll('img').length,
      linkCount: document.querySelectorAll('a').length,
      isCapturable: this.isPageCapturable(),
      isPdf: this.isPdfPage(),
    };
  }
}
