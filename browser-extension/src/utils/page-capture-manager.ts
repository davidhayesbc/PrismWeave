// Generated by Copilot
// Page Capture Manager - Orchestrates the complete page capture workflow
// Extracted from service worker for better testability and reusability

import { ICaptureResult, ISettings } from '../types/index.js';
import { ContentExtractionManager } from './content-extraction-manager.js';
import { DocumentProcessor } from './document-processor.js';
import { GitHubFileManager, IGitHubCommitParams } from './github-file-manager.js';
import { createLogger } from './logger.js';
import { SettingsManager } from './settings-manager.js';

const logger = createLogger('PageCaptureManager');

export interface ICaptureOptions {
  validateSettings?: boolean;
  includeMarkdown?: boolean;
  forceGitHubCommit?: boolean;
}

export class PageCaptureManager {
  private contentExtractor: ContentExtractionManager;
  private documentProcessor: DocumentProcessor;
  private githubManager: GitHubFileManager;
  private settingsManager: SettingsManager;

  constructor(settingsManager: SettingsManager) {
    this.contentExtractor = new ContentExtractionManager();
    this.documentProcessor = new DocumentProcessor();
    this.githubManager = new GitHubFileManager();
    this.settingsManager = settingsManager;
  }

  /**
   * Capture and process a page from the active tab
   */
  async capturePage(
    data?: Record<string, unknown>,
    options: ICaptureOptions = {}
  ): Promise<ICaptureResult> {
    try {
      logger.info('Starting page capture workflow');

      // Step 1: Validate settings
      const settings = await this.validateAndGetSettings(options.validateSettings !== false);

      // Step 2: Get active tab
      const activeTab = await this.getActiveTab();
      const tabId = activeTab.id!;

      logger.debug('Capturing content from tab:', {
        url: activeTab.url,
        title: activeTab.title,
        id: tabId,
      });

      // Step 3: Extract content
      const extractionResult = await this.contentExtractor.extractContent(tabId);

      if (!extractionResult.success || !extractionResult.data) {
        throw new Error(extractionResult.error || 'Content extraction failed');
      }

      const { markdown, frontmatter, title, url, metadata } = extractionResult.data;

      // Step 4: Validate content
      if (!markdown && !extractionResult.data.html) {
        throw new Error('No content extracted from page');
      }

      // Step 5: Process document
      const finalContent = (frontmatter || '') + (markdown || '');
      const processedDoc = this.documentProcessor.processDocument(
        finalContent,
        title || activeTab.title || 'Untitled',
        url || activeTab.url || '',
        metadata || {},
        settings
      );

      logger.debug('Document processed:', {
        filename: processedDoc.filename,
        folder: processedDoc.folder,
        contentLength: processedDoc.content.length,
      });

      // Step 6: Handle GitHub commit if enabled
      const shouldCommit =
        options.forceGitHubCommit ||
        (settings.autoCommit && settings.githubToken && settings.githubRepo);

      if (shouldCommit) {
        logger.info('Committing to GitHub repository');
        const commitResult = await this.commitToGitHub(processedDoc, settings);

        if (commitResult.success) {
          return this.createSuccessResult(processedDoc, {
            message: 'Page captured and committed to repository',
            ...(commitResult.data?.html_url && { commitUrl: commitResult.data.html_url }),
            ...(options.includeMarkdown !== undefined && {
              includeMarkdown: options.includeMarkdown,
            }),
          });
        } else {
          logger.warn('GitHub commit failed, falling back to local storage:', commitResult.error);
        }
      }

      // Step 7: Fallback to local storage
      await this.storeLocally(processedDoc);

      return this.createSuccessResult(processedDoc, {
        message: 'Page captured and stored locally (pending sync)',
        status: 'pending_sync',
        ...(options.includeMarkdown !== undefined && { includeMarkdown: options.includeMarkdown }),
      });
    } catch (error) {
      logger.error('Error in page capture workflow:', error);
      return {
        success: false,
        message: error instanceof Error ? error.message : 'Unknown error occurred',
      };
    }
  }

  /**
   * Test GitHub connection using current settings
   */
  async testGitHubConnection(): Promise<unknown> {
    try {
      const settings = await this.settingsManager.getSettings();

      if (!settings.githubToken || !settings.githubRepo) {
        return {
          success: false,
          status: 'failed',
          error: 'GitHub token and repository are required',
          timestamp: new Date().toISOString(),
        };
      }

      const result = await this.githubManager.testConnection(
        settings.githubToken,
        settings.githubRepo
      );

      return {
        ...result,
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      logger.error('GitHub connection test failed:', error);
      return {
        success: false,
        status: 'failed',
        error: error instanceof Error ? error.message : 'Unknown error occurred',
        timestamp: new Date().toISOString(),
      };
    }
  }

  /**
   * Validate settings and return them
   */
  private async validateAndGetSettings(shouldValidate: boolean): Promise<ISettings> {
    const settings = await this.settingsManager.getSettings();

    if (shouldValidate) {
      const validation = this.settingsManager.validateSettings(settings);
      if (!validation.isValid) {
        throw new Error(`Invalid settings: ${validation.errors.join(', ')}`);
      }
    }

    return settings as ISettings;
  }

  /**
   * Get the currently active tab
   */
  private async getActiveTab(): Promise<chrome.tabs.Tab> {
    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });

    if (!tabs.length || !tabs[0].id) {
      throw new Error('No active tab found');
    }

    return tabs[0];
  }

  /**
   * Commit processed document to GitHub
   */
  private async commitToGitHub(
    processedDoc: ReturnType<DocumentProcessor['processDocument']>,
    settings: ISettings
  ) {
    const commitParams: IGitHubCommitParams = {
      token: settings.githubToken!,
      repo: settings.githubRepo!,
      filePath: processedDoc.filePath,
      content: processedDoc.content,
      message: this.documentProcessor.generateCommitMessage(processedDoc.metadata),
      url: processedDoc.metadata.url,
    };

    return await this.githubManager.commitToGitHub(commitParams);
  }

  /**
   * Store document locally for later sync
   */
  private async storeLocally(
    processedDoc: ReturnType<DocumentProcessor['processDocument']>
  ): Promise<void> {
    const storageKey = `pending_capture_${Date.now()}`;

    await chrome.storage.local.set({
      [storageKey]: {
        filePath: processedDoc.filePath,
        content: processedDoc.content,
        title: processedDoc.metadata.title,
        url: processedDoc.metadata.url,
        timestamp: new Date().toISOString(),
      },
    });

    logger.debug('Document stored locally with key:', storageKey);
  }

  /**
   * Create a successful capture result
   */
  private createSuccessResult(
    processedDoc: ReturnType<DocumentProcessor['processDocument']>,
    options: {
      message: string;
      commitUrl?: string;
      status?: string;
      includeMarkdown?: boolean;
    }
  ): ICaptureResult {
    const result: ICaptureResult = {
      success: true,
      message: options.message,
      data: {
        filename: processedDoc.filename,
        filePath: processedDoc.filePath,
        title: processedDoc.metadata.title,
        url: processedDoc.metadata.url,
        markdownLength: processedDoc.content.length,
        timestamp: new Date().toISOString(),
      },
    };

    // Add optional fields
    if (options.commitUrl) {
      result.data!.commitUrl = options.commitUrl;
    }

    if (options.status) {
      result.data!.status = options.status;
    }

    if (options.includeMarkdown) {
      result.data!.markdown = processedDoc.content;
    }

    return result;
  }
}
