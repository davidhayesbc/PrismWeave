// Generated by Copilot
// Test-specific logger implementation for PrismWeave browser extension
// Phase 2.3: Test Environment Logging - Controlled output for test development

type TestLogLevel = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG' | 'TRACE';

interface ITestLogConfig {
  enabled: boolean;
  level: TestLogLevel;
  writeToFile: boolean;
  showTimestamps: boolean;
  showTestContext: boolean;
  maxLogLength: number;
}

interface ITestLogEntry {
  timestamp: string;
  level: TestLogLevel;
  testSuite?: string | undefined;
  testCase?: string | undefined;
  component: string;
  message: string;
  data?: unknown;
}

class TestLogger {
  private _config: ITestLogConfig;
  private _component: string;
  private _entries: ITestLogEntry[] = [];
  private _testContext: { suite?: string | undefined; case?: string | undefined } = {};
  private static _globalConfig: Partial<ITestLogConfig> = {};

  constructor(component: string, config?: Partial<ITestLogConfig>) {
    this._component = component;
    this._config = {
      enabled: this._isDebugMode(),
      level: this._getDefaultLevel(),
      writeToFile: false,
      showTimestamps: true,
      showTestContext: true,
      maxLogLength: 500,
      ...TestLogger._globalConfig,
      ...config,
    };
  }

  private _isDebugMode(): boolean {
    return (
      process.env.TEST_DEBUG === 'true' ||
      process.env.NODE_ENV === 'development' ||
      typeof (global as any).TEST_LOGGER_DEBUG !== 'undefined'
    );
  }

  private _getDefaultLevel(): TestLogLevel {
    const envLevel = process.env.TEST_LOG_LEVEL as TestLogLevel;
    if (envLevel && ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE'].includes(envLevel)) {
      return envLevel;
    }
    return this._isDebugMode() ? 'DEBUG' : 'ERROR';
  }

  private _shouldLog(level: TestLogLevel): boolean {
    if (!this._config.enabled) return false;

    const levels = ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE'];
    const currentLevelIndex = levels.indexOf(this._config.level);
    const messageLevelIndex = levels.indexOf(level);

    return messageLevelIndex <= currentLevelIndex;
  }

  private _formatMessage(level: TestLogLevel, message: string, data?: unknown): string {
    const parts: string[] = [];

    if (this._config.showTimestamps) {
      parts.push(`[${new Date().toISOString().substr(11, 12)}]`);
    }

    parts.push(`[TEST-${level}]`);
    parts.push(`[${this._component}]`);

    if (this._config.showTestContext) {
      if (this._testContext.suite) {
        parts.push(`[${this._testContext.suite}]`);
      }
      if (this._testContext.case) {
        parts.push(`[${this._testContext.case}]`);
      }
    }

    let fullMessage = `${parts.join(' ')} ${message}`;

    if (data !== undefined) {
      const dataStr = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
      const truncatedData =
        dataStr.length > this._config.maxLogLength
          ? dataStr.substring(0, this._config.maxLogLength) + '...[truncated]'
          : dataStr;
      fullMessage += `\nData: ${truncatedData}`;
    }

    return fullMessage;
  }

  private _log(level: TestLogLevel, message: string, data?: unknown): void {
    if (!this._shouldLog(level)) return;

    const entry: ITestLogEntry = {
      timestamp: new Date().toISOString(),
      level,
      testSuite: this._testContext.suite,
      testCase: this._testContext.case,
      component: this._component,
      message,
      data,
    };

    this._entries.push(entry);

    // Keep only last 1000 entries to prevent memory issues
    if (this._entries.length > 1000) {
      this._entries.shift();
    }

    const formattedMessage = this._formatMessage(level, message, data);

    // Only output to console in debug mode
    if (this._isDebugMode()) {
      switch (level) {
        case 'ERROR':
          console.error(formattedMessage);
          break;
        case 'WARN':
          console.warn(formattedMessage);
          break;
        case 'INFO':
          console.info(formattedMessage);
          break;
        case 'DEBUG':
        case 'TRACE':
          console.log(formattedMessage);
          break;
      }
    }
  }

  // Public logging methods
  error(message: string, error?: unknown): void {
    this._log('ERROR', message, error);
  }

  warn(message: string, data?: unknown): void {
    this._log('WARN', message, data);
  }

  info(message: string, data?: unknown): void {
    this._log('INFO', message, data);
  }

  debug(message: string, data?: unknown): void {
    this._log('DEBUG', message, data);
  }

  trace(message: string, data?: unknown): void {
    this._log('TRACE', message, data);
  }

  // Test context management
  setTestSuite(suiteName: string): void {
    this._testContext.suite = suiteName;
    this._testContext.case = undefined;
  }

  setTestCase(caseName: string): void {
    this._testContext.case = caseName;
  }

  clearTestContext(): void {
    this._testContext = {};
  }

  // Test-specific utilities
  logTestStart(testName: string, data?: unknown): void {
    this.info(`üß™ Test started: ${testName}`, data);
  }

  logTestEnd(testName: string, success: boolean, duration?: number): void {
    const status = success ? '‚úÖ PASS' : '‚ùå FAIL';
    const durationStr = duration ? ` (${duration}ms)` : '';
    this.info(`${status}: ${testName}${durationStr}`);
  }

  logAssertion(assertion: string, success: boolean, actual?: unknown, expected?: unknown): void {
    if (success) {
      this.debug(`‚úì ${assertion}`);
    } else {
      this.error(`‚úó ${assertion}`, { actual, expected });
    }
  }

  logMockCall(mockName: string, args?: unknown[], result?: unknown): void {
    this.debug(`üé≠ Mock called: ${mockName}`, { args, result });
  }

  logPerformance(operation: string, duration: number, threshold?: number): void {
    const level = threshold && duration > threshold ? 'WARN' : 'DEBUG';
    const warning = threshold && duration > threshold ? ' (‚ö†Ô∏è slow)' : '';
    this._log(level, `‚è±Ô∏è ${operation}: ${duration}ms${warning}`);
  }

  // Configuration methods
  setConfig(config: Partial<ITestLogConfig>): void {
    this._config = { ...this._config, ...config };
  }

  enable(): void {
    this._config.enabled = true;
    this.info('Test logging enabled');
  }

  disable(): void {
    this.info('Test logging disabled');
    this._config.enabled = false;
  }

  // Log retrieval and management
  getEntries(filter?: { level?: TestLogLevel; component?: string }): ITestLogEntry[] {
    if (!filter) return [...this._entries];

    return this._entries.filter(entry => {
      if (filter.level && entry.level !== filter.level) return false;
      if (filter.component && entry.component !== filter.component) return false;
      return true;
    });
  }

  getEntriesAsText(): string {
    return this._entries
      .map(entry => this._formatMessage(entry.level, entry.message, entry.data))
      .join('\n');
  }

  clearEntries(): void {
    this._entries = [];
  }

  // Static configuration methods
  static setGlobalConfig(config: Partial<ITestLogConfig>): void {
    TestLogger._globalConfig = { ...TestLogger._globalConfig, ...config };
  }

  static enableDebugMode(): void {
    (global as any).TEST_LOGGER_DEBUG = true;
    TestLogger._globalConfig.enabled = true;
    TestLogger._globalConfig.level = 'DEBUG';
    console.log('üß™ Test Logger Debug Mode Enabled');
  }

  static disableDebugMode(): void {
    delete (global as any).TEST_LOGGER_DEBUG;
    TestLogger._globalConfig.enabled = false;
    console.log('üß™ Test Logger Debug Mode Disabled');
  }

  static createLogger(component: string): TestLogger {
    return new TestLogger(component);
  }
}

// Export factory function
export function createTestLogger(component: string): TestLogger {
  return new TestLogger(component);
}

// Export main class and types
export { ITestLogConfig, ITestLogEntry, TestLogger, TestLogLevel };
