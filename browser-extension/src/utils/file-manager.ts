// Generated by Copilot
// Unified File Manager - Consolidates file naming, organization, and GitHub operations
// Combines FileManager and GitHubFileManager into a single, comprehensive service

import { ChromeHttpProvider } from '../shared/adapters/chrome-adapters.js';
import { GitHubClient, ILogger } from '../shared/core/github-client.js';
import { IDocumentMetadata, IFileOperationResult } from '../types/index.js';
import { createLogger } from './logger.js';

const logger = createLogger('FileManager');

interface IFolderMapping {
  [key: string]: string[];
}

interface IFileNameComponents {
  date: string;
  domain: string;
  title: string;
  extension: string;
}

interface IFileManagerOptions {
  customNamingPattern?: string;
  fileNamingPattern?: string;
  defaultFolder?: string;
  customFolder?: string;
}

export interface IGitHubSettings {
  token: string;
  repository: string;
  branch?: string;
}

export interface IGitHubCommitParams {
  token: string;
  repo: string;
  filePath: string;
  content: string;
  message: string;
  url?: string;
}

export interface IGitHubCommitResult {
  success: boolean;
  data?: {
    html_url?: string;
    sha?: string;
    [key: string]: unknown;
  };
  error?: string;
}

export interface IGitHubFileInfo {
  sha: string;
  content: string;
  encoding: string;
}

export interface IRepositoryInfo {
  owner: string;
  repo: string;
}

export class FileManager {
  private static readonly API_BASE = 'https://api.github.com';
  private static readonly USER_AGENT = 'PrismWeave-Extension/1.0';
  private readonly folderMapping: IFolderMapping;
  private gitHubClient: GitHubClient;

  constructor() {
    this.folderMapping = {
      tech: [
        'programming',
        'software',
        'coding',
        'development',
        'technology',
        'tech',
        'javascript',
        'python',
        'react',
        'node',
        'github',
        'stackoverflow',
        'dev',
        'developer',
        'mozilla',
        'typescript',
        'haskell',
        'unison',
        'testing',
        'frontend',
        'backend',
        'api',
        'web',
        'code',
        'engineering',
        'computer',
        'ai',
        'machine-learning',
        'ocr',
        'document-processing',
        'ai-assisted-programming',
        'llm',
      ],
      business: [
        'business',
        'marketing',
        'finance',
        'startup',
        'entrepreneur',
        'sales',
        'management',
        'strategy',
        'linkedin',
        'leadership',
        'ceo',
        'fortune',
      ],
      tutorial: [
        'tutorial',
        'guide',
        'how-to',
        'learn',
        'course',
        'lesson',
        'walkthrough',
        'step-by-step',
        'complete',
        'beginner',
        'introduction',
        'getting-started',
        'setup',
        'install',
        'configure',
      ],
      news: [
        'news',
        'article',
        'blog',
        'opinion',
        'analysis',
        'update',
        'announcement',
        'breaking',
        'industry',
      ],
      research: [
        'research',
        'study',
        'paper',
        'academic',
        'journal',
        'thesis',
        'analysis',
        'data',
        'arxiv',
        'institute',
      ],
      design: ['design', 'ui', 'ux', 'css', 'figma', 'adobe', 'creative', 'visual', 'art'],
      tools: ['tool', 'utility', 'software', 'app', 'service', 'platform', 'extension'],
      personal: ['personal', 'diary', 'journal', 'thoughts', 'reflection', 'life', 'experience'],
      reference: ['reference', 'documentation', 'manual', 'spec', 'api', 'docs', 'wiki'],
    };
    
    // Initialize GitHub client with Chrome HTTP provider and logger
    const httpProvider = new ChromeHttpProvider();
    const gitHubLogger: ILogger = {
      info: (msg: string, ...args: any[]) => logger.info(msg, ...args),
      debug: (msg: string, ...args: any[]) => logger.debug(msg, ...args),
      warn: (msg: string, ...args: any[]) => logger.warn(msg, ...args),
      error: (msg: string, ...args: any[]) => logger.error(msg, ...args),
    };
    this.gitHubClient = new GitHubClient(httpProvider, gitHubLogger);
  }

  // =============================================================================
  // FILE NAMING AND ORGANIZATION METHODS
  // =============================================================================

  /**
   * Generate filename from metadata and settings
   */
  generateFilename(metadata: IDocumentMetadata, options: IFileManagerOptions = {}): string {
    try {
      const components = this.extractFileNameComponents(metadata);
      const pattern = options.fileNamingPattern || 'YYYY-MM-DD-domain-title';

      return this.applyNamingPattern(components, pattern, options);
    } catch (error) {
      logger.error('Error generating filename:', error);
      return this.getFallbackFilename(metadata);
    }
  }

  /**
   * Determine appropriate folder for content based on metadata
   */
  determineFolder(metadata: IDocumentMetadata, options: IFileManagerOptions = {}): string {
    // Use explicit folder setting if provided
    if (options.defaultFolder === 'custom' && options.customFolder) {
      return this.sanitizeFolderName(options.customFolder);
    }

    if (options.defaultFolder && options.defaultFolder !== 'auto') {
      return options.defaultFolder;
    }

    // Auto-detect folder based on content
    const detectedFolder = this.autoDetectFolder(metadata);
    return detectedFolder || 'unsorted';
  }

  /**
   * Generate complete file path including folder structure
   */
  generateFilePath(metadata: IDocumentMetadata, options: IFileManagerOptions = {}): string {
    const folder = this.determineFolder(metadata, options);
    const filename = this.generateFilename(metadata, options);

    return `documents/${folder}/${filename}`;
  }

  /**
   * Validate file path for safety and compliance
   */
  validateFilePath(filePath: string): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Check for dangerous characters
    const dangerousChars = /[<>:"|?*\x00-\x1f]/;
    if (dangerousChars.test(filePath)) {
      errors.push('File path contains invalid characters');
    }

    // Check path length
    if (filePath.length > 260) {
      errors.push('File path is too long (max 260 characters)');
    }

    // Check for reserved names
    const reservedNames = [
      'CON',
      'PRN',
      'AUX',
      'NUL',
      'COM1',
      'COM2',
      'COM3',
      'COM4',
      'COM5',
      'COM6',
      'COM7',
      'COM8',
      'COM9',
      'LPT1',
      'LPT2',
      'LPT3',
      'LPT4',
      'LPT5',
      'LPT6',
      'LPT7',
      'LPT8',
      'LPT9',
    ];
    const filename = filePath.split('/').pop()?.split('.')[0]?.toUpperCase();
    if (filename && reservedNames.includes(filename)) {
      errors.push('Filename uses reserved system name');
    }

    return {
      isValid: errors.length === 0,
      errors,
    };
  }

  /**
   * Create unique filename to avoid conflicts
   */
  createUniqueFilename(basePath: string, existingFiles: string[] = []): string {
    const pathParts = basePath.split('/');
    const filename = pathParts.pop() || '';
    const directory = pathParts.join('/');

    const [name, extension] = this.splitFilename(filename);

    let counter = 1;
    let uniquePath = basePath;

    while (existingFiles.includes(uniquePath)) {
      const uniqueName = `${name}-${counter}.${extension}`;
      uniquePath = directory ? `${directory}/${uniqueName}` : uniqueName;
      counter++;
    }

    return uniquePath;
  }

  /**
   * Organize files into folder structure
   */
  organizeFiles(
    files: Array<{ metadata: IDocumentMetadata; content: string }>,
    options: IFileManagerOptions = {}
  ): Record<string, Array<{ filename: string; content: string; metadata: IDocumentMetadata }>> {
    const organized: Record<
      string,
      Array<{ filename: string; content: string; metadata: IDocumentMetadata }>
    > = {};

    files.forEach(file => {
      const folder = this.determineFolder(file.metadata, options);
      const filename = this.generateFilename(file.metadata, options);

      if (!organized[folder]) {
        organized[folder] = [];
      }

      organized[folder].push({
        filename,
        content: file.content,
        metadata: file.metadata,
      });
    });

    return organized;
  }

  // =============================================================================
  // GITHUB OPERATIONS METHODS
  // =============================================================================

  /**
   * Save markdown file to GitHub with automatic file naming and organization
   */
  async saveToGitHub(
    content: string,
    metadata: IDocumentMetadata,
    githubSettings: IGitHubSettings,
    options: IFileManagerOptions = {}
  ): Promise<IFileOperationResult> {
    try {
      // Generate file path using naming/organization logic
      const fullPath = this.generateFilePath(metadata, options);
      const validation = this.validateFilePath(fullPath);

      if (!validation.isValid) {
        return {
          success: false,
          filePath: fullPath,
          error: `Invalid file path: ${validation.errors.join(', ')}`,
        };
      }

      // Create commit message
      const commitMessage = this.generateCommitMessage(metadata, fullPath);

      // Commit to GitHub
      const githubResult = await this.commitToGitHub({
        token: githubSettings.token,
        repo: githubSettings.repository,
        filePath: fullPath,
        content,
        message: commitMessage,
        url: metadata.url,
      });

      const result: IFileOperationResult = {
        success: githubResult.success,
        filePath: fullPath,
      };

      if (githubResult.data?.sha) {
        result.sha = githubResult.data.sha;
      }

      if (githubResult.data?.html_url) {
        result.url = githubResult.data.html_url;
      }

      if (githubResult.error) {
        result.error = githubResult.error;
      }

      return result;
    } catch (error) {
      logger.error('Error saving to GitHub:', error);
      return {
        success: false,
        filePath: '',
        error: (error as Error).message,
      };
    }
  }

  /**
   * Commit content to GitHub repository with automatic file creation/update
   */
  async commitToGitHub(params: IGitHubCommitParams): Promise<IGitHubCommitResult> {
    return this.gitHubClient.commitToGitHub(params);
  }

  /**
   * Test GitHub connection and permissions
   */
  async testGitHubConnection(
    token: string,
    repo: string
  ): Promise<{
    success: boolean;
    status: string;
    message?: string;
    details?: Record<string, unknown>;
    error?: string;
  }> {
    return this.gitHubClient.testConnection(token, repo);
  }

  // =============================================================================
  // UTILITY AND PREVIEW METHODS
  // =============================================================================

  /**
   * Generate file preview with validation and warnings
   */
  generateFilePreview(
    metadata: IDocumentMetadata,
    options: IFileManagerOptions = {}
  ): {
    filename: string;
    folder: string;
    fullPath: string;
    isValid: boolean;
    warnings: string[];
  } {
    const filename = this.generateFilename(metadata, options);
    const folder = this.determineFolder(metadata, options);
    const fullPath = `${folder}/${filename}`;
    const validation = this.validateFilePath(fullPath);

    const warnings: string[] = [];

    // Check for potential issues
    if (filename.length > 100) {
      warnings.push('Filename is quite long and may cause issues on some systems');
    }

    if (metadata.title.length < 5) {
      warnings.push('Document title is very short, consider adding more descriptive content');
    }

    return {
      filename,
      folder,
      fullPath,
      isValid: validation.isValid,
      warnings: [...warnings, ...validation.errors],
    };
  }

  // Public utility methods
  getAvailableFolders(): string[] {
    return Object.keys(this.folderMapping);
  }

  getFolderKeywords(folder: string): string[] {
    return this.folderMapping[folder] || [];
  }

  addFolderKeywords(folder: string, keywords: string[]): void {
    if (!this.folderMapping[folder]) {
      this.folderMapping[folder] = [];
    }

    keywords.forEach(keyword => {
      if (!this.folderMapping[folder].includes(keyword.toLowerCase())) {
        this.folderMapping[folder].push(keyword.toLowerCase());
      }
    });
  }

  getFileStats(filePath: string): { folder: string; filename: string; extension: string } {
    const parts = filePath.split('/');
    const filename = parts.pop() || '';
    const folder = parts.join('/') || '';
    const [name, extension] = this.splitFilename(filename);

    return { folder, filename: name, extension };
  }

  // =============================================================================
  // PRIVATE HELPER METHODS (FILE NAMING)
  // =============================================================================

  private extractFileNameComponents(metadata: IDocumentMetadata): IFileNameComponents {
    const date = this.formatDate(new Date(metadata.captureDate));
    const domain = this.extractDomain(metadata.url);
    const title = this.sanitizeTitle(metadata.title);

    return {
      date,
      domain,
      title,
      extension: 'md',
    };
  }

  private applyNamingPattern(
    components: IFileNameComponents,
    pattern: string,
    options: IFileManagerOptions = {}
  ): string {
    if (pattern === 'custom' && options.customNamingPattern) {
      pattern = options.customNamingPattern;
    }

    let filename = pattern
      .replace(/YYYY/g, components.date.substring(0, 4))
      .replace(/MM/g, components.date.substring(5, 7))
      .replace(/DD/g, components.date.substring(8, 10))
      .replace(/domain/g, components.domain)
      .replace(/title/g, components.title);

    // Add extension if not present
    if (!filename.endsWith(`.${components.extension}`)) {
      filename += `.${components.extension}`;
    }

    return this.sanitizeFilename(filename);
  }

  private formatDate(date: Date): string {
    return date.toISOString().split('T')[0];
  }

  private extractDomain(url: string): string {
    try {
      const urlObj = new URL(url);
      let domain = urlObj.hostname;

      // Remove www. prefix
      if (domain.startsWith('www.')) {
        domain = domain.substring(4);
      }

      // For known domains, keep meaningful subdomains
      const meaningfulSubdomains = ['developer', 'docs', 'api', 'blog', 'news'];
      const domainParts = domain.split('.');

      if (domainParts.length > 2) {
        const subdomain = domainParts[0];
        const mainDomain = domainParts.slice(-2).join('.');

        // Keep meaningful subdomains
        if (meaningfulSubdomains.includes(subdomain.toLowerCase())) {
          domain = `${subdomain}.${mainDomain}`;
        } else {
          // For other subdomains, just use main domain
          domain = mainDomain;
        }
      }

      return domain.replace(/\./g, '-');
    } catch {
      return 'unknown-site';
    }
  }

  private sanitizeTitle(title: string): string {
    return title
      .toLowerCase()
      .replace(/[^\w\s-]/g, '') // Remove special characters
      .replace(/\s+/g, '-') // Replace spaces with hyphens
      .replace(/-+/g, '-') // Replace multiple hyphens with single
      .replace(/^-|-$/g, '') // Remove leading/trailing hyphens
      .substring(0, 50); // Limit length
  }

  private sanitizeFilename(filename: string): string {
    return filename
      .replace(/[<>:"|?*\x00-\x1f]/g, '') // Remove invalid characters
      .replace(/\s+/g, '-') // Replace spaces with hyphens
      .replace(/-+/g, '-') // Replace multiple hyphens with single
      .replace(/^-|-$/g, ''); // Remove leading/trailing hyphens
  }

  private sanitizeFolderName(folderName: string): string {
    return folderName
      .toLowerCase()
      .replace(/[^\w\s-]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');
  }

  private getFallbackFilename(metadata: IDocumentMetadata): string {
    const date = this.formatDate(new Date(metadata.captureDate));
    const title = this.sanitizeTitle(metadata.title || 'untitled');
    return `${date}-${title}.md`;
  }

  private autoDetectFolder(metadata: IDocumentMetadata): string | null {
    // Prepare search content from multiple sources
    const searchSources = [
      metadata.title.toLowerCase(),
      metadata.url.toLowerCase(),
      ...metadata.tags.map(tag => tag.toLowerCase()),
      ...this.extractUrlKeywords(metadata.url),
    ];

    const searchText = searchSources.join(' ');

    // Score each folder based on keyword matches
    const folderScores: Record<string, number> = {};

    Object.entries(this.folderMapping).forEach(([folder, keywords]) => {
      let score = 0;

      keywords.forEach(keyword => {
        // Check for exact word matches (word boundaries)
        const wordBoundaryRegex = new RegExp(
          `\\b${keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`,
          'gi'
        );
        const matches = searchText.match(wordBoundaryRegex);
        if (matches) {
          score += matches.length;
        }

        // Additional scoring for URL domain matches
        if (metadata.url.toLowerCase().includes(keyword)) {
          score += 0.5; // Bonus points for URL matches
        }
      });

      if (score > 0) {
        folderScores[folder] = score;
      }
    });

    // Return folder with highest score, but only if score is meaningful
    const sortedFolders = Object.entries(folderScores).sort(([, a], [, b]) => b - a);
    const bestMatch = sortedFolders[0];

    // Require minimum score threshold to avoid false positives
    return bestMatch && bestMatch[1] >= 1 ? bestMatch[0] : null;
  }

  /**
   * Extract keywords from URL for enhanced folder detection
   */
  private extractUrlKeywords(url: string): string[] {
    try {
      const urlObj = new URL(url);
      const keywords: string[] = [];

      // Extract from hostname
      const hostname = urlObj.hostname.toLowerCase();

      // Remove www prefix and split by dots
      const domainParts = hostname.replace(/^www\./, '').split('.');
      keywords.push(...domainParts);

      // Extract meaningful parts from domain
      if (hostname.includes('github')) keywords.push('github', 'development', 'code');
      if (hostname.includes('stackoverflow'))
        keywords.push('stackoverflow', 'programming', 'development');
      if (hostname.includes('developer')) keywords.push('developer', 'development', 'tech');
      if (hostname.includes('mozilla')) keywords.push('mozilla', 'developer', 'web', 'tech');
      if (hostname.includes('linkedin')) keywords.push('linkedin', 'business', 'professional');
      if (hostname.includes('dev.to') || hostname.includes('dev'))
        keywords.push('dev', 'development', 'programming');
      if (hostname.includes('blog')) keywords.push('blog', 'article');
      if (hostname.includes('tutorial')) keywords.push('tutorial', 'guide');
      if (hostname.includes('news')) keywords.push('news', 'article');
      if (hostname.includes('research') || hostname.includes('arxiv'))
        keywords.push('research', 'academic');

      // Extract from pathname
      const pathParts = urlObj.pathname
        .toLowerCase()
        .split('/')
        .filter(part => part.length > 2);
      keywords.push(...pathParts);

      // Clean and filter keywords
      return keywords
        .map(keyword => keyword.replace(/[^a-z0-9]/g, ''))
        .filter(keyword => keyword.length > 2)
        .filter(keyword => !['com', 'org', 'net', 'www', 'http', 'https'].includes(keyword));
    } catch (error) {
      // If URL parsing fails, return empty array
      return [];
    }
  }

  private splitFilename(filename: string): [string, string] {
    const lastDot = filename.lastIndexOf('.');
    if (lastDot === -1) {
      return [filename, 'md'];
    }

    return [filename.substring(0, lastDot), filename.substring(lastDot + 1)];
  }

  private generateCommitMessage(metadata: IDocumentMetadata, filePath: string): string {
    const folder = this.getFileStats(filePath).folder;
    const domain = this.extractDomain(metadata.url);
    return `Add ${folder} article from ${domain}: ${metadata.title}`;
  }

  // =============================================================================
  // PRIVATE HELPER METHODS (GITHUB OPERATIONS)
  // =============================================================================

  /**
   * Parse repository path into owner and repo components
   */
  private parseRepositoryPath(repoPath: string): IRepositoryInfo {
    return this.gitHubClient.validateRepositoryPath(repoPath);
  }

  /**
   * Get file information from GitHub if it exists
   */

  /**
   * Create or update a file in the GitHub repository
   */
  // Removed: GitHub API methods are now handled by shared GitHubClient
  // Methods: createOrUpdateFile, validateToken, validateRepository, checkWritePermissions, getAuthHeaders
}
