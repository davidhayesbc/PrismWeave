// Generated by Copilot
// PrismWeave File Manager - TypeScript version
// File organization and management utilities

import { IDocumentMetadata, ISettings, IFileOperationResult } from '../types/index.js';

interface IFolderMapping {
  [key: string]: string[];
}

interface IFileNameComponents {
  date: string;
  domain: string;
  title: string;
  extension: string;
}

interface IFileManagerOptions {
  customNamingPattern?: string;
  fileNamingPattern?: string;
  defaultFolder?: string;
  customFolder?: string;
}

export class FileManager {
  private readonly folderMapping: IFolderMapping;

  constructor() {
    this.folderMapping = {
      tech: ['programming', 'software', 'coding', 'development', 'technology', 'tech', 'javascript', 'python', 'react', 'node', 'github', 'stackoverflow', 'dev.to'],
      business: ['business', 'marketing', 'finance', 'startup', 'entrepreneur', 'sales', 'management', 'strategy', 'linkedin'],
      tutorial: ['tutorial', 'guide', 'how-to', 'learn', 'course', 'lesson', 'walkthrough', 'step-by-step'],
      news: ['news', 'article', 'blog', 'opinion', 'analysis', 'update', 'announcement'],
      research: ['research', 'study', 'paper', 'academic', 'journal', 'thesis', 'analysis', 'data'],
      design: ['design', 'ui', 'ux', 'css', 'figma', 'adobe', 'creative', 'visual', 'art'],
      tools: ['tool', 'utility', 'software', 'app', 'service', 'platform', 'extension'],
      personal: ['personal', 'diary', 'journal', 'thoughts', 'reflection', 'life', 'experience'],
      reference: ['reference', 'documentation', 'manual', 'spec', 'api', 'docs', 'wiki']
    };
  }

  /**
   * Generate filename from metadata and settings
   */
  generateFilename(metadata: IDocumentMetadata, options: IFileManagerOptions = {}): string {
    try {
      const components = this.extractFileNameComponents(metadata);
      const pattern = options.fileNamingPattern || 'YYYY-MM-DD-domain-title';
      
      return this.applyNamingPattern(components, pattern, options);
    } catch (error) {
      console.error('FileManager: Error generating filename:', error);
      return this.getFallbackFilename(metadata);
    }
  }

  /**
   * Determine appropriate folder for content based on metadata
   */
  determineFolder(metadata: IDocumentMetadata, options: IFileManagerOptions = {}): string {
    // Use explicit folder setting if provided
    if (options.defaultFolder === 'custom' && options.customFolder) {
      return this.sanitizeFolderName(options.customFolder);
    }
    
    if (options.defaultFolder && options.defaultFolder !== 'auto') {
      return options.defaultFolder;
    }

    // Auto-detect folder based on content
    const detectedFolder = this.autoDetectFolder(metadata);
    return detectedFolder || 'unsorted';
  }

  /**
   * Generate complete file path including folder structure
   */
  generateFilePath(metadata: IDocumentMetadata, options: IFileManagerOptions = {}): string {
    const folder = this.determineFolder(metadata, options);
    const filename = this.generateFilename(metadata, options);
    
    return `${folder}/${filename}`;
  }

  /**
   * Validate file path for safety and compliance
   */
  validateFilePath(filePath: string): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];
    
    // Check for dangerous characters
    const dangerousChars = /[<>:"|?*\x00-\x1f]/;
    if (dangerousChars.test(filePath)) {
      errors.push('File path contains invalid characters');
    }
    
    // Check path length
    if (filePath.length > 260) {
      errors.push('File path is too long (max 260 characters)');
    }
    
    // Check for reserved names
    const reservedNames = ['CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9', 'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9'];
    const filename = filePath.split('/').pop()?.split('.')[0]?.toUpperCase();
    if (filename && reservedNames.includes(filename)) {
      errors.push('Filename uses reserved system name');
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }

  /**
   * Create unique filename to avoid conflicts
   */
  createUniqueFilename(basePath: string, existingFiles: string[] = []): string {
    const pathParts = basePath.split('/');
    const filename = pathParts.pop() || '';
    const directory = pathParts.join('/');
    
    const [name, extension] = this.splitFilename(filename);
    
    let counter = 1;
    let uniquePath = basePath;
    
    while (existingFiles.includes(uniquePath)) {
      const uniqueName = `${name}-${counter}.${extension}`;
      uniquePath = directory ? `${directory}/${uniqueName}` : uniqueName;
      counter++;
    }
    
    return uniquePath;
  }

  /**
   * Organize files into folder structure
   */
  organizeFiles(files: Array<{ metadata: IDocumentMetadata; content: string }>, options: IFileManagerOptions = {}): Record<string, Array<{ filename: string; content: string; metadata: IDocumentMetadata }>> {
    const organized: Record<string, Array<{ filename: string; content: string; metadata: IDocumentMetadata }>> = {};
    
    files.forEach(file => {
      const folder = this.determineFolder(file.metadata, options);
      const filename = this.generateFilename(file.metadata, options);
      
      if (!organized[folder]) {
        organized[folder] = [];
      }
      
      organized[folder].push({
        filename,
        content: file.content,
        metadata: file.metadata
      });
    });
    
    return organized;
  }

  private extractFileNameComponents(metadata: IDocumentMetadata): IFileNameComponents {
    const date = this.formatDate(new Date(metadata.captureDate));
    const domain = this.extractDomain(metadata.url);
    const title = this.sanitizeTitle(metadata.title);
    
    return {
      date,
      domain,
      title,
      extension: 'md'
    };
  }

  private applyNamingPattern(components: IFileNameComponents, pattern: string, options: IFileManagerOptions = {}): string {
    if (pattern === 'custom' && options.customNamingPattern) {
      pattern = options.customNamingPattern;
    }
    
    let filename = pattern
      .replace(/YYYY/g, components.date.substring(0, 4))
      .replace(/MM/g, components.date.substring(5, 7))
      .replace(/DD/g, components.date.substring(8, 10))
      .replace(/domain/g, components.domain)
      .replace(/title/g, components.title);
    
    // Add extension if not present
    if (!filename.endsWith(`.${components.extension}`)) {
      filename += `.${components.extension}`;
    }
    
    return this.sanitizeFilename(filename);
  }

  private formatDate(date: Date): string {
    return date.toISOString().split('T')[0];
  }

  private extractDomain(url: string): string {
    try {
      const urlObj = new URL(url);
      let domain = urlObj.hostname;
      
      // Remove www. prefix
      if (domain.startsWith('www.')) {
        domain = domain.substring(4);
      }
      
      // Take only the main domain (remove subdomains for common sites)
      const domainParts = domain.split('.');
      if (domainParts.length > 2) {
        // Keep only the last two parts for main domain
        domain = domainParts.slice(-2).join('.');
      }
      
      return domain.replace(/\./g, '-');
    } catch {
      return 'unknown-site';
    }
  }

  private sanitizeTitle(title: string): string {
    return title
      .toLowerCase()
      .replace(/[^\w\s-]/g, '') // Remove special characters
      .replace(/\s+/g, '-') // Replace spaces with hyphens
      .replace(/-+/g, '-') // Replace multiple hyphens with single
      .replace(/^-|-$/g, '') // Remove leading/trailing hyphens
      .substring(0, 50); // Limit length
  }

  private sanitizeFilename(filename: string): string {
    return filename
      .replace(/[<>:"|?*\x00-\x1f]/g, '') // Remove invalid characters
      .replace(/\s+/g, '-') // Replace spaces with hyphens
      .replace(/-+/g, '-') // Replace multiple hyphens with single
      .replace(/^-|-$/g, ''); // Remove leading/trailing hyphens
  }

  private sanitizeFolderName(folderName: string): string {
    return folderName
      .toLowerCase()
      .replace(/[^\w\s-]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');
  }

  private getFallbackFilename(metadata: IDocumentMetadata): string {
    const date = this.formatDate(new Date(metadata.captureDate));
    const title = this.sanitizeTitle(metadata.title || 'untitled');
    return `${date}-${title}.md`;
  }

  private autoDetectFolder(metadata: IDocumentMetadata): string | null {
    const searchText = [
      metadata.title.toLowerCase(),
      metadata.url.toLowerCase(),
      ...metadata.tags.map(tag => tag.toLowerCase())
    ].join(' ');

    // Score each folder based on keyword matches
    const folderScores: Record<string, number> = {};
    
    Object.entries(this.folderMapping).forEach(([folder, keywords]) => {
      let score = 0;
      keywords.forEach(keyword => {
        const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
        const matches = searchText.match(regex);
        if (matches) {
          score += matches.length;
        }
      });
      
      if (score > 0) {
        folderScores[folder] = score;
      }
    });

    // Return folder with highest score
    const bestFolder = Object.entries(folderScores)
      .sort(([, a], [, b]) => b - a)[0];
    
    return bestFolder ? bestFolder[0] : null;
  }

  private splitFilename(filename: string): [string, string] {
    const lastDot = filename.lastIndexOf('.');
    if (lastDot === -1) {
      return [filename, 'md'];
    }
    
    return [
      filename.substring(0, lastDot),
      filename.substring(lastDot + 1)
    ];
  }

  // Public utility methods
  getAvailableFolders(): string[] {
    return Object.keys(this.folderMapping);
  }

  getFolderKeywords(folder: string): string[] {
    return this.folderMapping[folder] || [];
  }

  addFolderKeywords(folder: string, keywords: string[]): void {
    if (!this.folderMapping[folder]) {
      this.folderMapping[folder] = [];
    }
    
    keywords.forEach(keyword => {
      if (!this.folderMapping[folder].includes(keyword.toLowerCase())) {
        this.folderMapping[folder].push(keyword.toLowerCase());
      }
    });
  }

  getFileStats(filePath: string): { folder: string; filename: string; extension: string } {
    const parts = filePath.split('/');
    const filename = parts.pop() || '';
    const folder = parts.join('/') || '';
    const [name, extension] = this.splitFilename(filename);
    
    return { folder, filename: name, extension };
  }

  generateFilePreview(metadata: IDocumentMetadata, options: IFileManagerOptions = {}): {
    filename: string;
    folder: string;
    fullPath: string;
    isValid: boolean;
    warnings: string[];
  } {
    const filename = this.generateFilename(metadata, options);
    const folder = this.determineFolder(metadata, options);
    const fullPath = `${folder}/${filename}`;
    const validation = this.validateFilePath(fullPath);
    
    const warnings: string[] = [];
    
    // Check for potential issues
    if (filename.length > 100) {
      warnings.push('Filename is quite long and may cause issues on some systems');
    }
    
    if (metadata.title.length < 5) {
      warnings.push('Document title is very short, consider adding more descriptive content');
    }
    
    return {
      filename,
      folder,
      fullPath,
      isValid: validation.isValid,
      warnings: [...warnings, ...validation.errors]
    };
  }

  /**
   * Save markdown file using the provided save function
   * This is a browser extension, so we can't write directly to filesystem
   * Instead, we'll save to GitHub via GitOperations
   */
  async saveMarkdownFile(
    content: string, 
    metadata: IDocumentMetadata, 
    options: IFileManagerOptions = {},
    gitOperations?: any
  ): Promise<IFileOperationResult> {
    try {
      // Generate file path
      const fullPath = this.generateFilePath(metadata, options);
      const validation = this.validateFilePath(fullPath);
      
      if (!validation.isValid) {
        return {
          success: false,
          filePath: fullPath,
          error: `Invalid file path: ${validation.errors.join(', ')}`
        };
      }

      // For browser extension, we need to use Git operations to save
      if (gitOperations) {
        const gitResult = await gitOperations.saveToGitHub(content, fullPath, metadata);
        
        return {
          success: gitResult.success,
          filePath: fullPath,
          sha: gitResult.sha,
          url: gitResult.url,
          error: gitResult.error
        };
      } else {
        // If no git operations provided, we can't actually save the file
        // This would be handled by the calling code
        return {
          success: false,
          filePath: fullPath,
          error: 'No save mechanism provided (Git operations required)'
        };
      }
    } catch (error) {
      console.error('FileManager: Error saving markdown file:', error);
      return {
        success: false,
        filePath: '',
        error: (error as Error).message
      };
    }
  }
}
