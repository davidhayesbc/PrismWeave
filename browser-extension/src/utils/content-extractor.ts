// Generated by Copilot
// Simplified Content Extractor - Refactored with separation of concerns
// Main orchestrator that uses specialized modules for different tasks

import { IDocumentMetadata } from '../types/index.js';
import { ContentCleaner, ICleaningOptions } from './content-cleaner.js';
import { ContentQualityAnalyzer, IQualityOptions } from './content-quality-analyzer.js';
import { ContentSelectorManager } from './content-selector-strategies.js';
import { createLogger } from './logger.js';
import { MetadataExtractor } from './metadata-extractor.js';

export interface IContentResult {
  content: string;
  metadata: IDocumentMetadata;
  cleanedContent: string;
  wordCount: number;
  readingTime: number;
}

export interface IExtractorOptions extends ICleaningOptions {
  customSelectors?: string[];
  waitForDynamicContent?: boolean;
}

/**
 * Main content extractor that orchestrates specialized modules
 */
export class ContentExtractor {
  private readonly logger = createLogger('ContentExtractor');
  private readonly selectorManager = new ContentSelectorManager();
  private readonly cleaner = new ContentCleaner();
  private readonly qualityAnalyzer = new ContentQualityAnalyzer();
  private readonly metadataExtractor = new MetadataExtractor();

  /**
   * Extract content from the current page
   */
  async extractContent(options: IExtractorOptions = {}): Promise<IContentResult> {
    try {
      this.logger.debug('Starting content extraction');

      // Wait for content to load if needed
      await this.waitForContentIfNeeded(options);

      // Extract metadata first
      const metadata = this.metadataExtractor.extractMetadata();
      this.logger.debug('Metadata extracted:', metadata);

      // Find main content element
      const contentElement = this.findMainContent(options);
      if (!contentElement) {
        throw new Error('No suitable content found on page');
      }

      // Clean the content with domain-aware options
      const cleaningOptions = {
        ...options,
        domain: window.location.hostname,
        isResearchPage: this.isResearchPage(window.location.hostname, window.location.pathname),
      };
      const cleanedElement = this.cleaner.cleanContent(contentElement, cleaningOptions);
      const content = cleanedElement.innerHTML || '';
      const cleanedContent = this.cleanContent(content, options);

      // Calculate metrics
      const wordCount = this.countWords(cleanedContent);
      const readingTime = this.estimateReadingTime(wordCount);

      // Update metadata with calculated values
      metadata.wordCount = wordCount;
      metadata.estimatedReadingTime = readingTime;

      this.logger.debug('Content extraction complete', {
        contentLength: content.length,
        wordCount,
        readingTime,
      });

      return {
        content,
        metadata,
        cleanedContent,
        wordCount,
        readingTime,
      };
    } catch (error) {
      this.logger.error('Error during extraction:', error);
      throw error;
    }
  }

  /**
   * Find the main content element on the page
   */
  private findMainContent(options: IExtractorOptions): Element | null {
    const url = window.location.href;

    // Try custom selectors first
    if (options.customSelectors?.length) {
      for (const selector of options.customSelectors) {
        try {
          const element = document.querySelector(selector);
          if (element && this.isValidContent(element)) {
            this.logger.debug('Found content with custom selector:', selector);
            return element;
          }
        } catch (error) {
          this.logger.warn('Invalid custom selector:', selector, error);
        }
      }
    }

    // For GitHub markdown files, use specific content extraction
    if (url.includes('github.com') && (url.includes('/blob/') || url.includes('.md'))) {
      const githubContent = this.findGitHubMarkdownContent();
      if (githubContent) {
        this.logger.debug('Found GitHub markdown content');
        return githubContent;
      }
    }

    // For Anthropic research pages, use specific content extraction
    if (url.includes('anthropic.com')) {
      const anthropicContent = this.findAnthropicContent();
      if (anthropicContent) {
        this.logger.debug('Found Anthropic research content');
        return anthropicContent;
      }
    }

    // For Stack Overflow blog, use specific content extraction
    if (url.includes('stackoverflow.blog')) {
      const soContent = this.findStackOverflowBlogContent();
      if (soContent) {
        this.logger.debug('Found Stack Overflow blog content');
        return soContent;
      }
    }

    // For Substack, use enhanced content extraction
    if (url.includes('substack.com')) {
      const substackContent = this.findSubstackContent();
      if (substackContent) {
        this.logger.debug('Found Substack content using enhanced extraction');
        return substackContent;
      }
    }

    // Use selector manager to find content
    const element = this.selectorManager.findContentElement(url, document);
    if (element) {
      this.logger.debug('Found content with selector strategy');
      return element;
    }

    // Fallback to largest content container
    const fallbackElement = this.findLargestContentContainer();
    if (fallbackElement) {
      this.logger.debug('Using largest content container as fallback');
      return fallbackElement;
    }

    // Final fallback to body
    this.logger.debug('Using body as final fallback');
    return document.body;
  }

  /**
   * Specific content extraction for Anthropic research pages
   */
  private findAnthropicContent(): Element | null {
    // Enhanced Anthropic content selectors for research pages
    const contentSelectors = [
      // Primary research content containers
      'main article',
      'article',
      'main',
      '[role="main"]',

      // Research-specific containers
      '.research-content',
      '.article-content',
      '.post-content',
      '.blog-content',
      '.content',
      '.main-content',

      // Next.js/React patterns (Anthropic uses Next.js)
      '#__next main',
      '[data-reactroot] main',
      '#__next article',
      '[data-reactroot] article',

      // Data attributes and components
      '[data-testid="article"]',
      '[data-testid="content"]',
      '[data-testid="research-content"]',
      '[data-component="article"]',
      '[data-component="research"]',

      // Container patterns
      '.container main',
      '.wrapper main',
      '.layout main',
      '.page-container main',
      '.content-container',
      '.article-container',
      '.research-container',

      // Fallback class-based selectors
      '[class*="research"]',
      '[class*="article"]',
      '[class*="content"]',
      '[class*="post"]',
    ];

    for (const selector of contentSelectors) {
      try {
        const element = document.querySelector(selector);
        if (element && this.isValidAnthropicContent(element)) {
          this.logger.debug('Found Anthropic content with selector:', selector);
          return element;
        }
      } catch (error) {
        this.logger.warn('Invalid Anthropic selector:', selector, error);
      }
    }

    // Advanced fallback: Find content by structure analysis for research pages
    const anthropicStructureContent = this.findAnthropicContentByStructure();
    if (anthropicStructureContent) {
      this.logger.debug('Found Anthropic content using structure analysis');
      return anthropicStructureContent;
    }

    this.logger.warn('No suitable Anthropic research content found');
    return null;
  }

  /**
   * Find Anthropic content using structure analysis when selectors fail
   */
  private findAnthropicContentByStructure(): Element | null {
    // Look for elements that contain typical research article structure:
    // - Research-related headings
    // - Multiple paragraphs with substantial content
    // - Academic/research language patterns

    const candidates = Array.from(document.querySelectorAll('div, section, article, main'))
      .filter(el => {
        const text = el.textContent?.trim() || '';
        const className = el.className.toLowerCase();

        // Must have substantial text content (research articles are typically long)
        if (text.length < 2000) return false;

        // Look for research article structure
        const paragraphs = el.querySelectorAll('p').length;
        const headings = el.querySelectorAll('h1, h2, h3, h4, h5, h6').length;

        // Should have substantial structure
        if (paragraphs < 5 && headings < 3) return false;

        // Prefer elements with content-related classes
        const contentTerms = ['content', 'research', 'article', 'post', 'main', 'body'];
        const hasContentClass = contentTerms.some(term => className.includes(term));

        // Exclude navigation and promotional areas
        const excludeTerms = [
          'nav',
          'menu',
          'header',
          'footer',
          'sidebar',
          'newsletter',
          'subscribe',
          'related',
          'recommendation',
          'comment',
          'social',
        ];
        const hasExcludeClass = excludeTerms.some(term => className.includes(term));

        if (hasExcludeClass && !hasContentClass) return false;

        // Check for research content indicators
        const researchIndicators = [
          'research',
          'study',
          'experiment',
          'analysis',
          'project',
          'findings',
          'methodology',
          'claude',
          'ai',
          'anthropic',
        ];

        const hasResearchContent = researchIndicators.some(indicator =>
          text.toLowerCase().includes(indicator)
        );

        return hasContentClass || hasResearchContent;
      })
      .sort((a, b) => {
        // Score by content quality
        const scoreA = this.scoreAnthropicElement(a);
        const scoreB = this.scoreAnthropicElement(b);
        return scoreB - scoreA;
      });

    return candidates.length > 0 ? candidates[0] : null;
  }

  /**
   * Score Anthropic elements for content quality
   */
  private scoreAnthropicElement(element: Element): number {
    let score = 0;
    const text = element.textContent?.trim() || '';
    const className = element.className.toLowerCase();

    // Base score from text length (research articles are longer)
    score += Math.min(text.length / 15, 400);

    // Bonus for content-related classes
    const contentBonuses = [
      { term: 'research', bonus: 250 },
      { term: 'article', bonus: 200 },
      { term: 'content', bonus: 150 },
      { term: 'main', bonus: 120 },
      { term: 'post', bonus: 100 },
      { term: 'blog', bonus: 80 },
    ];

    contentBonuses.forEach(({ term, bonus }) => {
      if (className.includes(term)) {
        score += bonus;
      }
    });

    // Bonus for semantic HTML elements
    if (element.tagName === 'MAIN' || element.tagName === 'ARTICLE') {
      score += 200;
    }

    // Penalty for navigation terms
    const navPenalties = [
      'nav',
      'menu',
      'header',
      'footer',
      'sidebar',
      'newsletter',
      'subscribe',
      'social',
      'comment',
      'related',
    ];

    navPenalties.forEach(term => {
      if (className.includes(term)) {
        score -= 150;
      }
    });

    // Bonus for paragraph structure (research articles have many paragraphs)
    const paragraphs = element.querySelectorAll('p').length;
    score += paragraphs * 20;

    // Bonus for headings (research articles have structured headings)
    const headings = element.querySelectorAll('h1, h2, h3, h4, h5, h6').length;
    score += headings * 30;

    // Bonus for research-specific content
    const researchTerms = [
      'research',
      'study',
      'experiment',
      'project',
      'analysis',
      'findings',
      'claude',
      'anthropic',
    ];

    researchTerms.forEach(term => {
      if (text.toLowerCase().includes(term)) {
        score += 30;
      }
    });

    return Math.max(0, score);
  }

  /**
   * Validate if element contains good Anthropic research content
   */
  private isValidAnthropicContent(element: Element): boolean {
    const text = element.textContent?.trim() || '';
    const className = element.className.toLowerCase();

    // Must have substantial content (research articles are typically long)
    if (text.length < 500) return false;

    // Should have good structure
    const paragraphs = element.querySelectorAll('p').length;
    const headings = element.querySelectorAll('h1, h2, h3, h4, h5, h6').length;

    if (paragraphs < 2 && headings < 1) return false;

    // Avoid pure navigation or promotional content
    const navTerms = ['navigation', 'nav', 'menu', 'footer', 'header', 'sidebar'];
    const isNavContent = navTerms.some(term => className.includes(term));

    if (isNavContent && paragraphs < 5) return false;

    // Check for research content indicators
    const researchPatterns = [
      'research',
      'study',
      'experiment',
      'project',
      'analysis',
      'claude',
      'anthropic',
      'ai',
      'methodology',
      'findings',
    ];

    const hasResearchContent = researchPatterns.some(pattern =>
      text.toLowerCase().includes(pattern)
    );

    // For Anthropic pages, prefer content with research indicators
    if (hasResearchContent || paragraphs > 5) {
      return true;
    }

    // Check for typical academic/research article patterns
    const hasAcademicStructure =
      text.includes('abstract') ||
      text.includes('conclusion') ||
      text.includes('methodology') ||
      text.includes('introduction') ||
      headings > 3;

    return hasAcademicStructure;
  }

  /**
   * Check if the current page is a research/academic page that needs special handling
   */
  private isResearchPage(hostname: string, pathname: string): boolean {
    const researchDomains = [
      'anthropic.com',
      'arxiv.org',
      'paper',
      'research',
      'academic',
      'openai.com',
      'deepmind.com',
      'microsoft.com/en-us/research',
      'ai.google',
      'research.google',
    ];

    const researchPathPatterns = [
      '/research/',
      '/papers/',
      '/publications/',
      '/blog/',
      '/insights/',
      '/technical/',
    ];

    // Check domain
    const isDomainResearch = researchDomains.some(domain => hostname.includes(domain));

    // Check path patterns
    const isPathResearch = researchPathPatterns.some(pattern =>
      pathname.toLowerCase().includes(pattern)
    );

    // Check for research-related keywords in URL
    const fullUrl = `${hostname}${pathname}`.toLowerCase();
    const hasResearchKeywords = [
      'research',
      'paper',
      'publication',
      'academic',
      'study',
      'analysis',
      'whitepaper',
      'technical',
      'science',
      'ai',
      'ml',
      'artificial-intelligence',
    ].some(keyword => fullUrl.includes(keyword));

    return isDomainResearch || isPathResearch || hasResearchKeywords;
  }

  /**
   * Specific content extraction for GitHub markdown files
   */
  private findGitHubMarkdownContent(): Element | null {
    // GitHub-specific selectors for markdown file content
    const githubSelectors = [
      // Main markdown content area
      '.markdown-body',
      'article.markdown-body',
      '.repository-content .markdown-body',
      '.Box-body .markdown-body',

      // File content containers
      '.file-editor-textarea',
      '.blob-wrapper',
      '.highlight',
      '.blob-code-content',

      // Repository content area
      '.repository-content',
      '.file-navigation + .Box .Box-body',
      '.file-navigation ~ .Box .Box-body',

      // Content containers
      '.Box-body',
      '.container-lg .Box-body',
      '.application-main .Box-body',

      // Readme and markdown specific
      '#readme .markdown-body',
      '[data-testid="readme"] .markdown-body',
      '.readme .markdown-body',

      // File view content
      '.file .highlight',
      '.file .blob-wrapper',
      '.file .Box-body',

      // Generic content fallbacks
      'main .Box-body',
      '[role="main"] .Box-body',
      '.Layout-main .Box-body',
    ];

    for (const selector of githubSelectors) {
      try {
        const element = document.querySelector(selector);
        if (element && this.isValidGitHubContent(element)) {
          this.logger.debug('Found GitHub content with selector:', selector);
          return element;
        }
      } catch (error) {
        this.logger.warn('Invalid GitHub selector:', selector, error);
      }
    }

    // Advanced fallback: Look for GitHub file content structure
    const githubStructureContent = this.findGitHubContentByStructure();
    if (githubStructureContent) {
      this.logger.debug('Found GitHub content using structure analysis');
      return githubStructureContent;
    }

    this.logger.warn('No suitable GitHub markdown content found');
    return null;
  }

  /**
   * Find GitHub content using structure analysis when selectors fail
   */
  private findGitHubContentByStructure(): Element | null {
    // Look for elements that contain the actual file content
    const candidates = Array.from(document.querySelectorAll('div, section, article, main'))
      .filter(el => {
        const text = el.textContent?.trim() || '';
        const className = el.className.toLowerCase();

        // Must have substantial text content
        if (text.length < 200) return false;

        // Look for GitHub-specific structure indicators
        const hasGitHubContent =
          className.includes('markdown') ||
          className.includes('blob') ||
          className.includes('highlight') ||
          className.includes('file') ||
          className.includes('repository-content');

        // Exclude navigation and GitHub UI elements
        const excludeTerms = [
          'header',
          'footer',
          'navigation',
          'nav',
          'menu',
          'sidebar',
          'breadcrumb',
          'pagehead',
          'subnav',
          'topics',
          'labels',
          'issues',
          'pulls',
          'commit',
          'discussion',
          'notification',
        ];
        const hasExcludeClass = excludeTerms.some(term => className.includes(term));

        if (hasExcludeClass && !hasGitHubContent) return false;

        return hasGitHubContent || text.length > 1000;
      })
      .sort((a, b) => {
        // Score by content quality for GitHub
        const scoreA = this.scoreGitHubElement(a);
        const scoreB = this.scoreGitHubElement(b);
        return scoreB - scoreA;
      });

    return candidates.length > 0 ? candidates[0] : null;
  }

  /**
   * Score GitHub elements for content quality
   */
  private scoreGitHubElement(element: Element): number {
    let score = 0;
    const text = element.textContent?.trim() || '';
    const className = element.className.toLowerCase();

    // Base score from text length
    score += Math.min(text.length / 10, 300);

    // Bonus for GitHub content-related classes
    const contentBonuses = [
      { term: 'markdown-body', bonus: 300 },
      { term: 'blob-wrapper', bonus: 250 },
      { term: 'highlight', bonus: 200 },
      { term: 'repository-content', bonus: 180 },
      { term: 'box-body', bonus: 150 },
      { term: 'file', bonus: 120 },
      { term: 'readme', bonus: 100 },
    ];

    contentBonuses.forEach(({ term, bonus }) => {
      if (className.includes(term)) {
        score += bonus;
      }
    });

    // Penalty for GitHub UI elements
    const uiPenalties = [
      'header',
      'footer',
      'nav',
      'menu',
      'sidebar',
      'breadcrumb',
      'pagehead',
      'subnav',
      'notification',
      'discussion',
      'issues',
      'pulls',
    ];

    uiPenalties.forEach(term => {
      if (className.includes(term)) {
        score -= 100;
      }
    });

    // Bonus for markdown structure (headings, paragraphs)
    const headings = element.querySelectorAll('h1, h2, h3, h4, h5, h6').length;
    const paragraphs = element.querySelectorAll('p').length;
    score += headings * 25;
    score += paragraphs * 15;

    return Math.max(0, score);
  }

  /**
   * Validate if element contains good GitHub markdown content
   */
  private isValidGitHubContent(element: Element): boolean {
    const text = element.textContent?.trim() || '';
    const className = element.className.toLowerCase();

    // Must have some content
    if (text.length < 100) return false;

    // Should be marked as markdown or file content
    const hasMarkdownIndicators =
      className.includes('markdown') ||
      className.includes('blob') ||
      className.includes('highlight') ||
      className.includes('file') ||
      className.includes('readme');

    // Avoid pure navigation or GitHub UI
    const navTerms = [
      'header',
      'footer',
      'nav',
      'menu',
      'sidebar',
      'breadcrumb',
      'pagehead',
      'subnav',
      'notification',
    ];
    const isNavContent = navTerms.some(term => className.includes(term));

    if (isNavContent && !hasMarkdownIndicators) return false;

    // For GitHub, prefer elements with markdown indicators or substantial content
    return hasMarkdownIndicators || text.length > 500;
  }

  /**
   * Specific content extraction for Stack Overflow blog
   */
  private findStackOverflowBlogContent(): Element | null {
    // Try to find the actual article content, avoiding navigation and promotional content
    const contentSelectors = [
      // Main article content
      'article',
      'main article',
      '.content article',
      '.main-content article',
      '.blog-content article',
      '.post-content',
      '.article-content',
      '.entry-content',
      // Look for content that follows the date/title pattern
      '.blog-post-content',
      '.content-main',
      '.main-article',
      // Find content near the published date
      '[class*="date"] ~ *',
      '[class*="publish"] ~ *',
      // Content after author information
      '[class*="author"] ~ *',
      '.author ~ *',
    ];

    for (const selector of contentSelectors) {
      try {
        const element = document.querySelector(selector);
        if (element && this.isStackOverflowContent(element)) {
          return element;
        }
      } catch (error) {
        this.logger.warn('Invalid SO selector:', selector, error);
      }
    }

    // Fallback: Find the largest text block that's not navigation
    const textBlocks = Array.from(document.querySelectorAll('div, section, article'))
      .filter(el => {
        const text = el.textContent?.trim() || '';
        const className = el.className.toLowerCase();
        const id = el.id.toLowerCase();

        // Must have substantial text
        if (text.length < 500) return false;

        // Exclude navigation and promotional content
        const excludeTerms = [
          'nav',
          'menu',
          'header',
          'footer',
          'sidebar',
          'promo',
          'subscribe',
          'teams',
          'advertising',
        ];
        if (excludeTerms.some(term => className.includes(term) || id.includes(term))) {
          return false;
        }

        // Exclude if it contains too much promotional text
        const promoTerms = [
          'stack overflow for teams',
          'promote your product',
          'advertising',
          'talent',
        ];
        const promoCount = promoTerms.filter(term => text.toLowerCase().includes(term)).length;
        if (promoCount > 1) return false;

        return true;
      })
      .sort((a, b) => (b.textContent?.length || 0) - (a.textContent?.length || 0));

    return textBlocks.length > 0 ? textBlocks[0] : null;
  }

  /**
   * Enhanced content extraction for Substack posts - 2025 structure analysis
   */
  private findSubstackContent(): Element | null {
    // Enhanced Substack content selectors based on current structure analysis
    const contentSelectors = [
      // Primary Substack content containers (highest priority)
      '.available-content',
      '.available-content .body.markup',
      '.available-content .markup',
      '.post-content .available-content',
      '.post .available-content',
      '.post-header + .available-content',

      // Direct content access
      '.body.markup',
      '.markup',
      '.post-body',
      '.post-content',

      // Article structure
      'article .available-content',
      'article .body.markup',
      'article .markup',
      'article .post-content',

      // Main content structure
      'main .available-content',
      'main .markup',
      '[role="main"] .available-content',
      '[role="main"] .markup',

      // Data attributes and component selectors
      '[data-testid="post-content"]',
      '[data-testid="available-content"]',
      '[data-component="post-content"]',

      // Fallback patterns
      '[class*="available-content"]',
      '[class*="post-content"]',
      '[class*="body"][class*="markup"]',
      '.publication-content',
      '.newsletter-content',
    ];

    for (const selector of contentSelectors) {
      try {
        const element = document.querySelector(selector);
        if (element && this.isValidSubstackContent(element)) {
          this.logger.debug('Found Substack content with selector:', selector);
          return element;
        }
      } catch (error) {
        this.logger.warn('Invalid Substack selector:', selector, error);
      }
    }

    // Advanced fallback: Find content by structure analysis
    const substackStructureContent = this.findSubstackContentByStructure();
    if (substackStructureContent) {
      this.logger.debug('Found Substack content using structure analysis');
      return substackStructureContent;
    }

    this.logger.warn('No suitable Substack content found');
    return null;
  }

  /**
   * Find Substack content using structure analysis when selectors fail
   */
  private findSubstackContentByStructure(): Element | null {
    // Look for elements that contain the typical Substack article structure:
    // - A title/heading at the top
    // - Multiple paragraphs with substantial text
    // - Minimal navigation/promotional content

    const candidates = Array.from(document.querySelectorAll('div, section, article, main'))
      .filter(el => {
        const text = el.textContent?.trim() || '';
        const className = el.className.toLowerCase();

        // Must have substantial text content
        if (text.length < 1000) return false;

        // Look for article-like structure
        const paragraphs = el.querySelectorAll('p').length;
        const headings = el.querySelectorAll('h1, h2, h3, h4, h5, h6').length;

        // Should have multiple paragraphs or headings
        if (paragraphs < 3 && headings < 2) return false;

        // Prefer elements with content-related classes
        const contentTerms = ['content', 'post', 'article', 'body', 'markup', 'available'];
        const hasContentClass = contentTerms.some(term => className.includes(term));

        // Exclude navigation and promotional areas
        const excludeTerms = [
          'nav',
          'menu',
          'header',
          'footer',
          'sidebar',
          'subscribe',
          'related',
          'recommendation',
          'comment',
          'discussion',
          'share',
        ];
        const hasExcludeClass = excludeTerms.some(term => className.includes(term));

        if (hasExcludeClass && !hasContentClass) return false;

        // Check for good content indicators in text
        const hasGoodIndicators =
          text.toLowerCase().includes('published') ||
          text.toLowerCase().includes('written') ||
          text.toLowerCase().includes('author') ||
          text.includes('\n\n'); // Multiple paragraphs

        return hasContentClass || hasGoodIndicators;
      })
      .sort((a, b) => {
        // Score by content quality
        const scoreA = this.scoreSubstackElement(a);
        const scoreB = this.scoreSubstackElement(b);
        return scoreB - scoreA;
      });

    return candidates.length > 0 ? candidates[0] : null;
  }

  /**
   * Score Substack elements for content quality
   */
  private scoreSubstackElement(element: Element): number {
    let score = 0;
    const text = element.textContent?.trim() || '';
    const className = element.className.toLowerCase();

    // Base score from text length
    score += Math.min(text.length / 20, 300);

    // Bonus for content-related classes
    const contentBonuses = [
      { term: 'available-content', bonus: 200 },
      { term: 'markup', bonus: 150 },
      { term: 'post-content', bonus: 120 },
      { term: 'body', bonus: 100 },
      { term: 'article', bonus: 80 },
      { term: 'content', bonus: 60 },
    ];

    contentBonuses.forEach(({ term, bonus }) => {
      if (className.includes(term)) {
        score += bonus;
      }
    });

    // Penalty for navigation terms
    const navPenalties = [
      'nav',
      'menu',
      'header',
      'footer',
      'sidebar',
      'subscribe',
      'related',
      'recommendation',
      'comment',
      'share',
    ];

    navPenalties.forEach(term => {
      if (className.includes(term)) {
        score -= 100;
      }
    });

    // Bonus for paragraph structure
    const paragraphs = element.querySelectorAll('p').length;
    score += paragraphs * 15;

    // Bonus for headings
    const headings = element.querySelectorAll('h1, h2, h3, h4, h5, h6').length;
    score += headings * 25;

    return Math.max(0, score);
  }

  /**
   * Validate if element contains good Substack content
   */
  private isValidSubstackContent(element: Element): boolean {
    const text = element.textContent?.trim() || '';
    const className = element.className.toLowerCase();

    // Must have substantial content
    if (text.length < 200) return false;

    // Should have some structure (paragraphs or headings)
    const paragraphs = element.querySelectorAll('p').length;
    const headings = element.querySelectorAll('h1, h2, h3, h4, h5, h6').length;

    if (paragraphs < 1 && headings < 1) return false;

    // Avoid pure navigation or promotional content
    const navTerms = ['navigation', 'subscribe-form', 'footer', 'header', 'sidebar'];
    const isNavContent = navTerms.some(term => className.includes(term));

    if (isNavContent && paragraphs < 3) return false;

    // Check for Substack-specific promotional patterns
    const promoPatterns = [
      'upgrade to paid',
      'subscribe now',
      'get full access',
      'become a paid subscriber',
    ];

    const promoCount = promoPatterns.filter(pattern => text.toLowerCase().includes(pattern)).length;

    // If mostly promotional content, reject
    if (promoCount > 1 && text.length < 1000) return false;

    return true;
  }

  /**
   * Validate if element contains Stack Overflow blog content
   */
  private isStackOverflowContent(element: Element): boolean {
    const text = element.textContent?.trim() || '';

    // Must have substantial content
    if (text.length < 300) return false;

    // Should not be primarily promotional
    const promoTerms = [
      'stack overflow for teams',
      'promote your product',
      'advertising',
      'talent',
    ];
    const promoCount = promoTerms.filter(term => text.toLowerCase().includes(term)).length;
    const promoRatio = promoCount / (text.length / 1000); // Promo density per 1000 chars

    if (promoRatio > 2) return false; // Too much promotional content

    // Should have typical article structure
    const paragraphs = element.querySelectorAll('p').length;
    const headings = element.querySelectorAll('h1, h2, h3, h4, h5, h6').length;

    return paragraphs >= 2 || headings >= 1;
  }

  /**
   * Validate if element contains suitable content
   */
  private isValidContent(element: Element): boolean {
    const qualityOptions: IQualityOptions = {
      isDynamicSite: this.isDynamicSite(),
      minTextLength: 50,
      minTextRatio: 0.05,
      maxLinkDensity: 0.5,
    };

    const quality = this.qualityAnalyzer.analyzeContent(element, qualityOptions);

    this.logger.debug('Content quality analysis:', {
      score: quality.score,
      isContent: quality.isContent,
      reasons: quality.reasons,
    });

    return quality.isContent;
  }

  /**
   * Find largest content container as fallback
   */
  private findLargestContentContainer(): Element | null {
    const candidates = document.querySelectorAll(
      'div, section, article, main, aside, [role="main"], [role="article"]'
    );

    let bestCandidate: Element | null = null;
    let bestScore = 0;
    const minScore = this.isDynamicSite() ? 50 : 100;

    for (const candidate of Array.from(candidates)) {
      const quality = this.qualityAnalyzer.analyzeContent(candidate, {
        isDynamicSite: this.isDynamicSite(),
      });

      if (quality.score > bestScore && quality.score > minScore) {
        bestScore = quality.score;
        bestCandidate = candidate;
      }
    }

    return bestCandidate;
  }

  /**
   * Wait for dynamic content to load if needed
   */
  private async waitForContentIfNeeded(options: IExtractorOptions): Promise<void> {
    if (options.waitForDynamicContent === false) {
      return;
    }

    // Wait for document to be ready
    if (document.readyState !== 'complete') {
      this.logger.debug('Waiting for document to complete loading...');
      await new Promise<void>(resolve => {
        if (document.readyState === 'complete') {
          resolve();
        } else {
          window.addEventListener('load', () => resolve(), { once: true });
          setTimeout(() => resolve(), 3000); // Fallback timeout
        }
      });
    }

    // For dynamic sites, wait additional time
    if (this.isDynamicSite()) {
      this.logger.debug('Dynamic site detected, waiting for content...');
      await this.waitForDynamicContent();
    }
  }

  /**
   * Wait for dynamic content to stabilize - Enhanced with platform-specific handling
   */
  private async waitForDynamicContent(): Promise<void> {
    const maxWaitTime = 5000;
    const checkInterval = 500;
    const startTime = Date.now();
    let previousContentLength = 0;

    // First, try platform-specific waiting
    await this.waitForSpecificContent();

    // Then general content stabilization
    while (Date.now() - startTime < maxWaitTime) {
      const currentContentLength = document.body.textContent?.length || 0;

      if (currentContentLength > previousContentLength) {
        this.logger.debug('Content still loading...', currentContentLength, 'chars');
        previousContentLength = currentContentLength;
        await new Promise(resolve => setTimeout(resolve, checkInterval));
      } else if (previousContentLength > 1000) {
        this.logger.debug('Content appears stable');
        break;
      } else {
        await new Promise(resolve => setTimeout(resolve, checkInterval));
      }
    }
  }

  /**
   * Platform-specific content waiting logic
   */
  private async waitForSpecificContent(): Promise<void> {
    const url = window.location.href.toLowerCase();

    // Docker blog specific waiting logic
    if (url.includes('docker.com/blog')) {
      this.logger.debug('Waiting for Docker blog specific content...');

      const dockerSelectors = [
        '.post-content',
        '.entry-content',
        '.article-content',
        '.blog-content',
        'article',
        '.content',
        '[data-testid*="content"]',
      ];

      const maxWait = 5000;
      const startTime = Date.now();

      while (Date.now() - startTime < maxWait) {
        for (const selector of dockerSelectors) {
          const element = document.querySelector(selector);
          if (element && element.textContent && element.textContent.trim().length > 500) {
            this.logger.debug(`Found Docker content via selector: ${selector}`);
            return;
          }
        }
        await new Promise(resolve => setTimeout(resolve, 200));
      }

      this.logger.debug('Docker blog content wait timeout');
    }
  }

  /**
   * Check if current site is dynamic
   */
  private isDynamicSite(): boolean {
    const hostname = window.location.hostname.toLowerCase();
    const dynamicSites = [
      'docker.com',
      'medium.com',
      'dev.to',
      'hashnode.com',
      'substack.com',
      'wordpress.com',
      'ghost.org',
    ];

    const hasKnownDynamicSite = dynamicSites.some(site => hostname.includes(site));
    const hasModernFramework = !!(
      document.querySelector('[data-reactroot], [data-vue], [ng-version]') ||
      (window as any).React ||
      (window as any).Vue ||
      (window as any).angular
    );

    return hasKnownDynamicSite || hasModernFramework;
  }

  /**
   * Clean content string
   */
  private cleanContent(content: string, options: IExtractorOptions): string {
    if (options.preserveFormatting) {
      return content;
    }

    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = content;

    // Normalize whitespace in text nodes
    const walker = document.createTreeWalker(tempDiv, NodeFilter.SHOW_TEXT);
    const textNodes: Text[] = [];
    let node: Node | null;

    while ((node = walker.nextNode())) {
      textNodes.push(node as Text);
    }

    for (const textNode of textNodes) {
      if (textNode.textContent) {
        textNode.textContent = textNode.textContent.replace(/\s+/g, ' ').trim();
      }
    }

    return tempDiv.innerHTML;
  }

  /**
   * Count words in content
   */
  private countWords(content: string): number {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = content;
    const text = tempDiv.textContent || '';

    return text
      .trim()
      .split(/\s+/)
      .filter(word => word.length > 0).length;
  }

  /**
   * Estimate reading time
   */
  private estimateReadingTime(wordCount: number): number {
    const wordsPerMinute = 225;
    return Math.ceil(wordCount / wordsPerMinute);
  }

  // Utility methods for backward compatibility

  /**
   * Extract images from the page
   */
  extractImages(): Array<{ src: string; alt: string; title?: string }> {
    return Array.from(document.querySelectorAll('img'))
      .map(img => {
        const result: { src: string; alt: string; title?: string } = {
          src: img.src,
          alt: img.alt || '',
        };
        if (img.title) {
          result.title = img.title;
        }
        return result;
      })
      .filter(img => img.src && !img.src.startsWith('data:'));
  }

  /**
   * Extract links from the page
   */
  extractLinks(): Array<{ href: string; text: string; title?: string }> {
    return Array.from(document.querySelectorAll('a[href]'))
      .map(link => {
        const anchor = link as HTMLAnchorElement;
        const result: { href: string; text: string; title?: string } = {
          href: anchor.href,
          text: anchor.textContent?.trim() || '',
        };
        if (anchor.title) {
          result.title = anchor.title;
        }
        return result;
      })
      .filter(link => link.href && !link.href.startsWith('javascript:'));
  }

  /**
   * Get page structure information
   */
  getPageStructure(): { headings: string[]; sections: number; paragraphs: number } {
    const headings = Array.from(document.querySelectorAll('h1, h2, h3, h4, h5, h6'))
      .map(h => h.textContent?.trim() || '')
      .filter(text => text.length > 0);

    const sections = document.querySelectorAll('section, article, div.section').length;
    const paragraphs = document.querySelectorAll('p').length;

    return { headings, sections, paragraphs };
  }

  /**
   * Check if paywall is present
   */
  isPaywallPresent(): boolean {
    const paywallSelectors = [
      '.paywall',
      '.subscription-wall',
      '.premium-content',
      '[class*="paywall"]',
      '[id*="paywall"]',
      '.login-required',
      '.subscriber-only',
    ];

    return paywallSelectors.some(selector => document.querySelector(selector) !== null);
  }

  /**
   * Get content quality score
   */
  getContentQualityScore(): number {
    return this.qualityAnalyzer.getPageQualityScore();
  }
}
