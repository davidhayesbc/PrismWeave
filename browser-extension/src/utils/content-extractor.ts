// Generated by Copilot
// PrismWeave Content Extractor - TypeScript version
// Enhanced content extraction and cleaning utilities

import { IDocumentMetadata } from '../types/index.js';

interface IContentResult {
  content: string;
  metadata: IDocumentMetadata;
  cleanedContent: string;
  wordCount: number;
  readingTime: number;
}

interface IExtractorOptions {
  preserveFormatting?: boolean;
  removeAds?: boolean;
  removeNavigation?: boolean;
  customSelectors?: string[];
  excludeSelectors?: string[];
}

export class ContentExtractor {
  private readonly readabilitySelectors: string[];
  private readonly unwantedSelectors: string[];
  private readonly adSelectors: string[];
  private readonly navigationSelectors: string[];
  constructor() {
    this.readabilitySelectors = [
      'article',
      'main',
      '[role="main"]',
      '.content',
      '.post-content',
      '.entry-content',
      '.article-content',
      '.article-body',
      '.post-body',
      '.entry-body',
      '.content-body',
      '.main-content',
      '.article-text',
      '.story-body',
      '.article-wrapper',
      '.post-text',
      '.content-area',
      '.entry-text',
      // Enhanced selectors for various blog platforms
      '.post__content',
      '.blog-content',
      '.article__content',
      '.entry__content',
      '.content__body',
      '.prose',
      '.rich-text',
      '.wp-content',
      '.post-body-content',
      '.article-text-content',
      '.blog-post-content',
      '.single-post-content',
      '.content-wrapper',
      '.page-content',
      '.entry-content-wrapper',
      // Docker and tech blog specific
      '.documentation-content',
      '.tutorial-content',
      '.guide-content',
      '.blog-article-content',
      // Fallback for broad content containers
      '[data-content]',
      '[data-article]',
      '[id*="content"]',
      '[class*="content"]',
      '[class*="article"]',
      '[class*="post"]',
    ];
    this.unwantedSelectors = [
      'script',
      'style',
      'noscript',
      'iframe[src*="ads"]',
      'iframe[src*="advertisement"]',
      'iframe[src*="google"]',
      'embed[src*="ads"]',
      'object[data*="ads"]',
      '.ad',
      '.ads',
      '.advertisement',
      '.banner',
      '.popup',
      '.modal',
      '.overlay',
      '.social-share',
      '.share-buttons',
      '.comments-section',
      '.related-posts',
      '.sidebar',
      '.widget',
      // Additional unwanted elements
      '.newsletter-signup',
      '.subscription-box',
      '.email-signup',
      '.social-links',
      '.author-bio',
      '.author-card',
      '.breadcrumb',
      '.pagination',
      '.tag-list',
      '.category-list',
      '.metadata',
      '.post-meta',
      '.article-meta',
      '.sharing',
      '.social-sharing',
      '.follow-buttons',
      '.call-to-action',
      '.cta',
      '.promo-box',
      '.advertisement-block',
      // Navigation elements
      'nav',
      'header:not(.article-header):not(.post-header)',
      'footer:not(.article-footer):not(.post-footer)',
      'aside:not(.content-aside)',
      '.navigation',
      '.nav',
      '.menu',
      '.navbar',
      '.header',
      '.footer',
      '.top-bar',
      '.bottom-bar',
      // Cookie and privacy notices
      '.cookie-notice',
      '.privacy-notice',
      '.gdpr-notice',
      '.consent-banner',
    ];

    this.adSelectors = [
      '[id*="ad"]',
      '[class*="ad"]',
      '[id*="advertisement"]',
      '[class*="advertisement"]',
      '[id*="banner"]',
      '[class*="banner"]',
      '[id*="sponsor"]',
      '[class*="sponsor"]',
      '.google-ad',
      '.adsystem',
      '.ad-container',
      '.ad-wrapper',
      '.advertisement-wrapper',
      '.sponsored-content',
      '.promo',
      '.promotion',
    ];

    this.navigationSelectors = [
      'nav',
      'header:not(.article-header):not(.post-header)',
      'footer:not(.article-footer):not(.post-footer)',
      'aside:not(.content-aside)',
      '.navigation',
      '.nav',
      '.menu',
      '.navbar',
      '.header',
      '.footer',
      '.breadcrumb',
      '.pagination',
      '.site-header',
      '.site-footer',
      '.top-bar',
      '.bottom-bar',
    ];
  }

  async extractContent(options: IExtractorOptions = {}): Promise<IContentResult> {
    try {
      console.log('ContentExtractor: Starting content extraction');

      const metadata = this.extractMetadata();
      console.log('ContentExtractor: Metadata extracted:', metadata);

      let content = this.findMainContent(options);
      console.log('ContentExtractor: Main content found, length:', content.length);

      if (options.removeAds !== false) {
        content = this.removeAds(content);
        console.log('ContentExtractor: Ads removed');
      }

      if (options.removeNavigation !== false) {
        content = this.removeNavigation(content);
        console.log('ContentExtractor: Navigation removed');
      }

      const cleanedContent = this.cleanContent(content, options);
      const wordCount = this.countWords(cleanedContent);
      const readingTime = this.estimateReadingTime(wordCount);

      console.log('ContentExtractor: Content extraction complete');

      return {
        content,
        metadata,
        cleanedContent,
        wordCount,
        readingTime,
      };
    } catch (error) {
      console.error('ContentExtractor: Error during extraction:', error);
      throw error;
    }
  }

  private extractMetadata(): IDocumentMetadata {
    const title = this.extractTitle();
    const author = this.extractAuthor();
    const captureDate = new Date().toISOString();
    const tags = this.extractTags();
    const metadata: IDocumentMetadata = {
      title,
      url: window.location.href,
      captureDate,
      tags,
      wordCount: 0, // Will be calculated later
      estimatedReadingTime: 0, // Will be calculated later
    };

    if (author) {
      metadata.author = author;
    }

    return metadata;
  }

  private extractTitle(): string {
    // Try multiple methods to get the best title
    const methods = [
      () => document.querySelector('meta[property="og:title"]')?.getAttribute('content'),
      () => document.querySelector('meta[name="twitter:title"]')?.getAttribute('content'),
      () => document.querySelector('h1')?.textContent?.trim(),
      () => document.querySelector('.article-title')?.textContent?.trim(),
      () => document.querySelector('.post-title')?.textContent?.trim(),
      () => document.querySelector('.entry-title')?.textContent?.trim(),
      () => document.title?.trim(),
    ];

    for (const method of methods) {
      try {
        const title = method();
        if (title && title.length > 0) {
          return this.cleanText(title);
        }
      } catch (e) {
        // Continue to next method
      }
    }

    return 'Untitled Document';
  }

  private extractAuthor(): string | undefined {
    const methods = [
      () => document.querySelector('meta[name="author"]')?.getAttribute('content'),
      () => document.querySelector('meta[property="article:author"]')?.getAttribute('content'),
      () => document.querySelector('.author')?.textContent?.trim(),
      () => document.querySelector('.byline')?.textContent?.trim(),
      () => document.querySelector('.post-author')?.textContent?.trim(),
      () => document.querySelector('[rel="author"]')?.textContent?.trim(),
    ];

    for (const method of methods) {
      try {
        const author = method();
        if (author && author.length > 0) {
          return this.cleanText(author);
        }
      } catch (e) {
        // Continue to next method
      }
    }

    return undefined;
  }

  private extractTags(): string[] {
    const tags = new Set<string>();

    // Extract from meta keywords
    const metaKeywords = document.querySelector('meta[name="keywords"]')?.getAttribute('content');
    if (metaKeywords) {
      metaKeywords.split(',').forEach(tag => {
        const cleaned = tag.trim().toLowerCase();
        if (cleaned.length > 0) tags.add(cleaned);
      });
    }

    // Extract from article tags/categories
    const tagElements = document.querySelectorAll('.tag, .category, .label, [rel="tag"]');
    tagElements.forEach(element => {
      const tag = element.textContent?.trim().toLowerCase();
      if (tag && tag.length > 0) {
        tags.add(tag);
      }
    });

    // Extract from URL-based categories
    const urlParts = window.location.pathname
      .split('/')
      .filter(
        part => part.length > 0 && !part.match(/^\d+$/) && part !== 'article' && part !== 'post'
      );
    urlParts.slice(0, 2).forEach(part => tags.add(part.toLowerCase()));

    return Array.from(tags).slice(0, 10); // Limit to 10 tags
  }
  private findMainContent(options: IExtractorOptions): string {
    console.log('ContentExtractor: Starting main content search...');

    // Try to find the main content using various selectors
    let mainElement: Element | null = null;
    let selectedSelector = '';

    // First try custom selectors if provided
    if (options.customSelectors?.length) {
      console.log('ContentExtractor: Trying custom selectors:', options.customSelectors);
      for (const selector of options.customSelectors) {
        try {
          mainElement = document.querySelector(selector);
          if (mainElement && this.isContentElement(mainElement)) {
            selectedSelector = selector;
            console.log('ContentExtractor: Found content with custom selector:', selector);
            break;
          }
        } catch (error) {
          console.warn('ContentExtractor: Invalid custom selector:', selector, error);
        }
        mainElement = null;
      }
    }

    // Then try readability selectors
    if (!mainElement) {
      console.log('ContentExtractor: Trying readability selectors...');
      for (const selector of this.readabilitySelectors) {
        try {
          const elements = document.querySelectorAll(selector);
          console.log(
            `ContentExtractor: Found ${elements.length} elements for selector "${selector}"`
          );
          for (let i = 0; i < elements.length; i++) {
            const element = elements[i];
            if (this.isContentElement(element)) {
              mainElement = element;
              selectedSelector = selector;
              console.log('ContentExtractor: Found content with selector:', selector);
              break;
            }
          }
          if (mainElement) break;
        } catch (error) {
          console.warn('ContentExtractor: Error with selector:', selector, error);
        }
      }
    }

    // Enhanced fallback: Try to find largest content container
    if (!mainElement) {
      console.log(
        'ContentExtractor: No specific content selector worked, trying enhanced fallback...'
      );
      mainElement = this.findLargestContentContainer();
      selectedSelector = 'enhanced-fallback';
    }

    // Final fallback to body if nothing found
    if (!mainElement) {
      console.log('ContentExtractor: Using body as final fallback');
      mainElement = document.body;
      selectedSelector = 'body-fallback';
    }

    console.log('ContentExtractor: Selected element with selector:', selectedSelector);
    console.log('ContentExtractor: Element tag:', mainElement.tagName);
    console.log('ContentExtractor: Element text length:', mainElement.textContent?.length || 0);

    // Clone the element to avoid modifying the original DOM
    const cloned = mainElement.cloneNode(true) as Element;

    // Remove unwanted elements
    this.removeUnwantedElements(cloned, options);

    const finalContent = cloned.innerHTML || '';
    console.log('ContentExtractor: Final content length after cleanup:', finalContent.length);

    return finalContent;
  }
  private isContentElement(element: Element): boolean {
    const text = element.textContent?.trim() || '';
    const html = element.innerHTML || '';

    // More lenient minimum content length
    if (text.length < 50) {
      console.log('ContentExtractor: Element rejected - too short:', text.length);
      return false;
    }

    // Check ratio of text to HTML (avoid heavily nested/formatted content)
    const ratio = text.length / html.length;
    if (ratio < 0.05) {
      console.log('ContentExtractor: Element rejected - poor text/html ratio:', ratio);
      return false;
    }

    // Check for too many links relative to content (likely navigation)
    const links = element.querySelectorAll('a').length;
    const paragraphs = element.querySelectorAll('p').length;
    const textBlocks = element.querySelectorAll('p, div, span, section').length;

    // More sophisticated link density check
    if (links > 20 && links > textBlocks && paragraphs < 3) {
      console.log(
        'ContentExtractor: Element rejected - too many links:',
        links,
        'paragraphs:',
        paragraphs
      );
      return false;
    }

    // Positive signals for content
    const hasHeadings = element.querySelectorAll('h1, h2, h3, h4, h5, h6').length > 0;
    const hasParagraphs = paragraphs > 0;
    const hasCodeBlocks = element.querySelectorAll('pre, code').length > 0;

    // Content-related class/id names
    const className = element.className.toLowerCase();
    const id = element.id.toLowerCase();
    const contentTerms = ['content', 'article', 'post', 'entry', 'body', 'text', 'prose'];
    const hasContentClass = contentTerms.some(
      term => className.includes(term) || id.includes(term)
    );

    // Navigation/non-content class/id names
    const navTerms = ['nav', 'menu', 'sidebar', 'footer', 'header', 'ad', 'banner', 'widget'];
    const hasNavClass = navTerms.some(term => className.includes(term) || id.includes(term));

    if (hasNavClass) {
      console.log('ContentExtractor: Element rejected - navigation class detected');
      return false;
    }

    const isLikelyContent = hasHeadings || hasParagraphs || hasCodeBlocks || hasContentClass;

    console.log('ContentExtractor: Element assessment:', {
      textLength: text.length,
      ratio: ratio.toFixed(3),
      links,
      paragraphs,
      hasHeadings,
      hasParagraphs,
      hasCodeBlocks,
      hasContentClass,
      isLikelyContent,
    });

    return isLikelyContent;
  }
  private removeUnwantedElements(element: Element, options: IExtractorOptions): void {
    console.log('ContentExtractor: Removing unwanted elements...');

    // Remove script, style, and other unwanted elements
    const unwanted = element.querySelectorAll(this.unwantedSelectors.join(','));
    console.log('ContentExtractor: Removing', unwanted.length, 'unwanted elements');
    unwanted.forEach(el => el.remove());

    // Remove excluded selectors if specified
    if (options.excludeSelectors?.length) {
      const excluded = element.querySelectorAll(options.excludeSelectors.join(','));
      console.log('ContentExtractor: Removing', excluded.length, 'excluded elements');
      excluded.forEach(el => el.remove());
    }

    // Remove empty elements that might remain
    const emptyElements = element.querySelectorAll('div:empty, span:empty, p:empty, section:empty');
    console.log('ContentExtractor: Removing', emptyElements.length, 'empty elements');
    emptyElements.forEach(el => el.remove());

    // Remove elements with only whitespace
    const allElements = element.querySelectorAll('*');
    let removedWhitespace = 0;
    for (let i = 0; i < allElements.length; i++) {
      const el = allElements[i];
      if (el.children.length === 0 && (!el.textContent || el.textContent.trim() === '')) {
        el.remove();
        removedWhitespace++;
      }
    }
    console.log('ContentExtractor: Removed', removedWhitespace, 'whitespace-only elements');

    // Remove elements that are likely ads by content
    const suspiciousElements = element.querySelectorAll('div, span, section, aside');
    let removedAds = 0;
    for (let i = 0; i < suspiciousElements.length; i++) {
      const el = suspiciousElements[i];
      const text = el.textContent?.toLowerCase() || '';
      const className = el.className?.toLowerCase() || '';
      const id = el.id?.toLowerCase() || '';

      if (this.isAdContent(text, id, className)) {
        el.remove();
        removedAds++;
      }
    }
    console.log('ContentExtractor: Removed', removedAds, 'ad-like elements');
  }

  private removeAds(content: string): string {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = content;

    // Remove ad elements
    const adElements = tempDiv.querySelectorAll(this.adSelectors.join(','));
    adElements.forEach(el => el.remove());

    // Remove elements with ad-related text
    const allElements = tempDiv.querySelectorAll('*');
    allElements.forEach(el => {
      const text = el.textContent?.toLowerCase() || '';
      const id = el.id?.toLowerCase() || '';
      const className = el.className?.toString().toLowerCase() || '';

      if (this.isAdContent(text, id, className)) {
        el.remove();
      }
    });

    return tempDiv.innerHTML;
  }

  private isAdContent(text: string, id: string, className: string): boolean {
    const adKeywords = [
      'advertisement',
      'sponsored',
      'promoted',
      'ads by',
      'google ads',
      'affiliate',
      'partner content',
      'paid promotion',
      'shop now',
      'buy now',
      'get deal',
      'limited time',
      'subscribe now',
    ];

    const combinedText = `${text} ${id} ${className}`.toLowerCase();
    return adKeywords.some(keyword => combinedText.includes(keyword));
  }

  private removeNavigation(content: string): string {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = content;

    // Remove navigation elements
    const navElements = tempDiv.querySelectorAll(this.navigationSelectors.join(','));
    navElements.forEach(el => el.remove());

    return tempDiv.innerHTML;
  }

  private cleanContent(content: string, options: IExtractorOptions): string {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = content;

    // Remove empty elements
    this.removeEmptyElements(tempDiv);

    // Clean up whitespace and formatting
    if (!options.preserveFormatting) {
      this.normalizeWhitespace(tempDiv);
    }

    return tempDiv.innerHTML;
  }

  private removeEmptyElements(element: Element): void {
    const allElements = element.querySelectorAll('*');

    // Process elements in reverse order to avoid issues with removal
    for (let i = allElements.length - 1; i >= 0; i--) {
      const el = allElements[i];
      const text = el.textContent?.trim() || '';
      const hasVisibleChildren = el.querySelector('img, video, audio, canvas, svg, iframe');

      // Remove if empty and has no visible children
      if (text.length === 0 && !hasVisibleChildren) {
        el.remove();
      }
    }
  }
  private normalizeWhitespace(element: Element): void {
    const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT);

    const textNodes: Text[] = [];
    let node;
    while ((node = walker.nextNode())) {
      textNodes.push(node as Text);
    }

    textNodes.forEach(textNode => {
      if (textNode.textContent) {
        textNode.textContent = textNode.textContent.replace(/\s+/g, ' ').trim();
      }
    });
  }

  private cleanText(text: string): string {
    return text
      .replace(/\s+/g, ' ')
      .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,\-.\/:;<=>?@\[\]^_`{|}~]/g, '')
      .trim();
  }

  private countWords(content: string): number {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = content;
    const text = tempDiv.textContent || '';

    return text
      .trim()
      .split(/\s+/)
      .filter(word => word.length > 0).length;
  }

  private estimateReadingTime(wordCount: number): number {
    // Average reading speed: 200-250 words per minute
    const wordsPerMinute = 225;
    return Math.ceil(wordCount / wordsPerMinute);
  }

  // Public utility methods
  extractImages(): Array<{ src: string; alt: string; title?: string }> {
    const images = document.querySelectorAll('img');
    return Array.from(images)
      .map(img => ({
        src: img.src,
        alt: img.alt || '',
        title: img.title,
      }))
      .filter(img => img.src && !img.src.startsWith('data:'));
  }
  extractLinks(): Array<{ href: string; text: string; title?: string }> {
    const links = document.querySelectorAll('a[href]');
    return Array.from(links)
      .map(link => {
        const anchor = link as HTMLAnchorElement;
        return {
          href: anchor.href,
          text: anchor.textContent?.trim() || '',
          title: anchor.title,
        };
      })
      .filter(link => link.href && !link.href.startsWith('javascript:'));
  }

  getPageStructure(): { headings: string[]; sections: number; paragraphs: number } {
    const headings = Array.from(document.querySelectorAll('h1, h2, h3, h4, h5, h6'))
      .map(h => h.textContent?.trim() || '')
      .filter(text => text.length > 0);

    const sections = document.querySelectorAll('section, article, div.section').length;
    const paragraphs = document.querySelectorAll('p').length;

    return { headings, sections, paragraphs };
  }

  isPaywallPresent(): boolean {
    const paywallIndicators = [
      '.paywall',
      '.subscription-wall',
      '.premium-content',
      '[class*="paywall"]',
      '[id*="paywall"]',
      '.login-required',
      '.subscriber-only',
    ];

    return paywallIndicators.some(selector => document.querySelector(selector) !== null);
  }

  getContentQualityScore(): number {
    let score = 0;
    const content = document.body.textContent || '';

    // Length score (0-30 points)
    const wordCount = this.countWords(content);
    if (wordCount > 500) score += 30;
    else if (wordCount > 200) score += 20;
    else if (wordCount > 100) score += 10;

    // Structure score (0-25 points)
    const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6').length;
    const paragraphs = document.querySelectorAll('p').length;
    if (headings > 0 && paragraphs > 3) score += 25;
    else if (paragraphs > 1) score += 15;

    // Media score (0-20 points)
    const images = document.querySelectorAll('img').length;
    if (images > 2) score += 20;
    else if (images > 0) score += 10;

    // Link quality (0-15 points)
    const links = document.querySelectorAll('a[href]').length;
    const textLength = content.length;
    const linkRatio = links / (textLength / 1000); // Links per 1000 chars
    if (linkRatio < 5 && linkRatio > 0.5) score += 15;
    else if (linkRatio < 10) score += 10;

    // Readability indicators (0-10 points)
    if (document.querySelector('article, main, .content')) score += 10;
    else if (document.querySelector('.post, .entry')) score += 5;

    return Math.min(score, 100);
  }
  private findLargestContentContainer(): Element | null {
    console.log('ContentExtractor: Searching for largest content container...');

    // Find all potential content containers
    const candidates = document.querySelectorAll('div, section, article, main');
    let bestCandidate: Element | null = null;
    let bestScore = 0;

    for (let i = 0; i < candidates.length; i++) {
      const candidate = candidates[i];
      const score = this.scoreContentElement(candidate);

      if (score > bestScore && score > 100) {
        // Minimum score threshold
        bestScore = score;
        bestCandidate = candidate;
      }
    }

    if (bestCandidate) {
      console.log('ContentExtractor: Found best content container with score:', bestScore);
      console.log('ContentExtractor: Element tag:', bestCandidate.tagName);
      console.log('ContentExtractor: Element class:', bestCandidate.className);
    }

    return bestCandidate;
  }

  private scoreContentElement(element: Element): number {
    let score = 0;
    const text = element.textContent?.trim() || '';
    const html = element.innerHTML || '';

    // Base score from text length
    score += Math.min(text.length / 10, 500);

    // Bonus for paragraphs
    const paragraphs = element.querySelectorAll('p').length;
    score += paragraphs * 25;

    // Bonus for headings
    const headings = element.querySelectorAll('h1, h2, h3, h4, h5, h6').length;
    score += headings * 30;

    // Penalty for too many links (likely navigation)
    const links = element.querySelectorAll('a').length;
    if (links > paragraphs * 2) {
      score -= links * 10;
    }

    // Penalty for too many script/style tags
    const scripts = element.querySelectorAll('script, style').length;
    score -= scripts * 50;

    // Bonus for content-related class names
    const className = element.className.toLowerCase();
    const id = element.id.toLowerCase();
    const contentTerms = ['content', 'article', 'post', 'entry', 'main', 'body', 'text'];

    contentTerms.forEach(term => {
      if (className.includes(term) || id.includes(term)) {
        score += 100;
      }
    });

    // Penalty for navigation-related class names
    const navTerms = ['nav', 'menu', 'sidebar', 'footer', 'header', 'ad', 'banner'];
    navTerms.forEach(term => {
      if (className.includes(term) || id.includes(term)) {
        score -= 200;
      }
    });

    return Math.max(0, score);
  }
}
