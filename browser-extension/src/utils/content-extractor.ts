// Generated by Copilot
// Simplified Content Extractor - Refactored with separation of concerns
// Main orchestrator that uses specialized modules for different tasks

import { IDocumentMetadata } from '../types/index.js';
import { ContentCleaner, ICleaningOptions } from './content-cleaner.js';
import { ContentQualityAnalyzer, IQualityOptions } from './content-quality-analyzer.js';
import { ContentSelectorManager } from './content-selector-strategies.js';
import { createLogger } from './logger.js';
import { MetadataExtractor } from './metadata-extractor.js';

export interface IContentResult {
  content: string;
  metadata: IDocumentMetadata;
  cleanedContent: string;
  wordCount: number;
  readingTime: number;
}

export interface IExtractorOptions extends ICleaningOptions {
  customSelectors?: string[];
  waitForDynamicContent?: boolean;
}

/**
 * Main content extractor that orchestrates specialized modules
 */
export class ContentExtractor {
  private readonly logger = createLogger('ContentExtractor');
  private readonly selectorManager = new ContentSelectorManager();
  private readonly cleaner = new ContentCleaner();
  private readonly qualityAnalyzer = new ContentQualityAnalyzer();
  private readonly metadataExtractor = new MetadataExtractor();

  /**
   * Extract content from the current page
   */
  async extractContent(options: IExtractorOptions = {}): Promise<IContentResult> {
    try {
      this.logger.debug('Starting content extraction');

      // Wait for content to load if needed
      await this.waitForContentIfNeeded(options);

      // Extract metadata first
      const metadata = this.metadataExtractor.extractMetadata();
      this.logger.debug('Metadata extracted:', metadata);

      // Find main content element
      const contentElement = this.findMainContent(options);
      if (!contentElement) {
        throw new Error('No suitable content found on page');
      }

      // Clean the content
      const cleanedElement = this.cleaner.cleanContent(contentElement, options);
      const content = cleanedElement.innerHTML || '';
      const cleanedContent = this.cleanContent(content, options);

      // Calculate metrics
      const wordCount = this.countWords(cleanedContent);
      const readingTime = this.estimateReadingTime(wordCount);

      // Update metadata with calculated values
      metadata.wordCount = wordCount;
      metadata.estimatedReadingTime = readingTime;

      this.logger.debug('Content extraction complete', {
        contentLength: content.length,
        wordCount,
        readingTime,
      });

      return {
        content,
        metadata,
        cleanedContent,
        wordCount,
        readingTime,
      };
    } catch (error) {
      this.logger.error('Error during extraction:', error);
      throw error;
    }
  }

  /**
   * Find the main content element on the page
   */
  private findMainContent(options: IExtractorOptions): Element | null {
    const url = window.location.href;

    // Try custom selectors first
    if (options.customSelectors?.length) {
      for (const selector of options.customSelectors) {
        try {
          const element = document.querySelector(selector);
          if (element && this.isValidContent(element)) {
            this.logger.debug('Found content with custom selector:', selector);
            return element;
          }
        } catch (error) {
          this.logger.warn('Invalid custom selector:', selector, error);
        }
      }
    }

    // For Stack Overflow blog, use specific content extraction
    if (url.includes('stackoverflow.blog')) {
      const soContent = this.findStackOverflowBlogContent();
      if (soContent) {
        this.logger.debug('Found Stack Overflow blog content');
        return soContent;
      }
    }

    // For Substack, use enhanced content extraction
    if (url.includes('substack.com')) {
      const substackContent = this.findSubstackContent();
      if (substackContent) {
        this.logger.debug('Found Substack content using enhanced extraction');
        return substackContent;
      }
    }

    // Use selector manager to find content
    const element = this.selectorManager.findContentElement(url, document);
    if (element) {
      this.logger.debug('Found content with selector strategy');
      return element;
    }

    // Fallback to largest content container
    const fallbackElement = this.findLargestContentContainer();
    if (fallbackElement) {
      this.logger.debug('Using largest content container as fallback');
      return fallbackElement;
    }

    // Final fallback to body
    this.logger.debug('Using body as final fallback');
    return document.body;
  }

  /**
   * Specific content extraction for Stack Overflow blog
   */
  private findStackOverflowBlogContent(): Element | null {
    // Try to find the actual article content, avoiding navigation and promotional content
    const contentSelectors = [
      // Main article content
      'article',
      'main article',
      '.content article',
      '.main-content article',
      '.blog-content article',
      '.post-content',
      '.article-content',
      '.entry-content',
      // Look for content that follows the date/title pattern
      '.blog-post-content',
      '.content-main',
      '.main-article',
      // Find content near the published date
      '[class*="date"] ~ *',
      '[class*="publish"] ~ *',
      // Content after author information
      '[class*="author"] ~ *',
      '.author ~ *',
    ];

    for (const selector of contentSelectors) {
      try {
        const element = document.querySelector(selector);
        if (element && this.isStackOverflowContent(element)) {
          return element;
        }
      } catch (error) {
        this.logger.warn('Invalid SO selector:', selector, error);
      }
    }

    // Fallback: Find the largest text block that's not navigation
    const textBlocks = Array.from(document.querySelectorAll('div, section, article'))
      .filter(el => {
        const text = el.textContent?.trim() || '';
        const className = el.className.toLowerCase();
        const id = el.id.toLowerCase();

        // Must have substantial text
        if (text.length < 500) return false;

        // Exclude navigation and promotional content
        const excludeTerms = [
          'nav',
          'menu',
          'header',
          'footer',
          'sidebar',
          'promo',
          'subscribe',
          'teams',
          'advertising',
        ];
        if (excludeTerms.some(term => className.includes(term) || id.includes(term))) {
          return false;
        }

        // Exclude if it contains too much promotional text
        const promoTerms = [
          'stack overflow for teams',
          'promote your product',
          'advertising',
          'talent',
        ];
        const promoCount = promoTerms.filter(term => text.toLowerCase().includes(term)).length;
        if (promoCount > 1) return false;

        return true;
      })
      .sort((a, b) => (b.textContent?.length || 0) - (a.textContent?.length || 0));

    return textBlocks.length > 0 ? textBlocks[0] : null;
  }

  /**
   * Enhanced content extraction for Substack posts - 2025 structure analysis
   */
  private findSubstackContent(): Element | null {
    // Enhanced Substack content selectors based on current structure analysis
    const contentSelectors = [
      // Primary Substack content containers (highest priority)
      '.available-content',
      '.available-content .body.markup',
      '.available-content .markup',
      '.post-content .available-content',
      '.post .available-content',
      '.post-header + .available-content',

      // Direct content access
      '.body.markup',
      '.markup',
      '.post-body',
      '.post-content',

      // Article structure
      'article .available-content',
      'article .body.markup',
      'article .markup',
      'article .post-content',

      // Main content structure
      'main .available-content',
      'main .markup',
      '[role="main"] .available-content',
      '[role="main"] .markup',

      // Data attributes and component selectors
      '[data-testid="post-content"]',
      '[data-testid="available-content"]',
      '[data-component="post-content"]',

      // Fallback patterns
      '[class*="available-content"]',
      '[class*="post-content"]',
      '[class*="body"][class*="markup"]',
      '.publication-content',
      '.newsletter-content',
    ];

    for (const selector of contentSelectors) {
      try {
        const element = document.querySelector(selector);
        if (element && this.isValidSubstackContent(element)) {
          this.logger.debug('Found Substack content with selector:', selector);
          return element;
        }
      } catch (error) {
        this.logger.warn('Invalid Substack selector:', selector, error);
      }
    }

    // Advanced fallback: Find content by structure analysis
    const substackStructureContent = this.findSubstackContentByStructure();
    if (substackStructureContent) {
      this.logger.debug('Found Substack content using structure analysis');
      return substackStructureContent;
    }

    this.logger.warn('No suitable Substack content found');
    return null;
  }

  /**
   * Find Substack content using structure analysis when selectors fail
   */
  private findSubstackContentByStructure(): Element | null {
    // Look for elements that contain the typical Substack article structure:
    // - A title/heading at the top
    // - Multiple paragraphs with substantial text
    // - Minimal navigation/promotional content

    const candidates = Array.from(document.querySelectorAll('div, section, article, main'))
      .filter(el => {
        const text = el.textContent?.trim() || '';
        const className = el.className.toLowerCase();

        // Must have substantial text content
        if (text.length < 1000) return false;

        // Look for article-like structure
        const paragraphs = el.querySelectorAll('p').length;
        const headings = el.querySelectorAll('h1, h2, h3, h4, h5, h6').length;

        // Should have multiple paragraphs or headings
        if (paragraphs < 3 && headings < 2) return false;

        // Prefer elements with content-related classes
        const contentTerms = ['content', 'post', 'article', 'body', 'markup', 'available'];
        const hasContentClass = contentTerms.some(term => className.includes(term));

        // Exclude navigation and promotional areas
        const excludeTerms = [
          'nav',
          'menu',
          'header',
          'footer',
          'sidebar',
          'subscribe',
          'related',
          'recommendation',
          'comment',
          'discussion',
          'share',
        ];
        const hasExcludeClass = excludeTerms.some(term => className.includes(term));

        if (hasExcludeClass && !hasContentClass) return false;

        // Check for good content indicators in text
        const hasGoodIndicators =
          text.toLowerCase().includes('published') ||
          text.toLowerCase().includes('written') ||
          text.toLowerCase().includes('author') ||
          text.includes('\n\n'); // Multiple paragraphs

        return hasContentClass || hasGoodIndicators;
      })
      .sort((a, b) => {
        // Score by content quality
        const scoreA = this.scoreSubstackElement(a);
        const scoreB = this.scoreSubstackElement(b);
        return scoreB - scoreA;
      });

    return candidates.length > 0 ? candidates[0] : null;
  }

  /**
   * Score Substack elements for content quality
   */
  private scoreSubstackElement(element: Element): number {
    let score = 0;
    const text = element.textContent?.trim() || '';
    const className = element.className.toLowerCase();

    // Base score from text length
    score += Math.min(text.length / 20, 300);

    // Bonus for content-related classes
    const contentBonuses = [
      { term: 'available-content', bonus: 200 },
      { term: 'markup', bonus: 150 },
      { term: 'post-content', bonus: 120 },
      { term: 'body', bonus: 100 },
      { term: 'article', bonus: 80 },
      { term: 'content', bonus: 60 },
    ];

    contentBonuses.forEach(({ term, bonus }) => {
      if (className.includes(term)) {
        score += bonus;
      }
    });

    // Penalty for navigation terms
    const navPenalties = [
      'nav',
      'menu',
      'header',
      'footer',
      'sidebar',
      'subscribe',
      'related',
      'recommendation',
      'comment',
      'share',
    ];

    navPenalties.forEach(term => {
      if (className.includes(term)) {
        score -= 100;
      }
    });

    // Bonus for paragraph structure
    const paragraphs = element.querySelectorAll('p').length;
    score += paragraphs * 15;

    // Bonus for headings
    const headings = element.querySelectorAll('h1, h2, h3, h4, h5, h6').length;
    score += headings * 25;

    return Math.max(0, score);
  }

  /**
   * Validate if element contains good Substack content
   */
  private isValidSubstackContent(element: Element): boolean {
    const text = element.textContent?.trim() || '';
    const className = element.className.toLowerCase();

    // Must have substantial content
    if (text.length < 200) return false;

    // Should have some structure (paragraphs or headings)
    const paragraphs = element.querySelectorAll('p').length;
    const headings = element.querySelectorAll('h1, h2, h3, h4, h5, h6').length;

    if (paragraphs < 1 && headings < 1) return false;

    // Avoid pure navigation or promotional content
    const navTerms = ['navigation', 'subscribe-form', 'footer', 'header', 'sidebar'];
    const isNavContent = navTerms.some(term => className.includes(term));

    if (isNavContent && paragraphs < 3) return false;

    // Check for Substack-specific promotional patterns
    const promoPatterns = [
      'upgrade to paid',
      'subscribe now',
      'get full access',
      'become a paid subscriber',
    ];

    const promoCount = promoPatterns.filter(pattern => text.toLowerCase().includes(pattern)).length;

    // If mostly promotional content, reject
    if (promoCount > 1 && text.length < 1000) return false;

    return true;
  }

  /**
   * Validate if element contains Stack Overflow blog content
   */
  private isStackOverflowContent(element: Element): boolean {
    const text = element.textContent?.trim() || '';

    // Must have substantial content
    if (text.length < 300) return false;

    // Should not be primarily promotional
    const promoTerms = [
      'stack overflow for teams',
      'promote your product',
      'advertising',
      'talent',
    ];
    const promoCount = promoTerms.filter(term => text.toLowerCase().includes(term)).length;
    const promoRatio = promoCount / (text.length / 1000); // Promo density per 1000 chars

    if (promoRatio > 2) return false; // Too much promotional content

    // Should have typical article structure
    const paragraphs = element.querySelectorAll('p').length;
    const headings = element.querySelectorAll('h1, h2, h3, h4, h5, h6').length;

    return paragraphs >= 2 || headings >= 1;
  }

  /**
   * Validate if element contains suitable content
   */
  private isValidContent(element: Element): boolean {
    const qualityOptions: IQualityOptions = {
      isDynamicSite: this.isDynamicSite(),
      minTextLength: 50,
      minTextRatio: 0.05,
      maxLinkDensity: 0.5,
    };

    const quality = this.qualityAnalyzer.analyzeContent(element, qualityOptions);

    this.logger.debug('Content quality analysis:', {
      score: quality.score,
      isContent: quality.isContent,
      reasons: quality.reasons,
    });

    return quality.isContent;
  }

  /**
   * Find largest content container as fallback
   */
  private findLargestContentContainer(): Element | null {
    const candidates = document.querySelectorAll(
      'div, section, article, main, aside, [role="main"], [role="article"]'
    );

    let bestCandidate: Element | null = null;
    let bestScore = 0;
    const minScore = this.isDynamicSite() ? 50 : 100;

    for (const candidate of Array.from(candidates)) {
      const quality = this.qualityAnalyzer.analyzeContent(candidate, {
        isDynamicSite: this.isDynamicSite(),
      });

      if (quality.score > bestScore && quality.score > minScore) {
        bestScore = quality.score;
        bestCandidate = candidate;
      }
    }

    return bestCandidate;
  }

  /**
   * Wait for dynamic content to load if needed
   */
  private async waitForContentIfNeeded(options: IExtractorOptions): Promise<void> {
    if (options.waitForDynamicContent === false) {
      return;
    }

    // Wait for document to be ready
    if (document.readyState !== 'complete') {
      this.logger.debug('Waiting for document to complete loading...');
      await new Promise<void>(resolve => {
        if (document.readyState === 'complete') {
          resolve();
        } else {
          window.addEventListener('load', () => resolve(), { once: true });
          setTimeout(() => resolve(), 3000); // Fallback timeout
        }
      });
    }

    // For dynamic sites, wait additional time
    if (this.isDynamicSite()) {
      this.logger.debug('Dynamic site detected, waiting for content...');
      await this.waitForDynamicContent();
    }
  }

  /**
   * Wait for dynamic content to stabilize - Enhanced with platform-specific handling
   */
  private async waitForDynamicContent(): Promise<void> {
    const maxWaitTime = 5000;
    const checkInterval = 500;
    const startTime = Date.now();
    let previousContentLength = 0;

    // First, try platform-specific waiting
    await this.waitForSpecificContent();

    // Then general content stabilization
    while (Date.now() - startTime < maxWaitTime) {
      const currentContentLength = document.body.textContent?.length || 0;

      if (currentContentLength > previousContentLength) {
        this.logger.debug('Content still loading...', currentContentLength, 'chars');
        previousContentLength = currentContentLength;
        await new Promise(resolve => setTimeout(resolve, checkInterval));
      } else if (previousContentLength > 1000) {
        this.logger.debug('Content appears stable');
        break;
      } else {
        await new Promise(resolve => setTimeout(resolve, checkInterval));
      }
    }
  }

  /**
   * Platform-specific content waiting logic
   */
  private async waitForSpecificContent(): Promise<void> {
    const url = window.location.href.toLowerCase();

    // Docker blog specific waiting logic
    if (url.includes('docker.com/blog')) {
      this.logger.debug('Waiting for Docker blog specific content...');

      const dockerSelectors = [
        '.post-content',
        '.entry-content',
        '.article-content',
        '.blog-content',
        'article',
        '.content',
        '[data-testid*="content"]',
      ];

      const maxWait = 5000;
      const startTime = Date.now();

      while (Date.now() - startTime < maxWait) {
        for (const selector of dockerSelectors) {
          const element = document.querySelector(selector);
          if (element && element.textContent && element.textContent.trim().length > 500) {
            this.logger.debug(`Found Docker content via selector: ${selector}`);
            return;
          }
        }
        await new Promise(resolve => setTimeout(resolve, 200));
      }

      this.logger.debug('Docker blog content wait timeout');
    }
  }

  /**
   * Check if current site is dynamic
   */
  private isDynamicSite(): boolean {
    const hostname = window.location.hostname.toLowerCase();
    const dynamicSites = [
      'docker.com',
      'medium.com',
      'dev.to',
      'hashnode.com',
      'substack.com',
      'wordpress.com',
      'ghost.org',
    ];

    const hasKnownDynamicSite = dynamicSites.some(site => hostname.includes(site));
    const hasModernFramework = !!(
      document.querySelector('[data-reactroot], [data-vue], [ng-version]') ||
      (window as any).React ||
      (window as any).Vue ||
      (window as any).angular
    );

    return hasKnownDynamicSite || hasModernFramework;
  }

  /**
   * Clean content string
   */
  private cleanContent(content: string, options: IExtractorOptions): string {
    if (options.preserveFormatting) {
      return content;
    }

    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = content;

    // Normalize whitespace in text nodes
    const walker = document.createTreeWalker(tempDiv, NodeFilter.SHOW_TEXT);
    const textNodes: Text[] = [];
    let node: Node | null;

    while ((node = walker.nextNode())) {
      textNodes.push(node as Text);
    }

    for (const textNode of textNodes) {
      if (textNode.textContent) {
        textNode.textContent = textNode.textContent.replace(/\s+/g, ' ').trim();
      }
    }

    return tempDiv.innerHTML;
  }

  /**
   * Count words in content
   */
  private countWords(content: string): number {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = content;
    const text = tempDiv.textContent || '';

    return text
      .trim()
      .split(/\s+/)
      .filter(word => word.length > 0).length;
  }

  /**
   * Estimate reading time
   */
  private estimateReadingTime(wordCount: number): number {
    const wordsPerMinute = 225;
    return Math.ceil(wordCount / wordsPerMinute);
  }

  // Utility methods for backward compatibility

  /**
   * Extract images from the page
   */
  extractImages(): Array<{ src: string; alt: string; title?: string }> {
    return Array.from(document.querySelectorAll('img'))
      .map(img => {
        const result: { src: string; alt: string; title?: string } = {
          src: img.src,
          alt: img.alt || '',
        };
        if (img.title) {
          result.title = img.title;
        }
        return result;
      })
      .filter(img => img.src && !img.src.startsWith('data:'));
  }

  /**
   * Extract links from the page
   */
  extractLinks(): Array<{ href: string; text: string; title?: string }> {
    return Array.from(document.querySelectorAll('a[href]'))
      .map(link => {
        const anchor = link as HTMLAnchorElement;
        const result: { href: string; text: string; title?: string } = {
          href: anchor.href,
          text: anchor.textContent?.trim() || '',
        };
        if (anchor.title) {
          result.title = anchor.title;
        }
        return result;
      })
      .filter(link => link.href && !link.href.startsWith('javascript:'));
  }

  /**
   * Get page structure information
   */
  getPageStructure(): { headings: string[]; sections: number; paragraphs: number } {
    const headings = Array.from(document.querySelectorAll('h1, h2, h3, h4, h5, h6'))
      .map(h => h.textContent?.trim() || '')
      .filter(text => text.length > 0);

    const sections = document.querySelectorAll('section, article, div.section').length;
    const paragraphs = document.querySelectorAll('p').length;

    return { headings, sections, paragraphs };
  }

  /**
   * Check if paywall is present
   */
  isPaywallPresent(): boolean {
    const paywallSelectors = [
      '.paywall',
      '.subscription-wall',
      '.premium-content',
      '[class*="paywall"]',
      '[id*="paywall"]',
      '.login-required',
      '.subscriber-only',
    ];

    return paywallSelectors.some(selector => document.querySelector(selector) !== null);
  }

  /**
   * Get content quality score
   */
  getContentQualityScore(): number {
    return this.qualityAnalyzer.getPageQualityScore();
  }
}
