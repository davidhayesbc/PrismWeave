// Generated by Copilot
// PrismWeave Content Extractor - TypeScript version
// Enhanced content extraction and cleaning utilities

import { IDocumentMetadata } from '../types/index.js';
import { createLogger } from './logger';

interface IContentResult {
  content: string;
  metadata: IDocumentMetadata;
  cleanedContent: string;
  wordCount: number;
  readingTime: number;
}

interface IExtractorOptions {
  preserveFormatting?: boolean;
  removeAds?: boolean;
  removeNavigation?: boolean;
  customSelectors?: string[];
  excludeSelectors?: string[];
}

export class ContentExtractor {
  private readonly readabilitySelectors: string[];
  private readonly unwantedSelectors: string[];
  private readonly adSelectors: string[];
  private readonly navigationSelectors: string[];
  private readonly logger = createLogger('ContentExtractor');
  
  constructor() {
    this.readabilitySelectors = [
      // Prioritize specific content containers over generic ones
      '.entry-content',
      '.post-content',
      '.article-content',
      '.blog-content',
      '.article-body',
      '.post-body',
      '.entry-body',
      '.content-body',
      'article',
      '.main-content',
      '.article-text',
      '.story-body',
      '.article-wrapper',
      '.post-text',
      '.content-area',
      '.entry-text', // Enhanced selectors for various blog platforms
      '.post__content',
      '.blog-content',
      '.article__content',
      '.entry__content',
      '.content__body',
      '.prose',
      '.rich-text',
      '.wp-content',
      '.post-body-content',
      '.article-text-content',
      '.blog-post-content',
      '.single-post-content',
      '.content-wrapper',
      '.page-content',
      // Fallback to broader selectors only if specific ones don't work
      'main',
      '[role="main"]',
      '.content',
      '.entry-content-wrapper', // Docker and tech blog specific
      '.documentation-content',
      '.tutorial-content',
      '.guide-content',
      '.blog-article-content',
      '.DockerBlogPost',
      '.blog-article',
      '.article-wrapper',
      '.content-area',
      '.container .row',
      '.single-post',
      '.blog-post',
      'section[class*="content"]',
      'section[class*="post"]',
      'section[class*="article"]',
      // Additional Docker-specific patterns
      '[data-testid="post-content"]',
      '[data-testid="article-content"]',
      '[data-testid="blog-content"]',
      '.post-container',
      '.article-container',
      '.blog-container',
      '.content-main',
      '.main-article',
      '.blog-article-body',
      '.entry-content-wrap',
      '[itemtype*="BlogPosting"]',
      '[itemtype*="Article"]',
      // Fallback for broad content containers
      '[data-content]',
      '[data-article]',
      '[id*="content"]',
      '[class*="content"]',
      '[class*="article"]',
      '[class*="post"]',
    ];
    this.unwantedSelectors = [
      'script',
      'style',
      'noscript',
      'iframe[src*="ads"]',
      'iframe[src*="advertisement"]',
      'iframe[src*="google"]',
      'embed[src*="ads"]',
      'object[data*="ads"]',
      '.ad',
      '.ads',
      '.advertisement',
      '.banner',
      '.popup',
      '.modal',
      '.overlay',
      '.social-share',
      '.share-buttons',
      '.comments-section',
      '.related-posts',
      '.sidebar',
      '.widget',
      // Additional unwanted elements
      '.newsletter-signup',
      '.subscription-box',
      '.email-signup',
      '.social-links',
      '.author-bio',
      '.author-card',
      '.breadcrumb',
      '.pagination',
      '.tag-list',
      '.category-list',
      '.metadata',
      '.post-meta',
      '.article-meta',
      '.sharing',
      '.social-sharing',
      '.follow-buttons',
      '.call-to-action',
      '.cta',
      '.promo-box',
      '.advertisement-block',
      // Navigation elements
      'nav',
      'header:not(.article-header):not(.post-header)',
      'footer:not(.article-footer):not(.post-footer)',
      'aside:not(.content-aside)',
      '.navigation',
      '.nav',
      '.menu',
      '.navbar',
      '.header',
      '.footer',
      '.top-bar',
      '.bottom-bar',
      // Cookie and privacy notices
      '.cookie-notice',
      '.privacy-notice',
      '.gdpr-notice',
      '.consent-banner',
    ];

    this.adSelectors = [
      '[id*="ad"]',
      '[class*="ad"]',
      '[id*="advertisement"]',
      '[class*="advertisement"]',
      '[id*="banner"]',
      '[class*="banner"]',
      '[id*="sponsor"]',
      '[class*="sponsor"]',
      '.google-ad',
      '.adsystem',
      '.ad-container',
      '.ad-wrapper',
      '.advertisement-wrapper',
      '.sponsored-content',
      '.promo',
      '.promotion',
    ];

    this.navigationSelectors = [
      'nav',
      'header:not(.article-header):not(.post-header)',
      'footer:not(.article-footer):not(.post-footer)',
      'aside:not(.content-aside)',
      '.navigation',
      '.nav',
      '.menu',
      '.navbar',
      '.header',
      '.footer',
      '.breadcrumb',
      '.pagination',
      '.site-header',
      '.site-footer',
      '.top-bar',
      '.bottom-bar',
    ];
  }
  async extractContent(options: IExtractorOptions = {}): Promise<IContentResult> {
    try {
      this.logger.debug('Starting content extraction');

      // For modern sites, wait a moment for dynamic content
      if (document.readyState !== 'complete') {
        this.logger.debug('Document not fully loaded, waiting...');
        await new Promise(resolve => {
          if (document.readyState === 'complete') {
            resolve(void 0);
          } else {
            window.addEventListener('load', () => resolve(void 0), { once: true });
            // Fallback timeout
            setTimeout(() => resolve(void 0), 3000);
          }
        });
      } // For dynamic sites (like Docker blog), wait additional time for content to load
      const isDynamicSite = this.isDynamicSite();
      if (isDynamicSite) {
        this.logger.debug('Dynamic site detected, waiting for content to load...');
        await this.waitForContentToLoad();
        await this.waitForSpecificContent();
      }

      const metadata = this.extractMetadata();
      this.logger.debug('Metadata extracted:', metadata);

      let content = this.findMainContent(options);
      this.logger.debug('Main content found, length:', content.length);

      if (options.removeAds !== false) {
        content = this.removeAds(content);
        this.logger.debug('Ads removed');
      }

      if (options.removeNavigation !== false) {
        content = this.removeNavigation(content);
        this.logger.debug('Navigation removed');
      }

      const cleanedContent = this.cleanContent(content, options);
      const wordCount = this.countWords(cleanedContent);
      const readingTime = this.estimateReadingTime(wordCount);

      this.logger.debug('Content extraction complete');

      return {
        content,
        metadata,
        cleanedContent,
        wordCount,
        readingTime,
      };
    } catch (error) {
      console.error('ContentExtractor: Error during extraction:', error);
      throw error;
    }
  }

  private extractMetadata(): IDocumentMetadata {
    const title = this.extractTitle();
    const author = this.extractAuthor();
    const captureDate = new Date().toISOString();
    const tags = this.extractTags();
    const metadata: IDocumentMetadata = {
      title,
      url: window.location.href,
      captureDate,
      tags,
      wordCount: 0, // Will be calculated later
      estimatedReadingTime: 0, // Will be calculated later
    };

    if (author) {
      metadata.author = author;
    }

    return metadata;
  }

  private extractTitle(): string {
    // Try multiple methods to get the best title
    const methods = [
      () => document.querySelector('meta[property="og:title"]')?.getAttribute('content'),
      () => document.querySelector('meta[name="twitter:title"]')?.getAttribute('content'),
      () => document.querySelector('h1')?.textContent?.trim(),
      () => document.querySelector('.article-title')?.textContent?.trim(),
      () => document.querySelector('.post-title')?.textContent?.trim(),
      () => document.querySelector('.entry-title')?.textContent?.trim(),
      () => document.title?.trim(),
    ];

    for (const method of methods) {
      try {
        const title = method();
        if (title && title.length > 0) {
          return this.cleanText(title);
        }
      } catch (e) {
        // Continue to next method
      }
    }

    return 'Untitled Document';
  }

  private extractAuthor(): string | undefined {
    const methods = [
      () => document.querySelector('meta[name="author"]')?.getAttribute('content'),
      () => document.querySelector('meta[property="article:author"]')?.getAttribute('content'),
      () => document.querySelector('.author')?.textContent?.trim(),
      () => document.querySelector('.byline')?.textContent?.trim(),
      () => document.querySelector('.post-author')?.textContent?.trim(),
      () => document.querySelector('[rel="author"]')?.textContent?.trim(),
    ];

    for (const method of methods) {
      try {
        const author = method();
        if (author && author.length > 0) {
          return this.cleanText(author);
        }
      } catch (e) {
        // Continue to next method
      }
    }

    return undefined;
  }

  private extractTags(): string[] {
    const tags = new Set<string>();

    // Extract from meta keywords
    const metaKeywords = document.querySelector('meta[name="keywords"]')?.getAttribute('content');
    if (metaKeywords) {
      metaKeywords.split(',').forEach(tag => {
        const cleaned = tag.trim().toLowerCase();
        if (cleaned.length > 0) tags.add(cleaned);
      });
    }

    // Extract from article tags/categories
    const tagElements = document.querySelectorAll('.tag, .category, .label, [rel="tag"]');
    tagElements.forEach(element => {
      const tag = element.textContent?.trim().toLowerCase();
      if (tag && tag.length > 0) {
        tags.add(tag);
      }
    });

    // Extract from URL-based categories
    const urlParts = window.location.pathname
      .split('/')
      .filter(
        part => part.length > 0 && !part.match(/^\d+$/) && part !== 'article' && part !== 'post'
      );
    urlParts.slice(0, 2).forEach(part => tags.add(part.toLowerCase()));

    return Array.from(tags).slice(0, 10); // Limit to 10 tags
  }
  private findMainContent(options: IExtractorOptions): string {
    this.logger.debug('Starting main content search...');

    // Try to find the main content using various selectors
    let mainElement: Element | null = null;
    let selectedSelector = '';

    // First try custom selectors if provided
    if (options.customSelectors?.length) {
      this.logger.debug('Trying custom selectors:', options.customSelectors);
      for (const selector of options.customSelectors) {
        try {
          mainElement = document.querySelector(selector);
          if (mainElement && this.isContentElement(mainElement)) {
            selectedSelector = selector;
            this.logger.debug('Found content with custom selector:', selector);
            break;
          }
        } catch (error) {
          console.warn('ContentExtractor: Invalid custom selector:', selector, error);
        }
        mainElement = null;
      }
    }

    // Then try readability selectors
    if (!mainElement) {
      this.logger.debug('Trying readability selectors...');
      for (const selector of this.readabilitySelectors) {
        try {
          const elements = document.querySelectorAll(selector);
          this.logger.debug(
            `Found ${elements.length} elements for selector "${selector}"`
          );
          for (let i = 0; i < elements.length; i++) {
            const element = elements[i];
            if (this.isContentElement(element)) {
              mainElement = element;
              selectedSelector = selector;
              this.logger.debug('Found content with selector:', selector);
              break;
            }
          }
          if (mainElement) break;
        } catch (error) {
          console.warn('ContentExtractor: Error with selector:', selector, error);
        }
      }
    }

    // Enhanced fallback: Try to find largest content container
    if (!mainElement) {
      this.logger.debug(
        'No specific content selector worked, trying enhanced fallback...'
      );
      mainElement = this.findLargestContentContainer();
      selectedSelector = 'enhanced-fallback';
    }

    // Final fallback to body if nothing found
    if (!mainElement) {
      this.logger.debug('Using body as final fallback');
      mainElement = document.body;
      selectedSelector = 'body-fallback';
    }

    this.logger.debug('Selected element with selector:', selectedSelector);
    this.logger.debug('Element tag:', mainElement.tagName);
    this.logger.debug('Element text length:', mainElement.textContent?.length || 0);

    // Clone the element to avoid modifying the original DOM
    const cloned = mainElement.cloneNode(true) as Element;

    // Remove unwanted elements
    this.removeUnwantedElements(cloned, options);

    const finalContent = cloned.innerHTML || '';
    this.logger.debug('Final content length after cleanup:', finalContent.length);

    return finalContent;
  }
  private isContentElement(element: Element): boolean {
    const text = element.textContent?.trim() || '';
    const html = element.innerHTML || '';

    // More lenient minimum content length for dynamic sites
    const minLength = this.isDynamicSite() ? 30 : 50;
    if (text.length < minLength) {
      this.logger.debug('Element rejected - too short:', text.length);
      return false;
    }

    // Check ratio of text to HTML (avoid heavily nested/formatted content)
    // Be more lenient for dynamic sites
    const ratio = text.length / html.length;
    const minRatio = this.isDynamicSite() ? 0.02 : 0.05;
    if (ratio < minRatio) {
      this.logger.debug('Element rejected - poor text/html ratio:', ratio);
      return false;
    }

    // Check for too many links relative to content (likely navigation)
    const links = element.querySelectorAll('a').length;
    const paragraphs = element.querySelectorAll('p').length;
    const textBlocks = element.querySelectorAll('p, div, span, section, article').length;

    // More sophisticated link density check - be more lenient for tech blogs
    const isDynamicSite = this.isDynamicSite();
    const maxLinkRatio = isDynamicSite ? 0.7 : 0.5;

    if (links > 20 && links > textBlocks * maxLinkRatio && paragraphs < 2) {
      this.logger.debug(
        'Element rejected - too many links:',
        links,
        'paragraphs:',
        paragraphs,
        'textBlocks:',
        textBlocks
      );
      return false;
    }

    // Positive signals for content
    const hasHeadings = element.querySelectorAll('h1, h2, h3, h4, h5, h6').length > 0;
    const hasParagraphs = paragraphs > 0;
    const hasCodeBlocks = element.querySelectorAll('pre, code').length > 0;
    const hasListItems = element.querySelectorAll('li').length > 2;
    const hasBlockquotes = element.querySelectorAll('blockquote').length > 0;

    // Content-related class/id names
    const className = element.className.toLowerCase();
    const id = element.id.toLowerCase();
    const contentTerms = [
      'content',
      'article',
      'post',
      'entry',
      'body',
      'text',
      'prose',
      'blog',
      'main',
    ];
    const hasContentClass = contentTerms.some(
      term => className.includes(term) || id.includes(term)
    );

    // Check for structured data indicators
    const hasStructuredData = !!(
      element.getAttribute('itemtype') ||
      element.querySelector('[itemtype]') ||
      element.getAttribute('data-testid') ||
      element.querySelector('[data-testid]')
    );

    // Navigation/non-content class/id names - be more specific
    const navTerms = [
      'navigation',
      'navbar',
      'menu-',
      'sidebar',
      'footer',
      'header',
      'banner',
      'widget',
      '-ad-',
      'advertisement',
    ];
    const hasNavClass = navTerms.some(term => className.includes(term) || id.includes(term));

    if (hasNavClass && !hasContentClass) {
      this.logger.debug(
        'Element rejected - navigation class detected without content class'
      );
      return false;
    }

    const contentSignals = [
      hasHeadings,
      hasParagraphs,
      hasCodeBlocks,
      hasContentClass,
      hasStructuredData,
      hasListItems,
      hasBlockquotes,
    ];
    const positiveSignals = contentSignals.filter(Boolean).length;
    const isLikelyContent = positiveSignals >= 2 || (positiveSignals >= 1 && text.length > 200);

    this.logger.debug('Element assessment:', {
      textLength: text.length,
      ratio: ratio.toFixed(3),
      links,
      paragraphs,
      hasHeadings,
      hasParagraphs,
      hasCodeBlocks,
      hasContentClass,
      hasStructuredData,
      hasListItems,
      hasBlockquotes,
      positiveSignals,
      isLikelyContent,
    });

    return isLikelyContent;
  }
  private removeUnwantedElements(element: Element, options: IExtractorOptions): void {
    this.logger.debug('Removing unwanted elements...');

    // Remove script, style, and other unwanted elements
    const unwanted = element.querySelectorAll(this.unwantedSelectors.join(','));
    this.logger.debug('Removing', unwanted.length, 'unwanted elements');
    unwanted.forEach(el => el.remove());

    // Remove excluded selectors if specified
    if (options.excludeSelectors?.length) {
      const excluded = element.querySelectorAll(options.excludeSelectors.join(','));
      this.logger.debug('Removing', excluded.length, 'excluded elements');
      excluded.forEach(el => el.remove());
    }

    // Remove empty elements that might remain
    const emptyElements = element.querySelectorAll('div:empty, span:empty, p:empty, section:empty');
    this.logger.debug('Removing', emptyElements.length, 'empty elements');
    emptyElements.forEach(el => el.remove());

    // Remove elements with only whitespace
    const allElements = element.querySelectorAll('*');
    let removedWhitespace = 0;
    for (let i = 0; i < allElements.length; i++) {
      const el = allElements[i];
      if (el.children.length === 0 && (!el.textContent || el.textContent.trim() === '')) {
        el.remove();
        removedWhitespace++;
      }
    }
    this.logger.debug('Removed', removedWhitespace, 'whitespace-only elements');

    // Remove elements that are likely ads by content
    const suspiciousElements = element.querySelectorAll('div, span, section, aside');
    let removedAds = 0;
    for (let i = 0; i < suspiciousElements.length; i++) {
      const el = suspiciousElements[i];
      const text = el.textContent?.toLowerCase() || '';
      const className = el.className?.toLowerCase() || '';
      const id = el.id?.toLowerCase() || '';

      if (this.isAdContent(text, id, className)) {
        el.remove();
        removedAds++;
      }
    }
    this.logger.debug('Removed', removedAds, 'ad-like elements');
  }

  private removeAds(content: string): string {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = content;

    // Remove ad elements
    const adElements = tempDiv.querySelectorAll(this.adSelectors.join(','));
    adElements.forEach(el => el.remove());

    // Remove elements with ad-related text
    const allElements = tempDiv.querySelectorAll('*');
    allElements.forEach(el => {
      const text = el.textContent?.toLowerCase() || '';
      const id = el.id?.toLowerCase() || '';
      const className = el.className?.toString().toLowerCase() || '';

      if (this.isAdContent(text, id, className)) {
        el.remove();
      }
    });

    return tempDiv.innerHTML;
  }

  private isAdContent(text: string, id: string, className: string): boolean {
    const adKeywords = [
      'advertisement',
      'sponsored',
      'promoted',
      'ads by',
      'google ads',
      'affiliate',
      'partner content',
      'paid promotion',
      'shop now',
      'buy now',
      'get deal',
      'limited time',
      'subscribe now',
    ];

    const combinedText = `${text} ${id} ${className}`.toLowerCase();
    return adKeywords.some(keyword => combinedText.includes(keyword));
  }

  private removeNavigation(content: string): string {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = content;

    // Remove navigation elements
    const navElements = tempDiv.querySelectorAll(this.navigationSelectors.join(','));
    navElements.forEach(el => el.remove());

    return tempDiv.innerHTML;
  }

  private cleanContent(content: string, options: IExtractorOptions): string {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = content;

    // Remove empty elements
    this.removeEmptyElements(tempDiv);

    // Clean up whitespace and formatting
    if (!options.preserveFormatting) {
      this.normalizeWhitespace(tempDiv);
    }

    return tempDiv.innerHTML;
  }

  private removeEmptyElements(element: Element): void {
    const allElements = element.querySelectorAll('*');

    // Process elements in reverse order to avoid issues with removal
    for (let i = allElements.length - 1; i >= 0; i--) {
      const el = allElements[i];
      const text = el.textContent?.trim() || '';
      const hasVisibleChildren = el.querySelector('img, video, audio, canvas, svg, iframe');

      // Remove if empty and has no visible children
      if (text.length === 0 && !hasVisibleChildren) {
        el.remove();
      }
    }
  }
  private normalizeWhitespace(element: Element): void {
    const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT);

    const textNodes: Text[] = [];
    let node;
    while ((node = walker.nextNode())) {
      textNodes.push(node as Text);
    }

    textNodes.forEach(textNode => {
      if (textNode.textContent) {
        textNode.textContent = textNode.textContent.replace(/\s+/g, ' ').trim();
      }
    });
  }

  private cleanText(text: string): string {
    return text
      .replace(/\s+/g, ' ')
      .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,\-.\/:;<=>?@\[\]^_`{|}~]/g, '')
      .trim();
  }

  private countWords(content: string): number {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = content;
    const text = tempDiv.textContent || '';

    return text
      .trim()
      .split(/\s+/)
      .filter(word => word.length > 0).length;
  }

  private estimateReadingTime(wordCount: number): number {
    // Average reading speed: 200-250 words per minute
    const wordsPerMinute = 225;
    return Math.ceil(wordCount / wordsPerMinute);
  }

  // Public utility methods
  extractImages(): Array<{ src: string; alt: string; title?: string }> {
    const images = document.querySelectorAll('img');
    return Array.from(images)
      .map(img => ({
        src: img.src,
        alt: img.alt || '',
        title: img.title,
      }))
      .filter(img => img.src && !img.src.startsWith('data:'));
  }
  extractLinks(): Array<{ href: string; text: string; title?: string }> {
    const links = document.querySelectorAll('a[href]');
    return Array.from(links)
      .map(link => {
        const anchor = link as HTMLAnchorElement;
        return {
          href: anchor.href,
          text: anchor.textContent?.trim() || '',
          title: anchor.title,
        };
      })
      .filter(link => link.href && !link.href.startsWith('javascript:'));
  }

  getPageStructure(): { headings: string[]; sections: number; paragraphs: number } {
    const headings = Array.from(document.querySelectorAll('h1, h2, h3, h4, h5, h6'))
      .map(h => h.textContent?.trim() || '')
      .filter(text => text.length > 0);

    const sections = document.querySelectorAll('section, article, div.section').length;
    const paragraphs = document.querySelectorAll('p').length;

    return { headings, sections, paragraphs };
  }

  isPaywallPresent(): boolean {
    const paywallIndicators = [
      '.paywall',
      '.subscription-wall',
      '.premium-content',
      '[class*="paywall"]',
      '[id*="paywall"]',
      '.login-required',
      '.subscriber-only',
    ];

    return paywallIndicators.some(selector => document.querySelector(selector) !== null);
  }

  getContentQualityScore(): number {
    let score = 0;
    const content = document.body.textContent || '';

    // Length score (0-30 points)
    const wordCount = this.countWords(content);
    if (wordCount > 500) score += 30;
    else if (wordCount > 200) score += 20;
    else if (wordCount > 100) score += 10;

    // Structure score (0-25 points)
    const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6').length;
    const paragraphs = document.querySelectorAll('p').length;
    if (headings > 0 && paragraphs > 3) score += 25;
    else if (paragraphs > 1) score += 15;

    // Media score (0-20 points)
    const images = document.querySelectorAll('img').length;
    if (images > 2) score += 20;
    else if (images > 0) score += 10;

    // Link quality (0-15 points)
    const links = document.querySelectorAll('a[href]').length;
    const textLength = content.length;
    const linkRatio = links / (textLength / 1000); // Links per 1000 chars
    if (linkRatio < 5 && linkRatio > 0.5) score += 15;
    else if (linkRatio < 10) score += 10;

    // Readability indicators (0-10 points)
    if (document.querySelector('article, main, .content')) score += 10;
    else if (document.querySelector('.post, .entry')) score += 5;

    return Math.min(score, 100);
  }
  private findLargestContentContainer(): Element | null {
    this.logger.debug('Searching for largest content container...');

    // Find all potential content containers with broader selection
    const candidates = document.querySelectorAll(
      'div, section, article, main, aside, [role="main"], [role="article"]'
    );
    let bestCandidate: Element | null = null;
    let bestScore = 0;

    // Lower the minimum threshold for dynamic sites
    const isDynamic = this.isDynamicSite();
    const minScore = isDynamic ? 50 : 100;

    for (let i = 0; i < candidates.length; i++) {
      const candidate = candidates[i];
      const score = this.scoreContentElement(candidate);

      this.logger.debug(
        `Candidate ${i}: ${candidate.tagName}.${candidate.className} - Score: ${score}`
      );

      if (score > bestScore && score > minScore) {
        bestScore = score;
        bestCandidate = candidate;
      }
    }

    if (bestCandidate) {
      this.logger.debug('Found best content container with score:', bestScore);
      this.logger.debug('Element tag:', bestCandidate.tagName);
      this.logger.debug('Element class:', bestCandidate.className);
      this.logger.debug('Element id:', bestCandidate.id);
      this.logger.debug('Text length:', bestCandidate.textContent?.length || 0);
    } else {
      this.logger.debug('No suitable content container found, trying fallback...');

      // Final fallback: try to find any element with substantial text content
      const allElements = Array.from(document.querySelectorAll('*')).filter(el => {
        const text = el.textContent?.trim() || '';
        return text.length > 200 && el.children.length < 50; // Not too deeply nested
      });

      if (allElements.length > 0) {
        // Sort by text length and take the largest
        allElements.sort((a, b) => (b.textContent?.length || 0) - (a.textContent?.length || 0));
        bestCandidate = allElements[0];
        this.logger.debug(
          'Using fallback element:',
          bestCandidate.tagName,
          bestCandidate.className
        );
      }
    }

    return bestCandidate;
  }

  private scoreContentElement(element: Element): number {
    let score = 0;
    const text = element.textContent?.trim() || '';
    const html = element.innerHTML || '';

    // Base score from text length
    score += Math.min(text.length / 10, 500);

    // Bonus for paragraphs
    const paragraphs = element.querySelectorAll('p').length;
    score += paragraphs * 25;

    // Bonus for headings
    const headings = element.querySelectorAll('h1, h2, h3, h4, h5, h6').length;
    score += headings * 30;

    // Penalty for too many links (likely navigation)
    const links = element.querySelectorAll('a').length;
    if (links > paragraphs * 2) {
      score -= links * 10;
    }

    // Penalty for too many script/style tags
    const scripts = element.querySelectorAll('script, style').length;
    score -= scripts * 50;

    // Bonus for content-related class names
    const className = element.className.toLowerCase();
    const id = element.id.toLowerCase();
    const contentTerms = ['content', 'article', 'post', 'entry', 'main', 'body', 'text'];

    contentTerms.forEach(term => {
      if (className.includes(term) || id.includes(term)) {
        score += 100;
      }
    });

    // Penalty for navigation-related class names
    const navTerms = ['nav', 'menu', 'sidebar', 'footer', 'header', 'ad', 'banner'];
    navTerms.forEach(term => {
      if (className.includes(term) || id.includes(term)) {
        score -= 200;
      }
    });

    return Math.max(0, score);
  }

  private isDynamicSite(): boolean {
    const url = window.location.href.toLowerCase();
    const hostname = window.location.hostname.toLowerCase();

    // Known dynamic sites that need extra loading time
    const dynamicSites = [
      'docker.com',
      'medium.com',
      'dev.to',
      'hashnode.com',
      'substack.com',
      'wordpress.com',
      'ghost.org',
    ];

    const isDynamic = dynamicSites.some(site => hostname.includes(site));
    // Also check for React/Vue/Angular indicators
    const hasModernFramework = !!(
      document.querySelector('[data-reactroot]') ||
      document.querySelector('[data-vue]') ||
      document.querySelector('[ng-version]') ||
      (window as any).React ||
      (window as any).Vue ||
      (window as any).angular
    );

    this.logger.debug('Dynamic site check:', {
      hostname,
      isDynamic,
      hasModernFramework,
      final: isDynamic || hasModernFramework,
    });

    return isDynamic || hasModernFramework;
  }

  private async waitForContentToLoad(): Promise<void> {
    const maxWaitTime = 5000; // 5 seconds max
    const checkInterval = 500; // Check every 500ms
    const startTime = Date.now();

    let previousContentLength = 0;

    while (Date.now() - startTime < maxWaitTime) {
      // Check if content has stabilized (stopped growing)
      const currentContent = document.body.textContent?.length || 0;

      if (currentContent > previousContentLength) {
        this.logger.debug('Content still loading...', currentContent, 'chars');
        previousContentLength = currentContent;
        await new Promise(resolve => setTimeout(resolve, checkInterval));
      } else if (previousContentLength > 1000) {
        // Content has stabilized and we have enough content
        this.logger.debug('Content appears to have finished loading');
        break;
      } else {
        // Content is stable but might be too little, keep waiting
        await new Promise(resolve => setTimeout(resolve, checkInterval));
      }
    }

    this.logger.debug('Finished waiting for content load');
  }
  private async waitForSpecificContent(): Promise<void> {
    const url = window.location.href.toLowerCase();

    // Docker blog specific waiting logic
    if (url.includes('docker.com/blog')) {
      this.logger.debug('Waiting for Docker blog specific content...');

      // Wait for any of these selectors to appear with substantial content
      const dockerSelectors = [
        '.post-content',
        '.entry-content',
        '.article-content',
        '.blog-content',
        'article',
        '.content',
        '[data-testid*="content"]',
      ];

      const maxWait = 5000; // 5 seconds
      const startTime = Date.now();

      while (Date.now() - startTime < maxWait) {
        for (const selector of dockerSelectors) {
          const element = document.querySelector(selector);
          if (element && element.textContent && element.textContent.trim().length > 500) {
            this.logger.debug(`Found Docker content via selector: ${selector}`);
            return;
          }
        }
        await new Promise(resolve => setTimeout(resolve, 200));
      }

      this.logger.debug('Docker blog content wait timeout');
    }
  }
}
