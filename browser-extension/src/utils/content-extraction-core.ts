// Generated by Copilot
// Content Extraction Core - Reusable content extraction utilities for bookmarklet and extension
// DOM-only dependencies, no Chrome APIs, compatible with any webpage context

export interface IExtractionConfig {
  includeImages: boolean;
  includeLinks: boolean;
  cleanHtml: boolean;
  customSelectors: string[];
  excludeSelectors: string[];
  maxWordCount?: number;
  preserveFormatting: boolean;
}

export interface IExtractedContent {
  title: string;
  content: string;
  cleanedContent: string;
  images: string[];
  links: string[];
  metadata: IContentMetadata;
  structure: IPageStructure;
  qualityScore: number;
}

export interface IContentMetadata {
  url: string;
  domain: string;
  author?: string;
  description?: string;
  keywords: string[];
  publishedDate?: string;
  language: string;
  wordCount: number;
  readingTime: number;
  extractedAt: string;
  extractionMethod: string;
  [key: string]: unknown;
}

export interface IPageStructure {
  headings: Array<{ level: number; text: string }>;
  sections: number;
  paragraphs: number;
  lists: number;
  codeBlocks: number;
  blockquotes: number;
}

export interface IImageInfo {
  src: string;
  alt: string;
  title?: string | undefined;
  width?: number | undefined;
  height?: number | undefined;
}

export interface ILinkInfo {
  href: string;
  text: string;
  title?: string | undefined;
  isInternal: boolean;
}

/**
 * Core content extraction engine that works in any DOM context
 * No Chrome APIs, suitable for bookmarklets and browser extensions
 */
export class ContentExtractionCore {
  private readonly _config: IExtractionConfig;
  private readonly _baseUrl: string;

  constructor(config: Partial<IExtractionConfig> = {}, baseUrl?: string) {
    this._config = {
      includeImages: true,
      includeLinks: true,
      cleanHtml: true,
      customSelectors: [],
      excludeSelectors: [
        'script',
        'style',
        'noscript',
        'iframe',
        '.advertisement',
        '.ad',
        '.ads',
        '.popup',
        '.modal',
        '.social-share',
        '.comments',
        '.related-posts',
        '[style*="display: none"]',
        '[style*="visibility: hidden"]',
      ],
      preserveFormatting: true,
      ...config,
    };

    this._baseUrl = baseUrl || (typeof window !== 'undefined' ? window.location.href : '');
  }

  /**
   * Extract content from the current document or provided element
   */
  extractContent(rootElement?: Element | Document): IExtractedContent {
    const doc = rootElement || document;
    const contentElement = this.findMainContent(doc);

    if (!contentElement) {
      throw new Error('No suitable content found');
    }

    // Clean the content
    const cleanedElement = this.cleanContent(contentElement);
    const content = cleanedElement.innerHTML || '';
    const textContent = cleanedElement.textContent || '';

    // Extract components
    const title = this.extractTitle(doc);
    const images = this._config.includeImages ? this.extractImages(doc) : [];
    const links = this._config.includeLinks ? this.extractLinks(doc) : [];
    const metadata = this.extractMetadata(doc, textContent);
    const structure = this.analyzePageStructure(doc);
    const qualityScore = this.calculateQualityScore(textContent, structure);

    return {
      title,
      content,
      cleanedContent: textContent,
      images: images.map(img => img.src),
      links: links.map(link => link.href),
      metadata,
      structure,
      qualityScore,
    };
  }

  /**
   * Find the main content element using various strategies
   */
  findMainContent(doc: Element | Document): Element | null {
    // Try custom selectors first
    if (this._config.customSelectors.length > 0) {
      for (const selector of this._config.customSelectors) {
        const element = this.safeQuerySelector(selector, doc);
        if (element && this.hasSubstantialContent(element)) {
          return element;
        }
      }
    }

    // Try semantic HTML elements
    const semanticSelectors = [
      'article',
      'main',
      '[role="main"]',
      '[role="article"]',
      'section[class*="content"]',
      'div[class*="content"]',
    ];

    for (const selector of semanticSelectors) {
      const element = this.safeQuerySelector(selector, doc);
      if (element && this.hasSubstantialContent(element)) {
        return element;
      }
    }

    // Try common content class/ID patterns
    const contentSelectors = [
      '.content',
      '.post-content',
      '.entry-content',
      '.article-content',
      '#content',
      '#main',
      '#post',
      '#entry',
      '.main-content',
      '.page-content',
      '.blog-content',
    ];

    for (const selector of contentSelectors) {
      const element = this.safeQuerySelector(selector, doc);
      if (element && this.hasSubstantialContent(element)) {
        return element;
      }
    }

    // Score-based content detection fallback
    return this.findContentByScoring(doc);
  }

  /**
   * Clean content by removing unwanted elements
   */
  cleanContent(element: Element): Element {
    const cloned = element.cloneNode(true) as Element;

    if (!this._config.cleanHtml) {
      return cloned;
    }

    // Remove elements based on exclude selectors
    this._config.excludeSelectors.forEach(selector => {
      const elements = this.safeQuerySelectorAll(selector, cloned);
      elements.forEach(el => el.remove());
    });

    // Remove additional unwanted content
    this.removeUnwantedElements(cloned);
    this.removeEmptyElements(cloned);
    this.cleanAttributes(cloned);

    return cloned;
  }

  /**
   * Extract page title from multiple sources
   */
  extractTitle(doc: Element | Document = document): string {
    const titleSources = [
      () => this.safeQuerySelector('[property="og:title"]', doc)?.getAttribute('content'),
      () => this.safeQuerySelector('[name="twitter:title"]', doc)?.getAttribute('content'),
      () => this.safeQuerySelector('h1', doc)?.textContent,
      () => this.safeQuerySelector('title', doc)?.textContent,
      () => (doc as Document).title,
    ];

    for (const source of titleSources) {
      try {
        const title = source();
        if (title && title.trim().length > 0) {
          return this.cleanText(title);
        }
      } catch (error) {
        // Ignore errors and try next source
      }
    }

    return 'Untitled Page';
  }

  /**
   * Extract images with detailed information
   */
  extractImages(doc: Element | Document = document): IImageInfo[] {
    const images: IImageInfo[] = [];
    const imgElements = this.safeQuerySelectorAll('img', doc);

    imgElements.forEach(img => {
      const src = img.getAttribute('src');
      if (src && !src.startsWith('data:') && src.length > 0) {
        try {
          const absoluteUrl = this.resolveUrl(src);
          const imgElement = img as HTMLImageElement;
          const imageInfo: IImageInfo = {
            src: absoluteUrl,
            alt: img.getAttribute('alt') || '',
            title: img.getAttribute('title') || undefined,
            width: imgElement.naturalWidth > 0 ? imgElement.naturalWidth : undefined,
            height: imgElement.naturalHeight > 0 ? imgElement.naturalHeight : undefined,
          };

          // Avoid duplicates
          if (!images.some(existing => existing.src === absoluteUrl)) {
            images.push(imageInfo);
          }
        } catch (error) {
          // Skip invalid URLs
        }
      }
    });

    return images;
  }

  /**
   * Extract links with detailed information
   */
  extractLinks(doc: Element | Document = document): ILinkInfo[] {
    const links: ILinkInfo[] = [];
    const linkElements = this.safeQuerySelectorAll('a[href]', doc);

    linkElements.forEach(link => {
      const href = link.getAttribute('href');
      if (href && href.length > 0 && !href.startsWith('#')) {
        try {
          const absoluteUrl = this.resolveUrl(href);
          const linkInfo: ILinkInfo = {
            href: absoluteUrl,
            text: this.cleanText(link.textContent || ''),
            title: link.getAttribute('title') || undefined,
            isInternal: this.isInternalLink(absoluteUrl),
          };

          // Only include links with meaningful text
          if (linkInfo.text.length > 0 && !links.some(existing => existing.href === absoluteUrl)) {
            links.push(linkInfo);
          }
        } catch (error) {
          // Skip invalid URLs
        }
      }
    });

    return links;
  }

  /**
   * Extract comprehensive metadata from the document
   */
  extractMetadata(doc: Element | Document = document, textContent: string = ''): IContentMetadata {
    const metadata: IContentMetadata = {
      url: this._baseUrl,
      domain: this.extractDomain(this._baseUrl),
      keywords: [],
      language: this.extractLanguage(doc),
      wordCount: this.countWords(textContent),
      readingTime: this.estimateReadingTime(textContent),
      extractedAt: new Date().toISOString(),
      extractionMethod: 'content-extraction-core',
    };

    // Extract author
    const author = this.extractAuthor(doc);
    if (author) metadata.author = author;

    // Extract description
    const description = this.extractDescription(doc);
    if (description) metadata.description = description;

    // Extract keywords
    metadata.keywords = this.extractKeywords(doc);

    // Extract published date
    const publishedDate = this.extractPublishedDate(doc);
    if (publishedDate) metadata.publishedDate = publishedDate;

    // Extract Open Graph and Twitter Card metadata
    this.extractSocialMetadata(doc, metadata);

    return metadata;
  }

  /**
   * Analyze page structure for content quality assessment
   */
  analyzePageStructure(doc: Element | Document = document): IPageStructure {
    const headings: Array<{ level: number; text: string }> = [];

    // Extract headings
    const headingElements = this.safeQuerySelectorAll('h1, h2, h3, h4, h5, h6', doc);
    headingElements.forEach(heading => {
      const level = parseInt(heading.tagName.substring(1));
      const text = this.cleanText(heading.textContent || '');
      if (text) {
        headings.push({ level, text });
      }
    });

    return {
      headings,
      sections: this.safeQuerySelectorAll('section, article', doc).length,
      paragraphs: this.safeQuerySelectorAll('p', doc).length,
      lists: this.safeQuerySelectorAll('ul, ol', doc).length,
      codeBlocks: this.safeQuerySelectorAll('pre, code', doc).length,
      blockquotes: this.safeQuerySelectorAll('blockquote', doc).length,
    };
  }

  /**
   * Calculate content quality score
   */
  calculateQualityScore(textContent: string, structure: IPageStructure): number {
    let score = 0;
    const wordCount = this.countWords(textContent);

    // Text length scoring
    if (wordCount > 100) score += 20;
    if (wordCount > 500) score += 20;
    if (wordCount > 1500) score += 10;

    // Structure scoring
    if (structure.headings.length > 0) score += 15;
    if (structure.headings.length > 2) score += 10;
    if (structure.paragraphs > 3) score += 15;
    if (structure.sections > 0) score += 10;

    // Diversity scoring
    if (structure.lists > 0) score += 5;
    if (structure.blockquotes > 0) score += 5;
    if (structure.codeBlocks > 0) score += 5;

    return Math.min(Math.max(score, 0), 100);
  }

  /**
   * Check if an element has substantial content
   */
  hasSubstantialContent(element: Element): boolean {
    const textContent = element.textContent || '';
    const wordCount = this.countWords(textContent);

    // Must have meaningful text content
    if (wordCount < 20) return false;

    // Must be visible (basic check)
    if (element instanceof HTMLElement) {
      const style = window.getComputedStyle(element);
      if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') {
        return false;
      }
    }

    return true;
  }

  /**
   * Detect if content indicates a paywall
   */
  isPaywallPresent(doc: Element | Document = document): boolean {
    const paywallIndicators = [
      '.paywall',
      '.subscription-required',
      '.premium-content',
      '[class*="paywall"]',
      '[class*="subscription"]',
      '[id*="paywall"]',
      '.login-required',
      '.register-required',
    ];

    return paywallIndicators.some(selector => {
      const element = this.safeQuerySelector(selector, doc);
      return element !== null;
    });
  }

  // Private helper methods

  private findContentByScoring(doc: Element | Document): Element | null {
    const candidates = this.safeQuerySelectorAll('div, section, article', doc);
    let bestCandidate: { element: Element; score: number } | null = null;

    for (const candidate of candidates) {
      if (this.hasSubstantialContent(candidate)) {
        const score = this.scoreElement(candidate);
        if (!bestCandidate || score > bestCandidate.score) {
          bestCandidate = { element: candidate, score };
        }
      }
    }

    return bestCandidate?.element || this.safeQuerySelector('body', doc);
  }

  private scoreElement(element: Element): number {
    const text = element.textContent || '';
    const wordCount = this.countWords(text);
    let score = 0;

    // Word count scoring
    score += Math.min(wordCount / 10, 50);

    // Paragraph count scoring
    const paragraphs = this.safeQuerySelectorAll('p', element).length;
    score += paragraphs * 2;

    // Link density penalty (too many links = likely navigation)
    const links = this.safeQuerySelectorAll('a', element).length;
    const linkDensity = links / Math.max(wordCount, 1);
    if (linkDensity > 0.3) score -= 20;

    // Semantic element bonus
    const tagName = element.tagName.toLowerCase();
    if (tagName === 'article') score += 15;
    if (tagName === 'main') score += 10;
    if (tagName === 'section') score += 5;

    // Class name scoring
    const className = (element.className || '').toLowerCase();
    if (className.includes('content')) score += 10;
    if (className.includes('post')) score += 8;
    if (className.includes('article')) score += 8;
    if (className.includes('entry')) score += 5;

    // Negative scoring for common non-content areas
    if (className.includes('sidebar')) score -= 15;
    if (className.includes('footer')) score -= 15;
    if (className.includes('header')) score -= 15;
    if (className.includes('nav')) score -= 20;
    if (className.includes('menu')) score -= 15;
    if (className.includes('advertisement')) score -= 25;

    return Math.max(score, 0);
  }

  private removeUnwantedElements(element: Element): void {
    // Remove ads and promotional content
    const adSelectors = [
      '[class*="ad"]',
      '[id*="ad"]',
      '[class*="banner"]',
      '[id*="banner"]',
      '[class*="promo"]',
      '[id*="promo"]',
      '[class*="sponsor"]',
      '[id*="sponsor"]',
    ];

    adSelectors.forEach(selector => {
      const elements = this.safeQuerySelectorAll(selector, element);
      elements.forEach(el => {
        const text = (el.textContent || '').toLowerCase();
        if (text.includes('advertisement') || text.includes('sponsored') || text.length < 50) {
          el.remove();
        }
      });
    });

    // Remove navigation elements
    const navSelectors = [
      'nav',
      'header',
      'footer',
      '[role="navigation"]',
      '[role="banner"]',
      '[role="contentinfo"]',
      '.navigation',
      '.nav',
      '.menu',
      '.breadcrumb',
    ];

    navSelectors.forEach(selector => {
      const elements = this.safeQuerySelectorAll(selector, element);
      elements.forEach(el => el.remove());
    });
  }

  private removeEmptyElements(element: Element): void {
    const emptyElements = this.safeQuerySelectorAll('p, div, span', element);
    emptyElements.forEach(el => {
      if (!el.textContent?.trim() && !el.querySelector('img, video, audio, iframe')) {
        el.remove();
      }
    });
  }

  private cleanAttributes(element: Element): void {
    if (!this._config.preserveFormatting) {
      const unwantedAttributes = ['style', 'class', 'id', 'onclick', 'onload'];

      const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, null);

      const elements: Element[] = [];
      let node = walker.nextNode();
      while (node) {
        elements.push(node as Element);
        node = walker.nextNode();
      }

      elements.forEach(el => {
        unwantedAttributes.forEach(attr => {
          el.removeAttribute(attr);
        });
      });
    }
  }

  private extractAuthor(doc: Element | Document): string {
    const authorSources = [
      () => this.safeQuerySelector('[property="article:author"]', doc)?.getAttribute('content'),
      () => this.safeQuerySelector('[name="author"]', doc)?.getAttribute('content'),
      () => this.safeQuerySelector('[rel="author"]', doc)?.textContent,
      () => this.safeQuerySelector('.author', doc)?.textContent,
      () => this.safeQuerySelector('.byline', doc)?.textContent,
      () => this.safeQuerySelector('[class*="author"]', doc)?.textContent,
    ];

    for (const source of authorSources) {
      try {
        const author = source();
        if (author && author.trim().length > 0) {
          return this.cleanText(author);
        }
      } catch (error) {
        // Continue to next source
      }
    }

    return '';
  }

  private extractDescription(doc: Element | Document): string {
    const descSources = [
      () => this.safeQuerySelector('[property="og:description"]', doc)?.getAttribute('content'),
      () => this.safeQuerySelector('[name="twitter:description"]', doc)?.getAttribute('content'),
      () => this.safeQuerySelector('[name="description"]', doc)?.getAttribute('content'),
    ];

    for (const source of descSources) {
      try {
        const desc = source();
        if (desc && desc.trim().length > 0) {
          return this.cleanText(desc);
        }
      } catch (error) {
        // Continue to next source
      }
    }

    return '';
  }

  private extractKeywords(doc: Element | Document): string[] {
    const keywordSources = [
      () => this.safeQuerySelector('[name="keywords"]', doc)?.getAttribute('content'),
      () => this.safeQuerySelector('[property="article:tag"]', doc)?.getAttribute('content'),
    ];

    const keywords: string[] = [];

    keywordSources.forEach(source => {
      try {
        const keywordString = source();
        if (keywordString) {
          const extracted = keywordString
            .split(/[,;|]/)
            .map(k => this.cleanText(k))
            .filter(k => k.length > 2 && k.length < 30);
          keywords.push(...extracted);
        }
      } catch (error) {
        // Continue to next source
      }
    });

    return [...new Set(keywords)]; // Remove duplicates
  }

  private extractPublishedDate(doc: Element | Document): string {
    const dateSources = [
      () =>
        this.safeQuerySelector('[property="article:published_time"]', doc)?.getAttribute('content'),
      () => this.safeQuerySelector('[name="publish_date"]', doc)?.getAttribute('content'),
      () => this.safeQuerySelector('time[datetime]', doc)?.getAttribute('datetime'),
      () => this.safeQuerySelector('.publish-date', doc)?.textContent,
      () => this.safeQuerySelector('.date', doc)?.textContent,
      () => this.safeQuerySelector('[class*="date"]', doc)?.textContent,
    ];

    for (const source of dateSources) {
      try {
        const date = source();
        if (date && date.trim().length > 0) {
          return this.cleanText(date);
        }
      } catch (error) {
        // Continue to next source
      }
    }

    return '';
  }

  private extractLanguage(doc: Element | Document): string {
    try {
      const docElement = doc instanceof Document ? doc.documentElement : doc;
      return (
        docElement.getAttribute('lang') ||
        this.safeQuerySelector('[property="og:locale"]', doc)?.getAttribute('content') ||
        'en'
      );
    } catch (error) {
      return 'en';
    }
  }

  private extractSocialMetadata(doc: Element | Document, metadata: IContentMetadata): void {
    // Open Graph metadata
    const ogSelectors = [
      'og:site_name',
      'og:type',
      'og:locale',
      'og:image',
      'og:video',
      'og:audio',
    ];

    ogSelectors.forEach(property => {
      try {
        const content = this.safeQuerySelector(`[property="${property}"]`, doc)?.getAttribute(
          'content'
        );
        if (content) {
          metadata[property] = content;
        }
      } catch (error) {
        // Continue to next property
      }
    });

    // Twitter Card metadata
    const twitterSelectors = ['twitter:card', 'twitter:site', 'twitter:creator', 'twitter:image'];

    twitterSelectors.forEach(name => {
      try {
        const content = this.safeQuerySelector(`[name="${name}"]`, doc)?.getAttribute('content');
        if (content) {
          metadata[name] = content;
        }
      } catch (error) {
        // Continue to next name
      }
    });
  }

  private resolveUrl(url: string): string {
    try {
      return new URL(url, this._baseUrl).href;
    } catch (error) {
      throw new Error(`Invalid URL: ${url}`);
    }
  }

  private isInternalLink(url: string): boolean {
    try {
      const linkDomain = new URL(url).hostname;
      const baseDomain = new URL(this._baseUrl).hostname;
      return linkDomain === baseDomain;
    } catch (error) {
      return false;
    }
  }

  private extractDomain(url: string): string {
    try {
      return new URL(url).hostname.replace(/^www\./, '');
    } catch (error) {
      return 'unknown';
    }
  }

  private countWords(text: string): number {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }

  private estimateReadingTime(text: string): number {
    const wordCount = this.countWords(text);
    return Math.ceil(wordCount / 200); // 200 words per minute average
  }

  private cleanText(text: string): string {
    return text.replace(/\s+/g, ' ').trim();
  }

  private safeQuerySelector(
    selector: string,
    context: Element | Document = document
  ): Element | null {
    try {
      return context.querySelector(selector);
    } catch (error) {
      return null;
    }
  }

  private safeQuerySelectorAll(
    selector: string,
    context: Element | Document = document
  ): Element[] {
    try {
      return Array.from(context.querySelectorAll(selector));
    } catch (error) {
      return [];
    }
  }
}
