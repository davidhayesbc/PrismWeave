// Generated by Copilot
// Content Extraction Manager - Handles content extraction workflows with fallback strategies
// Extracted from service worker for better testability and reusability

import { IContentExtractionData, IContentExtractionResult } from '../types/index.js';
import { createLogger } from './logger.js';

const logger = createLogger('ContentExtractionManager');

export class ContentExtractionManager {
  private static readonly CONTENT_SCRIPT_TIMEOUT = 10000; // 10 seconds
  private static readonly PING_TIMEOUT = 1000; // 1 second
  private static readonly SCRIPT_INIT_DELAY = 500; // 500ms

  /**
   * Main content extraction method with automatic fallback strategy
   */
  async extractContent(tabId: number): Promise<IContentExtractionResult> {
    try {
      logger.info('Starting content extraction for tab:', tabId);

      // Validate tab first
      await this.validateTab(tabId);

      // Strategy 1: Try content script extraction (preferred)
      try {
        await this.ensureContentScriptInjected(tabId);
        await this.delay(ContentExtractionManager.SCRIPT_INIT_DELAY);
        return await this.extractContentFromTab(tabId);
      } catch (error) {
        logger.warn('Content script extraction failed, falling back to direct extraction:', error);
      }

      // Strategy 2: Direct extraction fallback
      try {
        return await this.extractContentDirectly(tabId);
      } catch (error) {
        logger.warn('Direct extraction failed, using basic fallback:', error);
      }

      // Strategy 3: Basic fallback (last resort)
      return await this.extractBasicContent(tabId);
    } catch (error) {
      logger.error('All extraction strategies failed:', error);
      throw error;
    }
  }

  /**
   * Validate that the tab is accessible for content extraction
   */
  private async validateTab(tabId: number): Promise<void> {
    const tab = await chrome.tabs.get(tabId);
    
    if (!tab.url || this.isSpecialPage(tab.url)) {
      throw new Error('Cannot extract content from special pages');
    }
  }

  /**
   * Check if URL is a special page that cannot be accessed
   */
  private isSpecialPage(url: string): boolean {
    const specialPrefixes = [
      'chrome://',
      'chrome-extension://',
      'moz-extension://',
      'edge://',
      'about:',
      'file://'
    ];
    
    return specialPrefixes.some(prefix => url.startsWith(prefix));
  }

  /**
   * Ensure content script is injected and ready
   */
  private async ensureContentScriptInjected(tabId: number): Promise<void> {
    logger.debug('Ensuring content script is injected in tab:', tabId);

    // Check if content script is already available
    if (await this.pingContentScript(tabId)) {
      logger.debug('Content script already active');
      return;
    }

    // Inject TurndownService library first
    await this.injectTurndownLibrary(tabId);

    // Inject content script
    await this.injectContentScript(tabId);
  }

  /**
   * Ping content script to check if it's active
   */
  private async pingContentScript(tabId: number): Promise<boolean> {
    return new Promise<boolean>(resolve => {
      const timeout = setTimeout(() => resolve(false), ContentExtractionManager.PING_TIMEOUT);

      chrome.tabs.sendMessage(tabId, { type: 'PING' }, response => {
        clearTimeout(timeout);
        if (chrome.runtime.lastError) {
          logger.debug('Ping failed (expected if script not injected):', chrome.runtime.lastError.message);
          resolve(false);
        } else {
          resolve(!!response);
        }
      });
    });
  }

  /**
   * Inject TurndownService library for markdown conversion
   */
  private async injectTurndownLibrary(tabId: number): Promise<void> {
    logger.debug('Injecting TurndownService library...');
    
    try {
      await chrome.scripting.executeScript({
        target: { tabId },
        files: ['libs/turndown.min.js'],
      });
      logger.debug('TurndownService library injected successfully');
    } catch (error) {
      logger.warn('Failed to inject TurndownService library:', error);
      // This is not fatal - content script may still work with basic conversion
    }
  }

  /**
   * Inject the main content script
   */
  private async injectContentScript(tabId: number): Promise<void> {
    logger.debug('Injecting content script...');
    
    try {
      await chrome.scripting.executeScript({
        target: { tabId },
        files: ['content/content-script.js'],
      });
      logger.debug('Content script injected successfully');
    } catch (error) {
      logger.warn('Failed to inject content script:', error);
      throw new Error('Content script injection failed');
    }
  }

  /**
   * Extract content using the injected content script
   */
  private async extractContentFromTab(tabId: number): Promise<IContentExtractionResult> {
    return new Promise<IContentExtractionResult>((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('Content extraction timeout after 10 seconds'));
      }, ContentExtractionManager.CONTENT_SCRIPT_TIMEOUT);

      logger.debug('Sending EXTRACT_AND_CONVERT message to tab:', tabId);

      chrome.tabs.sendMessage(
        tabId,
        {
          type: 'EXTRACT_AND_CONVERT_TO_MARKDOWN',
          data: {
            extractionRules: ['article', 'main', '.content', '#content', 'body'],
            includeImages: true,
            cleanHtml: true,
            convertToMarkdown: true,
          },
        },
        (response: IContentExtractionResult) => {
          clearTimeout(timeout);

          if (chrome.runtime.lastError) {
            logger.error('Content script message error:', chrome.runtime.lastError.message);
            reject(new Error(chrome.runtime.lastError.message));
          } else if (!response) {
            logger.error('No response received from content script');
            reject(new Error('No response received from content script'));
          } else if (!response.success) {
            logger.error('Content script reported failure:', response.error);
            reject(new Error(response.error || 'Content extraction failed'));
          } else {
            logger.debug('Content extraction and conversion successful via content script');
            resolve(response);
          }
        }
      );
    });
  }

  /**
   * Extract content directly using chrome.scripting API
   */
  private async extractContentDirectly(tabId: number): Promise<IContentExtractionResult> {
    logger.debug('Extracting content directly from tab:', tabId);

    const results = await chrome.scripting.executeScript({
      target: { tabId },
      func: this.directExtractionScript,
    });

    if (!results || results.length === 0 || !results[0].result) {
      throw new Error('Failed to execute extraction script');
    }

    const extractedData = results[0].result;
    logger.debug('Direct extraction completed successfully');

    return {
      success: true,
      data: {
        html: extractedData.html,
        title: extractedData.title,
        url: extractedData.url,
        metadata: extractedData.metadata,
      },
      extractionMethod: 'direct',
      timestamp: new Date().toISOString(),
    };
  }

  /**
   * Script function that runs in the page context for direct extraction
   */
  private directExtractionScript = () => {
    const getPageTitle = (): string => {
      return document.title || 'Untitled';
    };

    const getPageUrl = (): string => {
      return window.location.href;
    };

    const extractMainContent = (): string => {
      const contentSelectors = [
        'article',
        '[role="article"]',
        'main',
        '[role="main"]',
        '.content',
        '#content',
        '.post-content',
        '.entry-content',
        '.article-content',
        '.page-content',
      ];

      let contentElement: Element | null = null;
      for (const selector of contentSelectors) {
        contentElement = document.querySelector(selector);
        if (
          contentElement &&
          contentElement.textContent &&
          contentElement.textContent.trim().length > 100
        ) {
          break;
        }
      }

      if (!contentElement) {
        contentElement = document.body;
      }

      return contentElement?.innerHTML || document.body.innerHTML;
    };

    const extractMetadata = (): Record<string, string> => {
      const metadata: Record<string, string> = {};

      const metaTags = document.querySelectorAll('meta');
      metaTags.forEach(meta => {
        const name = meta.getAttribute('name') || meta.getAttribute('property');
        const content = meta.getAttribute('content');
        if (name && content) {
          metadata[name] = content;
        }
      });

      return metadata;
    };

    return {
      title: getPageTitle(),
      url: getPageUrl(),
      html: extractMainContent(),
      metadata: extractMetadata(),
    };
  };

  /**
   * Basic content extraction as last resort fallback
   */
  private async extractBasicContent(tabId: number): Promise<IContentExtractionResult> {
    logger.warn('Using basic content extraction fallback');
    
    const tab = await chrome.tabs.get(tabId);
    const basicContent = `# ${tab.title || 'Untitled'}\n\nContent extraction failed. Only basic page information is available.\n\n**URL:** ${tab.url || 'Unknown'}\n**Captured:** ${new Date().toISOString()}`;

    return {
      success: true,
      data: {
        markdown: basicContent,
        frontmatter: this.generateBasicFrontmatter(tab.title, tab.url),
        html: `<h1>${tab.title || 'Untitled'}</h1><p>Content extraction failed. Only basic page information is available.</p><p>URL: ${tab.url || 'Unknown'}</p>`,
        title: tab.title || 'Untitled',
        url: tab.url || '',
        metadata: {
          extractedAt: new Date().toISOString(),
          method: 'basic-fallback',
          error: 'Content extraction failed',
        },
        images: [],
      },
      extractionMethod: 'basic-fallback',
      timestamp: new Date().toISOString(),
    };
  }

  /**
   * Generate basic frontmatter for fallback content
   */
  private generateBasicFrontmatter(title?: string, url?: string): string {
    return [
      '---',
      `title: "${(title || 'Untitled').replace(/"/g, '\\"')}"`,
      `url: "${url || ''}"`,
      `capture_date: "${new Date().toISOString()}"`,
      'source: "PrismWeave Browser Extension"',
      'tags: ["web-capture", "fallback"]',
      '---',
      '',
    ].join('\n');
  }

  /**
   * Utility delay function
   */
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
