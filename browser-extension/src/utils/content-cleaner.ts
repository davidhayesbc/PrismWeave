// Generated by Copilot
// Content Cleaning Utilities - Separated content cleaning logic
// Handles removal of unwanted elements and content normalization

import { createLogger } from './logger';
const logger = createLogger('ContentCleaner');

export interface ICleaningOptions {
  preserveFormatting?: boolean;
  removeAds?: boolean;
  removeNavigation?: boolean;
  excludeSelectors?: string[];
  isResearchPage?: boolean;
  domain?: string;
}

export interface ICleaningRule {
  name: string;
  selectors: string[];
  condition?: (element: Element) => boolean;
}

/**
 * Manages content cleaning operations
 */
export class ContentCleaner {
  private readonly unwantedRules: ICleaningRule[] = [
    {
      name: 'scripts-and-styles',
      selectors: ['script', 'style', 'noscript'],
    },
    {
      name: 'advertisements',
      selectors: [
        '.ad',
        '.ads',
        '.advertisement',
        '.banner',
        '[id*="ad"]',
        '[class*="ad"]',
        '[id*="advertisement"]',
        '[class*="advertisement"]',
        '.google-ad',
        '.sponsored-content',
        '.promo',
      ],
    },
    {
      name: 'navigation',
      selectors: [
        'nav',
        'header:not(.article-header):not(.post-header)',
        'footer:not(.article-footer):not(.post-footer)',
        '.navigation',
        '.nav',
        '.menu',
        '.navbar',
        '.breadcrumb',
        '.pagination',
      ],
    },
    {
      name: 'social-and-widgets',
      selectors: [
        '.social-share',
        '.share-buttons',
        '.social-links',
        '.newsletter-signup',
        '.subscription-box',
        '.comments-section',
        '.widget',
        '.sidebar',
      ],
    },
    {
      name: 'metadata-and-tags',
      selectors: [
        '.author-bio',
        '.author-card',
        '.tag-list',
        '.category-list',
        '.metadata',
        '.post-meta',
        '.article-meta',
      ],
    },
    {
      name: 'stackoverflow-specific',
      selectors: [
        // Stack Overflow blog specific unwanted elements
        '.s-navigation',
        '.s-topbar',
        '.js-header',
        '.js-footer',
        '.recent-articles',
        '.latest-podcast',
        '.add-to-discussion',
        '.blog-sidebar',
        '.blog-nav',
        '.site-header',
        '.site-footer',
        '.products-nav',
        '[href*="/teams/"]',
        '[href*="/advertising/"]',
        '[href*="/talent/"]',
        // Generic promotional content patterns
        '[class*="promo"]',
        '[class*="subscribe"]',
        '[class*="newsletter"]',
        '[class*="signup"]',
        '[class*="cta"]',
        '[class*="call-to-action"]',
        // Recent/related content sections
        '.recent',
        '.related',
        '.more-posts',
        '.latest',
        // Login/account related
        '.login',
        '.account',
        '.user-menu',
      ],
    },
  ];

  private readonly adKeywords = [
    'advertisement',
    'sponsored',
    'promoted',
    'ads by',
    'google ads',
    'affiliate',
    'partner content',
    'paid promotion',
    'shop now',
    'buy now',
    'subscribe now',
    // Stack Overflow specific promotional phrases
    'stack overflow for teams',
    'capture, share, & collaborate',
    'promote your product',
    "engage the world's technology talent",
    'advertising',
    'talent',
    'employer brand',
    'add to the discussion',
    'login with your stackoverflow.com account',
    'recent articles',
    'latest podcast',
  ];

  /**
   * Clean content by removing unwanted elements
   */
  cleanContent(element: Element, options: ICleaningOptions = {}): Element {
    const cloned = element.cloneNode(true) as Element;

    // Apply cleaning rules
    this.applyCleaningRules(cloned, options);

    // Remove empty elements
    this.removeEmptyElements(cloned);

    // Remove ad content by text analysis
    if (options.removeAds !== false) {
      this.removeAdContentByText(cloned, options);
    }

    // Normalize whitespace
    if (!options.preserveFormatting) {
      this.normalizeWhitespace(cloned);
    }

    return cloned;
  }

  /**
   * Apply specific cleaning rules based on options
   */
  private applyCleaningRules(element: Element, options: ICleaningOptions): void {
    // Use gentler cleaning for research pages
    if (options.isResearchPage || options.domain?.includes('anthropic.com')) {
      this.applyGentleCleaningRules(element, options);
    } else {
      this.applyStandardCleaningRules(element, options);
    }

    // Apply custom exclusion selectors
    if (options.excludeSelectors?.length) {
      const customRule: ICleaningRule = {
        name: 'custom-exclusions',
        selectors: options.excludeSelectors,
      };
      this.applyRule(element, customRule);
    }
  }

  /**
   * Apply standard aggressive cleaning rules
   */
  private applyStandardCleaningRules(element: Element, options: ICleaningOptions): void {
    // Apply built-in cleaning rules
    for (const rule of this.unwantedRules) {
      // Skip navigation rule if disabled
      if (rule.name === 'navigation' && options.removeNavigation === false) {
        continue;
      }

      // Skip ad rule if disabled
      if (rule.name === 'advertisements' && options.removeAds === false) {
        continue;
      }

      this.applyRule(element, rule);
    }
  }

  /**
   * Apply gentler cleaning rules for research pages
   */
  private applyGentleCleaningRules(element: Element, options: ICleaningOptions): void {
    // Only apply essential cleaning rules for research pages
    const essentialRules = this.unwantedRules.filter(
      rule =>
        rule.name === 'scripts-and-styles' ||
        (rule.name === 'navigation' && options.removeNavigation !== false)
    );

    for (const rule of essentialRules) {
      this.applyRule(element, rule);
    }

    // Apply minimal ad cleaning for research pages
    if (options.removeAds !== false) {
      this.removeObviousAds(element);
    }
  }

  /**
   * Remove only obvious advertisements, not research content
   */
  private removeObviousAds(element: Element): void {
    const obviousAdSelectors = [
      '.google-ad',
      '.advertisement',
      '[id*="google_ads"]',
      '[class*="google-ad"]',
      '.banner-ad',
      '.display-ad',
    ];

    const adElements = element.querySelectorAll(obviousAdSelectors.join(','));
    for (const ad of Array.from(adElements)) {
      ad.remove();
    }
  }

  /**
   * Apply a single cleaning rule
   */
  private applyRule(element: Element, rule: ICleaningRule): void {
    try {
      const elementsToRemove = element.querySelectorAll(rule.selectors.join(','));

      for (const el of Array.from(elementsToRemove)) {
        // Apply condition if specified
        if (rule.condition && !rule.condition(el)) {
          continue;
        }

        el.remove();
      }
    } catch (error) {
      logger.warn('Error applying rule', rule.name, error);
    }
  }

  /**
   * Remove elements that are likely ads based on text content
   */
  private removeAdContentByText(element: Element, options: ICleaningOptions = {}): void {
    // Skip aggressive text-based ad removal for research pages
    if (options.isResearchPage || options.domain?.includes('anthropic.com')) {
      logger.debug('Skipping aggressive ad text removal for research page');
      return;
    }

    const suspiciousElements = element.querySelectorAll('div, span, section, aside');

    for (const el of Array.from(suspiciousElements)) {
      const text = el.textContent?.toLowerCase() || '';
      const className = el.className?.toLowerCase() || '';
      const id = el.id?.toLowerCase() || '';

      if (this.isAdContent(text, id, className)) {
        el.remove();
      }
    }
  }

  /**
   * Check if content appears to be advertising
   */
  private isAdContent(text: string, id: string, className: string): boolean {
    const combinedText = `${text} ${id} ${className}`.toLowerCase();
    return this.adKeywords.some(keyword => combinedText.includes(keyword));
  }

  /**
   * Remove empty elements
   */
  private removeEmptyElements(element: Element): void {
    const allElements = element.querySelectorAll('*');

    // Process in reverse order to avoid issues with removal
    for (let i = allElements.length - 1; i >= 0; i--) {
      const el = allElements[i];
      const text = el.textContent?.trim() || '';
      const hasVisibleChildren = el.querySelector('img, video, audio, canvas, svg, iframe');

      // Remove if empty and has no visible children
      if (text.length === 0 && !hasVisibleChildren) {
        el.remove();
      }
    }
  }

  /**
   * Normalize whitespace in text nodes
   */
  private normalizeWhitespace(element: Element): void {
    const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null);

    const textNodes: Text[] = [];
    let node: Node | null;

    while ((node = walker.nextNode())) {
      textNodes.push(node as Text);
    }

    for (const textNode of textNodes) {
      if (textNode.textContent) {
        textNode.textContent = textNode.textContent.replace(/\s+/g, ' ').trim();
      }
    }
  }

  /**
   * Get list of cleaning rules for debugging
   */
  getCleaningRules(): ICleaningRule[] {
    return [...this.unwantedRules];
  }
}
