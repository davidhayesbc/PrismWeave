// Generated by Copilot
// Content Cleaning Utilities - Separated content cleaning logic
// Handles removal of unwanted elements and content normalization

import { createLogger } from './logger';
const logger = createLogger('ContentCleaner');

export interface ICleaningOptions {
  preserveFormatting?: boolean;
  removeAds?: boolean;
  removeNavigation?: boolean;
  excludeSelectors?: string[];
}

export interface ICleaningRule {
  name: string;
  selectors: string[];
  condition?: (element: Element) => boolean;
}

/**
 * Manages content cleaning operations
 */
export class ContentCleaner {
  private readonly unwantedRules: ICleaningRule[] = [
    {
      name: 'scripts-and-styles',
      selectors: ['script', 'style', 'noscript'],
    },
    {
      name: 'advertisements',
      selectors: [
        '.ad',
        '.ads',
        '.advertisement',
        '.banner',
        '[id*="ad"]',
        '[class*="ad"]',
        '[id*="advertisement"]',
        '[class*="advertisement"]',
        '.google-ad',
        '.sponsored-content',
        '.promo',
      ],
    },
    {
      name: 'navigation',
      selectors: [
        'nav',
        'header:not(.article-header):not(.post-header)',
        'footer:not(.article-footer):not(.post-footer)',
        '.navigation',
        '.nav',
        '.menu',
        '.navbar',
        '.breadcrumb',
        '.pagination',
      ],
    },
    {
      name: 'social-and-widgets',
      selectors: [
        '.social-share',
        '.share-buttons',
        '.social-links',
        '.newsletter-signup',
        '.subscription-box',
        '.comments-section',
        '.widget',
        '.sidebar',
      ],
    },
    {
      name: 'metadata-and-tags',
      selectors: [
        '.author-bio',
        '.author-card',
        '.tag-list',
        '.category-list',
        '.metadata',
        '.post-meta',
        '.article-meta',
      ],
    },
  ];

  private readonly adKeywords = [
    'advertisement',
    'sponsored',
    'promoted',
    'ads by',
    'google ads',
    'affiliate',
    'partner content',
    'paid promotion',
    'shop now',
    'buy now',
    'subscribe now',
  ];

  /**
   * Clean content by removing unwanted elements
   */
  cleanContent(element: Element, options: ICleaningOptions = {}): Element {
    const cloned = element.cloneNode(true) as Element;

    // Apply cleaning rules
    this.applyCleaningRules(cloned, options);

    // Remove empty elements
    this.removeEmptyElements(cloned);

    // Remove ad content by text analysis
    if (options.removeAds !== false) {
      this.removeAdContentByText(cloned);
    }

    // Normalize whitespace
    if (!options.preserveFormatting) {
      this.normalizeWhitespace(cloned);
    }

    return cloned;
  }

  /**
   * Apply specific cleaning rules based on options
   */
  private applyCleaningRules(element: Element, options: ICleaningOptions): void {
    // Apply built-in cleaning rules
    for (const rule of this.unwantedRules) {
      // Skip navigation rule if disabled
      if (rule.name === 'navigation' && options.removeNavigation === false) {
        continue;
      }

      // Skip ad rule if disabled
      if (rule.name === 'advertisements' && options.removeAds === false) {
        continue;
      }

      this.applyRule(element, rule);
    }

    // Apply custom exclusion selectors
    if (options.excludeSelectors?.length) {
      const customRule: ICleaningRule = {
        name: 'custom-exclusions',
        selectors: options.excludeSelectors,
      };
      this.applyRule(element, customRule);
    }
  }

  /**
   * Apply a single cleaning rule
   */
  private applyRule(element: Element, rule: ICleaningRule): void {
    try {
      const elementsToRemove = element.querySelectorAll(rule.selectors.join(','));

      for (const el of elementsToRemove) {
        // Apply condition if specified
        if (rule.condition && !rule.condition(el)) {
          continue;
        }

        el.remove();
      }
    } catch (error) {
      logger.warn('Error applying rule', rule.name, error);
    }
  }

  /**
   * Remove elements that are likely ads based on text content
   */
  private removeAdContentByText(element: Element): void {
    const suspiciousElements = element.querySelectorAll('div, span, section, aside');

    for (const el of suspiciousElements) {
      const text = el.textContent?.toLowerCase() || '';
      const className = el.className?.toLowerCase() || '';
      const id = el.id?.toLowerCase() || '';

      if (this.isAdContent(text, id, className)) {
        el.remove();
      }
    }
  }

  /**
   * Check if content appears to be advertising
   */
  private isAdContent(text: string, id: string, className: string): boolean {
    const combinedText = `${text} ${id} ${className}`.toLowerCase();
    return this.adKeywords.some(keyword => combinedText.includes(keyword));
  }

  /**
   * Remove empty elements
   */
  private removeEmptyElements(element: Element): void {
    const allElements = element.querySelectorAll('*');

    // Process in reverse order to avoid issues with removal
    for (let i = allElements.length - 1; i >= 0; i--) {
      const el = allElements[i];
      const text = el.textContent?.trim() || '';
      const hasVisibleChildren = el.querySelector('img, video, audio, canvas, svg, iframe');

      // Remove if empty and has no visible children
      if (text.length === 0 && !hasVisibleChildren) {
        el.remove();
      }
    }
  }

  /**
   * Normalize whitespace in text nodes
   */
  private normalizeWhitespace(element: Element): void {
    const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null);

    const textNodes: Text[] = [];
    let node: Node | null;

    while ((node = walker.nextNode())) {
      textNodes.push(node as Text);
    }

    for (const textNode of textNodes) {
      if (textNode.textContent) {
        textNode.textContent = textNode.textContent.replace(/\s+/g, ' ').trim();
      }
    }
  }

  /**
   * Get list of cleaning rules for debugging
   */
  getCleaningRules(): ICleaningRule[] {
    return [...this.unwantedRules];
  }
}
