// Generated by Copilot
// Cross-domain bookmarklet storage test suite for PrismWeave
// Tests that bookmarklet settings persist across different website domains

interface IStorageTestResult {
  testName: string;
  success: boolean;
  message: string;
  details?: Record<string, unknown>;
  duration?: number;
}

interface IStorageTestSuite {
  suiteName: string;
  tests: IStorageTestResult[];
  overallSuccess: boolean;
  totalDuration: number;
  summary: string;
}

class CrossDomainStorageTest {
  private readonly EXTENSION_ID = 'your-extension-id-here';
  private readonly TEST_CONFIG = {
    githubToken: 'ghp_test_token_12345',
    githubRepo: 'testuser/test-repo',
    storedBy: 'cross-domain-test',
    timestamp: Date.now(),
  };

  async runFullTestSuite(): Promise<IStorageTestSuite> {
    const startTime = Date.now();
    const tests: IStorageTestResult[] = [];

    console.log('üß™ Starting Cross-Domain Bookmarklet Storage Test Suite...');

    // Test 1: Extension Storage API Availability
    tests.push(await this.testExtensionStorageAvailability());

    // Test 2: Store Configuration via Extension API
    tests.push(await this.testStoreConfigViaExtension());

    // Test 3: Retrieve Configuration via Extension API
    tests.push(await this.testRetrieveConfigViaExtension());

    // Test 4: Update Configuration via Extension API
    tests.push(await this.testUpdateConfigViaExtension());

    // Test 5: Cross-Domain Persistence Simulation
    tests.push(await this.testCrossDomainPersistence());

    // Test 6: Fallback to localStorage when extension unavailable
    tests.push(await this.testLocalStorageFallback());

    // Test 7: Clear Configuration via Extension API
    tests.push(await this.testClearConfigViaExtension());

    // Test 8: Error Handling for Invalid Data
    tests.push(await this.testErrorHandling());

    const totalDuration = Date.now() - startTime;
    const overallSuccess = tests.every(test => test.success);

    const summary = this.generateSummary(tests, overallSuccess, totalDuration);

    return {
      suiteName: 'Cross-Domain Bookmarklet Storage',
      tests,
      overallSuccess,
      totalDuration,
      summary,
    };
  }

  private async testExtensionStorageAvailability(): Promise<IStorageTestResult> {
    const testName = 'Extension Storage API Availability';
    const startTime = Date.now();

    try {
      const isAvailable =
        typeof chrome !== 'undefined' &&
        chrome.runtime &&
        typeof chrome.runtime.sendMessage === 'function' &&
        chrome.storage &&
        chrome.storage.sync;

      const duration = Date.now() - startTime;

      if (isAvailable) {
        return {
          testName,
          success: true,
          message: '‚úÖ Chrome extension storage API is available',
          details: {
            hasChrome: typeof chrome !== 'undefined',
            hasRuntime: !!chrome?.runtime,
            hasSendMessage: !!chrome?.runtime?.sendMessage,
            hasStorage: !!chrome?.storage,
            hasStorageSync: !!chrome?.storage?.sync,
          },
          duration,
        };
      } else {
        return {
          testName,
          success: false,
          message: '‚ùå Chrome extension storage API is not available',
          details: {
            hasChrome: typeof chrome !== 'undefined',
            hasRuntime: !!chrome?.runtime,
            hasSendMessage: !!chrome?.runtime?.sendMessage,
            hasStorage: !!chrome?.storage,
            hasStorageSync: !!chrome?.storage?.sync,
          },
          duration,
        };
      }
    } catch (error) {
      return {
        testName,
        success: false,
        message: `‚ùå Error checking extension API availability: ${error instanceof Error ? error.message : 'Unknown error'}`,
        duration: Date.now() - startTime,
      };
    }
  }

  private async testStoreConfigViaExtension(): Promise<IStorageTestResult> {
    const testName = 'Store Configuration via Extension API';
    const startTime = Date.now();

    try {
      if (typeof chrome === 'undefined' || !chrome.runtime?.sendMessage) {
        return {
          testName,
          success: false,
          message: '‚ùå Chrome extension API not available for testing',
          duration: Date.now() - startTime,
        };
      }

      const response = await new Promise<any>((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error('Storage request timed out after 5 seconds'));
        }, 5000);

        chrome.runtime.sendMessage(
          this.EXTENSION_ID,
          {
            type: 'STORE_BOOKMARKLET_CONFIG',
            data: { config: this.TEST_CONFIG },
          },
          response => {
            clearTimeout(timeout);

            if (chrome.runtime.lastError) {
              reject(new Error(chrome.runtime.lastError.message));
            } else {
              resolve(response);
            }
          }
        );
      });

      const duration = Date.now() - startTime;

      if (response?.success) {
        return {
          testName,
          success: true,
          message: '‚úÖ Configuration stored successfully via extension API',
          details: { response },
          duration,
        };
      } else {
        return {
          testName,
          success: false,
          message: `‚ùå Failed to store configuration: ${response?.error || 'Unknown error'}`,
          details: { response },
          duration,
        };
      }
    } catch (error) {
      return {
        testName,
        success: false,
        message: `‚ùå Error storing configuration: ${error instanceof Error ? error.message : 'Unknown error'}`,
        duration: Date.now() - startTime,
      };
    }
  }

  private async testRetrieveConfigViaExtension(): Promise<IStorageTestResult> {
    const testName = 'Retrieve Configuration via Extension API';
    const startTime = Date.now();

    try {
      if (typeof chrome === 'undefined' || !chrome.runtime?.sendMessage) {
        return {
          testName,
          success: false,
          message: '‚ùå Chrome extension API not available for testing',
          duration: Date.now() - startTime,
        };
      }

      const response = await new Promise<any>((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error('Retrieval request timed out after 5 seconds'));
        }, 5000);

        chrome.runtime.sendMessage(
          this.EXTENSION_ID,
          {
            type: 'GET_BOOKMARKLET_CONFIG',
          },
          response => {
            clearTimeout(timeout);

            if (chrome.runtime.lastError) {
              reject(new Error(chrome.runtime.lastError.message));
            } else {
              resolve(response);
            }
          }
        );
      });

      const duration = Date.now() - startTime;

      if (response?.success && response?.data?.config) {
        const retrievedConfig = response.data.config;
        const configMatches =
          retrievedConfig.githubToken === this.TEST_CONFIG.githubToken &&
          retrievedConfig.githubRepo === this.TEST_CONFIG.githubRepo;

        if (configMatches) {
          return {
            testName,
            success: true,
            message: '‚úÖ Configuration retrieved successfully and matches stored data',
            details: {
              retrievedConfig,
              originalConfig: this.TEST_CONFIG,
              configMatches,
            },
            duration,
          };
        } else {
          return {
            testName,
            success: false,
            message: '‚ùå Retrieved configuration does not match stored data',
            details: {
              retrievedConfig,
              originalConfig: this.TEST_CONFIG,
              configMatches,
            },
            duration,
          };
        }
      } else {
        return {
          testName,
          success: false,
          message: `‚ùå Failed to retrieve configuration: ${response?.error || 'No config data returned'}`,
          details: { response },
          duration,
        };
      }
    } catch (error) {
      return {
        testName,
        success: false,
        message: `‚ùå Error retrieving configuration: ${error instanceof Error ? error.message : 'Unknown error'}`,
        duration: Date.now() - startTime,
      };
    }
  }

  private async testUpdateConfigViaExtension(): Promise<IStorageTestResult> {
    const testName = 'Update Configuration via Extension API';
    const startTime = Date.now();

    try {
      const updatedConfig = {
        ...this.TEST_CONFIG,
        githubRepo: 'testuser/updated-repo',
        lastUpdated: Date.now(),
      };

      // Store updated config
      const storeResponse = await new Promise<any>((resolve, reject) => {
        chrome.runtime.sendMessage(
          this.EXTENSION_ID,
          {
            type: 'STORE_BOOKMARKLET_CONFIG',
            data: { config: updatedConfig },
          },
          resolve
        );
      });

      if (!storeResponse?.success) {
        return {
          testName,
          success: false,
          message: '‚ùå Failed to store updated configuration',
          duration: Date.now() - startTime,
        };
      }

      // Retrieve and verify updated config
      const retrieveResponse = await new Promise<any>((resolve, reject) => {
        chrome.runtime.sendMessage(
          this.EXTENSION_ID,
          {
            type: 'GET_BOOKMARKLET_CONFIG',
          },
          resolve
        );
      });

      const duration = Date.now() - startTime;

      if (retrieveResponse?.success && retrieveResponse?.data?.config) {
        const retrievedConfig = retrieveResponse.data.config;
        const updateWorked = retrievedConfig.githubRepo === updatedConfig.githubRepo;

        if (updateWorked) {
          return {
            testName,
            success: true,
            message: '‚úÖ Configuration updated successfully',
            details: {
              updatedConfig,
              retrievedConfig,
              updateWorked,
            },
            duration,
          };
        } else {
          return {
            testName,
            success: false,
            message: '‚ùå Configuration update did not persist',
            details: {
              updatedConfig,
              retrievedConfig,
              updateWorked,
            },
            duration,
          };
        }
      } else {
        return {
          testName,
          success: false,
          message: '‚ùå Failed to retrieve updated configuration',
          details: { retrieveResponse },
          duration,
        };
      }
    } catch (error) {
      return {
        testName,
        success: false,
        message: `‚ùå Error updating configuration: ${error instanceof Error ? error.message : 'Unknown error'}`,
        duration: Date.now() - startTime,
      };
    }
  }

  private async testCrossDomainPersistence(): Promise<IStorageTestResult> {
    const testName = 'Cross-Domain Persistence Simulation';
    const startTime = Date.now();

    try {
      // Simulate bookmarklet running on different domains
      const domains = ['example.com', 'github.com', 'stackoverflow.com'];
      const results = [];

      for (const domain of domains) {
        // Simulate loading bookmarklet on different domain
        const mockLocation = { hostname: domain, href: `https://${domain}/test-page` };

        // Test that extension storage works regardless of domain
        const testResult = await this.simulateDomainTest(domain, mockLocation);
        results.push(testResult);
      }

      const duration = Date.now() - startTime;
      const allDomainsWorked = results.every(result => result.success);

      if (allDomainsWorked) {
        return {
          testName,
          success: true,
          message: '‚úÖ Configuration persists across all simulated domains',
          details: {
            domains,
            results,
            allDomainsWorked,
          },
          duration,
        };
      } else {
        return {
          testName,
          success: false,
          message: '‚ùå Configuration persistence failed on some domains',
          details: {
            domains,
            results,
            allDomainsWorked,
          },
          duration,
        };
      }
    } catch (error) {
      return {
        testName,
        success: false,
        message: `‚ùå Error testing cross-domain persistence: ${error instanceof Error ? error.message : 'Unknown error'}`,
        duration: Date.now() - startTime,
      };
    }
  }

  private async simulateDomainTest(
    domain: string,
    mockLocation: any
  ): Promise<{ domain: string; success: boolean; message: string }> {
    try {
      // Test retrieval (should work on any domain with extension storage)
      const response = await new Promise<any>(resolve => {
        chrome.runtime.sendMessage(
          this.EXTENSION_ID,
          {
            type: 'GET_BOOKMARKLET_CONFIG',
          },
          resolve
        );
      });

      if (response?.success && response?.data?.config) {
        return {
          domain,
          success: true,
          message: `‚úÖ Config accessible from ${domain}`,
        };
      } else {
        return {
          domain,
          success: false,
          message: `‚ùå Config not accessible from ${domain}`,
        };
      }
    } catch (error) {
      return {
        domain,
        success: false,
        message: `‚ùå Error on ${domain}: ${error instanceof Error ? error.message : 'Unknown'}`,
      };
    }
  }

  private async testLocalStorageFallback(): Promise<IStorageTestResult> {
    const testName = 'localStorage Fallback when Extension Unavailable';
    const startTime = Date.now();

    try {
      // Test localStorage fallback
      const fallbackKey = 'prismweave_bookmarklet_config';
      const fallbackConfig = { ...this.TEST_CONFIG, storageMethod: 'localStorage' };

      // Store in localStorage
      localStorage.setItem(fallbackKey, JSON.stringify(fallbackConfig));

      // Retrieve from localStorage
      const storedValue = localStorage.getItem(fallbackKey);
      const retrievedConfig = storedValue ? JSON.parse(storedValue) : null;

      const duration = Date.now() - startTime;

      if (retrievedConfig && retrievedConfig.githubToken === fallbackConfig.githubToken) {
        // Clean up
        localStorage.removeItem(fallbackKey);

        return {
          testName,
          success: true,
          message: '‚úÖ localStorage fallback works correctly',
          details: {
            fallbackConfig,
            retrievedConfig,
            fallbackWorking: true,
          },
          duration,
        };
      } else {
        return {
          testName,
          success: false,
          message: '‚ùå localStorage fallback failed',
          details: {
            fallbackConfig,
            retrievedConfig,
            fallbackWorking: false,
          },
          duration,
        };
      }
    } catch (error) {
      return {
        testName,
        success: false,
        message: `‚ùå Error testing localStorage fallback: ${error instanceof Error ? error.message : 'Unknown error'}`,
        duration: Date.now() - startTime,
      };
    }
  }

  private async testClearConfigViaExtension(): Promise<IStorageTestResult> {
    const testName = 'Clear Configuration via Extension API';
    const startTime = Date.now();

    try {
      // Clear configuration
      const clearResponse = await new Promise<any>(resolve => {
        chrome.runtime.sendMessage(
          this.EXTENSION_ID,
          {
            type: 'CLEAR_BOOKMARKLET_CONFIG',
          },
          resolve
        );
      });

      if (!clearResponse?.success) {
        return {
          testName,
          success: false,
          message: '‚ùå Failed to clear configuration',
          details: { clearResponse },
          duration: Date.now() - startTime,
        };
      }

      // Verify configuration is cleared
      const retrieveResponse = await new Promise<any>(resolve => {
        chrome.runtime.sendMessage(
          this.EXTENSION_ID,
          {
            type: 'GET_BOOKMARKLET_CONFIG',
          },
          resolve
        );
      });

      const duration = Date.now() - startTime;

      if (retrieveResponse?.success && !retrieveResponse?.data?.config) {
        return {
          testName,
          success: true,
          message: '‚úÖ Configuration cleared successfully',
          details: {
            clearResponse,
            retrieveResponse,
            configCleared: true,
          },
          duration,
        };
      } else {
        return {
          testName,
          success: false,
          message: '‚ùå Configuration was not properly cleared',
          details: {
            clearResponse,
            retrieveResponse,
            configCleared: false,
          },
          duration,
        };
      }
    } catch (error) {
      return {
        testName,
        success: false,
        message: `‚ùå Error clearing configuration: ${error instanceof Error ? error.message : 'Unknown error'}`,
        duration: Date.now() - startTime,
      };
    }
  }

  private async testErrorHandling(): Promise<IStorageTestResult> {
    const testName = 'Error Handling for Invalid Data';
    const startTime = Date.now();

    try {
      // Test storing invalid data
      const invalidResponse = await new Promise<any>(resolve => {
        chrome.runtime.sendMessage(
          this.EXTENSION_ID,
          {
            type: 'STORE_BOOKMARKLET_CONFIG',
            data: { config: null }, // Invalid config
          },
          resolve
        );
      });

      const duration = Date.now() - startTime;

      // Should fail gracefully
      if (!invalidResponse?.success) {
        return {
          testName,
          success: true,
          message: '‚úÖ Error handling works correctly for invalid data',
          details: {
            invalidResponse,
            errorHandledCorrectly: true,
          },
          duration,
        };
      } else {
        return {
          testName,
          success: false,
          message: '‚ùå Invalid data was accepted (should have been rejected)',
          details: {
            invalidResponse,
            errorHandledCorrectly: false,
          },
          duration,
        };
      }
    } catch (error) {
      return {
        testName,
        success: false,
        message: `‚ùå Error testing error handling: ${error instanceof Error ? error.message : 'Unknown error'}`,
        duration: Date.now() - startTime,
      };
    }
  }

  private generateSummary(
    tests: IStorageTestResult[],
    overallSuccess: boolean,
    totalDuration: number
  ): string {
    const passedTests = tests.filter(test => test.success).length;
    const failedTests = tests.length - passedTests;

    let summary = `\nüß™ Cross-Domain Storage Test Results:\n`;
    summary += `üìä ${passedTests}/${tests.length} tests passed\n`;
    summary += `‚è±Ô∏è Total duration: ${totalDuration}ms\n`;
    summary += `${overallSuccess ? '‚úÖ' : '‚ùå'} Overall result: ${overallSuccess ? 'PASSED' : 'FAILED'}\n\n`;

    if (failedTests > 0) {
      summary += `‚ùå Failed tests:\n`;
      tests
        .filter(test => !test.success)
        .forEach(test => {
          summary += `   - ${test.testName}: ${test.message}\n`;
        });
      summary += '\n';
    }

    summary += `üìã Test Details:\n`;
    tests.forEach(test => {
      const status = test.success ? '‚úÖ' : '‚ùå';
      const duration = test.duration ? `(${test.duration}ms)` : '';
      summary += `   ${status} ${test.testName} ${duration}\n`;
    });

    return summary;
  }
}

// Usage example and export
export { CrossDomainStorageTest, IStorageTestResult, IStorageTestSuite };

// Auto-run test when included in bookmarklet (for development)
if (typeof window !== 'undefined' && window.location?.hostname) {
  console.log('üîß Cross-domain storage test module loaded');

  // Expose test runner to global scope for manual testing
  (window as any).runCrossDomainStorageTest = async () => {
    const tester = new CrossDomainStorageTest();
    const results = await tester.runFullTestSuite();
    console.log(results.summary);
    return results;
  };
}
