// Generated by Copilot
// Document Processor - Handles document processing workflows
// Extracted from service worker for better testability and reusability

import { IDocumentMetadata, ISettings } from '../types/index.js';
import { createLogger } from './logger.js';
import SharedUtils from './shared-utils.js';

const logger = createLogger('DocumentProcessor');

export interface IProcessedDocument {
  filename: string;
  filePath: string;
  folder: string;
  content: string;
  metadata: IDocumentMetadata;
}

export interface IDocumentProcessingOptions {
  includeTimestamp?: boolean;
  maxFilenameLength?: number;
  filenamePattern?: string;
}

export class DocumentProcessor {
  private static readonly DEFAULT_FOLDER = 'unsorted';
  private static readonly DEFAULT_FILENAME_PATTERN = 'YYYY-MM-DD-domain-title';

  // Folder classification mapping
  private static readonly FOLDER_MAPPING: Record<string, string[]> = {
    tech: [
      'programming',
      'software',
      'coding',
      'development',
      'technology',
      'tech',
      'javascript',
      'python',
      'react',
      'node',
      'github',
      'stackoverflow',
      'dev.to',
      'css',
      'html',
      'typescript',
      'api',
      'framework',
      'library',
    ],
    business: [
      'business',
      'marketing',
      'finance',
      'startup',
      'entrepreneur',
      'sales',
      'management',
      'strategy',
      'linkedin',
      'enterprise',
      'corporate',
      'economics',
      'market',
      'revenue',
      'profit',
    ],
    tutorial: [
      'tutorial',
      'guide',
      'how-to',
      'learn',
      'course',
      'lesson',
      'walkthrough',
      'step-by-step',
      'instructions',
      'tips',
      'howto',
      'example',
    ],
    news: [
      'news',
      'article',
      'blog',
      'opinion',
      'analysis',
      'update',
      'announcement',
      'breaking',
      'report',
      'current',
      'events',
    ],
    research: [
      'research',
      'study',
      'paper',
      'academic',
      'journal',
      'thesis',
      'analysis',
      'data',
      'science',
      'experiment',
      'findings',
      'methodology',
    ],
    design: [
      'design',
      'ui',
      'ux',
      'css',
      'figma',
      'adobe',
      'creative',
      'visual',
      'art',
      'layout',
      'typography',
      'color',
      'interface',
    ],
    tools: [
      'tool',
      'utility',
      'software',
      'app',
      'service',
      'platform',
      'extension',
      'plugin',
      'resource',
      'toolkit',
    ],
    personal: [
      'personal',
      'diary',
      'journal',
      'thoughts',
      'reflection',
      'life',
      'experience',
      'blog',
      'opinion',
    ],
    reference: [
      'reference',
      'documentation',
      'manual',
      'spec',
      'api',
      'docs',
      'wiki',
      'handbook',
      'guide',
    ],
  };

  /**
   * Process a document with content, metadata, and settings
   */
  processDocument(
    content: string,
    title: string,
    url: string,
    metadata: Record<string, unknown>,
    settings: Partial<ISettings>,
    options: IDocumentProcessingOptions = {}
  ): IProcessedDocument {
    logger.debug('Processing document:', {
      title,
      url,
      contentLength: content.length,
      hasSettings: !!settings,
    });

    // Create document metadata
    const docMetadata: IDocumentMetadata = {
      title,
      url,
      captureDate: new Date().toISOString(),
      tags: this.extractTagsFromMetadata(metadata),
      ...metadata,
    };

    // Generate filename
    const filename = this.generateFileName(
      title,
      url,
      options.filenamePattern || DocumentProcessor.DEFAULT_FILENAME_PATTERN,
      options
    );

    // Determine folder
    const folder = this.determineFolder(docMetadata, settings);

    // Build full file path
    const filePath = this.buildFilePath(filename, folder);

    // Prepare final content with frontmatter
    const finalContent = this.prepareContent(content, docMetadata);

    logger.debug('Document processed:', {
      filename,
      folder,
      filePath,
      finalContentLength: finalContent.length,
    });

    return {
      filename,
      filePath,
      folder,
      content: finalContent,
      metadata: docMetadata,
    };
  }

  /**
   * Generate a safe filename from title and URL
   */
  generateFileName(
    title: string,
    url: string,
    pattern: string = DocumentProcessor.DEFAULT_FILENAME_PATTERN,
    options: IDocumentProcessingOptions = {}
  ): string {
    try {
      logger.debug('Generating filename:', { title, url, pattern });

      // Extract components
      const date = SharedUtils.formatDateForFilename();
      const domain = SharedUtils.sanitizeDomain(this.extractDomain(url));
      const sanitizedTitle = SharedUtils.sanitizeForFilename(
        title,
        options.maxFilenameLength || 50
      );

      // Build filename using pattern
      let filename = pattern
        .replace(/YYYY-MM-DD/g, date)
        .replace(/domain/g, domain)
        .replace(/title/g, sanitizedTitle);

      // Sanitize the complete filename
      filename = SharedUtils.sanitizeForFilename(filename, 100);

      // Ensure .md extension
      if (!filename.endsWith('.md')) {
        filename += '.md';
      }

      logger.debug('Generated filename:', filename);
      return filename;
    } catch (error) {
      logger.error('Error generating filename:', error);
      // Fallback to timestamp-based filename
      const fallback = `capture-${Date.now()}.md`;
      logger.debug('Using fallback filename:', fallback);
      return fallback;
    }
  }

  /**
   * Determine the appropriate folder for a document
   */
  determineFolder(metadata: IDocumentMetadata, settings: Partial<ISettings>): string {
    logger.debug('Determining folder for document:', {
      title: metadata.title,
      url: metadata.url,
      tags: metadata.tags,
      defaultFolder: settings.defaultFolder,
    });

    // Use explicit folder setting if provided
    if (
      settings.defaultFolder &&
      settings.defaultFolder !== 'auto' &&
      settings.defaultFolder !== 'custom'
    ) {
      logger.debug('Using explicit folder setting:', settings.defaultFolder);
      return settings.defaultFolder;
    }

    // Use custom folder if specified
    if (settings.defaultFolder === 'custom' && settings.customFolder) {
      const sanitized = SharedUtils.sanitizeForFilename(settings.customFolder);
      logger.debug('Using custom folder:', sanitized);
      return sanitized;
    }

    // Auto-detect folder based on content
    const detected = this.autoDetectFolder(metadata);
    const final = detected || DocumentProcessor.DEFAULT_FOLDER;

    logger.debug('Auto-detected folder:', { detected, final });
    return final;
  }

  /**
   * Auto-detect folder based on document metadata
   */
  private autoDetectFolder(metadata: IDocumentMetadata): string | null {
    const searchText = [
      metadata.title.toLowerCase(),
      metadata.url.toLowerCase(),
      ...metadata.tags.map(tag => tag.toLowerCase()),
    ].join(' ');

    // Score each folder based on keyword matches
    const folderScores: Record<string, number> = {};

    Object.entries(DocumentProcessor.FOLDER_MAPPING).forEach(([folder, keywords]) => {
      let score = 0;
      keywords.forEach(keyword => {
        const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
        const matches = searchText.match(regex);
        if (matches) {
          score += matches.length;
        }
      });

      if (score > 0) {
        folderScores[folder] = score;
      }
    });

    // Return folder with highest score
    const bestFolder = Object.entries(folderScores).sort(([, a], [, b]) => b - a)[0];

    return bestFolder ? bestFolder[0] : null;
  }

  /**
   * Build the complete file path with folder structure
   */
  private buildFilePath(filename: string, folder: string): string {
    const documentPath = 'documents';
    const cleanFolder = folder.replace(/^\/+|\/+$/g, '');
    const cleanFilename = filename.replace(/^\/+/, '');

    return `${documentPath}/${cleanFolder}/${cleanFilename}`;
  }

  /**
   * Prepare the final content with frontmatter
   */
  private prepareContent(content: string, metadata: IDocumentMetadata): string {
    const frontmatter = this.generateFrontmatter(metadata);
    return `${frontmatter}\n${content}`;
  }

  /**
   * Generate YAML frontmatter for the document
   */
  private generateFrontmatter(metadata: IDocumentMetadata): string {
    const frontmatterData: Record<string, unknown> = {
      title: metadata.title,
      url: metadata.url,
      captured: metadata.captureDate,
      tags: metadata.tags,
    };

    // Add optional metadata fields
    if (metadata.author) {
      frontmatterData.author = metadata.author;
    }

    if (metadata.wordCount) {
      frontmatterData.wordCount = metadata.wordCount;
    }

    if (metadata.estimatedReadingTime) {
      frontmatterData.readingTime = `${metadata.estimatedReadingTime} min`;
    }

    let frontmatter = '---\n';

    Object.entries(frontmatterData).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        frontmatter += `${key}:\n`;
        value.forEach(item => {
          frontmatter += `  - ${item}\n`;
        });
      } else {
        frontmatter += `${key}: ${SharedUtils.formatYamlValue(value)}\n`;
      }
    });

    frontmatter += '---';
    return frontmatter;
  }

  /**
   * Extract tags from metadata
   */
  private extractTagsFromMetadata(metadata: Record<string, unknown>): string[] {
    const tags: string[] = [];

    // Extract keywords from common metadata fields
    const keywordFields = ['keywords', 'description', 'author', 'category', 'tags'];

    keywordFields.forEach(field => {
      const value = metadata[field];
      if (typeof value === 'string') {
        // Split by common delimiters and clean up
        const extractedTags = value
          .split(/[,;|]/)
          .map(tag => tag.trim().toLowerCase())
          .filter(tag => tag.length > 2 && tag.length < 30);
        tags.push(...extractedTags);
      }
    });

    return [...new Set(tags)]; // Remove duplicates
  }

  /**
   * Extract domain from URL
   */
  private extractDomain(url: string): string {
    try {
      const urlObj = new URL(url);
      return urlObj.hostname.replace(/^www\./, '');
    } catch {
      return 'unknown';
    }
  }

  /**
   * Generate commit message for the document
   */
  generateCommitMessage(metadata: IDocumentMetadata, isUpdate: boolean = false): string {
    const action = isUpdate ? 'Update' : 'Add';
    const domain = this.extractDomain(metadata.url);
    return `${action} captured content: ${metadata.title} (${domain})`;
  }
}
