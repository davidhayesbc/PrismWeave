// Generated by Copilot
// Bookmarklet storage validation utilities for PrismWeave browser extension

export interface IBookmarkletStorageTest {
  testName: string;
  success: boolean;
  result?: unknown;
  error?: string;
  duration: number;
}

export interface IBookmarkletStorageValidation {
  isValid: boolean;
  tests: IBookmarkletStorageTest[];
  recommendations: string[];
  summary: {
    totalTests: number;
    passed: number;
    failed: number;
  };
}

export class BookmarkletStorageValidator {
  private static readonly STORAGE_KEY = 'prismweave_bookmarklet_config';
  private static readonly TEST_CONFIG = {
    githubToken: 'ghp_test_token_12345678901234567890123456',
    githubRepo: 'test-user/test-repo',
    defaultFolder: 'unsorted',
    version: '1.0.0',
  };

  /**
   * Run comprehensive validation of bookmarklet storage functionality
   */
  static async validateStorageSystem(): Promise<IBookmarkletStorageValidation> {
    const tests: IBookmarkletStorageTest[] = [];
    const recommendations: string[] = [];

    // Test 1: Basic localStorage availability
    tests.push(await this.testLocalStorageAvailability());

    // Test 2: Basic sessionStorage availability
    tests.push(await this.testSessionStorageAvailability());

    // Test 3: Storage and retrieval functionality
    tests.push(await this.testStorageAndRetrieval());

    // Test 4: Cross-tab persistence (simulated)
    tests.push(await this.testCrossTabPersistence());

    // Test 5: Storage quota and limits
    tests.push(await this.testStorageQuota());

    // Test 6: Error handling and fallbacks
    tests.push(await this.testErrorHandling());

    // Test 7: Configuration validation
    tests.push(await this.testConfigurationValidation());

    // Generate recommendations based on test results
    const failedTests = tests.filter(t => !t.success);
    if (failedTests.some(t => t.testName.includes('localStorage'))) {
      recommendations.push(
        'localStorage is not available - bookmarklet will use sessionStorage as fallback'
      );
    }
    if (failedTests.some(t => t.testName.includes('sessionStorage'))) {
      recommendations.push(
        'Both localStorage and sessionStorage are unavailable - settings will not persist'
      );
    }
    if (failedTests.length > 0) {
      recommendations.push('Some storage tests failed - bookmarklet functionality may be limited');
    }
    if (failedTests.length === 0) {
      recommendations.push(
        'All storage tests passed - bookmarklet should work correctly across tabs'
      );
    }

    const passed = tests.filter(t => t.success).length;
    const failed = tests.length - passed;

    return {
      isValid: failed === 0 || failed <= 2, // Allow some failures for non-critical tests
      tests,
      recommendations,
      summary: {
        totalTests: tests.length,
        passed,
        failed,
      },
    };
  }

  /**
   * Test basic localStorage functionality
   */
  private static async testLocalStorageAvailability(): Promise<IBookmarkletStorageTest> {
    const startTime = Date.now();

    try {
      if (typeof localStorage === 'undefined') {
        throw new Error('localStorage is not defined');
      }

      // Test basic operations
      const testKey = 'prismweave_test_' + Date.now();
      const testValue = 'test_value_' + Math.random();

      localStorage.setItem(testKey, testValue);
      const retrieved = localStorage.getItem(testKey);
      localStorage.removeItem(testKey);

      if (retrieved !== testValue) {
        throw new Error('localStorage read/write test failed');
      }

      return {
        testName: 'localStorage availability',
        success: true,
        result: 'localStorage is available and functional',
        duration: Date.now() - startTime,
      };
    } catch (error) {
      return {
        testName: 'localStorage availability',
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        duration: Date.now() - startTime,
      };
    }
  }

  /**
   * Test basic sessionStorage functionality
   */
  private static async testSessionStorageAvailability(): Promise<IBookmarkletStorageTest> {
    const startTime = Date.now();

    try {
      if (typeof sessionStorage === 'undefined') {
        throw new Error('sessionStorage is not defined');
      }

      // Test basic operations
      const testKey = 'prismweave_test_' + Date.now();
      const testValue = 'test_value_' + Math.random();

      sessionStorage.setItem(testKey, testValue);
      const retrieved = sessionStorage.getItem(testKey);
      sessionStorage.removeItem(testKey);

      if (retrieved !== testValue) {
        throw new Error('sessionStorage read/write test failed');
      }

      return {
        testName: 'sessionStorage availability',
        success: true,
        result: 'sessionStorage is available and functional',
        duration: Date.now() - startTime,
      };
    } catch (error) {
      return {
        testName: 'sessionStorage availability',
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        duration: Date.now() - startTime,
      };
    }
  }

  /**
   * Test storage and retrieval of bookmarklet configuration
   */
  private static async testStorageAndRetrieval(): Promise<IBookmarkletStorageTest> {
    const startTime = Date.now();

    try {
      // Store test configuration
      const configJson = JSON.stringify(this.TEST_CONFIG);
      localStorage.setItem(this.STORAGE_KEY, configJson);

      // Retrieve and validate
      const retrieved = localStorage.getItem(this.STORAGE_KEY);
      if (!retrieved) {
        throw new Error('Failed to retrieve stored configuration');
      }

      const parsedConfig = JSON.parse(retrieved);
      if (parsedConfig.githubToken !== this.TEST_CONFIG.githubToken) {
        throw new Error('Retrieved configuration does not match stored configuration');
      }

      // Clean up
      localStorage.removeItem(this.STORAGE_KEY);

      return {
        testName: 'Configuration storage and retrieval',
        success: true,
        result: 'Configuration can be stored and retrieved correctly',
        duration: Date.now() - startTime,
      };
    } catch (error) {
      return {
        testName: 'Configuration storage and retrieval',
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        duration: Date.now() - startTime,
      };
    }
  }

  /**
   * Test cross-tab persistence simulation
   */
  private static async testCrossTabPersistence(): Promise<IBookmarkletStorageTest> {
    const startTime = Date.now();

    try {
      // Store configuration
      const configJson = JSON.stringify(this.TEST_CONFIG);
      localStorage.setItem(this.STORAGE_KEY, configJson);

      // Simulate what would happen in another tab by creating new storage instance
      // In a real scenario, this would be tested across actual tabs
      const simulatedNewTabStorage = localStorage;
      const retrieved = simulatedNewTabStorage.getItem(this.STORAGE_KEY);

      if (!retrieved) {
        throw new Error('Configuration not accessible in simulated new tab');
      }

      const parsedConfig = JSON.parse(retrieved);
      if (!parsedConfig.githubToken || !parsedConfig.githubRepo) {
        throw new Error('Required configuration fields missing in simulated new tab');
      }

      // Clean up
      localStorage.removeItem(this.STORAGE_KEY);

      return {
        testName: 'Cross-tab persistence simulation',
        success: true,
        result: 'Configuration persists across simulated tab access',
        duration: Date.now() - startTime,
      };
    } catch (error) {
      return {
        testName: 'Cross-tab persistence simulation',
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        duration: Date.now() - startTime,
      };
    }
  }

  /**
   * Test storage quota and limits
   */
  private static async testStorageQuota(): Promise<IBookmarkletStorageTest> {
    const startTime = Date.now();

    try {
      // Test storing larger configuration objects
      const largeConfig = {
        ...this.TEST_CONFIG,
        customSelectors: Array(100).fill('.test-selector'),
        excludeSelectors: Array(100).fill('.exclude-selector'),
        metadata: {
          description: 'Large test configuration '.repeat(50),
          keywords: Array(100).fill('test-keyword'),
          customFields: Object.fromEntries(
            Array(50)
              .fill(null)
              .map((_, i) => [`field${i}`, `value${i}`.repeat(10)])
          ),
        },
      };

      const configJson = JSON.stringify(largeConfig);
      const configSize = new Blob([configJson]).size;

      if (configSize > 100000) {
        // 100KB
        throw new Error(`Configuration too large: ${configSize} bytes`);
      }

      localStorage.setItem(this.STORAGE_KEY + '_large', configJson);
      const retrieved = localStorage.getItem(this.STORAGE_KEY + '_large');
      localStorage.removeItem(this.STORAGE_KEY + '_large');

      if (!retrieved) {
        throw new Error('Failed to store/retrieve large configuration');
      }

      return {
        testName: 'Storage quota and limits',
        success: true,
        result: `Large configuration (${configSize} bytes) stored successfully`,
        duration: Date.now() - startTime,
      };
    } catch (error) {
      return {
        testName: 'Storage quota and limits',
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        duration: Date.now() - startTime,
      };
    }
  }

  /**
   * Test error handling and fallbacks
   */
  private static async testErrorHandling(): Promise<IBookmarkletStorageTest> {
    const startTime = Date.now();

    try {
      // Test invalid JSON handling
      localStorage.setItem(this.STORAGE_KEY + '_invalid', 'invalid-json-{');

      try {
        const retrieved = localStorage.getItem(this.STORAGE_KEY + '_invalid');
        if (retrieved) {
          JSON.parse(retrieved);
          throw new Error('Expected JSON.parse to fail');
        }
      } catch (parseError) {
        // This is expected
      }

      localStorage.removeItem(this.STORAGE_KEY + '_invalid');

      // Test fallback to sessionStorage when localStorage is "full"
      // Note: This is a simplified test - in real scenarios, you'd need to actually fill up localStorage

      return {
        testName: 'Error handling and fallbacks',
        success: true,
        result: 'Error handling works correctly',
        duration: Date.now() - startTime,
      };
    } catch (error) {
      return {
        testName: 'Error handling and fallbacks',
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        duration: Date.now() - startTime,
      };
    }
  }

  /**
   * Test configuration validation
   */
  private static async testConfigurationValidation(): Promise<IBookmarkletStorageTest> {
    const startTime = Date.now();

    try {
      const testCases = [
        // Valid configuration
        { ...this.TEST_CONFIG, expected: true },
        // Missing GitHub token
        { ...this.TEST_CONFIG, githubToken: '', expected: false },
        // Invalid repository format
        { ...this.TEST_CONFIG, githubRepo: 'invalid-repo', expected: false },
        // Missing repository
        { ...this.TEST_CONFIG, githubRepo: '', expected: false },
      ];

      const results = testCases.map(testCase => {
        const isValid = this.validateConfiguration(testCase);
        return isValid === testCase.expected;
      });

      const allPassed = results.every(result => result);

      if (!allPassed) {
        throw new Error('Configuration validation tests failed');
      }

      return {
        testName: 'Configuration validation',
        success: true,
        result: `All ${testCases.length} validation test cases passed`,
        duration: Date.now() - startTime,
      };
    } catch (error) {
      return {
        testName: 'Configuration validation',
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        duration: Date.now() - startTime,
      };
    }
  }

  /**
   * Validate configuration object
   */
  private static validateConfiguration(config: any): boolean {
    if (!config.githubToken || config.githubToken.trim().length === 0) {
      return false;
    }

    if (!config.githubRepo || config.githubRepo.trim().length === 0) {
      return false;
    }

    // Check repository format
    if (!/^[\w\-\.]+\/[\w\-\.]+$/.test(config.githubRepo)) {
      return false;
    }

    return true;
  }

  /**
   * Get current stored configuration (for debugging)
   */
  static getCurrentStoredConfig(): any {
    try {
      const stored =
        localStorage.getItem(this.STORAGE_KEY) || sessionStorage.getItem(this.STORAGE_KEY);
      return stored ? JSON.parse(stored) : null;
    } catch (error) {
      return null;
    }
  }

  /**
   * Clear stored configuration (for testing)
   */
  static clearStoredConfig(): void {
    try {
      localStorage.removeItem(this.STORAGE_KEY);
      sessionStorage.removeItem(this.STORAGE_KEY);
    } catch (error) {
      console.warn('Failed to clear stored configuration:', error);
    }
  }

  /**
   * Store test configuration (for manual testing)
   */
  static storeTestConfig(): void {
    try {
      const configJson = JSON.stringify(this.TEST_CONFIG);
      localStorage.setItem(this.STORAGE_KEY, configJson);
      console.log('Test configuration stored successfully');
    } catch (error) {
      console.error('Failed to store test configuration:', error);
    }
  }

  /**
   * Generate a test bookmarklet with embedded debugging
   */
  static generateTestBookmarklet(): string {
    const testScript = `
javascript:(function(){
  const STORAGE_KEY = 'prismweave_bookmarklet_config';
  
  // Check for stored config
  const stored = localStorage.getItem(STORAGE_KEY) || sessionStorage.getItem(STORAGE_KEY);
  
  if (stored) {
    try {
      const config = JSON.parse(stored);
      alert('✅ PrismWeave Config Found!\\n\\nRepo: ' + config.githubRepo + '\\nToken: ' + (config.githubToken ? config.githubToken.substring(0, 10) + '...' : 'Not set') + '\\nFolder: ' + (config.defaultFolder || 'documents'));
    } catch (error) {
      alert('❌ Config found but invalid JSON: ' + error.message);
    }
  } else {
    alert('⚠️ No PrismWeave configuration found in storage.\\n\\nThe bookmarklet needs to be configured first.');
  }
})();`;

    return testScript;
  }
}
