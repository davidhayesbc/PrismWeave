// Generated by Copilot
// Dedicated Stack Overflow Blog Content Extractor
// This targets the specific DOM structure of stackoverflow.blog

import { createLogger } from './logger.js';

export interface IStackOverflowBlogResult {
  title: string;
  content: string;
  publishDate?: string | undefined;
  author?: string | undefined;
  tags: string[];
  readingTime?: number | undefined;
}

/**
 * Specialized extractor for stackoverflow.blog pages
 * Uses knowledge of SO's specific blog structure
 */
export class StackOverflowBlogExtractor {
  private readonly logger = createLogger('StackOverflowBlogExtractor');

  /**
   * Check if current page is a Stack Overflow blog post
   */
  isStackOverflowBlog(): boolean {
    return (
      window.location.hostname.includes('stackoverflow.blog') ||
      window.location.href.includes('stackoverflow.blog')
    );
  }

  /**
   * Extract content specifically from Stack Overflow blog
   */
  extractBlogContent(): IStackOverflowBlogResult | null {
    if (!this.isStackOverflowBlog()) {
      this.logger.warn('Not a Stack Overflow blog page');
      return null;
    }

    try {
      this.logger.debug('Extracting Stack Overflow blog content');

      // Extract title - try multiple approaches
      const title = this.extractTitle();
      if (!title) {
        this.logger.warn('Could not find blog title');
        return null;
      }

      // Extract main content using aggressive approach
      const content = this.extractMainContent();
      if (!content) {
        this.logger.warn('Could not find main blog content');
        return null;
      }

      // Extract metadata
      const publishDate = this.extractPublishDate();
      const author = this.extractAuthor();
      const tags = this.extractTags();
      const readingTime = this.estimateReadingTime(content);

      this.logger.info('Successfully extracted SO blog content', {
        titleLength: title.length,
        contentLength: content.length,
        author,
        tags: tags.length,
      });

      return {
        title,
        content,
        publishDate,
        author,
        tags,
        readingTime,
      };
    } catch (error) {
      this.logger.error('Error extracting SO blog content:', error);
      return null;
    }
  }

  /**
   * Extract blog title using multiple strategies
   */
  private extractTitle(): string {
    // Try different title sources in order of preference
    const titleSelectors = [
      'h1',
      '.entry-title',
      '.post-title',
      '.article-title',
      '[class*="title"] h1',
      '[class*="title"] h2',
      'article h1',
      'main h1',
    ];

    for (const selector of titleSelectors) {
      const element = document.querySelector(selector);
      if (element && element.textContent) {
        const title = element.textContent.trim();
        if (title.length > 10 && title.length < 200) {
          return title;
        }
      }
    }

    // Fallback to page title, but clean it up
    const pageTitle = document.title;
    if (pageTitle) {
      // Remove common suffixes
      return pageTitle
        .replace(/\s*[-–—]\s*Stack Overflow Blog\s*$/i, '')
        .replace(/\s*\|\s*Stack Overflow\s*$/i, '')
        .trim();
    }

    return 'Untitled Post';
  }

  /**
   * Extract main content using aggressive DOM analysis
   */
  private extractMainContent(): string {
    // NEW: First try HTML-preserving extraction for better paragraph handling
    let content = this.tryArticleContentHTML();
    if (content && content.length > 500) {
      this.logger.debug('Using article HTML content');
      return content;
    }

    content = this.tryContentNearTitleHTML();
    if (content && content.length > 500) {
      this.logger.debug('Using content near title HTML');
      return content;
    }

    content = this.tryLargestValidTextBlockHTML();
    if (content && content.length > 500) {
      this.logger.debug('Using largest valid text block HTML');
      return content;
    }

    // Last resort: aggressive extraction with HTML paragraphs
    this.logger.debug('Falling back to aggressive HTML extraction');
    return this.tryAggressiveExtractionHTML();
  }

  /**
   * Try to find content within article tags
   */
  private tryArticleContent(): string {
    const articles = document.querySelectorAll('article');

    for (const article of Array.from(articles)) {
      // Skip if it's clearly navigation or sidebar
      const classList = article.className.toLowerCase();
      if (
        classList.includes('nav') ||
        classList.includes('sidebar') ||
        classList.includes('promo') ||
        classList.includes('ad')
      ) {
        continue;
      }

      const content = this.extractTextFromElement(article);
      if (this.isValidBlogContent(content)) {
        return content;
      }
    }

    return '';
  }

  /**
   * Try to find content near the main title
   */
  private tryContentNearTitle(): string {
    const h1 = document.querySelector('h1');
    if (!h1) return '';

    // Look for content containers near the title
    let parent = h1.parentElement;
    let attempts = 0;

    while (parent && attempts < 5) {
      const content = this.extractTextFromElement(parent);
      if (this.isValidBlogContent(content)) {
        return content;
      }
      parent = parent.parentElement;
      attempts++;
    }

    // Try siblings of the title
    const nextElements = this.getNextSiblings(h1, 10);
    for (const element of nextElements) {
      const content = this.extractTextFromElement(element);
      if (this.isValidBlogContent(content)) {
        return content;
      }
    }

    return '';
  }

  /**
   * Analyze all substantial text blocks and pick the best one
   */
  private tryLargestValidTextBlock(): string {
    const candidates: Array<{ element: Element; content: string; score: number }> = [];

    // Get all potential content containers
    const selectors = ['div', 'section', 'main', 'article'];

    for (const selector of selectors) {
      const elements = document.querySelectorAll(selector);

      for (const element of Array.from(elements)) {
        const content = this.extractTextFromElement(element);

        if (content.length > 200) {
          const score = this.scoreContentBlock(element, content);
          candidates.push({ element, content, score });
        }
      }
    }

    // Sort by score and return the best
    candidates.sort((a, b) => b.score - a.score);

    if (candidates.length > 0 && candidates[0].score > 50) {
      return candidates[0].content;
    }

    return '';
  }

  /**
   * Last resort: extract everything and clean very aggressively - HTML version
   */
  private tryAggressiveExtractionHTML(): string {
    this.logger.debug('Trying aggressive HTML extraction...');

    // NEW: First try to find the main content area more intelligently
    const contentSelectors = [
      'main',
      '[role="main"]',
      '.main-content',
      '.content',
      '.post-content',
      '.entry-content',
      '.article-body',
    ];

    for (const selector of contentSelectors) {
      const element = document.querySelector(selector);
      if (element) {
        const htmlContent = this.extractHTMLFromElement(element);
        const textLength = this.extractTextFromElement(element).length;
        if (textLength > 500) {
          this.logger.debug(`Found content using selector: ${selector}, length: ${textLength}`);
          return htmlContent;
        }
      }
    }

    // NEW: Try to extract all content sections (like SO blog's multiple ##sections)
    const allSections = document.querySelectorAll('h2, h3, p, div[class*="content"]');
    const contentBlocks: string[] = [];
    let currentSection = '';

    for (const element of Array.from(allSections)) {
      const tagName = element.tagName.toLowerCase();

      if (tagName === 'h2' || tagName === 'h3') {
        // Save previous section if it has content
        if (currentSection.trim().length > 50) {
          contentBlocks.push(currentSection.trim());
        }
        // Start new section with header
        const headerText = element.textContent?.trim() || '';
        if (headerText.length > 0 && !this.isPromotionalLine(headerText)) {
          currentSection = `<h${tagName.charAt(1)}>${this.escapeHtml(headerText)}</h${tagName.charAt(1)}>\n\n`;
        }
      } else if (tagName === 'p') {
        // Add paragraph to current section
        const pText = element.textContent?.trim() || '';
        if (pText.length > 20 && !this.isPromotionalLine(pText) && !this.isNavigationLine(pText)) {
          currentSection += `<p>${this.escapeHtml(pText)}</p>\n\n`;
        }
      }
    }

    // Add final section
    if (currentSection.trim().length > 50) {
      contentBlocks.push(currentSection.trim());
    }

    if (contentBlocks.length > 0) {
      const combinedContent = contentBlocks.join('\n\n');
      if (combinedContent.length > 500) {
        this.logger.debug(
          `Assembled content from ${contentBlocks.length} sections, total length: ${combinedContent.length}`
        );
        return combinedContent;
      }
    }

    // Fallback to the original aggressive extraction
    return this.tryAggressiveExtraction();
  }

  /**
   * Last resort: extract everything and clean very aggressively
   */
  private tryAggressiveExtraction(): string {
    // Get the main body content
    const body = document.body;
    const fullText = body.textContent || '';

    // Split into lines and filter aggressively
    const lines = fullText
      .split('\n')
      .map(line => line.trim())
      .filter(line => {
        // Skip empty lines
        if (line.length < 10) return false;

        // Skip navigation patterns
        if (this.isNavigationLine(line)) return false;

        // Skip promotional patterns
        if (this.isPromotionalLine(line)) return false;

        return true;
      });

    // Find the main content section by looking for paragraphs
    const paragraphs: string[] = [];
    let inMainContent = false;

    for (const line of lines) {
      // Start capturing after we find what looks like a title
      if (!inMainContent && this.looksLikeTitle(line)) {
        inMainContent = true;
        continue;
      }

      if (inMainContent) {
        // Stop if we hit footer/navigation
        if (this.looksLikeFooter(line)) {
          break;
        }

        paragraphs.push(line);
      }
    }

    // Convert paragraphs to HTML format
    const htmlParagraphs = paragraphs
      .filter(p => p.length > 20) // Only keep substantial paragraphs
      .map(p => `<p>${this.escapeHtml(p)}</p>`)
      .join('\n');

    return htmlParagraphs;
  }

  /**
   * Extract clean text from an element, removing unwanted parts
   */
  private extractTextFromElement(element: Element): string {
    // Clone the element to avoid modifying the original
    const clone = element.cloneNode(true) as Element;

    // Remove unwanted elements
    const unwantedSelectors = [
      'nav',
      'header',
      'footer',
      'aside',
      '.nav',
      '.navigation',
      '.menu',
      '.sidebar',
      '.promo',
      '.promotion',
      '.advertisement',
      '.ad',
      '.social',
      '.share',
      '.sharing',
      '.comments',
      '.comment-form',
      '.related',
      '.related-posts',
      'script',
      'style',
      'noscript',
    ];

    for (const selector of unwantedSelectors) {
      const elements = clone.querySelectorAll(selector);
      elements.forEach(el => el.remove());
    }

    // Get text and clean it up
    let text = clone.textContent || '';

    // Remove extra whitespace
    text = text.replace(/\s+/g, ' ').trim();

    return text;
  }

  /**
   * Try to find content within article tags - HTML version
   */
  private tryArticleContentHTML(): string {
    const articles = document.querySelectorAll('article');

    for (const article of Array.from(articles)) {
      // Skip if it's clearly navigation or sidebar
      const classList = article.className.toLowerCase();
      if (
        classList.includes('nav') ||
        classList.includes('sidebar') ||
        classList.includes('promo') ||
        classList.includes('ad')
      ) {
        continue;
      }

      // NEW: For Stack Overflow blog, look for the main content structure
      const htmlContent = this.extractHTMLFromElement(article);
      const textContent = this.extractTextFromElement(article);

      this.logger.debug(`Article candidate: ${textContent.length} chars, classes: ${classList}`);

      // NEW: More lenient content validation for SO blog structure
      if (textContent.length > 200 && this.isValidBlogContent(textContent)) {
        this.logger.debug('Found valid article content');
        return htmlContent;
      }
    }

    // NEW: If no article tags work, try looking for content sections directly
    const contentAreas = document.querySelectorAll(
      '[class*="content"], [class*="post"], [class*="entry"]'
    );
    for (const area of Array.from(contentAreas)) {
      const htmlContent = this.extractHTMLFromElement(area);
      const textContent = this.extractTextFromElement(area);

      if (textContent.length > 200 && this.isValidBlogContent(textContent)) {
        this.logger.debug('Found valid content area');
        return htmlContent;
      }
    }

    return '';
  }

  /**
   * Try to find content near the main title - HTML version
   */
  private tryContentNearTitleHTML(): string {
    const h1 = document.querySelector('h1');
    if (!h1) return '';

    // Look for content containers near the title
    let parent = h1.parentElement;
    let attempts = 0;

    while (parent && attempts < 5) {
      const htmlContent = this.extractHTMLFromElement(parent);
      const textContent = this.extractTextFromElement(parent);
      if (this.isValidBlogContent(textContent)) {
        return htmlContent;
      }
      parent = parent.parentElement;
      attempts++;
    }

    // Try siblings of the title
    const nextElements = this.getNextSiblings(h1, 10);
    for (const element of nextElements) {
      const htmlContent = this.extractHTMLFromElement(element);
      const textContent = this.extractTextFromElement(element);
      if (this.isValidBlogContent(textContent)) {
        return htmlContent;
      }
    }

    return '';
  }

  /**
   * Analyze all substantial text blocks and pick the best one - HTML version
   */
  private tryLargestValidTextBlockHTML(): string {
    const candidates: Array<{
      element: Element;
      content: string;
      htmlContent: string;
      score: number;
    }> = [];

    // Get all potential content containers
    const selectors = ['div', 'section', 'main', 'article'];

    for (const selector of selectors) {
      const elements = document.querySelectorAll(selector);

      for (const element of Array.from(elements)) {
        const textContent = this.extractTextFromElement(element);
        const htmlContent = this.extractHTMLFromElement(element);

        if (textContent.length > 200) {
          const score = this.scoreContentBlock(element, textContent);
          candidates.push({ element, content: textContent, htmlContent, score });
        }
      }
    }

    // Sort by score and return the best
    candidates.sort((a, b) => b.score - a.score);

    if (candidates.length > 0 && candidates[0].score > 50) {
      return candidates[0].htmlContent;
    }

    return '';
  }

  /**
   * Extract clean HTML from an element, removing unwanted parts but preserving structure
   */
  private extractHTMLFromElement(element: Element): string {
    // Clone the element to avoid modifying the original
    const clone = element.cloneNode(true) as Element;

    // Remove unwanted elements - expanded for Stack Overflow blog
    const unwantedSelectors = [
      'nav',
      'header',
      'footer',
      'aside',
      '.nav',
      '.navigation',
      '.menu',
      '.sidebar',
      '.promo',
      '.promotion',
      '.advertisement',
      '.ad',
      '.social',
      '.share',
      '.sharing',
      '.comments',
      '.comment-form',
      '.related',
      '.related-posts',
      'script',
      'style',
      'noscript',
      // NEW: Stack Overflow specific unwanted elements
      '[class*="teams"]',
      '[class*="talent"]',
      '[class*="hiring"]',
      '[class*="subscribe"]',
      '[class*="newsletter"]',
      '[class*="products"]',
      '[href*="stackoverflow.co"]',
      '.so-header',
      '.so-footer',
      // Remove empty or very short elements that might be promotional
      'div:empty',
      'p:empty',
      'span:empty',
    ];

    for (const selector of unwantedSelectors) {
      try {
        const elements = clone.querySelectorAll(selector);
        elements.forEach(el => el.remove());
      } catch (error) {
        // Some selectors might be invalid, continue with others
        this.logger.debug(`Failed to remove elements with selector: ${selector}`);
      }
    }

    // NEW: Remove elements with promotional text content
    const allElements = clone.querySelectorAll('*');
    allElements.forEach(el => {
      const text = el.textContent?.toLowerCase() || '';
      if (
        text.includes('stack overflow for teams') ||
        text.includes('hire top talent') ||
        text.includes('subscribe to') ||
        text.includes('newsletter') ||
        (text.length < 200 && (text.includes('products') || text.includes('pricing')))
      ) {
        el.remove();
      }
    });

    // Get the HTML content
    let html = clone.innerHTML;

    // Clean up the HTML while preserving paragraph structure
    html = this.cleanHTMLContent(html);

    return html;
  }

  /**
   * Clean HTML content while preserving paragraph structure
   */
  private cleanHTMLContent(html: string): string {
    // Remove empty paragraphs and divs
    html = html.replace(/<p[^>]*>\s*<\/p>/gi, '');
    html = html.replace(/<div[^>]*>\s*<\/div>/gi, '');

    // Remove excessive nested divs (keep content but remove wrapper)
    html = html.replace(/<div[^>]*>(\s*<p[^>]*>.*?<\/p>\s*)<\/div>/gi, '$1');

    // Ensure paragraph breaks are preserved
    html = html.replace(/(<\/p>)(\s*)(<p[^>]*>)/gi, '$1\n\n$3');

    // Clean up excessive whitespace but preserve line breaks
    html = html.replace(/[ \t]+/g, ' ');
    html = html.replace(/\n\s*\n\s*\n/g, '\n\n');

    // Remove attributes from paragraph tags to clean up
    html = html.replace(/<p[^>]*>/gi, '<p>');

    return html.trim();
  }

  /**
   * Score a content block to determine if it's likely the main article
   */
  private scoreContentBlock(element: Element, content: string): number {
    let score = 0;

    // Content length scoring (optimal around 1000-5000 chars)
    const length = content.length;
    if (length > 500) score += 20;
    if (length > 1000) score += 20;
    if (length > 2000) score += 10;
    if (length > 10000) score -= 10; // Too long might include sidebar

    // Element type scoring
    const tagName = element.tagName.toLowerCase();
    if (tagName === 'article') score += 30;
    if (tagName === 'main') score += 25;
    if (tagName === 'section') score += 15;

    // Class name scoring
    const className = element.className.toLowerCase();
    if (className.includes('content')) score += 15;
    if (className.includes('post')) score += 15;
    if (className.includes('article')) score += 15;
    if (className.includes('entry')) score += 10;

    // Negative scoring for unwanted content
    if (className.includes('nav')) score -= 30;
    if (className.includes('sidebar')) score -= 25;
    if (className.includes('footer')) score -= 25;
    if (className.includes('header')) score -= 20;
    if (className.includes('promo')) score -= 30;

    // Content quality scoring
    const sentences = content.split(/[.!?]+/).length;
    const avgSentenceLength = length / sentences;
    if (avgSentenceLength > 20 && avgSentenceLength < 200) score += 10;

    // Promotional content penalty
    const promoWords = ['teams', 'advertising', 'promote', 'talent', 'subscribe'];
    const promoCount = promoWords.filter(word => content.toLowerCase().includes(word)).length;
    score -= promoCount * 5;

    return score;
  }

  /**
   * Check if content looks like valid blog content
   */
  private isValidBlogContent(content: string): boolean {
    // NEW: More lenient validation for Stack Overflow blog structure
    if (content.length < 200) return false; // Reduced from 300

    // Should have some sentence structure
    const sentences = content.split(/[.!?]+/).length;
    if (sentences < 3) return false; // Reduced from 5

    // NEW: Check for actual article content vs navigation
    const contentIndicators = [
      /\b(the|this|that|these|those|when|where|how|why|what)\b/i,
      /\b(development|software|programming|code|application|system)\b/i,
      /\b(you|your|we|our|they|their)\b/i,
    ];

    const hasContentIndicators = contentIndicators.some(pattern => pattern.test(content));
    if (!hasContentIndicators) {
      this.logger.debug('Content lacks article indicators');
      return false;
    }

    // Should not be primarily promotional (more lenient)
    const promoWords = ['teams', 'advertising', 'promote', 'talent', 'subscription', 'pricing'];
    const promoCount = promoWords.filter(word => content.toLowerCase().includes(word)).length;
    const promoRatio = promoCount / (content.length / 1000);

    const isValid = promoRatio < 2; // Increased from 1 to be more lenient

    if (!isValid) {
      this.logger.debug(`Content rejected due to promotional ratio: ${promoRatio}`);
    }

    return isValid;
  }

  /**
   * Extract publish date
   */
  private extractPublishDate(): string | undefined {
    const dateSelectors = [
      '[datetime]',
      '.date',
      '.publish-date',
      '.published',
      '[class*="date"]',
      'time',
    ];

    for (const selector of dateSelectors) {
      const element = document.querySelector(selector);
      if (element) {
        const datetime = element.getAttribute('datetime');
        if (datetime) return datetime;

        const text = element.textContent?.trim();
        if (text && /\d{4}/.test(text)) return text;
      }
    }

    return undefined;
  }

  /**
   * Extract author information
   */
  private extractAuthor(): string | undefined {
    const authorSelectors = [
      '.author',
      '.by-author',
      '[rel="author"]',
      '.post-author',
      '[class*="author"]',
    ];

    for (const selector of authorSelectors) {
      const element = document.querySelector(selector);
      if (element && element.textContent) {
        const author = element.textContent.trim().replace(/^by\s+/i, '');
        if (author.length > 0 && author.length < 100) {
          return author;
        }
      }
    }

    return undefined;
  }

  /**
   * Extract tags
   */
  private extractTags(): string[] {
    const tags: string[] = [];

    const tagSelectors = ['.tags a', '.tag', '.post-tags a', '[class*="tag"] a', '.categories a'];

    for (const selector of tagSelectors) {
      const elements = document.querySelectorAll(selector);
      elements.forEach(element => {
        const tag = element.textContent?.trim();
        if (tag && tag.length > 0 && tag.length < 50 && !tags.includes(tag)) {
          tags.push(tag);
        }
      });
    }

    return tags;
  }

  /**
   * Get next siblings up to a limit
   */
  private getNextSiblings(element: Element, limit: number): Element[] {
    const siblings: Element[] = [];
    let current = element.nextElementSibling;
    let count = 0;

    while (current && count < limit) {
      siblings.push(current);
      current = current.nextElementSibling;
      count++;
    }

    return siblings;
  }

  /**
   * Check if a line looks like navigation
   */
  private isNavigationLine(line: string): boolean {
    const navPatterns = [
      /^(home|about|contact|blog|products|teams)$/i,
      /^(menu|navigation|nav)$/i,
      /^(login|sign up|register)$/i,
      /^\[\]/, // Empty links
      /^→/, // Arrow navigation
    ];

    return navPatterns.some(pattern => pattern.test(line));
  }

  /**
   * Check if a line is promotional content
   */
  private isPromotionalLine(line: string): boolean {
    const promoPatterns = [
      /stack overflow for teams/i,
      /promote your product/i,
      /advertising/i,
      /talent solutions/i,
      /recent articles/i,
      /latest podcast/i,
      /add to the discussion/i,
      /login with your.*account/i,
    ];

    return promoPatterns.some(pattern => pattern.test(line));
  }

  /**
   * Check if a line looks like a title
   */
  private looksLikeTitle(line: string): boolean {
    return line.length > 10 && line.length < 200 && !line.includes('.') && /^[A-Z]/.test(line);
  }

  /**
   * Check if a line looks like footer content
   */
  private looksLikeFooter(line: string): boolean {
    const footerPatterns = [
      /copyright/i,
      /all rights reserved/i,
      /privacy policy/i,
      /terms of service/i,
      /©/,
      /\d{4}\s*stack overflow/i,
    ];

    return footerPatterns.some(pattern => pattern.test(line));
  }

  /**
   * Estimate reading time based on content
   */
  private estimateReadingTime(content: string): number {
    const wordsPerMinute = 200;
    const words = content.split(/\s+/).length;
    return Math.ceil(words / wordsPerMinute);
  }

  /**
   * Escape HTML characters to prevent XSS
   */
  private escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
}
