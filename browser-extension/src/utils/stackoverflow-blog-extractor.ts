// Generated by Copilot
// Dedicated Stack Overflow Blog Content Extractor
// This targets the specific DOM structure of stackoverflow.blog

import { createLogger } from './logger.js';

export interface IStackOverflowBlogResult {
  title: string;
  content: string;
  publishDate?: string | undefined;
  author?: string | undefined;
  tags: string[];
  readingTime?: number | undefined;
}

/**
 * Specialized extractor for stackoverflow.blog pages
 * Uses knowledge of SO's specific blog structure
 */
export class StackOverflowBlogExtractor {
  private readonly logger = createLogger('StackOverflowBlogExtractor');

  /**
   * Check if current page is a Stack Overflow blog post
   */
  isStackOverflowBlog(): boolean {
    return (
      window.location.hostname.includes('stackoverflow.blog') ||
      window.location.href.includes('stackoverflow.blog')
    );
  }

  /**
   * Extract content specifically from Stack Overflow blog
   */
  extractBlogContent(): IStackOverflowBlogResult | null {
    if (!this.isStackOverflowBlog()) {
      this.logger.warn('Not a Stack Overflow blog page');
      return null;
    }

    try {
      this.logger.debug('Extracting Stack Overflow blog content');

      // Extract title - try multiple approaches
      const title = this.extractTitle();
      if (!title) {
        this.logger.warn('Could not find blog title');
        return null;
      }

      // Extract main content using aggressive approach
      const content = this.extractMainContent();
      if (!content) {
        this.logger.warn('Could not find main blog content');
        return null;
      }

      // Extract metadata
      const publishDate = this.extractPublishDate();
      const author = this.extractAuthor();
      const tags = this.extractTags();
      const readingTime = this.estimateReadingTime(content);

      this.logger.info('Successfully extracted SO blog content', {
        titleLength: title.length,
        contentLength: content.length,
        author,
        tags: tags.length,
      });

      return {
        title,
        content,
        publishDate,
        author,
        tags,
        readingTime,
      };
    } catch (error) {
      this.logger.error('Error extracting SO blog content:', error);
      return null;
    }
  }

  /**
   * Extract blog title using multiple strategies
   */
  private extractTitle(): string {
    // Try different title sources in order of preference
    const titleSelectors = [
      'h1',
      '.entry-title',
      '.post-title',
      '.article-title',
      '[class*="title"] h1',
      '[class*="title"] h2',
      'article h1',
      'main h1',
    ];

    for (const selector of titleSelectors) {
      const element = document.querySelector(selector);
      if (element && element.textContent) {
        const title = element.textContent.trim();
        if (title.length > 10 && title.length < 200) {
          return title;
        }
      }
    }

    // Fallback to page title, but clean it up
    const pageTitle = document.title;
    if (pageTitle) {
      // Remove common suffixes
      return pageTitle
        .replace(/\s*[-–—]\s*Stack Overflow Blog\s*$/i, '')
        .replace(/\s*\|\s*Stack Overflow\s*$/i, '')
        .trim();
    }

    return 'Untitled Post';
  }

  /**
   * Extract main content using aggressive DOM analysis
   */
  private extractMainContent(): string {
    // Strategy 1: Look for article content specifically
    let content = this.tryArticleContent();
    if (content && content.length > 500) {
      return content;
    }

    // Strategy 2: Find content by proximity to title
    content = this.tryContentNearTitle();
    if (content && content.length > 500) {
      return content;
    }

    // Strategy 3: Analyze all text blocks and pick the best one
    content = this.tryLargestValidTextBlock();
    if (content && content.length > 500) {
      return content;
    }

    // Strategy 4: Last resort - extract everything and clean aggressively
    return this.tryAggressiveExtraction();
  }

  /**
   * Try to find content within article tags
   */
  private tryArticleContent(): string {
    const articles = document.querySelectorAll('article');

    for (const article of articles) {
      // Skip if it's clearly navigation or sidebar
      const classList = article.className.toLowerCase();
      if (
        classList.includes('nav') ||
        classList.includes('sidebar') ||
        classList.includes('promo') ||
        classList.includes('ad')
      ) {
        continue;
      }

      const content = this.extractTextFromElement(article);
      if (this.isValidBlogContent(content)) {
        return content;
      }
    }

    return '';
  }

  /**
   * Try to find content near the main title
   */
  private tryContentNearTitle(): string {
    const h1 = document.querySelector('h1');
    if (!h1) return '';

    // Look for content containers near the title
    let parent = h1.parentElement;
    let attempts = 0;

    while (parent && attempts < 5) {
      const content = this.extractTextFromElement(parent);
      if (this.isValidBlogContent(content)) {
        return content;
      }
      parent = parent.parentElement;
      attempts++;
    }

    // Try siblings of the title
    const nextElements = this.getNextSiblings(h1, 10);
    for (const element of nextElements) {
      const content = this.extractTextFromElement(element);
      if (this.isValidBlogContent(content)) {
        return content;
      }
    }

    return '';
  }

  /**
   * Analyze all substantial text blocks and pick the best one
   */
  private tryLargestValidTextBlock(): string {
    const candidates: Array<{ element: Element; content: string; score: number }> = [];

    // Get all potential content containers
    const selectors = ['div', 'section', 'main', 'article'];

    for (const selector of selectors) {
      const elements = document.querySelectorAll(selector);

      for (const element of elements) {
        const content = this.extractTextFromElement(element);

        if (content.length > 200) {
          const score = this.scoreContentBlock(element, content);
          candidates.push({ element, content, score });
        }
      }
    }

    // Sort by score and return the best
    candidates.sort((a, b) => b.score - a.score);

    if (candidates.length > 0 && candidates[0].score > 50) {
      return candidates[0].content;
    }

    return '';
  }

  /**
   * Last resort: extract everything and clean very aggressively
   */
  private tryAggressiveExtraction(): string {
    // Get the main body content
    const body = document.body;
    const fullText = body.textContent || '';

    // Split into lines and filter aggressively
    const lines = fullText
      .split('\n')
      .map(line => line.trim())
      .filter(line => {
        // Skip empty lines
        if (line.length < 10) return false;

        // Skip navigation patterns
        if (this.isNavigationLine(line)) return false;

        // Skip promotional patterns
        if (this.isPromotionalLine(line)) return false;

        return true;
      });

    // Find the main content section by looking for paragraphs
    const paragraphs: string[] = [];
    let inMainContent = false;

    for (const line of lines) {
      // Start capturing after we find what looks like a title
      if (!inMainContent && this.looksLikeTitle(line)) {
        inMainContent = true;
        continue;
      }

      if (inMainContent) {
        // Stop if we hit footer/navigation
        if (this.looksLikeFooter(line)) {
          break;
        }

        paragraphs.push(line);
      }
    }

    return paragraphs.join('\n\n');
  }

  /**
   * Extract clean text from an element, removing unwanted parts
   */
  private extractTextFromElement(element: Element): string {
    // Clone the element to avoid modifying the original
    const clone = element.cloneNode(true) as Element;

    // Remove unwanted elements
    const unwantedSelectors = [
      'nav',
      'header',
      'footer',
      'aside',
      '.nav',
      '.navigation',
      '.menu',
      '.sidebar',
      '.promo',
      '.promotion',
      '.advertisement',
      '.ad',
      '.social',
      '.share',
      '.sharing',
      '.comments',
      '.comment-form',
      '.related',
      '.related-posts',
      'script',
      'style',
      'noscript',
    ];

    for (const selector of unwantedSelectors) {
      const elements = clone.querySelectorAll(selector);
      elements.forEach(el => el.remove());
    }

    // Get text and clean it up
    let text = clone.textContent || '';

    // Remove extra whitespace
    text = text.replace(/\s+/g, ' ').trim();

    return text;
  }

  /**
   * Score a content block to determine if it's likely the main article
   */
  private scoreContentBlock(element: Element, content: string): number {
    let score = 0;

    // Content length scoring (optimal around 1000-5000 chars)
    const length = content.length;
    if (length > 500) score += 20;
    if (length > 1000) score += 20;
    if (length > 2000) score += 10;
    if (length > 10000) score -= 10; // Too long might include sidebar

    // Element type scoring
    const tagName = element.tagName.toLowerCase();
    if (tagName === 'article') score += 30;
    if (tagName === 'main') score += 25;
    if (tagName === 'section') score += 15;

    // Class name scoring
    const className = element.className.toLowerCase();
    if (className.includes('content')) score += 15;
    if (className.includes('post')) score += 15;
    if (className.includes('article')) score += 15;
    if (className.includes('entry')) score += 10;

    // Negative scoring for unwanted content
    if (className.includes('nav')) score -= 30;
    if (className.includes('sidebar')) score -= 25;
    if (className.includes('footer')) score -= 25;
    if (className.includes('header')) score -= 20;
    if (className.includes('promo')) score -= 30;

    // Content quality scoring
    const sentences = content.split(/[.!?]+/).length;
    const avgSentenceLength = length / sentences;
    if (avgSentenceLength > 20 && avgSentenceLength < 200) score += 10;

    // Promotional content penalty
    const promoWords = ['teams', 'advertising', 'promote', 'talent', 'subscribe'];
    const promoCount = promoWords.filter(word => content.toLowerCase().includes(word)).length;
    score -= promoCount * 5;

    return score;
  }

  /**
   * Check if content looks like valid blog content
   */
  private isValidBlogContent(content: string): boolean {
    if (content.length < 300) return false;

    // Should have reasonable sentence structure
    const sentences = content.split(/[.!?]+/).length;
    if (sentences < 5) return false;

    // Should not be primarily promotional
    const promoWords = ['teams', 'advertising', 'promote', 'talent'];
    const promoCount = promoWords.filter(word => content.toLowerCase().includes(word)).length;
    const promoRatio = promoCount / (content.length / 1000);

    return promoRatio < 1; // Less than 1 promo word per 1000 characters
  }

  /**
   * Extract publish date
   */
  private extractPublishDate(): string | undefined {
    const dateSelectors = [
      '[datetime]',
      '.date',
      '.publish-date',
      '.published',
      '[class*="date"]',
      'time',
    ];

    for (const selector of dateSelectors) {
      const element = document.querySelector(selector);
      if (element) {
        const datetime = element.getAttribute('datetime');
        if (datetime) return datetime;

        const text = element.textContent?.trim();
        if (text && /\d{4}/.test(text)) return text;
      }
    }

    return undefined;
  }

  /**
   * Extract author information
   */
  private extractAuthor(): string | undefined {
    const authorSelectors = [
      '.author',
      '.by-author',
      '[rel="author"]',
      '.post-author',
      '[class*="author"]',
    ];

    for (const selector of authorSelectors) {
      const element = document.querySelector(selector);
      if (element && element.textContent) {
        const author = element.textContent.trim().replace(/^by\s+/i, '');
        if (author.length > 0 && author.length < 100) {
          return author;
        }
      }
    }

    return undefined;
  }

  /**
   * Extract tags
   */
  private extractTags(): string[] {
    const tags: string[] = [];

    const tagSelectors = ['.tags a', '.tag', '.post-tags a', '[class*="tag"] a', '.categories a'];

    for (const selector of tagSelectors) {
      const elements = document.querySelectorAll(selector);
      elements.forEach(element => {
        const tag = element.textContent?.trim();
        if (tag && tag.length > 0 && tag.length < 50 && !tags.includes(tag)) {
          tags.push(tag);
        }
      });
    }

    return tags;
  }

  /**
   * Get next siblings up to a limit
   */
  private getNextSiblings(element: Element, limit: number): Element[] {
    const siblings: Element[] = [];
    let current = element.nextElementSibling;
    let count = 0;

    while (current && count < limit) {
      siblings.push(current);
      current = current.nextElementSibling;
      count++;
    }

    return siblings;
  }

  /**
   * Check if a line looks like navigation
   */
  private isNavigationLine(line: string): boolean {
    const navPatterns = [
      /^(home|about|contact|blog|products|teams)$/i,
      /^(menu|navigation|nav)$/i,
      /^(login|sign up|register)$/i,
      /^\[\]/, // Empty links
      /^→/, // Arrow navigation
    ];

    return navPatterns.some(pattern => pattern.test(line));
  }

  /**
   * Check if a line is promotional content
   */
  private isPromotionalLine(line: string): boolean {
    const promoPatterns = [
      /stack overflow for teams/i,
      /promote your product/i,
      /advertising/i,
      /talent solutions/i,
      /recent articles/i,
      /latest podcast/i,
      /add to the discussion/i,
      /login with your.*account/i,
    ];

    return promoPatterns.some(pattern => pattern.test(line));
  }

  /**
   * Check if a line looks like a title
   */
  private looksLikeTitle(line: string): boolean {
    return line.length > 10 && line.length < 200 && !line.includes('.') && /^[A-Z]/.test(line);
  }

  /**
   * Check if a line looks like footer content
   */
  private looksLikeFooter(line: string): boolean {
    const footerPatterns = [
      /copyright/i,
      /all rights reserved/i,
      /privacy policy/i,
      /terms of service/i,
      /©/,
      /\d{4}\s*stack overflow/i,
    ];

    return footerPatterns.some(pattern => pattern.test(line));
  }

  /**
   * Estimate reading time based on content
   */
  private estimateReadingTime(content: string): number {
    const wordsPerMinute = 200;
    const words = content.split(/\s+/).length;
    return Math.ceil(words / wordsPerMinute);
  }
}
