// Generated by Copilot
// PrismWeave UI Utilities
// Consolidated UI patterns, DOM manipulation, and toast notifications

import { getGlobalScope } from './global-types';
import { createLogger } from './logger';

const logger = createLogger('UIUtils');

type StatusType = 'success' | 'error' | 'warning' | 'info';

interface IEventListener {
  selector: string | Element;
  event: string;
  handler: EventListener;
  options?: AddEventListenerOptions;
}

interface IValidationRules {
  required?: boolean;
  pattern?: RegExp;
  minLength?: number;
  maxLength?: number;
  min?: number;
  max?: number;
}

interface IModalOptions {
  title?: string;
}

class UIUtils {
  static readonly STATUS_TYPES = {
    SUCCESS: 'success' as const,
    ERROR: 'error' as const,
    WARNING: 'warning' as const,
    INFO: 'info' as const,
  };

  // Status/notification management
  static showStatus(
    message: string,
    type: StatusType = UIUtils.STATUS_TYPES.SUCCESS,
    duration: number = 5000
  ): void {
    const statusElement = document.getElementById('status') || UIUtils.createStatusElement();
    const statusText = statusElement.querySelector('.status-text') || statusElement;

    statusText.textContent = message;
    statusElement.className = `status ${type}`;
    statusElement.style.display = 'block';

    if (duration > 0) {
      setTimeout(() => {
        UIUtils.hideStatus();
      }, duration);
    }
  }

  static hideStatus(): void {
    const statusElement = document.getElementById('status');
    if (statusElement) {
      statusElement.style.display = 'none';
    }
  }

  // Modern toast notifications (consolidated from ui-enhancer)
  static showProgressToast(message: string, duration: number = 3000): void {
    const toast = document.createElement('div');
    toast.className = 'prismweave-toast';
    toast.innerHTML = `
      <div class="toast-content">
        <div class="toast-icon">⏳</div>
        <div class="toast-message">${message}</div>
      </div>
    `;

    UIUtils.injectToastStyles();
    document.body.appendChild(toast);

    // Animate in
    setTimeout(() => toast.classList.add('show'), 100);

    // Remove after duration
    setTimeout(() => {
      toast.classList.remove('show');
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  static showSuccessToast(message: string, duration: number = 3000): void {
    const toast = document.createElement('div');
    toast.className = 'prismweave-toast success';
    toast.innerHTML = `
      <div class="toast-content">
        <div class="toast-icon">✅</div>
        <div class="toast-message">${message}</div>
      </div>
    `;

    UIUtils.injectToastStyles();
    document.body.appendChild(toast);

    setTimeout(() => toast.classList.add('show'), 100);
    setTimeout(() => {
      toast.classList.remove('show');
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  static showErrorToast(message: string, solution: string = '', duration: number = 5000): void {
    const toast = document.createElement('div');
    toast.className = 'prismweave-toast error';
    toast.innerHTML = `
      <div class="toast-content">
        <div class="toast-icon">❌</div>
        <div class="toast-message">${message}</div>
        ${solution ? `<div class="toast-solution">${solution}</div>` : ''}
        <button class="toast-close" onclick="this.parentElement.parentElement.remove()">×</button>
      </div>
    `;

    UIUtils.injectToastStyles();
    document.body.appendChild(toast);

    setTimeout(() => toast.classList.add('show'), 100);
    setTimeout(() => {
      toast.classList.remove('show');
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  static injectToastStyles(): void {
    if (document.getElementById('prismweave-toast-styles')) return;

    const styles = document.createElement('style');
    styles.id = 'prismweave-toast-styles';
    styles.textContent = `
      .prismweave-toast {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #333;
        color: white;
        border-radius: 8px;
        padding: 16px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        z-index: 10000;
        opacity: 0;
        transform: translateX(100%);
        transition: all 0.3s ease;
        max-width: 400px;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      }
      
      .prismweave-toast.show {
        opacity: 1;
        transform: translateX(0);
      }
      
      .prismweave-toast.success {
        background: #4caf50;
      }
      
      .prismweave-toast.error {
        background: #f44336;
      }
      
      .toast-content {
        display: flex;
        align-items: center;
        gap: 12px;
      }
      
      .toast-icon {
        font-size: 18px;
        flex-shrink: 0;
      }
      
      .toast-message {
        flex: 1;
        font-size: 14px;
        line-height: 1.4;
      }
      
      .toast-solution {
        font-size: 12px;
        opacity: 0.8;
        margin-top: 4px;
      }
      
      .toast-close {
        background: none;
        border: none;
        color: white;
        font-size: 18px;
        cursor: pointer;
        padding: 0;
        margin-left: 8px;
      }
    `;
    document.head.appendChild(styles);
  }

  // Modal functionality
  static showModal(content: string, options: IModalOptions = {}): void {
    const modal = document.createElement('div');
    modal.className = 'prismweave-modal';
    modal.innerHTML = `
      <div class="modal-content">
        ${options.title ? `<div class="modal-title">${options.title}</div>` : ''}
        <div class="modal-body">${content}</div>
        <button class="modal-close" onclick="this.closest('.prismweave-modal').remove()">×</button>
      </div>
    `;

    UIUtils.injectModalStyles();
    document.body.appendChild(modal);
  }

  static hideModal(): void {
    const modal = document.querySelector('.prismweave-modal');
    if (modal) {
      modal.remove();
    }
  }

  static injectModalStyles(): void {
    if (document.getElementById('prismweave-modal-styles')) return;

    const styles = document.createElement('style');
    styles.id = 'prismweave-modal-styles';
    styles.textContent = `
      .prismweave-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10001;
      }
      
      .modal-content {
        background: white;
        border-radius: 8px;
        padding: 20px;
        max-width: 500px;
        max-height: 80vh;
        overflow-y: auto;
        position: relative;
      }
      
      .modal-title {
        font-size: 18px;
        font-weight: bold;
        margin-bottom: 12px;
      }
      
      .modal-close {
        position: absolute;
        top: 10px;
        right: 15px;
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
      }
    `;
    document.head.appendChild(styles);
  }

  static createStatusElement(): HTMLElement {
    const statusElement = document.createElement('div');
    statusElement.id = 'status';
    statusElement.className = 'status';
    statusElement.innerHTML = '<span class="status-text"></span>';

    // Add basic styling if no CSS is present
    Object.assign(statusElement.style, {
      position: 'fixed',
      top: '10px',
      right: '10px',
      padding: '10px 15px',
      borderRadius: '4px',
      color: 'white',
      fontFamily: 'system-ui, sans-serif',
      fontSize: '14px',
      zIndex: '10000',
      display: 'none',
    });

    document.body.appendChild(statusElement);
    return statusElement;
  }

  // Loading state management
  static showLoading(show: boolean = true, targetId: string = 'main-content'): void {
    const loadingElement = document.getElementById('loading') || UIUtils.createLoadingElement();
    const mainContent = document.getElementById(targetId);

    if (show) {
      loadingElement.style.display = 'flex';
      if (mainContent) mainContent.style.display = 'none';
    } else {
      loadingElement.style.display = 'none';
      if (mainContent) mainContent.style.display = 'block';
    }
  }

  static createLoadingElement(): HTMLElement {
    const loadingElement = document.createElement('div');
    loadingElement.id = 'loading';
    loadingElement.innerHTML = `
      <div class="loading-spinner"></div>
      <span class="loading-text">Processing...</span>
    `;

    // Add basic styling
    Object.assign(loadingElement.style, {
      position: 'fixed',
      top: '0',
      left: '0',
      width: '100%',
      height: '100%',
      display: 'none',
      flexDirection: 'column',
      alignItems: 'center',
      justifyContent: 'center',
      backgroundColor: 'rgba(255, 255, 255, 0.9)',
      zIndex: '9999',
    });

    document.body.appendChild(loadingElement);
    return loadingElement;
  }

  // Form utilities
  static populateForm(
    settings: Record<string, unknown>,
    fieldMapping: Record<string, string> = {}
  ): void {
    Object.entries(settings).forEach(([key, value]) => {
      const fieldId = fieldMapping[key] || UIUtils.kebabCase(key);
      const element = document.getElementById(fieldId) as
        | HTMLInputElement
        | HTMLSelectElement
        | HTMLTextAreaElement;

      if (!element) return;

      switch (element.type) {
        case 'checkbox':
          (element as HTMLInputElement).checked = Boolean(value);
          break;
        case 'radio':
          if ((element as HTMLInputElement).value === value) {
            (element as HTMLInputElement).checked = true;
          }
          break;
        case 'select-one':
        case 'select-multiple':
          element.value = String(value || '');
          break;
        default:
          element.value = String(value || '');
      }
    });
  }

  static collectFormData(
    fieldMapping: Record<string, string> = {},
    containerSelector: string = 'body'
  ): Record<string, unknown> {
    const container = document.querySelector(containerSelector);
    if (!container) return {};

    const formData: Record<string, unknown> = {};

    // Collect all form inputs
    const inputs = container.querySelectorAll('input, select, textarea') as NodeListOf<
      HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement
    >;

    inputs.forEach(input => {
      if (!input.id) return;

      const key = UIUtils.findKeyByValue(fieldMapping, input.id) || UIUtils.camelCase(input.id);

      switch (input.type) {
        case 'checkbox':
          formData[key] = (input as HTMLInputElement).checked;
          break;
        case 'radio':
          if ((input as HTMLInputElement).checked) {
            formData[key] = input.value;
          }
          break;
        case 'number':
          formData[key] = input.value ? Number(input.value) : null;
          break;
        default:
          formData[key] = input.value?.trim() || '';
      }
    });

    return formData;
  }

  // Input validation helpers
  static validateField(
    fieldId: string,
    value: string,
    validationRules: IValidationRules = {}
  ): string[] {
    const element = document.getElementById(fieldId);
    const errors: string[] = [];

    // Required validation
    if (validationRules.required && (!value || value === '')) {
      errors.push('This field is required');
    }

    // Pattern validation
    if (validationRules.pattern && value && !validationRules.pattern.test(value)) {
      errors.push('Invalid format');
    }

    // Length validation
    if (validationRules.minLength && value.length < validationRules.minLength) {
      errors.push(`Minimum length is ${validationRules.minLength}`);
    }

    if (validationRules.maxLength && value.length > validationRules.maxLength) {
      errors.push(`Maximum length is ${validationRules.maxLength}`);
    }

    // Range validation for numbers
    if (validationRules.min !== undefined && Number(value) < validationRules.min) {
      errors.push(`Minimum value is ${validationRules.min}`);
    }

    if (validationRules.max !== undefined && Number(value) > validationRules.max) {
      errors.push(`Maximum value is ${validationRules.max}`);
    }

    // Update field styling
    if (element) {
      UIUtils.setFieldValidation(element, errors.length === 0, errors[0]);
    }

    return errors;
  }

  static setFieldValidation(element: HTMLElement, isValid: boolean, message: string = ''): void {
    if (isValid) {
      element.style.borderColor = '#ddd';
      element.title = '';
    } else {
      element.style.borderColor = '#f44336';
      element.title = message;
    }

    // Remove existing validation message
    const existingMessage = element.parentNode?.querySelector('.validation-message');
    if (existingMessage) {
      existingMessage.remove();
    }

    // Add validation message if invalid
    if (!isValid && message) {
      const messageElement = document.createElement('div');
      messageElement.className = 'validation-message';
      messageElement.textContent = message;
      messageElement.style.color = '#f44336';
      messageElement.style.fontSize = '12px';
      messageElement.style.marginTop = '4px';

      element.parentNode?.appendChild(messageElement);
    }
  }

  // Button state management
  static setButtonState(
    buttonId: string,
    disabled: boolean = false,
    text: string | null = null
  ): void {
    const button = document.getElementById(buttonId) as HTMLButtonElement;
    if (!button) return;

    button.disabled = disabled;
    if (text) {
      button.textContent = text;
    }

    if (disabled) {
      button.style.opacity = '0.6';
      button.style.cursor = 'not-allowed';
    } else {
      button.style.opacity = '1';
      button.style.cursor = 'pointer';
    }
  }

  // Event listener helpers
  static addEventListeners(listeners: IEventListener[]): void {
    listeners.forEach(({ selector, event, handler, options = {} }) => {
      const elements =
        typeof selector === 'string' ? document.querySelectorAll(selector) : [selector];

      elements.forEach(element => {
        if (element) {
          element.addEventListener(event, handler, options);
        }
      });
    });
  }

  static debounce<T extends (...args: unknown[]) => void>(
    func: T,
    delay: number = 300
  ): (...args: Parameters<T>) => void {
    let timeoutId: number;
    return function (this: ThisParameterType<T>, ...args: Parameters<T>) {
      clearTimeout(timeoutId);
      timeoutId = window.setTimeout(() => func.apply(this, args), delay);
    };
  }

  // Modal/dialog helpers
  static showConfirmDialog(message: string, title: string = 'Confirm'): Promise<boolean> {
    return new Promise(resolve => {
      const confirmed = confirm(`${title}\n\n${message}`);
      resolve(confirmed);
    });
  }

  static createModal(content: string, options: IModalOptions = {}): HTMLElement {
    const modal = document.createElement('div');
    modal.className = 'prismweave-modal';
    modal.innerHTML = `
      <div class="modal-backdrop" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000;"></div>
      <div class="modal-content" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 8px; z-index: 10001; max-width: 500px; width: 90%;">
        ${options.title ? `<h3>${options.title}</h3>` : ''}
        <div class="modal-body">${content}</div>
        <div class="modal-actions" style="text-align: right; margin-top: 20px;">
          <button class="modal-close" style="padding: 8px 16px; margin-left: 8px;">Close</button>
        </div>
      </div>
    `;

    // Close handlers
    modal.querySelector('.modal-backdrop')?.addEventListener('click', () => {
      UIUtils.closeModal(modal);
    });

    modal.querySelector('.modal-close')?.addEventListener('click', () => {
      UIUtils.closeModal(modal);
    });

    document.body.appendChild(modal);
    return modal;
  }

  static closeModal(modal: HTMLElement): void {
    if (modal && modal.parentNode) {
      modal.parentNode.removeChild(modal);
    }
  }

  // Utility string functions
  static kebabCase(str: string): string {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
  }

  static camelCase(str: string): string {
    return str.replace(/-([a-z])/g, (match, letter) => letter.toUpperCase());
  }

  static findKeyByValue(obj: Record<string, string>, value: string): string | undefined {
    return Object.keys(obj).find(key => obj[key] === value);
  }

  // File download helper
  static downloadFile(content: string, filename: string, mimeType: string = 'text/plain'): void {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);

    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    link.click();

    URL.revokeObjectURL(url);
  }

  // Copy to clipboard
  static async copyToClipboard(text: string): Promise<void> {
    try {
      await navigator.clipboard.writeText(text);
      UIUtils.showStatus('Copied to clipboard', UIUtils.STATUS_TYPES.SUCCESS, 2000);
    } catch (error) {
      // Use Logger for error logging
      logger.error('Failed to copy to clipboard:', error);
      UIUtils.showStatus('Failed to copy to clipboard', UIUtils.STATUS_TYPES.ERROR);
    }
  }

  // CSS helper to add status styling if not present
  static addStatusStyling(): void {
    if (document.getElementById('prismweave-ui-styles')) return;

    const style = document.createElement('style');
    style.id = 'prismweave-ui-styles';
    style.textContent = `
      .status {
        border-radius: 4px;
        padding: 10px 15px;
        margin: 10px 0;
        font-family: system-ui, sans-serif;
        font-size: 14px;
      }
      .status.success {
        background-color: #4CAF50;
        color: white;
      }
      .status.error {
        background-color: #f44336;
        color: white;
      }
      .status.warning {
        background-color: #FF9800;
        color: white;
      }
      .status.info {
        background-color: #2196F3;
        color: white;
      }
      .validation-message {
        font-size: 12px;
        color: #f44336;
        margin-top: 4px;
      }
      .loading-spinner {
        border: 3px solid #f3f3f3;
        border-top: 3px solid #2196F3;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        animation: spin 1s linear infinite;
        margin-bottom: 10px;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
    `;

    document.head.appendChild(style);
  }
}

// Auto-add styling when loaded
if (typeof document !== 'undefined') {
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', UIUtils.addStatusStyling);
  } else {
    UIUtils.addStatusStyling();
  }
}

// Export to global scope
const globalScope = getGlobalScope();
globalScope.UIUtils = {
  showStatus: UIUtils.showStatus.bind(UIUtils),
  hideStatus: UIUtils.hideStatus.bind(UIUtils),
  showModal: UIUtils.showModal.bind(UIUtils),
  hideModal: UIUtils.hideModal.bind(UIUtils),
};

export default UIUtils;
export type { IEventListener, IModalOptions, IValidationRules, StatusType };
