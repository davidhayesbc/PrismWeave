// Generated by Copilot
// Bookmarklet Content Capture - Self-contained content capture for bookmarklet use
// No Chrome APIs, works in any browser context, reuses core extraction logic

import {
  ContentExtractionCore,
  IExtractedContent,
  IExtractionConfig,
} from './content-extraction-core.js';
import { IConversionOptions, IConversionResult, MarkdownConverter } from './markdown-converter.js';

export interface IBookmarkletCaptureOptions {
  // Content extraction options
  includeImages: boolean;
  includeLinks: boolean;
  cleanHtml: boolean;
  customSelectors: string[];
  excludeSelectors: string[];
  maxWordCount?: number;
  preserveFormatting: boolean;

  // Markdown conversion options
  headingStyle: 'atx' | 'setext';
  bulletListMarker: '-' | '*' | '+';
  codeStyle: 'fenced' | 'indented';
  linkStyle: 'inline' | 'reference';

  // Processing options
  generateFrontmatter: boolean;
  includeMetadata: boolean;
  autoDetectLanguage: boolean;
}

export interface IBookmarkletCaptureResult {
  success: boolean;
  data?: {
    title: string;
    url: string;
    markdown: string;
    frontmatter: string;
    content: string;
    wordCount: number;
    readingTime: number;
    extractedAt: string;
    images: string[];
    metadata: Record<string, unknown>;
  };
  error?: string;
  warnings: string[];
  qualityScore: number;
  extractionTime: number;
}

/**
 * Self-contained content capture for bookmarklets
 * Uses ContentExtractionCore and MarkdownConverterCore for consistent results
 */
export class BookmarkletContentCapture {
  private readonly _options: IBookmarkletCaptureOptions;
  private readonly _extractor: ContentExtractionCore;
  private readonly _converter: MarkdownConverter;

  constructor(options: Partial<IBookmarkletCaptureOptions> = {}) {
    this._options = this.normalizeOptions(options);

    // Initialize extraction core
    const extractionConfig: Partial<IExtractionConfig> = {
      includeImages: this._options.includeImages,
      includeLinks: this._options.includeLinks,
      cleanHtml: this._options.cleanHtml,
      customSelectors: this._options.customSelectors,
      excludeSelectors: this._options.excludeSelectors,
      preserveFormatting: this._options.preserveFormatting,
      ...(this._options.maxWordCount !== undefined && { maxWordCount: this._options.maxWordCount }),
    };

    this._extractor = new ContentExtractionCore(extractionConfig);

    // Initialize markdown converter
    const markdownOptions: Partial<IConversionOptions> = {
      preserveFormatting: this._options.preserveFormatting,
      headingStyle: this._options.headingStyle,
      bulletListMarker: this._options.bulletListMarker,
      codeBlockStyle: this._options.codeStyle,
      linkStyle: this._options.linkStyle === 'reference' ? 'referenced' : 'inlined',
    };

    this._converter = new MarkdownConverter();
  }

  /**
   * Capture and process content from the current page
   */
  async captureCurrentPage(): Promise<IBookmarkletCaptureResult> {
    const startTime = Date.now();
    const warnings: string[] = [];

    try {
      console.log('[BookmarkletContentCapture] Starting capture process...');

      // Extract content from the current document
      const extractedContent = this._extractor.extractContent(document);
      console.log('[BookmarkletContentCapture] Content extracted successfully:', {
        title: extractedContent.title,
        contentLength: extractedContent.content.length,
        wordCount: extractedContent.metadata.wordCount,
      });

      // Convert content to markdown
      console.log('[BookmarkletContentCapture] Converting to markdown...');
      const conversionResult = this._converter.convertToMarkdown(extractedContent.content);
      console.log('[BookmarkletContentCapture] Markdown conversion completed:', {
        markdownLength: conversionResult.markdown.length,
        success: !!conversionResult.markdown,
      });

      // Combine warnings (conversion result doesn't have warnings in this implementation)

      // Generate frontmatter if requested
      let frontmatter = '';
      if (this._options.generateFrontmatter) {
        frontmatter = this.generateFrontmatter(extractedContent, conversionResult);
      }

      // Prepare final content
      const finalContent = frontmatter
        ? `${frontmatter}\n${conversionResult.markdown}`
        : conversionResult.markdown;

      // Calculate reading time
      const readingTime = Math.ceil(extractedContent.metadata.wordCount / 200);

      const extractionTime = Date.now() - startTime;

      return {
        success: true,
        data: {
          title: extractedContent.title,
          url: extractedContent.metadata.url,
          markdown: conversionResult.markdown,
          frontmatter: frontmatter,
          content: finalContent,
          wordCount: extractedContent.metadata.wordCount,
          readingTime: readingTime,
          extractedAt: extractedContent.metadata.extractedAt,
          images: extractedContent.images,
          metadata: this._options.includeMetadata ? extractedContent.metadata : {},
        },
        warnings,
        qualityScore: extractedContent.qualityScore,
        extractionTime,
      };
    } catch (error) {
      console.error('[BookmarkletContentCapture] Capture failed with error:', error);
      console.error(
        '[BookmarkletContentCapture] Error stack:',
        error instanceof Error ? error.stack : 'No stack'
      );
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
        warnings,
        qualityScore: 0,
        extractionTime: Date.now() - startTime,
      };
    }
  }

  /**
   * Capture content from a specific element
   */
  async captureElement(element: Element): Promise<IBookmarkletCaptureResult> {
    const startTime = Date.now();
    const warnings: string[] = [];

    try {
      // Extract content from the specified element
      const extractedContent = this._extractor.extractContent(element);

      // Convert content to markdown
      const conversionResult = this._converter.convertToMarkdown(extractedContent.content);

      // Combine warnings (conversion result doesn't have warnings in this implementation)

      // Generate frontmatter if requested
      let frontmatter = '';
      if (this._options.generateFrontmatter) {
        frontmatter = this.generateFrontmatter(extractedContent, conversionResult);
      }

      // Prepare final content
      const finalContent = frontmatter
        ? `${frontmatter}\n${conversionResult.markdown}`
        : conversionResult.markdown;

      // Calculate reading time
      const readingTime = Math.ceil(extractedContent.metadata.wordCount / 200);

      const extractionTime = Date.now() - startTime;

      return {
        success: true,
        data: {
          title: extractedContent.title,
          url: extractedContent.metadata.url,
          markdown: conversionResult.markdown,
          frontmatter: frontmatter,
          content: finalContent,
          wordCount: extractedContent.metadata.wordCount,
          readingTime: readingTime,
          extractedAt: extractedContent.metadata.extractedAt,
          images: extractedContent.images,
          metadata: this._options.includeMetadata ? extractedContent.metadata : {},
        },
        warnings,
        qualityScore: extractedContent.qualityScore,
        extractionTime,
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
        warnings,
        qualityScore: 0,
        extractionTime: Date.now() - startTime,
      };
    }
  }

  /**
   * Check if the current page has a paywall
   */
  isPaywallPresent(): boolean {
    return this._extractor.isPaywallPresent(document);
  }

  /**
   * Get page quality assessment
   */
  getPageQuality(): {
    score: number;
    wordCount: number;
    hasPaywall: boolean;
    contentType: 'article' | 'blog' | 'news' | 'documentation' | 'other';
    readingTime: number;
  } {
    try {
      const extractedContent = this._extractor.extractContent(document);
      const contentType = this.detectContentType(extractedContent);

      return {
        score: extractedContent.qualityScore,
        wordCount: extractedContent.metadata.wordCount,
        hasPaywall: this._extractor.isPaywallPresent(document),
        contentType,
        readingTime: extractedContent.metadata.readingTime,
      };
    } catch (error) {
      return {
        score: 0,
        wordCount: 0,
        hasPaywall: false,
        contentType: 'other',
        readingTime: 0,
      };
    }
  }

  /**
   * Test capture functionality with current page
   */
  async testCapture(): Promise<{
    canExtract: boolean;
    hasContent: boolean;
    contentPreview: string;
    warnings: string[];
    estimatedSize: number;
  }> {
    try {
      const result = await this.captureCurrentPage();

      return {
        canExtract: result.success,
        hasContent: (result.data?.wordCount || 0) > 20,
        contentPreview: result.data?.markdown.substring(0, 200) || '',
        warnings: result.warnings,
        estimatedSize: (result.data?.content || '').length,
      };
    } catch (error) {
      return {
        canExtract: false,
        hasContent: false,
        contentPreview: '',
        warnings: [error instanceof Error ? error.message : 'Test failed'],
        estimatedSize: 0,
      };
    }
  }

  // Private helper methods

  private normalizeOptions(
    options: Partial<IBookmarkletCaptureOptions>
  ): IBookmarkletCaptureOptions {
    const normalized: IBookmarkletCaptureOptions = {
      // Content extraction defaults
      includeImages: options.includeImages ?? true,
      includeLinks: options.includeLinks ?? true,
      cleanHtml: options.cleanHtml ?? true,
      customSelectors: options.customSelectors ?? [],
      excludeSelectors: options.excludeSelectors ?? [
        'nav',
        'header',
        'footer',
        '.advertisement',
        '.ad',
        '.ads',
        '.popup',
        '.modal',
        '.social-share',
        '.comments',
        '.related-posts',
      ],
      preserveFormatting: options.preserveFormatting ?? true,

      // Markdown conversion defaults
      headingStyle: options.headingStyle ?? 'atx',
      bulletListMarker: options.bulletListMarker ?? '-',
      codeStyle: options.codeStyle ?? 'fenced',
      linkStyle: options.linkStyle ?? 'inline',

      // Processing defaults
      generateFrontmatter: options.generateFrontmatter ?? true,
      includeMetadata: options.includeMetadata ?? true,
      autoDetectLanguage: options.autoDetectLanguage ?? true,
    };

    // Handle optional maxWordCount separately
    if (options.maxWordCount !== undefined) {
      normalized.maxWordCount = options.maxWordCount;
    }

    return normalized;
  }

  private generateFrontmatter(extracted: IExtractedContent, conversion: IConversionResult): string {
    const metadata = extracted.metadata;
    const frontmatterData: Record<string, unknown> = {
      title: extracted.title,
      url: metadata.url,
      captured: metadata.extractedAt,
      source: 'PrismWeave Bookmarklet',
      wordCount: metadata.wordCount,
      readingTime: `${metadata.readingTime} min`,
      qualityScore: extracted.qualityScore,
    };

    // Add optional metadata
    if (metadata.author) {
      frontmatterData.author = metadata.author;
    }

    if (metadata.description) {
      frontmatterData.description = metadata.description;
    }

    if (metadata.keywords.length > 0) {
      frontmatterData.keywords = metadata.keywords;
    }

    if (metadata.language !== 'en') {
      frontmatterData.language = metadata.language;
    }

    if (extracted.images.length > 0) {
      frontmatterData.images = extracted.images.slice(0, 5); // Limit to first 5 images
    }

    // Add conversion metadata (no warnings in current implementation)
    // Note: Future enhancement could add conversion warnings tracking

    // Format as YAML frontmatter
    let frontmatter = '---\n';

    Object.entries(frontmatterData).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        frontmatter += `${key}:\n`;
        value.forEach(item => {
          frontmatter += `  - ${this.escapeYamlValue(item)}\n`;
        });
      } else {
        frontmatter += `${key}: ${this.escapeYamlValue(value)}\n`;
      }
    });

    frontmatter += '---';
    return frontmatter;
  }

  private escapeYamlValue(value: unknown): string {
    if (typeof value === 'string') {
      // Escape quotes and wrap in quotes if needed
      if (value.includes(':') || value.includes('#') || value.includes('\n')) {
        return `"${value.replace(/"/g, '\\"')}"`;
      }
      return value;
    }

    return String(value);
  }

  private detectContentType(
    extracted: IExtractedContent
  ): 'article' | 'blog' | 'news' | 'documentation' | 'other' {
    const url = extracted.metadata.url.toLowerCase();
    const title = extracted.title.toLowerCase();
    const content = extracted.cleanedContent.toLowerCase();

    // Check URL patterns
    if (url.includes('blog') || url.includes('/post/') || url.includes('medium.com')) {
      return 'blog';
    }

    if (url.includes('news') || url.includes('article') || url.includes('story')) {
      return 'news';
    }

    if (
      url.includes('docs') ||
      url.includes('documentation') ||
      url.includes('guide') ||
      url.includes('tutorial')
    ) {
      return 'documentation';
    }

    // Check content patterns
    if (title.includes('how to') || title.includes('tutorial') || title.includes('guide')) {
      return 'documentation';
    }

    if (
      content.includes('breaking:') ||
      content.includes('reuters') ||
      content.includes('associated press')
    ) {
      return 'news';
    }

    // Check structure - articles typically have more structured content
    if (extracted.structure.headings.length > 2 && extracted.structure.paragraphs > 5) {
      return 'article';
    }

    return 'other';
  }
}

/**
 * Utility function for quick bookmarklet content capture
 */
export async function capturePageContent(
  options?: Partial<IBookmarkletCaptureOptions>
): Promise<IBookmarkletCaptureResult> {
  const capture = new BookmarkletContentCapture(options);
  return await capture.captureCurrentPage();
}

/**
 * Utility function for testing bookmarklet functionality on current page
 */
export async function testBookmarkletCapture(): Promise<{
  canExtract: boolean;
  hasContent: boolean;
  contentPreview: string;
  warnings: string[];
  estimatedSize: number;
}> {
  const capture = new BookmarkletContentCapture();
  return await capture.testCapture();
}
