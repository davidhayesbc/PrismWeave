/**
 * Processed document interface
 */
export interface IProcessedDocument {
  filename: string;
  filePath: string;
  folder: string;
  content: string;
  metadata: IDocumentMetadata;
}
// Generated by Copilot
// Content Capture Service - Unified service for content extraction, processing, and capture
// Consolidates ContentExtractionManager, PageCaptureManager, and DocumentProcessor


import {
    ICaptureResult,
    IContentExtractionData,
    IContentExtractionResult,
    IDocumentMetadata,
    ISettings,
} from '../types/index.js';
import { FileManager, IGitHubSettings } from './file-manager.js';
import { createLogger } from './logger.js';
import { SettingsManager } from './settings-manager.js';
import SharedUtils from './shared-utils.js';
// Shared adapters and core
import { BrowserDOMAdapter } from '../shared/adapters/browser-dom-adapter.js';
import { ChromeNotificationProvider } from '../shared/adapters/chrome-notification-adapter.js';
import { ChromeTabProvider } from '../shared/adapters/chrome-tab-provider.js';
import { ContentExtractorCore } from '../shared/core/content-extractor-core.js';

const logger = createLogger('ContentCaptureService');

/**
 * Options for content extraction
 */
export interface IContentExtractor {
  extractContent(tabId: number): Promise<IContentExtractionResult>;
}

/**
 * Options for document processing
 */
export interface IDocumentProcessor {
  processDocument(
    content: string,
    title: string,
    url: string,
    metadata: Record<string, unknown>,
    settings: Partial<ISettings>
  ): IProcessedDocument;
}

/**
 * Capture options interface
 */

export interface ICaptureServiceOptions {
  // Content extraction options
  includeImages?: boolean;
  preserveFormatting?: boolean;
  customSelectors?: string[];
  excludeSelectors?: string[];

  // Capture workflow options
  validateSettings?: boolean;
  includeMarkdown?: boolean;
  forceGitHubCommit?: boolean;
  maxFilenameLength?: number;
  filenamePattern?: string;
}

export class ContentCaptureService {
  private chrome: typeof chrome | undefined;
  // Static properties for timeouts, patterns, and folder mapping
  static readonly SCRIPT_INIT_DELAY = 500;
  static readonly PING_TIMEOUT = 1000;
  static readonly CONTENT_SCRIPT_TIMEOUT = 10000;
  static readonly DEFAULT_FILENAME_PATTERN = 'YYYY-MM-DD-domain-title.md';
  static readonly DEFAULT_FOLDER = 'unsorted';
  static readonly FOLDER_MAPPING: Record<string, string[]> = {
    business: ['business', 'company', 'enterprise', 'startup', 'finance', 'market', 'strategy'],
    news: ['news', 'press', 'update', 'announcement', 'media', 'headline'],
    tech: ['tech', 'technology', 'software', 'hardware', 'programming', 'ai', 'machine learning', 'data', 'cloud', 'javascript', 'typescript', 'python', 'java', 'code', 'coding', 'developer'],
    research: ['research', 'study', 'paper', 'journal', 'science', 'academic', 'experiment'],
    tutorial: ['tutorial', 'how-to', 'guide', 'lesson', 'course', 'walkthrough'],
    tools: ['tool', 'utility', 'app', 'application', 'service', 'platform'],
    reference: ['reference', 'docs', 'documentation', 'manual', 'spec', 'api'],
    unsorted: []
  };
  private fileManager: FileManager;
  private settingsManager: SettingsManager;
  private tabProvider: ChromeTabProvider;
  private notificationProvider: ChromeNotificationProvider;
  private domProvider: BrowserDOMAdapter;
  private contentExtractor: ContentExtractorCore;

  constructor(settingsManager: SettingsManager, chromeApi?: typeof chrome) {
    this.fileManager = new FileManager();
    this.settingsManager = settingsManager;
    this.tabProvider = new ChromeTabProvider();
    this.notificationProvider = new ChromeNotificationProvider();
    this.domProvider = new BrowserDOMAdapter();
    this.contentExtractor = new ContentExtractorCore(this.domProvider);
    // Allow injection of chrome API for testing
    this.chrome = typeof chrome !== 'undefined' ? chrome : chromeApi;
  }

  // =================================================================
  // MAIN CAPTURE WORKFLOW (from PageCaptureManager)
  // =================================================================


  /**
   * Capture and process a page from the active tab
   */
  async capturePage(
    data?: Record<string, unknown>,
    options: ICaptureServiceOptions = {}
  ): Promise<ICaptureResult> {
    try {
      logger.info('Starting page capture workflow with options:', options);

      // Step 1: Validate settings
      logger.debug('Starting settings validation...');
      const shouldValidateSettings = options.validateSettings ?? false;
      const settings = await this.validateAndGetSettings(shouldValidateSettings);
      logger.debug('Settings validation completed successfully');

      // Step 2: Get active tab
      logger.debug('Getting active tab...');
      const activeTab = await this.getActiveTab();
      const tabId = activeTab.id!;
      logger.debug('Active tab obtained:', {
        url: activeTab.url,
        title: activeTab.title,
        id: tabId,
      });

      // Step 3: Extract content or use provided content
      let extractionResult: IContentExtractionResult;

      if (data && data.extractedContent) {
        // Use content provided by caller (e.g., from content script)
        logger.debug('Using pre-extracted content from request data');
        extractionResult = {
          success: true,
          data: data.extractedContent as IContentExtractionData,
          extractionMethod: 'pre-extracted',
          timestamp: new Date().toISOString(),
        };
      } else {
        // Extract content using service worker
        logger.debug('Extracting content via service worker...');
        extractionResult = await this.extractContent(tabId);
      }

      logger.debug('Content extraction result received:', {
        success: extractionResult.success,
        hasData: !!extractionResult.data,
        error: extractionResult.error,
        extractionMethod: extractionResult.extractionMethod,
      });

      if (!extractionResult.success || !extractionResult.data) {
        const errorMsg = extractionResult.error || 'Content extraction failed';
        logger.error('Content extraction failed:', { error: errorMsg, extractionResult });
        throw new Error(errorMsg);
      }

      const { markdown, frontmatter, title, url, metadata } = extractionResult.data;

      logger.debug('Extracted content details:', {
        hasMarkdown: !!markdown,
        markdownLength: markdown?.length || 0,
        hasFrontmatter: !!frontmatter,
        frontmatterLength: frontmatter?.length || 0,
        hasHtml: !!extractionResult.data.html,
        htmlLength: extractionResult.data.html?.length || 0,
        title: title || 'no title',
        url: url || 'no url',
      });

      // Step 4: Validate content
      if (!markdown && !extractionResult.data.html) {
        logger.error('Content validation failed - no markdown and no HTML:', {
          markdown: markdown,
          html: extractionResult.data.html,
          extractionData: extractionResult.data,
        });
        throw new Error('No content extracted from page');
      }

      // Step 5: Process document
      logger.debug('Starting document processing...');
      const finalContent = (frontmatter || '') + (markdown || '');
      logger.debug('Final content prepared:', {
        frontmatterLength: frontmatter?.length || 0,
        markdownLength: markdown?.length || 0,
        finalContentLength: finalContent.length,
      });

      const processedDoc = this.processDocument(
        finalContent,
        title || activeTab.title || 'Untitled',
        url || activeTab.url || '',
        metadata || {},
        settings
      );

      logger.debug('Document processed successfully:', {
        filename: processedDoc.filename,
        folder: processedDoc.folder,
        contentLength: processedDoc.content.length,
      });

      // Step 6: Handle GitHub commit if enabled
      const shouldCommit =
        options.forceGitHubCommit ||
        (settings.autoCommit && settings.githubToken && settings.githubRepo);

      logger.info('üîç GitHub commit decision:', {
        shouldCommit,
        forceGitHubCommit: options.forceGitHubCommit,
        autoCommit: settings.autoCommit,
        hasGithubToken: !!settings.githubToken,
        hasGithubRepo: !!settings.githubRepo,
        githubTokenLength: settings.githubToken?.length || 0,
        githubRepo: settings.githubRepo || 'not set',
      });

      if (shouldCommit) {
        logger.info('‚úÖ Committing to GitHub repository');
        const commitResult = await this.commitToGitHub(processedDoc, settings);

        logger.info('üìä GitHub commit result:', {
          success: commitResult.success,
          url: commitResult.url,
          error: commitResult.error,
        });

        if (commitResult.success) {
          return this.createSuccessResult(processedDoc, {
            message: 'Page captured and committed to repository',
            ...(commitResult.url && { commitUrl: commitResult.url }),
            ...(options.includeMarkdown !== undefined && {
              includeMarkdown: options.includeMarkdown,
            }),
          });
        } else {
          logger.warn('GitHub commit failed, falling back to local storage:', commitResult.error);
        }
      }

      // Step 7: Fallback to local storage
      await this.storeLocally(processedDoc);

      return this.createSuccessResult(processedDoc, {
        message: 'Page captured and stored locally (pending sync)',
        status: 'pending_sync',
        ...(options.includeMarkdown !== undefined && { includeMarkdown: options.includeMarkdown }),
      });
    } catch (error) {
      logger.error('Error in page capture workflow:', error);
      return {
        success: false,
        message: error instanceof Error ? error.message : 'Unknown error occurred',
      };
    }
  }

  /**
   * Capture and process a page from a provided URL (for link capture)
   */
  async captureLink(
    linkUrl: string,
    data?: Record<string, unknown>,
    options: ICaptureServiceOptions = {}
  ): Promise<ICaptureResult> {
    try {
      logger.info('Starting link capture workflow for URL:', linkUrl, 'with options:', options);

      // Step 1: Validate settings
      logger.debug('Starting settings validation...');
      const shouldValidateSettings = options.validateSettings ?? false;
      const settings = await this.validateAndGetSettings(shouldValidateSettings);
      logger.debug('Settings validation completed successfully');

      // Step 2: Create a new tab to extract content from the link
      logger.debug('Creating new tab for link:', linkUrl);
      if (!this.chrome || !this.chrome.tabs || !this.chrome.tabs.create) {
        throw new Error('chrome.tabs.create is not available');
      }
      const newTab = await this.chrome.tabs.create({
        url: linkUrl,
        active: false, // Don't switch to the new tab
      });

      if (!newTab.id) {
        throw new Error('Failed to create tab for link capture');
      }

      try {
        // Wait for the tab to load
        await this.waitForTabToLoad(newTab.id);
        logger.debug('Tab loaded successfully:', newTab.id);

        // Step 3: Extract content from the new tab
        logger.debug('Extracting content from new tab...');
        const extractionResult = await this.extractContent(newTab.id);

        logger.debug('Content extraction result received:', {
          success: extractionResult.success,
          hasData: !!extractionResult.data,
          error: extractionResult.error,
          extractionMethod: extractionResult.extractionMethod,
        });

        if (!extractionResult.success || !extractionResult.data) {
          const errorMsg = extractionResult.error || 'Content extraction failed';
          throw new Error(errorMsg);
        }

        const { markdown, frontmatter, title, url, metadata } = extractionResult.data;

        logger.debug('Extracted content details:', {
          hasMarkdown: !!markdown,
          markdownLength: markdown?.length || 0,
          hasFrontmatter: !!frontmatter,
          frontmatterLength: frontmatter?.length || 0,
          hasHtml: !!extractionResult.data.html,
          htmlLength: extractionResult.data.html?.length || 0,
          title: title || 'no title',
          url: url || 'no url',
        });

        // Step 4: Validate content
        if (!markdown && !extractionResult.data.html) {
          logger.error('Content validation failed - no markdown and no HTML:', {
            markdown: markdown,
            html: extractionResult.data.html,
            extractionData: extractionResult.data,
          });
          throw new Error('No content extracted from link');
        }

        // Step 5: Process document
        logger.debug('Starting document processing...');
        const finalContent = (frontmatter || '') + (markdown || '');
        logger.debug('Final content prepared:', {
          frontmatterLength: frontmatter?.length || 0,
          markdownLength: markdown?.length || 0,
          finalContentLength: finalContent.length,
        });

        const processedDoc = this.processDocument(
          finalContent,
          title || newTab.title || 'Untitled',
          url || linkUrl,
          metadata || {},
          settings
        );

        logger.debug('Document processed successfully:', {
          filename: processedDoc.filename,
          folder: processedDoc.folder,
          contentLength: processedDoc.content.length,
        });

        // Step 6: Handle GitHub commit if enabled
        const shouldCommit =
          options.forceGitHubCommit ||
          (settings.autoCommit && settings.githubToken && settings.githubRepo);

        if (shouldCommit) {
          logger.info('Committing to GitHub repository');
          const commitResult = await this.commitToGitHub(processedDoc, settings);

          if (commitResult.success) {
            return this.createSuccessResult(processedDoc, {
              message: 'Link content captured and committed to repository',
              ...(commitResult.url && { commitUrl: commitResult.url }),
              ...(options.includeMarkdown !== undefined && {
                includeMarkdown: options.includeMarkdown,
              }),
            });
          } else {
            logger.warn('GitHub commit failed, falling back to local storage:', commitResult.error);
          }
        }

        // Step 7: Fallback to local storage
        await this.storeLocally(processedDoc);

        return this.createSuccessResult(processedDoc, {
          message: 'Link content captured and stored locally (pending sync)',
          status: 'pending_sync',
          ...(options.includeMarkdown !== undefined && {
            includeMarkdown: options.includeMarkdown,
          }),
        });
      } finally {
        // Always close the temporary tab
        try {
          if (this.chrome && this.chrome.tabs && this.chrome.tabs.remove) {
            await this.chrome.tabs.remove(newTab.id);
            logger.debug('Temporary tab closed:', newTab.id);
          }
        } catch (error) {
          logger.warn('Failed to close temporary tab:', error);
        }
      }
    } catch (error) {
      logger.error('Error in link capture workflow:', error);
      return {
        success: false,
        message: error instanceof Error ? error.message : 'Unknown error occurred',
      };
    }
  }

  /**
   * Wait for a tab to finish loading
   */
  private async waitForTabToLoad(tabId: number, timeout: number = 30000): Promise<void> {
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        reject(new Error('Tab loading timeout'));
      }, timeout);

      const checkTab = async () => {
        try {
          if (!this.chrome || !this.chrome.tabs || !this.chrome.tabs.get) {
            clearTimeout(timeoutId);
            reject(new Error('chrome.tabs.get is not available'));
            return;
          }
          const tab = await this.chrome.tabs.get(tabId);
          if (tab.status === 'complete') {
            clearTimeout(timeoutId);
            // Add a small delay to ensure content is fully rendered
            setTimeout(resolve, 1000);
          } else {
            setTimeout(checkTab, 500);
          }
        } catch (error) {
          clearTimeout(timeoutId);
          reject(error);
        }
      };

      checkTab();
    });
  }
  async testGitHubConnection(): Promise<unknown> {
    try {
      const settings = await this.settingsManager.getSettings();

      if (!settings.githubToken || !settings.githubRepo) {
        return {
          success: false,
          status: 'failed',
          error: 'GitHub token and repository are required',
          timestamp: new Date().toISOString(),
        };
      }

      const result = await this.fileManager.testGitHubConnection(
        settings.githubToken,
        settings.githubRepo
      );

      return {
        ...result,
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      logger.error('GitHub connection test failed:', error);
      return {
        success: false,
        status: 'failed',
        error: error instanceof Error ? error.message : 'Unknown error occurred',
        timestamp: new Date().toISOString(),
      };
    }
  }

  // =================================================================
  // CONTENT EXTRACTION (from ContentExtractionManager)
  // =================================================================

  /**
   * Main content extraction method with automatic fallback strategy
   */
  async extractContent(tabId: number): Promise<IContentExtractionResult> {
    try {
      logger.info('Starting content extraction for tab:', tabId);

      // Validate tab first
      await this.validateTab(tabId);

      // Strategy 1: Try content script extraction (preferred)
      try {
        await this.ensureContentScriptInjected(tabId);
        await this.delay(ContentCaptureService.SCRIPT_INIT_DELAY);
        return await this.extractContentFromTab(tabId);
      } catch (error) {
        logger.warn('Content script extraction failed, falling back to direct extraction:', error);
      }

      // Strategy 2: Direct extraction fallback
      try {
        return await this.extractContentDirectly(tabId);
      } catch (error) {
        logger.warn('Direct extraction failed, using basic fallback:', error);
      }

      // Strategy 3: Basic fallback (last resort)
      return await this.extractBasicContent(tabId);
    } catch (error) {
      logger.error('All extraction strategies failed:', error);
      throw error;
    }
  }

  // =================================================================
  // DOCUMENT PROCESSING (from DocumentProcessor)
  // =================================================================

  /**
   * Process a document with content, metadata, and settings
   */
  processDocument(
    content: string,
    title: string,
    url: string,
    metadata: Record<string, unknown>,
    settings: Partial<ISettings>
  ): IProcessedDocument {
    logger.debug('Processing document:', {
      title,
      url,
      contentLength: content.length,
      hasSettings: !!settings,
    });

    // Create document metadata
    const docMetadata: IDocumentMetadata = {
      title,
      url,
      captureDate: new Date().toISOString(),
      tags: this.extractTagsFromMetadata(metadata),
    };

    // Add optional metadata fields directly to document metadata
    if (metadata.author && typeof metadata.author === 'string') {
      docMetadata.author = metadata.author;
    }

    if (metadata.wordCount && typeof metadata.wordCount === 'number') {
      docMetadata.wordCount = metadata.wordCount;
    }

    if (metadata.estimatedReadingTime && typeof metadata.estimatedReadingTime === 'number') {
      docMetadata.estimatedReadingTime = metadata.estimatedReadingTime;
    }

    // Generate filename
    const filename = this.generateFileName(
      title,
      url,
      ContentCaptureService.DEFAULT_FILENAME_PATTERN
    );

    // Determine folder
    const folder = this.determineFolder(docMetadata, settings);

    // Build full file path
    const filePath = this.buildFilePath(filename, folder);

    // Prepare final content with frontmatter
    const finalContent = this.prepareContent(content, docMetadata);

    logger.debug('Document processed:', {
      filename,
      folder,
      filePath,
      finalContentLength: finalContent.length,
    });

    return {
      filename,
      filePath,
      folder,
      content: finalContent,
      metadata: docMetadata,
    };
  }

  /**
   * Generate commit message for the document
   */
  generateCommitMessage(metadata: IDocumentMetadata, isUpdate: boolean = false): string {
    const action = isUpdate ? 'Update' : 'Add';
    const domain = this.extractDomain(metadata.url);
    return `${action} captured content: ${metadata.title} (${domain})`;
  }

  // =================================================================
  // PRIVATE METHODS - Content Extraction
  // =================================================================

  private async validateTab(tabId: number): Promise<void> {
    if (!this.chrome || !this.chrome.tabs || !this.chrome.tabs.get) {
      throw new Error('chrome.tabs.get is not available');
    }
    const tab = await this.chrome.tabs.get(tabId);
    if (!tab.url || this.isSpecialPage(tab.url)) {
      throw new Error('Cannot extract content from special pages');
    }
  }

  private isSpecialPage(url: string): boolean {
    const specialPrefixes = [
      'chrome://',
      'chrome-extension://',
      'moz-extension://',
      'edge://',
      'about:',
      'file://',
    ];

    return specialPrefixes.some(prefix => url.startsWith(prefix));
  }

  private async ensureContentScriptInjected(tabId: number): Promise<void> {
    logger.debug('Ensuring content script is injected in tab:', tabId);

    // Check if content script is already available
    if (await this.pingContentScript(tabId)) {
      logger.debug('Content script already active');
      return;
    }

    // Inject TurndownService library first
    await this.injectTurndownLibrary(tabId);

    // Inject content script
    await this.injectContentScript(tabId);
  }

  private async pingContentScript(tabId: number): Promise<boolean> {
    return new Promise<boolean>(resolve => {
      const timeout = setTimeout(() => resolve(false), ContentCaptureService.PING_TIMEOUT);
      if (!this.chrome || !this.chrome.tabs || !this.chrome.tabs.sendMessage) {
        clearTimeout(timeout);
        resolve(false);
        return;
      }
      this.chrome.tabs.sendMessage(tabId, { type: 'PING' }, response => {
        clearTimeout(timeout);
        if (this.chrome && this.chrome.runtime && this.chrome.runtime.lastError) {
          logger.debug(
            'Ping failed (expected if script not injected):',
            this.chrome.runtime.lastError.message
          );
          resolve(false);
        } else {
          resolve(!!response);
        }
      });
    });
  }

  private async injectTurndownLibrary(tabId: number): Promise<void> {
    logger.debug('Injecting TurndownService library...');

    try {
          if (!this.chrome || !this.chrome.scripting || !this.chrome.scripting.executeScript) {
            throw new Error('chrome.scripting.executeScript is not available');
          }
          await this.chrome.scripting.executeScript({
        target: { tabId },
        files: ['libs/turndown.min.js'],
      });
      logger.debug('TurndownService library injected successfully');
    } catch (error) {
      logger.warn('Failed to inject TurndownService library:', error);
    }
  }

  private async injectContentScript(tabId: number): Promise<void> {
    logger.debug('Injecting content script...');

    try {
          if (!this.chrome || !this.chrome.scripting || !this.chrome.scripting.executeScript) {
            throw new Error('chrome.scripting.executeScript is not available');
          }
          await this.chrome.scripting.executeScript({
        target: { tabId },
        files: ['content/content-script.js'],
      });
      logger.debug('Content script injected successfully');
    } catch (error) {
      logger.warn('Failed to inject content script:', error);
      throw new Error('Content script injection failed');
    }
  }

  private async extractContentFromTab(tabId: number): Promise<IContentExtractionResult> {
    return new Promise<IContentExtractionResult>((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('Content extraction timeout after 10 seconds'));
      }, ContentCaptureService.CONTENT_SCRIPT_TIMEOUT);

      logger.debug('Sending EXTRACT_AND_CONVERT message to tab:', tabId);

          if (!this.chrome || !this.chrome.tabs || !this.chrome.tabs.sendMessage) {
            clearTimeout(timeout);
            reject(new Error('chrome.tabs.sendMessage is not available'));
            return;
          }
          this.chrome.tabs.sendMessage(
        tabId,
        {
          type: 'EXTRACT_AND_CONVERT_TO_MARKDOWN',
          data: {
            extractionRules: ['article', 'main', '.content', '#content', 'body'],
            includeImages: true,
            cleanHtml: true,
            convertToMarkdown: true,
          },
        },
        (response: IContentExtractionResult) => {
          clearTimeout(timeout);

          logger.debug('Content script response received:', {
            response: response,
            hasResponse: !!response,
            success: response?.success,
            hasData: !!response?.data,
            dataKeys: response?.data ? Object.keys(response.data) : [],
            error: response?.error,
          });

              if (this.chrome && this.chrome.runtime && this.chrome.runtime.lastError) {
                logger.error('Content script message error:', this.chrome.runtime.lastError?.message);
                reject(new Error(this.chrome.runtime.lastError?.message || 'Unknown error'));
          } else if (!response) {
            logger.error('No response received from content script');
            reject(new Error('No response received from content script'));
          } else if (!response.success) {
            logger.error('Content script reported failure:', response.error);
            reject(new Error(response.error || 'Content extraction failed'));
          } else {
            logger.debug('Content extraction and conversion successful via content script', {
              hasMarkdown: !!response.data?.markdown,
              markdownLength: response.data?.markdown?.length || 0,
              hasHtml: !!response.data?.html,
              htmlLength: response.data?.html?.length || 0,
            });
            resolve(response);
          }
        }
      );
    });
  }

  private async extractContentDirectly(tabId: number): Promise<IContentExtractionResult> {
    logger.debug('Extracting content directly from tab:', tabId);
    if (!this.chrome || !this.chrome.scripting || !this.chrome.scripting.executeScript) {
      throw new Error('chrome.scripting.executeScript is not available');
    }
    const results = await this.chrome.scripting.executeScript({
      target: { tabId },
      func: this.directExtractionScript,
    });
    if (!results || results.length === 0 || !results[0].result) {
      throw new Error('Failed to execute extraction script');
    }
    const extractedData = results[0].result;
    logger.debug('Direct extraction completed successfully');
    return {
      success: true,
      data: {
        html: extractedData.html,
        title: extractedData.title,
        url: extractedData.url,
        metadata: extractedData.metadata,
      },
      extractionMethod: 'direct',
      timestamp: new Date().toISOString(),
    };
  }

  private directExtractionScript = () => {
    const getPageTitle = (): string => {
      return document.title || 'Untitled';
    };

    const getPageUrl = (): string => {
      return window.location.href;
    };

    const extractMainContent = (): string => {
      const contentSelectors = [
        'article',
        '[role="article"]',
        'main',
        '[role="main"]',
        '.content',
        '#content',
        '.post-content',
        '.entry-content',
        '.article-content',
        '.page-content',
      ];

      let contentElement: Element | null = null;
      for (const selector of contentSelectors) {
        contentElement = document.querySelector(selector);
        if (
          contentElement &&
          contentElement.textContent &&
          contentElement.textContent.trim().length > 100
        ) {
          break;
        }
      }

      if (!contentElement) {
        contentElement = document.body;
      }

      return contentElement?.innerHTML || document.body.innerHTML;
    };

    const extractMetadata = (): Record<string, string> => {
      const metadata: Record<string, string> = {};

      const metaTags = document.querySelectorAll('meta');
      metaTags.forEach(meta => {
        const name = meta.getAttribute('name') || meta.getAttribute('property');
        const content = meta.getAttribute('content');
        if (name && content) {
          metadata[name] = content;
        }
      });

      return metadata;
    };

    return {
      title: getPageTitle(),
      url: getPageUrl(),
      html: extractMainContent(),
      metadata: extractMetadata(),
    };
  };

  private async extractBasicContent(tabId: number): Promise<IContentExtractionResult> {
    logger.warn('Using basic content extraction fallback');
    if (!this.chrome || !this.chrome.tabs || !this.chrome.tabs.get) {
      throw new Error('chrome.tabs.get is not available');
    }
    const tab = await this.chrome.tabs.get(tabId);
    const basicContent = `# ${tab.title || 'Untitled'}\n\nContent extraction failed. Only basic page information is available.\n\n**URL:** ${tab.url || 'Unknown'}\n**Captured:** ${new Date().toISOString()}`;
    return {
      success: true,
      data: {
        markdown: basicContent,
        frontmatter: this.generateBasicFrontmatter(tab.title, tab.url),
        html: `<h1>${tab.title || 'Untitled'}</h1><p>Content extraction failed. Only basic page information is available.</p><p>URL: ${tab.url || 'Unknown'}</p>`,
        title: tab.title || 'Untitled',
        url: tab.url || '',
        metadata: {
          extractedAt: new Date().toISOString(),
          method: 'basic-fallback',
          error: 'Content extraction failed',
        },
        images: [],
      },
      extractionMethod: 'basic-fallback',
      timestamp: new Date().toISOString(),
    };
  }

  // =================================================================
  // PRIVATE METHODS - Document Processing
  // =================================================================

  private generateFileName(
    title: string,
    url: string,
    pattern: string = ContentCaptureService.DEFAULT_FILENAME_PATTERN
  ): string {
    try {
      logger.debug('Generating filename:', { title, url, pattern });

      // Extract components
      const date = SharedUtils.formatDateForFilename();
      const domain = SharedUtils.sanitizeDomain(this.extractDomain(url));
      let sanitizedTitle = SharedUtils.sanitizeForFilename(title, 50);
      
      // Remove .md extension from title to avoid double extension
      if (sanitizedTitle.endsWith('-md')) {
        sanitizedTitle = sanitizedTitle.slice(0, -3);
      }

      // Build filename using pattern
      let filename = pattern
        .replace(/YYYY-MM-DD/g, date)
        .replace(/domain/g, domain)
        .replace(/title/g, sanitizedTitle);

      // Don't sanitize the complete filename as it would remove the .md extension
      // Instead, just ensure proper format
      if (!filename.endsWith('.md')) {
        filename += '.md';
      }

      logger.debug('Generated filename:', filename);
      return filename;
    } catch (error) {
      logger.error('Error generating filename:', error);
      const fallback = `capture-${Date.now()}.md`;
      logger.debug('Using fallback filename:', fallback);
      return fallback;
    }
  }

  private determineFolder(metadata: IDocumentMetadata, settings: Partial<ISettings>): string {
    logger.debug('Determining folder for document:', {
      title: metadata.title,
      url: metadata.url,
      tags: metadata.tags,
      defaultFolder: settings.defaultFolder,
    });

    // Use explicit folder setting if provided
    if (
      settings.defaultFolder &&
      settings.defaultFolder !== 'auto' &&
      settings.defaultFolder !== 'custom'
    ) {
      logger.debug('Using explicit folder setting:', settings.defaultFolder);
      return settings.defaultFolder;
    }

    // Use custom folder if specified
    if (settings.defaultFolder === 'custom' && settings.customFolder) {
      const sanitized = SharedUtils.sanitizeForFilename(settings.customFolder);
      logger.debug('Using custom folder:', sanitized);
      return sanitized;
    }

    // Auto-detect folder based on content
    const detected = this.autoDetectFolder(metadata);
    const final = detected || ContentCaptureService.DEFAULT_FOLDER;

    logger.debug('Auto-detected folder:', { detected, final });
    return final;
  }

  private autoDetectFolder(metadata: IDocumentMetadata): string | null {
    const searchText = [
      metadata.title.toLowerCase(),
      metadata.url.toLowerCase(),
      ...metadata.tags.map(tag => tag.toLowerCase()),
    ].join(' ');

    // Score each folder based on keyword matches
    const folderScores: Record<string, number> = {};

    Object.entries(ContentCaptureService.FOLDER_MAPPING).forEach(([folder, keywords]) => {
      let score = 0;
      keywords.forEach(keyword => {
        const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
        const matches = searchText.match(regex);
        if (matches) {
          score += matches.length;
        }
      });

      if (score > 0) {
        // Give tech folder bonus points for programming-related content
        if (folder === 'tech' && /(javascript|programming|code|coding|developer)/i.test(searchText)) {
          score += 0.5; // Small bonus to break ties in favor of tech
        }
        folderScores[folder] = score;
      }
    });

    // Return folder with highest score
    const bestFolder = Object.entries(folderScores).sort(([, a], [, b]) => b - a)[0];

    return bestFolder ? bestFolder[0] : null;
  }

  private buildFilePath(filename: string, folder: string): string {
    const documentPath = 'documents';
    const cleanFolder = folder.replace(/^\/+|\/+$/g, '');
    const cleanFilename = filename.replace(/^\/+/, '');

    return `${documentPath}/${cleanFolder}/${cleanFilename}`;
  }

  private prepareContent(content: string, metadata: IDocumentMetadata): string {
    const frontmatter = this.generateFrontmatter(metadata);
    return `${frontmatter}\n${content}`;
  }

  private generateFrontmatter(metadata: IDocumentMetadata): string {
    const frontmatterData: Record<string, unknown> = {
      title: metadata.title,
      url: metadata.url,
      captured: metadata.captureDate,
      tags: metadata.tags,
    };

    // Add optional metadata fields
    if (metadata.author) {
      frontmatterData.author = metadata.author;
    }

    if (metadata.wordCount) {
      frontmatterData.wordCount = metadata.wordCount;
    }

    if (metadata.estimatedReadingTime) {
      frontmatterData.readingTime = `${metadata.estimatedReadingTime} min`;
    }

    let frontmatter = '---\n';

    Object.entries(frontmatterData).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        frontmatter += `${key}:\n`;
        value.forEach(item => {
          frontmatter += `  - ${item}\n`;
        });
      } else {
        frontmatter += `${key}: ${SharedUtils.formatYamlValue(value)}\n`;
      }
    });

    frontmatter += '---';
    return frontmatter;
  }

  private extractTagsFromMetadata(metadata: Record<string, unknown>): string[] {
    const tags: string[] = [];

    // Extract keywords from common metadata fields
    const keywordFields = ['keywords', 'description', 'author', 'category', 'tags'];

    keywordFields.forEach(field => {
      const value = metadata[field];
      if (typeof value === 'string') {
        // Split by common delimiters and clean up
        const extractedTags = value
          .split(/[,;|]/)
          .map(tag => tag.trim().toLowerCase())
          .filter(tag => tag.length > 2 && tag.length < 30);
        tags.push(...extractedTags);
      }
    });

    return [...new Set(tags)]; // Remove duplicates
  }

  private extractDomain(url: string): string {
    try {
      const urlObj = new URL(url);
      return urlObj.hostname.replace(/^www\./, '');
    } catch {
      return 'unknown';
    }
  }

  // =================================================================
  // PRIVATE METHODS - Capture Workflow
  // =================================================================

  private async validateAndGetSettings(shouldValidate: boolean): Promise<ISettings> {
    logger.debug('üîß Getting settings, shouldValidate:', shouldValidate);
    const settings = await this.settingsManager.getSettings();
    
    logger.info('‚öôÔ∏è Current settings loaded:', {
      hasGithubToken: !!settings.githubToken,
      tokenLength: settings.githubToken?.length || 0,
      hasGithubRepo: !!settings.githubRepo,
      githubRepo: settings.githubRepo || 'not set',
      autoCommit: settings.autoCommit,
      shouldValidate,
    });

    if (shouldValidate) {
      logger.debug('‚úÖ Validating settings...');
      const validation = this.settingsManager.validateSettings(settings);
      logger.info('üìã Settings validation result:', {
        isValid: validation.isValid,
        errors: validation.errors,
      });
      if (!validation.isValid) {
        throw new Error(`Invalid settings: ${validation.errors.join(', ')}`);
      }
    }

    return settings as ISettings;
  }

  private async getActiveTab(): Promise<chrome.tabs.Tab> {
    if (!this.chrome || !this.chrome.tabs || !this.chrome.tabs.query) {
      throw new Error('chrome.tabs.query is not available');
    }
    const tabs = await this.chrome.tabs.query({ active: true, currentWindow: true });
    if (!tabs.length || !tabs[0].id) {
      throw new Error('No active tab found');
    }
    return tabs[0];
  }

  private async commitToGitHub(processedDoc: IProcessedDocument, settings: ISettings) {
    logger.info('üöÄ commitToGitHub called with:', {
      filePath: processedDoc.filePath,
      contentLength: processedDoc.content.length,
      hasToken: !!settings.githubToken,
      tokenLength: settings.githubToken?.length || 0,
      repository: settings.githubRepo,
    });

    const githubSettings: IGitHubSettings = {
      token: settings.githubToken!,
      repository: settings.githubRepo!,
      branch: 'main',
    };

    logger.info('üì° Calling fileManager.saveToGitHub...');
    const result = await this.fileManager.saveToGitHub(
      processedDoc.content,
      processedDoc.metadata,
      githubSettings
    );
    
    logger.info('üìä fileManager.saveToGitHub result:', {
      success: result.success,
      url: result.url,
      error: result.error,
      filePath: result.filePath,
    });

    return result;
  }

  private async storeLocally(processedDoc: IProcessedDocument): Promise<void> {
    const storageKey = `pending_capture_${Date.now()}`;
    if (!this.chrome || !this.chrome.storage || !this.chrome.storage.local || !this.chrome.storage.local.set) {
      throw new Error('chrome.storage.local.set is not available');
    }
    await this.chrome.storage.local.set({
      [storageKey]: {
        filePath: processedDoc.filePath,
        content: processedDoc.content,
        title: processedDoc.metadata.title,
        url: processedDoc.metadata.url,
        timestamp: new Date().toISOString(),
      },
    });
    logger.debug('Document stored locally with key:', storageKey);
  }

  private createSuccessResult(
    processedDoc: IProcessedDocument,
    options: {
      message: string;
      commitUrl?: string;
      status?: string;
      includeMarkdown?: boolean;
    }
  ): ICaptureResult {
    const result: ICaptureResult = {
      success: true,
      message: options.message,
      data: {
        filename: processedDoc.filename,
        filePath: processedDoc.filePath,
        title: processedDoc.metadata.title,
        url: processedDoc.metadata.url,
        markdownLength: processedDoc.content.length,
        timestamp: new Date().toISOString(),
      },
    };

    // Add optional fields
    if (options.commitUrl) {
      result.data!.commitUrl = options.commitUrl;
    }

    if (options.status) {
      result.data!.status = options.status;
    }

    if (options.includeMarkdown) {
      result.data!.markdown = processedDoc.content;
    }

    return result;
  }

  private generateBasicFrontmatter(title?: string, url?: string): string {
    return [
      '---',
      `title: "${(title || 'Untitled').replace(/"/g, '\\"')}"`,
      `url: "${url || ''}"`,
      `capture_date: "${new Date().toISOString()}"`,
      'source: "PrismWeave Browser Extension"',
      'tags: ["web-capture", "fallback"]',
      '---',
      '',
    ].join('\n');
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
