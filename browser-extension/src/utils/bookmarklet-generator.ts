// Generated by Copilot
// Bookmarklet generator utility for PrismWeave browser extension

export interface IBookmarkletConfig {
  githubToken: string;
  githubRepo: string;
  defaultFolder?: string;
  customFolder?: string;
  fileNamingPattern?: string;
  commitMessageTemplate?: string;
  captureImages?: boolean;
  removeAds?: boolean;
  removeNavigation?: boolean;
}

export interface IBookmarkletGenerationOptions {
  minify?: boolean;
  includeDebugInfo?: boolean;
  customDomain?: string;
  version?: string;
}

export class BookmarkletGenerator {
  private static readonly BOOKMARKLET_VERSION = '1.0.0';
  private static readonly MAX_BOOKMARKLET_LENGTH = 15000; // Modern browsers support longer URLs

  /**
   * Encode configuration as URL parameters for short bookmarklet
   */
  private static encodeConfigAsParams(config: IBookmarkletConfig): string {
    const params = new URLSearchParams();
    
    // Encode essential config as URL parameters
    if (config.githubToken) params.set('token', config.githubToken);
    if (config.githubRepo) params.set('repo', config.githubRepo);
    if (config.defaultFolder) params.set('folder', config.defaultFolder);
    if (config.commitMessageTemplate) params.set('msgTpl', config.commitMessageTemplate);
    
    // Boolean flags as single characters to save space
    if (config.captureImages === false) params.set('noImg', '1');
    if (config.removeAds === true) params.set('noAds', '1');
    if (config.removeNavigation === true) params.set('noNav', '1');
    
    return params.toString();
  }

  /**
   * Generate a short loader-style bookmarklet that loads the main script
   */
  static generateBookmarklet(
    config: IBookmarkletConfig,
    options: IBookmarkletGenerationOptions = {}
  ): string {
    const baseUrl = options.customDomain || 'https://davidhayesbc.github.io/PrismWeave';
    const version = options.version || this.BOOKMARKLET_VERSION;
    
    // Create a short loader that loads the main script with encoded config
    const configParams = this.encodeConfigAsParams(config);
    const loaderScript = `
(function(){
  if(window.prismweaveBookmarklet){
    window.prismweaveBookmarklet.show();
    return;
  }
  var s=document.createElement('script');
  s.src='${baseUrl}/bookmarklet.js?v=${version}&${configParams}';
  s.onload=function(){
    if(window.PrismWeaveBookmarklet){
      window.prismweaveBookmarklet=new window.PrismWeaveBookmarklet();
      window.prismweaveBookmarklet.init();
    }
  };
  document.head.appendChild(s);
})()`;

    const minifiedScript = options.minify !== false ? this.minifyScript(loaderScript) : loaderScript;
    const bookmarklet = `javascript:${minifiedScript}`;

    // This should be much shorter now
    if (bookmarklet.length > 2000) { // Much lower limit for short bookmarklets
      throw new Error(
        `Generated bookmarklet is too long (${bookmarklet.length} chars). Maximum is 2000 chars for short bookmarklets.`
      );
    }

    return bookmarklet;
  }

  /**
   * Generate a static bookmarklet script that will be served at the baseUrl
   * This method creates the main script that gets loaded by the short bookmarklet
   */
  static generateMainBookmarkletScript(): string {
    return `
// PrismWeave Bookmarklet Main Script v${this.BOOKMARKLET_VERSION}

// Parse configuration from URL parameters
function parseConfigFromUrl() {
  const script = document.querySelector('script[src*="bookmarklet.js"]');
  if (!script || !script.src) return {};
  
  const url = new URL(script.src);
  const params = url.searchParams;
  
  return {
    githubToken: params.get('token') || '',
    githubRepo: params.get('repo') || '',
    defaultFolder: params.get('folder') || 'documents',
    commitMessageTemplate: params.get('msgTpl') || 'Add captured content: {title}',
    captureImages: params.get('noImg') !== '1',
    removeAds: params.get('noAds') === '1',
    removeNavigation: params.get('noNav') === '1'
  };
}

${this.generateRuntimeScript()}

// Initialize with config from URL parameters
const config = parseConfigFromUrl();
window.PrismWeaveBookmarklet = function() {
  return new PrismweaveBookmarkletRuntime(config);
};

console.log('PrismWeave Bookmarklet Main Script loaded with config:', config);
`;
  }

  /**
   * Generate the runtime script that will be injected
   */
  private static generateRuntimeScript(): string {
    return `
class PrismweaveBookmarkletRuntime {
  constructor(config) {
    this.config = config;
    this.isVisible = false;
    this.overlay = null;
    this.STORAGE_KEY = 'prismweave_bookmarklet_config';
    this.EXTENSION_ID = 'your-extension-id'; // Will be replaced during build
    
    // Store config using extension storage API for true cross-domain persistence
    this.storeConfig(config);
  }

  init() {
    this.createOverlay();
    this.show();
  }

  // Store configuration using browser extension storage API for cross-domain persistence
  storeConfig(config) {
    try {
      // Try to use browser extension storage API for true cross-domain persistence
      if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.sendMessage) {
        chrome.runtime.sendMessage(this.EXTENSION_ID, {
          type: 'STORE_BOOKMARKLET_CONFIG',
          config: config
        }, (response) => {
          if (chrome.runtime.lastError) {
            console.warn('PrismWeave: Extension storage failed, falling back to localStorage:', chrome.runtime.lastError.message);
            this.fallbackStoreConfig(config);
          } else {
            console.log('PrismWeave: Configuration stored via extension storage');
          }
        });
      } else {
        // Fallback to localStorage with domain isolation warning
        console.warn('PrismWeave: Extension not available, using localStorage (domain-isolated)');
        this.fallbackStoreConfig(config);
      }
    } catch (error) {
      console.warn('PrismWeave: Extension communication failed, using localStorage fallback:', error);
      this.fallbackStoreConfig(config);
    }
  }

  // Fallback storage method (domain-isolated)
  fallbackStoreConfig(config) {
    try {
      const storedConfig = {
        ...config,
        lastUpdated: new Date().toISOString(),
        version: '1.0.0',
        storageMethod: 'localStorage' // Track which storage method was used
      };
      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(storedConfig));
      console.log('PrismWeave: Configuration stored in localStorage (domain-isolated)');
    } catch (error) {
      console.warn('PrismWeave: Failed to store configuration in localStorage:', error);
      // Fallback to session storage if localStorage is not available
      try {
        sessionStorage.setItem(this.STORAGE_KEY, JSON.stringify(config));
        console.log('PrismWeave: Configuration stored in sessionStorage as final fallback');
      } catch (sessionError) {
        console.error('PrismWeave: Failed to store configuration in any storage:', sessionError);
      }
    }
  }

  // Load configuration with extension storage API priority
  loadStoredConfig() {
    return new Promise((resolve) => {
      try {
        // Try to use browser extension storage API first
        if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.sendMessage) {
          chrome.runtime.sendMessage(this.EXTENSION_ID, {
            type: 'GET_BOOKMARKLET_CONFIG'
          }, (response) => {
            if (chrome.runtime.lastError || !response) {
              console.warn('PrismWeave: Extension storage unavailable, falling back to localStorage');
              resolve(this.fallbackLoadConfig());
            } else {
              console.log('PrismWeave: Configuration loaded from extension storage');
              resolve(response.config || {});
            }
          });
        } else {
          // Fallback to localStorage
          resolve(this.fallbackLoadConfig());
        }
      } catch (error) {
        console.warn('PrismWeave: Extension communication failed, using localStorage fallback:', error);
        resolve(this.fallbackLoadConfig());
      }
    });
  }

  // Fallback config loading (domain-isolated)
  fallbackLoadConfig() {
    try {
      const stored = localStorage.getItem(this.STORAGE_KEY) || sessionStorage.getItem(this.STORAGE_KEY);
      if (stored) {
        const config = JSON.parse(stored);
        console.log('PrismWeave: Configuration loaded from localStorage (domain-isolated)');
        return config;
      }
    } catch (error) {
      console.warn('PrismWeave: Failed to load stored configuration:', error);
    }
    return {};
  }

  // Get effective configuration (extension storage > stored config > embedded config)
  async getEffectiveConfig() {
    const storedConfig = await this.loadStoredConfig();
    if (storedConfig && storedConfig.githubToken && storedConfig.githubRepo) {
      console.log('PrismWeave: Using stored configuration from ' + (storedConfig.storageMethod || 'extension storage'));
      return storedConfig;
    }
    console.log('PrismWeave: Using embedded configuration');
    return this.config;
  }

  show() {
    if (this.overlay) {
      this.overlay.style.display = 'block';
      this.isVisible = true;
    }
  }

  hide() {
    if (this.overlay) {
      this.overlay.style.display = 'none';
      this.isVisible = false;
    }
  }

  createOverlay() {
    // Remove existing overlay if present
    const existing = document.getElementById('prismweave-bookmarklet');
    if (existing) {
      existing.remove();
    }

    // Create overlay container
    this.overlay = document.createElement('div');
    this.overlay.id = 'prismweave-bookmarklet';
    this.overlay.innerHTML = this.getOverlayHTML();
    this.addOverlayStyles();
    
    document.body.appendChild(this.overlay);
    this.bindEvents();
  }

  getOverlayHTML() {
    return \`
      <div class="prismweave-modal">
        <div class="prismweave-header">
          <h3>PrismWeave Content Capture</h3>
          <button class="prismweave-close" title="Close">&times;</button>
        </div>
        <div class="prismweave-content">
          <div class="prismweave-status" id="prismweave-status">
            <div class="prismweave-icon">📄</div>
            <div class="prismweave-message">Ready to capture content from this page</div>
          </div>
          <div id="prismweave-config-info" class="prismweave-config-info" style="display:none;">
            <div class="prismweave-config-status">
              <span id="config-source">Using stored configuration</span>
              <button id="update-config-btn" class="prismweave-link-btn" title="Update settings">⚙️</button>
            </div>
          </div>
          <div class="prismweave-actions">
            <button class="prismweave-btn prismweave-btn-primary" id="prismweave-capture">
              Capture Page
            </button>
            <button class="prismweave-btn" id="prismweave-settings" title="Update Settings">
              Settings
            </button>
            <button class="prismweave-btn" id="prismweave-cancel">
              Cancel
            </button>
          </div>
        </div>
      </div>
    \`;
  }

  addOverlayStyles() {
    const styles = \`
      #prismweave-bookmarklet {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.7);
        z-index: 999999;
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      }
      
      .prismweave-modal {
        background: white;
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        width: 90%;
        max-width: 400px;
        animation: prismweaveSlideIn 0.3s ease-out;
      }
      
      @keyframes prismweaveSlideIn {
        from { transform: translateY(-20px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
      }
      
      .prismweave-header {
        padding: 16px 20px;
        border-bottom: 1px solid #e5e5e5;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .prismweave-header h3 {
        margin: 0;
        font-size: 18px;
        font-weight: 600;
        color: #333;
      }
      
      .prismweave-close {
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        color: #666;
        padding: 0;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .prismweave-close:hover {
        color: #333;
      }
      
      .prismweave-content {
        padding: 20px;
      }
      
      .prismweave-status {
        display: flex;
        align-items: center;
        margin-bottom: 20px;
        padding: 12px;
        background: #f8f9fa;
        border-radius: 6px;
      }
      
      .prismweave-icon {
        font-size: 24px;
        margin-right: 12px;
      }
      
      .prismweave-message {
        font-size: 14px;
        color: #666;
      }
      
      .prismweave-actions {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
      }
      
      .prismweave-btn {
        padding: 8px 16px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: white;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
      }
      
      .prismweave-btn:hover {
        background: #f5f5f5;
      }
      
      .prismweave-btn-primary {
        background: #007cba;
        color: white;
        border-color: #007cba;
      }
      
      .prismweave-btn-primary:hover {
        background: #006ba1;
      }
      
      .prismweave-config-info {
        padding: 8px 12px;
        background: #f0f8ff;
        border: 1px solid #b3d9ff;
        border-radius: 4px;
        margin-bottom: 16px;
        font-size: 12px;
      }
      
      .prismweave-config-status {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .prismweave-link-btn {
        background: none;
        border: none;
        cursor: pointer;
        font-size: 14px;
        padding: 2px;
        border-radius: 2px;
      }
      
      .prismweave-link-btn:hover {
        background: rgba(0, 0, 0, 0.1);
      }
      
      .prismweave-settings-panel {
        background: white;
        border: 1px solid #ddd;
        border-radius: 6px;
        padding: 16px;
        margin: 12px 0;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
      }
      
      .prismweave-form-group {
        margin-bottom: 12px;
      }
      
      .prismweave-form-group label {
        display: block;
        font-size: 12px;
        font-weight: 500;
        margin-bottom: 4px;
        color: #333;
      }
      
      .prismweave-form-group input, .prismweave-form-group select {
        width: 100%;
        padding: 6px 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 13px;
      }
      
      .prismweave-form-group input:focus, .prismweave-form-group select:focus {
        outline: none;
        border-color: #007cba;
        box-shadow: 0 0 0 2px rgba(0, 124, 186, 0.2);
      }
      
      .prismweave-progress {
        width: 100%;
        height: 4px;
        background: #e5e5e5;
        border-radius: 2px;
        overflow: hidden;
        margin: 10px 0;
      }
      
      .prismweave-progress-bar {
        height: 100%;
        background: #007cba;
        width: 0%;
        transition: width 0.3s ease;
      }
    \`;
    
    const styleElement = document.createElement('style');
    styleElement.textContent = styles;
    document.head.appendChild(styleElement);
  }

  bindEvents() {
    const closeBtn = this.overlay.querySelector('.prismweave-close');
    const cancelBtn = this.overlay.querySelector('#prismweave-cancel');
    const captureBtn = this.overlay.querySelector('#prismweave-capture');
    const settingsBtn = this.overlay.querySelector('#prismweave-settings');
    const updateConfigBtn = this.overlay.querySelector('#update-config-btn');
    
    closeBtn.addEventListener('click', () => this.hide());
    cancelBtn.addEventListener('click', () => this.hide());
    captureBtn.addEventListener('click', () => this.captureContent());
    settingsBtn.addEventListener('click', () => this.showSettingsPanel());
    if (updateConfigBtn) {
      updateConfigBtn.addEventListener('click', () => this.showSettingsPanel());
    }
    
    // Show config info if we have stored settings
    this.updateConfigInfo();
    
    // Close on overlay click
    this.overlay.addEventListener('click', (e) => {
      if (e.target === this.overlay) {
        this.hide();
      }
    });
    
    // Close on Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && this.isVisible) {
        this.hide();
      }
    });
  }

  async updateConfigInfo() {
    const configInfo = this.overlay.querySelector('#prismweave-config-info');
    const configSource = this.overlay.querySelector('#config-source');
    const storedConfig = await this.loadStoredConfig();
    
    if (storedConfig && storedConfig.githubToken && storedConfig.githubRepo) {
      configInfo.style.display = 'block';
      const repoDisplay = storedConfig.githubRepo.length > 30 ? 
        storedConfig.githubRepo.substring(0, 30) + '...' : 
        storedConfig.githubRepo;
      const storageMethod = storedConfig.storageMethod || 'extension storage';
      configSource.textContent = \`Using stored config for \${repoDisplay} (\${storageMethod})\`;
    } else if (this.config.githubToken && this.config.githubRepo) {
      configInfo.style.display = 'block';
      const repoDisplay = this.config.githubRepo.length > 30 ? 
        this.config.githubRepo.substring(0, 30) + '...' : 
        this.config.githubRepo;
      configSource.textContent = \`Using embedded config for \${repoDisplay}\`;
    }
  }

  showSettingsPanel() {
    this.getEffectiveConfig().then(currentConfig => {
    
    // Create settings form
    const settingsHTML = \`
      <div class="prismweave-settings-panel" id="settings-panel">
        <h4 style="margin: 0 0 12px 0; font-size: 14px;">Bookmarklet Settings</h4>
        
        <div class="prismweave-form-group">
          <label for="settings-github-token">GitHub Token</label>
          <input type="password" id="settings-github-token" value="\${currentConfig.githubToken || ''}" 
                 placeholder="ghp_xxxxxxxxxxxxxxxxxxxxx">
        </div>
        
        <div class="prismweave-form-group">
          <label for="settings-github-repo">GitHub Repository</label>
          <input type="text" id="settings-github-repo" value="\${currentConfig.githubRepo || ''}" 
                 placeholder="username/repository-name">
        </div>
        
        <div class="prismweave-form-group">
          <label for="settings-default-folder">Default Folder</label>
          <select id="settings-default-folder">
            <option value="documents" \${currentConfig.defaultFolder === 'documents' ? 'selected' : ''}>documents</option>
            <option value="unsorted" \${currentConfig.defaultFolder === 'unsorted' ? 'selected' : ''}>unsorted</option>
            <option value="tech" \${currentConfig.defaultFolder === 'tech' ? 'selected' : ''}>tech</option>
            <option value="business" \${currentConfig.defaultFolder === 'business' ? 'selected' : ''}>business</option>
            <option value="research" \${currentConfig.defaultFolder === 'research' ? 'selected' : ''}>research</option>
            <option value="news" \${currentConfig.defaultFolder === 'news' ? 'selected' : ''}>news</option>
          </select>
        </div>
        
        <div class="prismweave-actions" style="margin-top: 16px;">
          <button class="prismweave-btn prismweave-btn-primary" id="save-settings">
            Save Settings
          </button>
          <button class="prismweave-btn" id="cancel-settings">
            Cancel
          </button>
          <button class="prismweave-btn" id="clear-stored-settings" title="Clear stored settings">
            Clear Stored
          </button>
          <button class="prismweave-btn" id="test-cross-domain-storage" title="Test cross-domain storage functionality">
            Test Storage
          </button>
        </div>
      </div>
    \`;
    
    // Insert settings panel before actions
    const actionsDiv = this.overlay.querySelector('.prismweave-actions');
    const existingPanel = this.overlay.querySelector('#settings-panel');
    if (existingPanel) {
      existingPanel.remove();
    }
    
    actionsDiv.insertAdjacentHTML('beforebegin', settingsHTML);
    
    // Bind settings events
    this.bindSettingsEvents();
    });
  }

  bindSettingsEvents() {
    const saveBtn = this.overlay.querySelector('#save-settings');
    const cancelBtn = this.overlay.querySelector('#cancel-settings');
    const clearBtn = this.overlay.querySelector('#clear-stored-settings');
    
    saveBtn.addEventListener('click', () => this.saveSettings());
    cancelBtn.addEventListener('click', () => this.hideSettingsPanel());
    clearBtn.addEventListener('click', () => this.clearStoredSettings());
    
    // Add test storage button event listener
    const testBtn = this.overlay.querySelector('#test-cross-domain-storage');
    if (testBtn) {
      testBtn.addEventListener('click', () => this.testCrossDomainStorage());
    }
  }

  saveSettings() {
    const token = this.overlay.querySelector('#settings-github-token').value.trim();
    const repo = this.overlay.querySelector('#settings-github-repo').value.trim();
    const folder = this.overlay.querySelector('#settings-default-folder').value;
    
    if (!token || !repo) {
      this.updateStatus('⚠️', 'GitHub token and repository are required', false);
      return;
    }
    
    // Validate repository format
    if (!/^[\\w\\-\\.]+\/[\\w\\-\\.]+$/.test(repo)) {
      this.updateStatus('⚠️', 'Repository must be in format: owner/repo', false);
      return;
    }
    
    const newConfig = {
      ...this.config,
      githubToken: token,
      githubRepo: repo,
      defaultFolder: folder,
      lastUpdated: new Date().toISOString()
    };
    
    this.storeConfig(newConfig);
    this.config = newConfig; // Update current session config
    
    this.updateStatus('✅', 'Settings saved successfully! (Cross-domain storage)', false);
    this.hideSettingsPanel();
    this.updateConfigInfo();
    
    setTimeout(() => {
      this.updateStatus('📄', 'Ready to capture content from this page', false);
    }, 2000);
  }

  hideSettingsPanel() {
    const panel = this.overlay.querySelector('#settings-panel');
    if (panel) {
      panel.remove();
    }
  }

  async testCrossDomainStorage() {
    try {
      this.updateStatus('🧪', 'Testing cross-domain storage...', false);

      // Dynamic import of the test module
      const testModule = await import('./cross-domain-storage-test');
      const tester = new testModule.CrossDomainStorageTest();
      
      const results = await tester.runFullTestSuite();
      
      if (results.overallSuccess) {
        this.updateStatus('✅', 'All storage tests passed (' + results.tests.length + ' tests)', false);
        console.log('📊 Cross-domain storage test results:', results);
      } else {
        const passedCount = results.tests.filter(t => t.success).length;
        this.updateStatus('⚠️', 'Some storage tests failed (' + passedCount + '/' + results.tests.length + ' passed)', false);
        console.warn('📊 Cross-domain storage test results:', results);
      }

      // Show detailed results in console
      console.log(results.summary);
      
      return results;
    } catch (error) {
      this.updateStatus('❌', 'Storage test failed to run', false);
      console.error('Error running cross-domain storage test:', error);
      return null;
    }
  }

  clearStoredSettings() {
      // Clear extension storage first
      if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.sendMessage) {
        chrome.runtime.sendMessage(this.EXTENSION_ID, {
          type: 'CLEAR_BOOKMARKLET_CONFIG'
        }, (response) => {
          if (!chrome.runtime.lastError) {
            console.log('PrismWeave: Extension storage cleared');
          }
        });
      }
      
      // Also clear fallback storage
      localStorage.removeItem(this.STORAGE_KEY);
      sessionStorage.removeItem(this.STORAGE_KEY);
      
      this.updateStatus('🗑️', 'All stored settings cleared (cross-domain)', false);
      this.hideSettingsPanel();
      this.updateConfigInfo();
      
      setTimeout(() => {
        this.updateStatus('📄', 'Ready to capture content from this page', false);
      }, 2000);
    } catch (error) {
      this.updateStatus('❌', 'Failed to clear all settings', false);
    }
  }
    
    // Close on overlay click
    this.overlay.addEventListener('click', (e) => {
      if (e.target === this.overlay) {
        this.hide();
      }
    });
    
    // Close on Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && this.isVisible) {
        this.hide();
      }
    });
  }

  async captureContent() {
    try {
      this.updateStatus('📥', 'Extracting content from page...', true);
      
      // Extract content using DOM-based approach
      const content = await this.extractPageContent();
      
      this.updateStatus('💾', 'Processing and saving content...', true);
      
      // Save to GitHub
      const result = await this.saveToGitHub(content);
      
      if (result.success) {
        this.updateStatus('✅', \`Content saved successfully! \${result.filename || ''}\`, false);
        setTimeout(() => this.hide(), 3000);
      } else {
        this.updateStatus('❌', \`Save failed: \${result.error}\`, false);
      }
      
    } catch (error) {
      this.updateStatus('❌', \`Error: \${error.message}\`, false);
    }
  }

  updateStatus(icon, message, showProgress) {
    const statusEl = this.overlay.querySelector('#prismweave-status');
    const iconEl = statusEl.querySelector('.prismweave-icon');
    const messageEl = statusEl.querySelector('.prismweave-message');
    
    iconEl.textContent = icon;
    messageEl.textContent = message;
    
    // Remove existing progress bar
    const existingProgress = statusEl.querySelector('.prismweave-progress');
    if (existingProgress) {
      existingProgress.remove();
    }
    
    // Add progress bar if needed
    if (showProgress) {
      const progressBar = document.createElement('div');
      progressBar.className = 'prismweave-progress';
      progressBar.innerHTML = '<div class="prismweave-progress-bar"></div>';
      statusEl.appendChild(progressBar);
      
      // Animate progress
      setTimeout(() => {
        const bar = progressBar.querySelector('.prismweave-progress-bar');
        bar.style.width = '100%';
      }, 100);
    }
  }

  extractPageContent() {
    // Get page title
    const title = document.title || 'Untitled';
    const url = window.location.href;
    
    // Find main content using semantic selectors
    const contentSelectors = [
      'article',
      'main',
      '[role="main"]',
      '.content',
      '.post',
      '.entry',
      '#content',
      '#main',
      '.main-content'
    ];
    
    let contentElement = null;
    for (const selector of contentSelectors) {
      contentElement = document.querySelector(selector);
      if (contentElement && contentElement.textContent.trim().length > 100) {
        break;
      }
    }
    
    // Fallback to body if no specific content found
    if (!contentElement) {
      contentElement = document.body;
    }
    
    // Clean content
    const cleanedContent = this.cleanContent(contentElement.cloneNode(true));
    
    // Convert to markdown
    const markdown = this.htmlToMarkdown(cleanedContent.innerHTML);
    
    // Generate frontmatter
    const frontmatter = this.generateFrontmatter(title, url);
    
    return {
      title,
      url,
      markdown,
      frontmatter,
      content: frontmatter + '\\n\\n' + markdown
    };
  }

  cleanContent(element) {
    // Remove unwanted elements
    const unwantedSelectors = [
      'script', 'style', 'nav', 'header', 'footer',
      '.advertisement', '.ad', '.ads', '.popup', '.modal',
      '.social-share', '.comments', '.related-posts'
    ];
    
    unwantedSelectors.forEach(selector => {
      const elements = element.querySelectorAll(selector);
      elements.forEach(el => el.remove());
    });
    
    return element;
  }

  htmlToMarkdown(html) {
    // Basic HTML to Markdown conversion
    let markdown = html;
    
    // Headers
    markdown = markdown.replace(/<h([1-6])[^>]*>(.*?)<\\/h[1-6]>/gi, (match, level, content) => {
      const headerLevel = '#'.repeat(parseInt(level));
      return \`\\n\${headerLevel} \${this.stripHtml(content).trim()}\\n\`;
    });
    
    // Paragraphs
    markdown = markdown.replace(/<p[^>]*>(.*?)<\\/p>/gi, '\\n$1\\n');
    
    // Bold/Strong
    markdown = markdown.replace(/<(strong|b)[^>]*>(.*?)<\\/(strong|b)>/gi, '**$2**');
    
    // Italic/Emphasis
    markdown = markdown.replace(/<(em|i)[^>]*>(.*?)<\\/(em|i)>/gi, '*$2*');
    
    // Links
    if (this.config.captureImages !== false) {
      markdown = markdown.replace(/<a[^>]*href=["']([^"']*)["'][^>]*>(.*?)<\\/a>/gi, '[$2]($1)');
    }
    
    // Line breaks
    markdown = markdown.replace(/<br[^>]*\\/?>/gi, '\\n');
    
    // Strip remaining HTML
    markdown = this.stripHtml(markdown);
    
    // Clean up whitespace
    markdown = markdown.replace(/\\n\\s*\\n\\s*\\n/g, '\\n\\n');
    
    return markdown.trim();
  }

  stripHtml(html) {
    return html.replace(/<[^>]*>/g, '').trim();
  }

  generateFrontmatter(title, url) {
    const now = new Date();
    const dateStr = now.toISOString().split('T')[0];
    
    return \`---
title: "\${title.replace(/"/g, '\\"')}"
url: "\${url}"
date: "\${dateStr}"
captured: "\${now.toISOString()}"
tags: []
---\`;
  }

  async saveToGitHub(content) {
    // Use effective configuration (stored config takes precedence)
    const effectiveConfig = this.getEffectiveConfig();
    const { githubToken, githubRepo } = effectiveConfig;
    
    if (!githubToken || !githubRepo) {
      throw new Error('GitHub token and repository must be configured. Please click Settings to configure.');
    }
    
    // Generate filename
    const timestamp = new Date().toISOString().split('T')[0];
    const titleSlug = content.title
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '')
      .substring(0, 50);
    
    const filename = \`\${timestamp}-\${titleSlug}.md\`;
    const filePath = effectiveConfig.defaultFolder ? 
      \`\${effectiveConfig.defaultFolder}/\${filename}\` : 
      \`documents/\${filename}\`;
    
    // Commit to GitHub
    const [owner, repo] = githubRepo.split('/');
    const apiUrl = \`https://api.github.com/repos/\${owner}/\${repo}/contents/\${filePath}\`;
    
    const commitData = {
      message: effectiveConfig.commitMessageTemplate ? 
        effectiveConfig.commitMessageTemplate
          .replace('{title}', content.title)
          .replace('{domain}', new URL(content.url).hostname) :
        \`Add captured content: \${content.title}\`,
      content: btoa(unescape(encodeURIComponent(content.content))),
      branch: 'main'
    };
    
    const response = await fetch(apiUrl, {
      method: 'PUT',
      headers: {
        'Authorization': \`token \${githubToken}\`,
        'Content-Type': 'application/json',
        'User-Agent': 'PrismWeave-Bookmarklet'
      },
      body: JSON.stringify(commitData)
    });
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(\`GitHub API error: \${error.message || response.statusText}\`);
    }
    
    const result = await response.json();
    return {
      success: true,
      filename,
      url: result.content.html_url
    };
  }
}

// Make runtime available globally
window.prismweaveBookmarkletRuntime = PrismweaveBookmarkletRuntime;
`;
  }

  /**
   * Minify JavaScript code for bookmarklet
   */
  private static minifyScript(script: string): string {
    return script
      .replace(/\/\*[\s\S]*?\*\//g, '') // Remove multi-line comments
      .replace(/\/\/.*$/gm, '') // Remove single-line comments
      .replace(/\s+/g, ' ') // Replace multiple whitespace with single space
      .replace(/;\s*}/g, '}') // Remove semicolons before closing braces
      .replace(/\s*{\s*/g, '{') // Remove spaces around opening braces
      .replace(/\s*}\s*/g, '}') // Remove spaces around closing braces
      .replace(/\s*;\s*/g, ';') // Remove spaces around semicolons
      .replace(/\s*,\s*/g, ',') // Remove spaces around commas
      .trim();
  }

  /**
   * Generate a user-friendly bookmarklet name
   */
  static generateBookmarkletName(config: IBookmarkletConfig): string {
    const repoName = config.githubRepo.split('/')[1] || 'repository';
    return `PrismWeave → ${repoName}`;
  }

  /**
   * Generate installation instructions for the bookmarklet
   */
  static generateInstallationInstructions(bookmarkletCode: string, name: string): string {
    return `
## Install PrismWeave Bookmarklet

### Step 1: Copy the Bookmarklet
Click the button below to copy the bookmarklet code to your clipboard.

### Step 2: Create a New Bookmark
1. Right-click on your browser's bookmark bar
2. Select "Add page..." or "Add bookmark..."
3. Set the name to: **${name}**
4. Set the URL to the copied bookmarklet code
5. Save the bookmark

### Step 3: Use the Bookmarklet
1. Navigate to any webpage you want to capture
2. Click the "${name}" bookmark
3. The PrismWeave capture dialog will appear
4. Click "Capture Page" to save the content to your GitHub repository

### Troubleshooting
- Make sure your GitHub token has write access to the repository
- The bookmarklet works on most websites, but some may block it due to security policies
- If the bookmarklet doesn't appear, try refreshing the page and clicking again
`;
  }

  /**
   * Validate bookmarklet configuration
   */
  static validateConfig(config: IBookmarkletConfig): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (!config.githubToken || config.githubToken.trim().length === 0) {
      errors.push('GitHub token is required');
    }

    if (!config.githubRepo || config.githubRepo.trim().length === 0) {
      errors.push('GitHub repository is required');
    } else if (!/^[\w\-\.]+\/[\w\-\.]+$/.test(config.githubRepo)) {
      errors.push('GitHub repository must be in format: owner/repo');
    }

    if (config.githubToken && config.githubToken.length < 20) {
      errors.push('GitHub token appears to be invalid (too short)');
    }

    return {
      isValid: errors.length === 0,
      errors,
    };
  }
}
