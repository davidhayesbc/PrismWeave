// Generated by Copilot
// Bookmarklet generator utility for PrismWeave browser extension

export interface IBookmarkletConfig {
  githubToken: string;
  githubRepo: string;
  defaultFolder?: string;
  customFolder?: string;
  fileNamingPattern?: string;
  commitMessageTemplate?: string;
  captureImages?: boolean;
  removeAds?: boolean;
  removeNavigation?: boolean;
}

export interface IBookmarkletGenerationOptions {
  minify?: boolean;
  includeDebugInfo?: boolean;
  customDomain?: string;
  version?: string;
}

export class BookmarkletGenerator {
  private static readonly BOOKMARKLET_VERSION = '1.0.0';
  private static readonly MAX_BOOKMARKLET_LENGTH = 2000; // URL length limit

  /**
   * Generate a complete bookmarklet JavaScript code
   */
  static generateBookmarklet(
    config: IBookmarkletConfig,
    options: IBookmarkletGenerationOptions = {}
  ): string {
    const coreScript = this.generateCoreScript(config, options);
    const minifiedScript = options.minify !== false ? this.minifyScript(coreScript) : coreScript;

    // Wrap in bookmarklet format
    const bookmarklet = `javascript:(${minifiedScript})();`;

    // Check length constraints
    if (bookmarklet.length > this.MAX_BOOKMARKLET_LENGTH) {
      throw new Error(
        `Generated bookmarklet is too long (${bookmarklet.length} chars). Maximum is ${this.MAX_BOOKMARKLET_LENGTH} chars.`
      );
    }

    return bookmarklet;
  }

  /**
   * Generate the core bookmarklet functionality
   */
  private static generateCoreScript(
    config: IBookmarkletConfig,
    options: IBookmarkletGenerationOptions
  ): string {
    const configJson = JSON.stringify(config);
    const version = options.version || this.BOOKMARKLET_VERSION;

    return `
function() {
  // PrismWeave Bookmarklet v${version}
  if (window.prismweaveBookmarklet) {
    window.prismweaveBookmarklet.show();
    return;
  }

  const config = ${configJson};
  
  // Create and inject the bookmarklet runtime
  const script = document.createElement('script');
  script.textContent = \`
    ${this.generateRuntimeScript()}
  \`;
  
  document.head.appendChild(script);
  
  // Initialize the bookmarklet
  setTimeout(() => {
    if (window.prismweaveBookmarkletRuntime) {
      window.prismweaveBookmarklet = new window.prismweaveBookmarkletRuntime(config);
      window.prismweaveBookmarklet.init();
    }
  }, 100);
}`;
  }

  /**
   * Generate the runtime script that will be injected
   */
  private static generateRuntimeScript(): string {
    return `
class PrismweaveBookmarkletRuntime {
  constructor(config) {
    this.config = config;
    this.isVisible = false;
    this.overlay = null;
  }

  init() {
    this.createOverlay();
    this.show();
  }

  show() {
    if (this.overlay) {
      this.overlay.style.display = 'block';
      this.isVisible = true;
    }
  }

  hide() {
    if (this.overlay) {
      this.overlay.style.display = 'none';
      this.isVisible = false;
    }
  }

  createOverlay() {
    // Remove existing overlay if present
    const existing = document.getElementById('prismweave-bookmarklet');
    if (existing) {
      existing.remove();
    }

    // Create overlay container
    this.overlay = document.createElement('div');
    this.overlay.id = 'prismweave-bookmarklet';
    this.overlay.innerHTML = this.getOverlayHTML();
    this.addOverlayStyles();
    
    document.body.appendChild(this.overlay);
    this.bindEvents();
  }

  getOverlayHTML() {
    return \`
      <div class="prismweave-modal">
        <div class="prismweave-header">
          <h3>PrismWeave Content Capture</h3>
          <button class="prismweave-close" title="Close">&times;</button>
        </div>
        <div class="prismweave-content">
          <div class="prismweave-status" id="prismweave-status">
            <div class="prismweave-icon">üìÑ</div>
            <div class="prismweave-message">Ready to capture content from this page</div>
          </div>
          <div class="prismweave-actions">
            <button class="prismweave-btn prismweave-btn-primary" id="prismweave-capture">
              Capture Page
            </button>
            <button class="prismweave-btn" id="prismweave-cancel">
              Cancel
            </button>
          </div>
        </div>
      </div>
    \`;
  }

  addOverlayStyles() {
    const styles = \`
      #prismweave-bookmarklet {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.7);
        z-index: 999999;
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      }
      
      .prismweave-modal {
        background: white;
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        width: 90%;
        max-width: 400px;
        animation: prismweaveSlideIn 0.3s ease-out;
      }
      
      @keyframes prismweaveSlideIn {
        from { transform: translateY(-20px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
      }
      
      .prismweave-header {
        padding: 16px 20px;
        border-bottom: 1px solid #e5e5e5;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .prismweave-header h3 {
        margin: 0;
        font-size: 18px;
        font-weight: 600;
        color: #333;
      }
      
      .prismweave-close {
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        color: #666;
        padding: 0;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .prismweave-close:hover {
        color: #333;
      }
      
      .prismweave-content {
        padding: 20px;
      }
      
      .prismweave-status {
        display: flex;
        align-items: center;
        margin-bottom: 20px;
        padding: 12px;
        background: #f8f9fa;
        border-radius: 6px;
      }
      
      .prismweave-icon {
        font-size: 24px;
        margin-right: 12px;
      }
      
      .prismweave-message {
        font-size: 14px;
        color: #666;
      }
      
      .prismweave-actions {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
      }
      
      .prismweave-btn {
        padding: 8px 16px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: white;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
      }
      
      .prismweave-btn:hover {
        background: #f5f5f5;
      }
      
      .prismweave-btn-primary {
        background: #007cba;
        color: white;
        border-color: #007cba;
      }
      
      .prismweave-btn-primary:hover {
        background: #006ba1;
      }
      
      .prismweave-progress {
        width: 100%;
        height: 4px;
        background: #e5e5e5;
        border-radius: 2px;
        overflow: hidden;
        margin: 10px 0;
      }
      
      .prismweave-progress-bar {
        height: 100%;
        background: #007cba;
        width: 0%;
        transition: width 0.3s ease;
      }
    \`;
    
    const styleElement = document.createElement('style');
    styleElement.textContent = styles;
    document.head.appendChild(styleElement);
  }

  bindEvents() {
    const closeBtn = this.overlay.querySelector('.prismweave-close');
    const cancelBtn = this.overlay.querySelector('#prismweave-cancel');
    const captureBtn = this.overlay.querySelector('#prismweave-capture');
    
    closeBtn.addEventListener('click', () => this.hide());
    cancelBtn.addEventListener('click', () => this.hide());
    captureBtn.addEventListener('click', () => this.captureContent());
    
    // Close on overlay click
    this.overlay.addEventListener('click', (e) => {
      if (e.target === this.overlay) {
        this.hide();
      }
    });
    
    // Close on Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && this.isVisible) {
        this.hide();
      }
    });
  }

  async captureContent() {
    try {
      this.updateStatus('üì•', 'Extracting content from page...', true);
      
      // Extract content using DOM-based approach
      const content = await this.extractPageContent();
      
      this.updateStatus('üíæ', 'Processing and saving content...', true);
      
      // Save to GitHub
      const result = await this.saveToGitHub(content);
      
      if (result.success) {
        this.updateStatus('‚úÖ', \`Content saved successfully! \${result.filename || ''}\`, false);
        setTimeout(() => this.hide(), 3000);
      } else {
        this.updateStatus('‚ùå', \`Save failed: \${result.error}\`, false);
      }
      
    } catch (error) {
      this.updateStatus('‚ùå', \`Error: \${error.message}\`, false);
    }
  }

  updateStatus(icon, message, showProgress) {
    const statusEl = this.overlay.querySelector('#prismweave-status');
    const iconEl = statusEl.querySelector('.prismweave-icon');
    const messageEl = statusEl.querySelector('.prismweave-message');
    
    iconEl.textContent = icon;
    messageEl.textContent = message;
    
    // Remove existing progress bar
    const existingProgress = statusEl.querySelector('.prismweave-progress');
    if (existingProgress) {
      existingProgress.remove();
    }
    
    // Add progress bar if needed
    if (showProgress) {
      const progressBar = document.createElement('div');
      progressBar.className = 'prismweave-progress';
      progressBar.innerHTML = '<div class="prismweave-progress-bar"></div>';
      statusEl.appendChild(progressBar);
      
      // Animate progress
      setTimeout(() => {
        const bar = progressBar.querySelector('.prismweave-progress-bar');
        bar.style.width = '100%';
      }, 100);
    }
  }

  extractPageContent() {
    // Get page title
    const title = document.title || 'Untitled';
    const url = window.location.href;
    
    // Find main content using semantic selectors
    const contentSelectors = [
      'article',
      'main',
      '[role="main"]',
      '.content',
      '.post',
      '.entry',
      '#content',
      '#main',
      '.main-content'
    ];
    
    let contentElement = null;
    for (const selector of contentSelectors) {
      contentElement = document.querySelector(selector);
      if (contentElement && contentElement.textContent.trim().length > 100) {
        break;
      }
    }
    
    // Fallback to body if no specific content found
    if (!contentElement) {
      contentElement = document.body;
    }
    
    // Clean content
    const cleanedContent = this.cleanContent(contentElement.cloneNode(true));
    
    // Convert to markdown
    const markdown = this.htmlToMarkdown(cleanedContent.innerHTML);
    
    // Generate frontmatter
    const frontmatter = this.generateFrontmatter(title, url);
    
    return {
      title,
      url,
      markdown,
      frontmatter,
      content: frontmatter + '\\n\\n' + markdown
    };
  }

  cleanContent(element) {
    // Remove unwanted elements
    const unwantedSelectors = [
      'script', 'style', 'nav', 'header', 'footer',
      '.advertisement', '.ad', '.ads', '.popup', '.modal',
      '.social-share', '.comments', '.related-posts'
    ];
    
    unwantedSelectors.forEach(selector => {
      const elements = element.querySelectorAll(selector);
      elements.forEach(el => el.remove());
    });
    
    return element;
  }

  htmlToMarkdown(html) {
    // Basic HTML to Markdown conversion
    let markdown = html;
    
    // Headers
    markdown = markdown.replace(/<h([1-6])[^>]*>(.*?)<\\/h[1-6]>/gi, (match, level, content) => {
      const headerLevel = '#'.repeat(parseInt(level));
      return \`\\n\${headerLevel} \${this.stripHtml(content).trim()}\\n\`;
    });
    
    // Paragraphs
    markdown = markdown.replace(/<p[^>]*>(.*?)<\\/p>/gi, '\\n$1\\n');
    
    // Bold/Strong
    markdown = markdown.replace(/<(strong|b)[^>]*>(.*?)<\\/(strong|b)>/gi, '**$2**');
    
    // Italic/Emphasis
    markdown = markdown.replace(/<(em|i)[^>]*>(.*?)<\\/(em|i)>/gi, '*$2*');
    
    // Links
    if (this.config.captureImages !== false) {
      markdown = markdown.replace(/<a[^>]*href=["']([^"']*)["'][^>]*>(.*?)<\\/a>/gi, '[$2]($1)');
    }
    
    // Line breaks
    markdown = markdown.replace(/<br[^>]*\\/?>/gi, '\\n');
    
    // Strip remaining HTML
    markdown = this.stripHtml(markdown);
    
    // Clean up whitespace
    markdown = markdown.replace(/\\n\\s*\\n\\s*\\n/g, '\\n\\n');
    
    return markdown.trim();
  }

  stripHtml(html) {
    return html.replace(/<[^>]*>/g, '').trim();
  }

  generateFrontmatter(title, url) {
    const now = new Date();
    const dateStr = now.toISOString().split('T')[0];
    
    return \`---
title: "\${title.replace(/"/g, '\\"')}"
url: "\${url}"
date: "\${dateStr}"
captured: "\${now.toISOString()}"
tags: []
---\`;
  }

  async saveToGitHub(content) {
    const { githubToken, githubRepo } = this.config;
    
    if (!githubToken || !githubRepo) {
      throw new Error('GitHub token and repository must be configured');
    }
    
    // Generate filename
    const timestamp = new Date().toISOString().split('T')[0];
    const titleSlug = content.title
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '')
      .substring(0, 50);
    
    const filename = \`\${timestamp}-\${titleSlug}.md\`;
    const filePath = this.config.defaultFolder ? 
      \`\${this.config.defaultFolder}/\${filename}\` : 
      \`documents/\${filename}\`;
    
    // Commit to GitHub
    const [owner, repo] = githubRepo.split('/');
    const apiUrl = \`https://api.github.com/repos/\${owner}/\${repo}/contents/\${filePath}\`;
    
    const commitData = {
      message: \`Add captured content: \${content.title}\`,
      content: btoa(unescape(encodeURIComponent(content.content))),
      branch: 'main'
    };
    
    const response = await fetch(apiUrl, {
      method: 'PUT',
      headers: {
        'Authorization': \`token \${githubToken}\`,
        'Content-Type': 'application/json',
        'User-Agent': 'PrismWeave-Bookmarklet'
      },
      body: JSON.stringify(commitData)
    });
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(\`GitHub API error: \${error.message || response.statusText}\`);
    }
    
    const result = await response.json();
    return {
      success: true,
      filename,
      url: result.content.html_url
    };
  }
}

// Make runtime available globally
window.prismweaveBookmarkletRuntime = PrismweaveBookmarkletRuntime;
`;
  }

  /**
   * Minify JavaScript code for bookmarklet
   */
  private static minifyScript(script: string): string {
    return script
      .replace(/\/\*[\s\S]*?\*\//g, '') // Remove multi-line comments
      .replace(/\/\/.*$/gm, '') // Remove single-line comments
      .replace(/\s+/g, ' ') // Replace multiple whitespace with single space
      .replace(/;\s*}/g, '}') // Remove semicolons before closing braces
      .replace(/\s*{\s*/g, '{') // Remove spaces around opening braces
      .replace(/\s*}\s*/g, '}') // Remove spaces around closing braces
      .replace(/\s*;\s*/g, ';') // Remove spaces around semicolons
      .replace(/\s*,\s*/g, ',') // Remove spaces around commas
      .trim();
  }

  /**
   * Generate a user-friendly bookmarklet name
   */
  static generateBookmarkletName(config: IBookmarkletConfig): string {
    const repoName = config.githubRepo.split('/')[1] || 'repository';
    return `PrismWeave ‚Üí ${repoName}`;
  }

  /**
   * Generate installation instructions for the bookmarklet
   */
  static generateInstallationInstructions(bookmarkletCode: string, name: string): string {
    return `
## Install PrismWeave Bookmarklet

### Step 1: Copy the Bookmarklet
Click the button below to copy the bookmarklet code to your clipboard.

### Step 2: Create a New Bookmark
1. Right-click on your browser's bookmark bar
2. Select "Add page..." or "Add bookmark..."
3. Set the name to: **${name}**
4. Set the URL to the copied bookmarklet code
5. Save the bookmark

### Step 3: Use the Bookmarklet
1. Navigate to any webpage you want to capture
2. Click the "${name}" bookmark
3. The PrismWeave capture dialog will appear
4. Click "Capture Page" to save the content to your GitHub repository

### Troubleshooting
- Make sure your GitHub token has write access to the repository
- The bookmarklet works on most websites, but some may block it due to security policies
- If the bookmarklet doesn't appear, try refreshing the page and clicking again
`;
  }

  /**
   * Validate bookmarklet configuration
   */
  static validateConfig(config: IBookmarkletConfig): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (!config.githubToken || config.githubToken.trim().length === 0) {
      errors.push('GitHub token is required');
    }

    if (!config.githubRepo || config.githubRepo.trim().length === 0) {
      errors.push('GitHub repository is required');
    } else if (!/^[\w\-\.]+\/[\w\-\.]+$/.test(config.githubRepo)) {
      errors.push('GitHub repository must be in format: owner/repo');
    }

    if (config.githubToken && config.githubToken.length < 20) {
      errors.push('GitHub token appears to be invalid (too short)');
    }

    return {
      isValid: errors.length === 0,
      errors,
    };
  }
}
