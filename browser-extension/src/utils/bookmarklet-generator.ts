// Generated by Copilot
// Bookmarklet generator utility for PrismWeave browser extension

export interface IBookmarkletConfig {
  githubToken: string;
  githubRepo: string;
  defaultFolder?: string;
  customFolder?: string;
  fileNamingPattern?: string;
  commitMessageTemplate?: string;
  captureImages?: boolean;
  removeAds?: boolean;
  removeNavigation?: boolean;
}

export interface IBookmarkletGenerationOptions {
  minify?: boolean;
  includeDebugInfo?: boolean;
  customDomain?: string;
  version?: string;
}

export class BookmarkletGenerator {
  private static readonly BOOKMARKLET_VERSION = '1.0.0';
  private static readonly MAX_BOOKMARKLET_LENGTH = 15000; // Modern browsers support longer URLs

  /**
   * Encode configuration as URL parameters for short bookmarklet
   */
  private static encodeConfigAsParams(config: IBookmarkletConfig): string {
    const params = new URLSearchParams();

    // Encode essential config as URL parameters
    if (config.githubToken) params.set('token', config.githubToken);
    if (config.githubRepo) params.set('repo', config.githubRepo);
    if (config.defaultFolder) params.set('folder', config.defaultFolder);
    if (config.commitMessageTemplate) params.set('msgTpl', config.commitMessageTemplate);

    // Boolean flags as single characters to save space
    if (config.captureImages === false) params.set('noImg', '1');
    if (config.removeAds === true) params.set('noAds', '1');
    if (config.removeNavigation === true) params.set('noNav', '1');

    return params.toString();
  }

  /**
   * Generate a short loader-style bookmarklet that loads the main script
   */
  static generateBookmarklet(
    config: IBookmarkletConfig,
    options: IBookmarkletGenerationOptions = {}
  ): string {
    const baseUrl = options.customDomain || 'https://davidhayesbc.github.io/PrismWeave';
    const version = options.version || this.BOOKMARKLET_VERSION;

    // Create a short loader that loads the main script with encoded config
    const configParams = this.encodeConfigAsParams(config);
    const loaderScript = `(function(){
  if(window.prismweaveBookmarklet){
    window.prismweaveBookmarklet.show();
    return;
  }
  var s=document.createElement('script');
  s.src='${baseUrl}/bookmarklet.js?v=${version}&${configParams}';
  s.onload=function(){
    if(window.PrismWeaveBookmarklet){
      window.prismweaveBookmarklet=new window.PrismWeaveBookmarklet();
      window.prismweaveBookmarklet.init();
    }
  };
  document.head.appendChild(s);
})();`;

    const processedScript =
      options.minify !== false ? this.minifyScript(loaderScript) : loaderScript;
    const bookmarklet = `javascript:${processedScript}`;

    // Validate length for reasonable bookmarklet size
    if (bookmarklet.length > 15000) {
      // Use original test limit
      throw new Error(
        `Generated bookmarklet is too long (${bookmarklet.length} chars). Maximum is 15000 chars.`
      );
    }

    return bookmarklet;
  }

  /**
   * Generate a static bookmarklet script that will be served at the baseUrl
   * This method creates the main script that gets loaded by the short bookmarklet
   */
  static generateMainBookmarkletScript(): string {
    return `
// PrismWeave Bookmarklet Main Script v${this.BOOKMARKLET_VERSION}

// Parse configuration from URL parameters
function parseConfigFromUrl() {
  const script = document.querySelector('script[src*="bookmarklet.js"]');
  if (!script || !script.src) return {};
  
  const url = new URL(script.src);
  const params = url.searchParams;
  
  return {
    githubToken: params.get('token') || '',
    githubRepo: params.get('repo') || '',
    defaultFolder: params.get('folder') || 'documents',
    commitMessageTemplate: params.get('msgTpl') || 'Add captured content: {title}',
    captureImages: params.get('noImg') !== '1',
    removeAds: params.get('noAds') === '1',
    removeNavigation: params.get('noNav') === '1'
  };
}

${this.generateRuntimeScript()}

// Initialize with config from URL parameters
const config = parseConfigFromUrl();
window.PrismWeaveBookmarklet = function() {
  return new PrismweaveBookmarkletRuntime(config);
};

console.log('PrismWeave Bookmarklet Main Script loaded with config:', config);
`;
  }

  /**
   * Generate the runtime script that will be injected
   */
  private static generateRuntimeScript(): string {
    return `
class PrismweaveBookmarkletRuntime {
  constructor(config) {
    this.config = config;
    this.isVisible = false;
    this.overlay = null;
    this.STORAGE_KEY = 'prismweave_bookmarklet_config';
    this.EXTENSION_ID = 'your-extension-id'; // Will be replaced during build
    
    // Store config using extension storage API for true cross-domain persistence
    this.storeConfig(config);
  }

  init() {
    this.createOverlay();
    this.show();
  }

  // Store configuration using browser extension storage API for cross-domain persistence
  storeConfig(config) {
    try {
      // Try to use browser extension storage API for true cross-domain persistence
      if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.sendMessage) {
        chrome.runtime.sendMessage(this.EXTENSION_ID, {
          type: 'STORE_BOOKMARKLET_CONFIG',
          config: config
        }, (response) => {
          if (chrome.runtime.lastError) {
            console.warn('PrismWeave: Extension storage failed, falling back to localStorage:', chrome.runtime.lastError.message);
            this.fallbackStoreConfig(config);
          } else {
            console.log('PrismWeave: Configuration stored via extension storage');
          }
        });
      } else {
        // Fallback to localStorage with domain isolation warning
        console.warn('PrismWeave: Extension not available, using localStorage (domain-isolated)');
        this.fallbackStoreConfig(config);
      }
    } catch (error) {
      console.warn('PrismWeave: Extension communication failed, using localStorage fallback:', error);
      this.fallbackStoreConfig(config);
    }
  }

  // Fallback storage method (domain-isolated)
  fallbackStoreConfig(config) {
    try {
      const storedConfig = {
        ...config,
        lastUpdated: new Date().toISOString(),
        version: '1.0.0',
        storageMethod: 'localStorage' // Track which storage method was used
      };
      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(storedConfig));
      console.log('PrismWeave: Configuration stored in localStorage (domain-isolated)');
    } catch (error) {
      console.warn('PrismWeave: Failed to store configuration in localStorage:', error);
      // Fallback to session storage if localStorage is not available
      try {
        sessionStorage.setItem(this.STORAGE_KEY, JSON.stringify(config));
        console.log('PrismWeave: Configuration stored in sessionStorage as final fallback');
      } catch (sessionError) {
        console.error('PrismWeave: Failed to store configuration in any storage:', sessionError);
      }
    }
  }

  // Load configuration with extension storage API priority
  loadStoredConfig() {
    return new Promise((resolve) => {
      try {
        // Try to use browser extension storage API first
        if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.sendMessage) {
          chrome.runtime.sendMessage(this.EXTENSION_ID, {
            type: 'GET_BOOKMARKLET_CONFIG'
          }, (response) => {
            if (chrome.runtime.lastError || !response) {
              console.warn('PrismWeave: Extension storage unavailable, falling back to localStorage');
              resolve(this.fallbackLoadConfig());
            } else {
              console.log('PrismWeave: Configuration loaded from extension storage');
              resolve(response.config || {});
            }
          });
        } else {
          // Fallback to localStorage
          resolve(this.fallbackLoadConfig());
        }
      } catch (error) {
        console.warn('PrismWeave: Extension communication failed, using localStorage fallback:', error);
        resolve(this.fallbackLoadConfig());
      }
    });
  }

  // Fallback config loading (domain-isolated)
  fallbackLoadConfig() {
    try {
      const stored = localStorage.getItem(this.STORAGE_KEY) || sessionStorage.getItem(this.STORAGE_KEY);
      if (stored) {
        const config = JSON.parse(stored);
        console.log('PrismWeave: Configuration loaded from localStorage (domain-isolated)');
        return config;
      }
    } catch (error) {
      console.warn('PrismWeave: Failed to load stored configuration:', error);
    }
    return {};
  }

  // Get effective configuration (extension storage > stored config > embedded config)
  async getEffectiveConfig() {
    const storedConfig = await this.loadStoredConfig();
    if (storedConfig && storedConfig.githubToken && storedConfig.githubRepo) {
      console.log('PrismWeave: Using stored configuration from ' + (storedConfig.storageMethod || 'extension storage'));
      return storedConfig;
    }
    console.log('PrismWeave: Using embedded configuration');
    return this.config;
  }

  show() {
    if (this.overlay) {
      this.overlay.style.display = 'block';
      this.isVisible = true;
    }
  }

  hide() {
    if (this.overlay) {
      this.overlay.style.display = 'none';
      this.isVisible = false;
    }
  }

  createOverlay() {
    // Remove existing overlay if present
    const existing = document.getElementById('prismweave-bookmarklet');
    if (existing) {
      existing.remove();
    }

    // Create overlay container
    this.overlay = document.createElement('div');
    this.overlay.id = 'prismweave-bookmarklet';
    this.overlay.innerHTML = this.getOverlayHTML();
    this.addOverlayStyles();
    
    document.body.appendChild(this.overlay);
    this.bindEvents();
  }

  getOverlayHTML() {
    return \`
      <div class="prismweave-modal">
        <div class="prismweave-header">
          <h3>PrismWeave Content Capture</h3>
          <button class="prismweave-close" title="Close">&times;</button>
        </div>
        <div class="prismweave-content">
          <div class="prismweave-status" id="prismweave-status">
            <div class="prismweave-icon">üìÑ</div>
            <div class="prismweave-message">Ready to capture content from this page</div>
          </div>
          <div id="prismweave-config-info" class="prismweave-config-info" style="display:none;">
            <div class="prismweave-config-status">
              <span id="config-source">Using stored configuration</span>
              <button id="update-config-btn" class="prismweave-link-btn" title="Update settings">‚öôÔ∏è</button>
            </div>
          </div>
          <div class="prismweave-actions">
            <button class="prismweave-btn prismweave-btn-primary" id="prismweave-capture">
              Capture Page
            </button>
            <button class="prismweave-btn" id="prismweave-settings" title="Update Settings">
              Settings
            </button>
            <button class="prismweave-btn" id="prismweave-cancel">
              Cancel
            </button>
          </div>
        </div>
      </div>
    \`;
  }

  addOverlayStyles() {
    const styles = \`
      #prismweave-bookmarklet {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.7);
        z-index: 999999;
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      }
      
      .prismweave-modal {
        background: white;
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        width: 90%;
        max-width: 400px;
        animation: prismweaveSlideIn 0.3s ease-out;
      }
      
      @keyframes prismweaveSlideIn {
        from { transform: translateY(-20px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
      }
      
      .prismweave-header {
        padding: 16px 20px;
        border-bottom: 1px solid #e5e5e5;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .prismweave-header h3 {
        margin: 0;
        font-size: 18px;
        font-weight: 600;
        color: #333;
      }
      
      .prismweave-close {
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        color: #666;
        padding: 0;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .prismweave-close:hover {
        color: #333;
      }
      
      .prismweave-content {
        padding: 20px;
      }
      
      .prismweave-status {
        display: flex;
        align-items: center;
        margin-bottom: 20px;
        padding: 12px;
        background: #f8f9fa;
        border-radius: 6px;
      }
      
      .prismweave-icon {
        font-size: 24px;
        margin-right: 12px;
      }
      
      .prismweave-message {
        font-size: 14px;
        color: #666;
      }
      
      .prismweave-actions {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
      }
      
      .prismweave-btn {
        padding: 8px 16px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: white;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
      }
      
      .prismweave-btn:hover {
        background: #f5f5f5;
      }
      
      .prismweave-btn-primary {
        background: #007cba;
        color: white;
        border-color: #007cba;
      }
      
      .prismweave-btn-primary:hover {
        background: #006ba1;
      }
      
      .prismweave-config-info {
        padding: 8px 12px;
        background: #f0f8ff;
        border: 1px solid #b3d9ff;
        border-radius: 4px;
        margin-bottom: 16px;
        font-size: 12px;
      }
      
      .prismweave-config-status {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .prismweave-link-btn {
        background: none;
        border: none;
        cursor: pointer;
        font-size: 14px;
        padding: 2px;
        border-radius: 2px;
      }
      
      .prismweave-link-btn:hover {
        background: rgba(0, 0, 0, 0.1);
      }
      
      .prismweave-settings-panel {
        background: white;
        border: 1px solid #ddd;
        border-radius: 6px;
        padding: 16px;
        margin: 12px 0;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
      }
      
      .prismweave-form-group {
        margin-bottom: 12px;
      }
      
      .prismweave-form-group label {
        display: block;
        font-size: 12px;
        font-weight: 500;
        margin-bottom: 4px;
        color: #333;
      }
      
      .prismweave-form-group input, .prismweave-form-group select {
        width: 100%;
        padding: 6px 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 13px;
      }
      
      .prismweave-form-group input:focus, .prismweave-form-group select:focus {
        outline: none;
        border-color: #007cba;
        box-shadow: 0 0 0 2px rgba(0, 124, 186, 0.2);
      }
      
      .prismweave-progress {
        width: 100%;
        height: 4px;
        background: #e5e5e5;
        border-radius: 2px;
        overflow: hidden;
        margin: 10px 0;
      }
      
      .prismweave-progress-bar {
        height: 100%;
        background: #007cba;
        width: 0%;
        transition: width 0.3s ease;
      }
    \`;
    
    const styleElement = document.createElement('style');
    styleElement.textContent = styles;
    document.head.appendChild(styleElement);
  }

  bindEvents() {
    const closeBtn = this.overlay.querySelector('.prismweave-close');
    const cancelBtn = this.overlay.querySelector('#prismweave-cancel');
    const captureBtn = this.overlay.querySelector('#prismweave-capture');
    const settingsBtn = this.overlay.querySelector('#prismweave-settings');
    const updateConfigBtn = this.overlay.querySelector('#update-config-btn');
    
    closeBtn.addEventListener('click', () => this.hide());
    cancelBtn.addEventListener('click', () => this.hide());
    captureBtn.addEventListener('click', () => this.captureContent());
    settingsBtn.addEventListener('click', () => this.showSettingsPanel());
    if (updateConfigBtn) {
      updateConfigBtn.addEventListener('click', () => this.showSettingsPanel());
    }
    
    // Show config info if we have stored settings
    this.updateConfigInfo();
    
    // Close on overlay click
    this.overlay.addEventListener('click', (e) => {
      if (e.target === this.overlay) {
        this.hide();
      }
    });
    
    // Close on Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && this.isVisible) {
        this.hide();
      }
    });
  }

  async updateConfigInfo() {
    const configInfo = this.overlay.querySelector('#prismweave-config-info');
    const configSource = this.overlay.querySelector('#config-source');
    const storedConfig = await this.loadStoredConfig();
    
    if (storedConfig && storedConfig.githubToken && storedConfig.githubRepo) {
      configInfo.style.display = 'block';
      const repoDisplay = storedConfig.githubRepo.length > 30 ? 
        storedConfig.githubRepo.substring(0, 30) + '...' : 
        storedConfig.githubRepo;
      const storageMethod = storedConfig.storageMethod || 'extension storage';
      configSource.textContent = \`Using stored config for \${repoDisplay} (\${storageMethod})\`;
    } else if (this.config.githubToken && this.config.githubRepo) {
      configInfo.style.display = 'block';
      const repoDisplay = this.config.githubRepo.length > 30 ? 
        this.config.githubRepo.substring(0, 30) + '...' : 
        this.config.githubRepo;
      configSource.textContent = \`Using embedded config for \${repoDisplay}\`;
    }
  }

  showSettingsPanel() {
    this.getEffectiveConfig().then(currentConfig => {
    
    // Create settings form
    const settingsHTML = \`
      <div class="prismweave-settings-panel" id="settings-panel">
        <h4 style="margin: 0 0 12px 0; font-size: 14px;">Bookmarklet Settings</h4>
        
        <div class="prismweave-form-group">
          <label for="settings-github-token">GitHub Token</label>
          <input type="password" id="settings-github-token" value="\${currentConfig.githubToken || ''}" 
                 placeholder="ghp_xxxxxxxxxxxxxxxxxxxxx">
        </div>
        
        <div class="prismweave-form-group">
          <label for="settings-github-repo">GitHub Repository</label>
          <input type="text" id="settings-github-repo" value="\${currentConfig.githubRepo || ''}" 
                 placeholder="username/repository-name">
        </div>
        
        <div class="prismweave-form-group">
          <label for="settings-default-folder">Default Folder</label>
          <select id="settings-default-folder">
            <option value="documents" \${currentConfig.defaultFolder === 'documents' ? 'selected' : ''}>documents</option>
            <option value="unsorted" \${currentConfig.defaultFolder === 'unsorted' ? 'selected' : ''}>unsorted</option>
            <option value="tech" \${currentConfig.defaultFolder === 'tech' ? 'selected' : ''}>tech</option>
            <option value="business" \${currentConfig.defaultFolder === 'business' ? 'selected' : ''}>business</option>
            <option value="research" \${currentConfig.defaultFolder === 'research' ? 'selected' : ''}>research</option>
            <option value="news" \${currentConfig.defaultFolder === 'news' ? 'selected' : ''}>news</option>
          </select>
        </div>
        
        <div class="prismweave-actions" style="margin-top: 16px;">
          <button class="prismweave-btn prismweave-btn-primary" id="save-settings">
            Save Settings
          </button>
          <button class="prismweave-btn" id="cancel-settings">
            Cancel
          </button>
          <button class="prismweave-btn" id="clear-stored-settings" title="Clear stored settings">
            Clear Stored
          </button>
          <button class="prismweave-btn" id="test-cross-domain-storage" title="Test cross-domain storage functionality">
            Test Storage
          </button>
        </div>
      </div>
    \`;
    
    // Insert settings panel before actions
    const actionsDiv = this.overlay.querySelector('.prismweave-actions');
    const existingPanel = this.overlay.querySelector('#settings-panel');
    if (existingPanel) {
      existingPanel.remove();
    }
    
    actionsDiv.insertAdjacentHTML('beforebegin', settingsHTML);
    
    // Bind settings events
    this.bindSettingsEvents();
    });
  }

  bindSettingsEvents() {
    const saveBtn = this.overlay.querySelector('#save-settings');
    const cancelBtn = this.overlay.querySelector('#cancel-settings');
    const clearBtn = this.overlay.querySelector('#clear-stored-settings');
    
    saveBtn.addEventListener('click', () => this.saveSettings());
    cancelBtn.addEventListener('click', () => this.hideSettingsPanel());
    clearBtn.addEventListener('click', () => this.clearStoredSettings());
    
    // Add test storage button event listener
    const testBtn = this.overlay.querySelector('#test-cross-domain-storage');
    if (testBtn) {
      testBtn.addEventListener('click', () => this.testCrossDomainStorage());
    }
  }

  saveSettings() {
    const token = this.overlay.querySelector('#settings-github-token').value.trim();
    const repo = this.overlay.querySelector('#settings-github-repo').value.trim();
    const folder = this.overlay.querySelector('#settings-default-folder').value;
    
    if (!token || !repo) {
      this.updateStatus('‚ö†Ô∏è', 'GitHub token and repository are required', false);
      return;
    }
    
    // Validate repository format
    if (!/^[\\w\\-\\.]+\/[\\w\\-\\.]+$/.test(repo)) {
      this.updateStatus('‚ö†Ô∏è', 'Repository must be in format: owner/repo', false);
      return;
    }
    
    const newConfig = {
      ...this.config,
      githubToken: token,
      githubRepo: repo,
      defaultFolder: folder,
      lastUpdated: new Date().toISOString()
    };
    
    this.storeConfig(newConfig);
    this.config = newConfig; // Update current session config
    
    this.updateStatus('‚úÖ', 'Settings saved successfully! (Cross-domain storage)', false);
    this.hideSettingsPanel();
    this.updateConfigInfo();
    
    setTimeout(() => {
      this.updateStatus('üìÑ', 'Ready to capture content from this page', false);
    }, 2000);
  }

  hideSettingsPanel() {
    const panel = this.overlay.querySelector('#settings-panel');
    if (panel) {
      panel.remove();
    }
  }

  async testCrossDomainStorage() {
    try {
      this.updateStatus('üß™', 'Testing cross-domain storage...', false);

      // Dynamic import of the test module
      const testModule = await import('./cross-domain-storage-test');
      const tester = new testModule.CrossDomainStorageTest();
      
      const results = await tester.runFullTestSuite();
      
      if (results.overallSuccess) {
        this.updateStatus('‚úÖ', 'All storage tests passed (' + results.tests.length + ' tests)', false);
        console.log('üìä Cross-domain storage test results:', results);
      } else {
        const passedCount = results.tests.filter(t => t.success).length;
        this.updateStatus('‚ö†Ô∏è', 'Some storage tests failed (' + passedCount + '/' + results.tests.length + ' passed)', false);
        console.warn('üìä Cross-domain storage test results:', results);
      }

      // Show detailed results in console
      console.log(results.summary);
      
      return results;
    } catch (error) {
      this.updateStatus('‚ùå', 'Storage test failed to run', false);
      console.error('Error running cross-domain storage test:', error);
      return null;
    }
  }

  clearStoredSettings() {
      // Clear extension storage first
      if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.sendMessage) {
        chrome.runtime.sendMessage(this.EXTENSION_ID, {
          type: 'CLEAR_BOOKMARKLET_CONFIG'
        }, (response) => {
          if (!chrome.runtime.lastError) {
            console.log('PrismWeave: Extension storage cleared');
          }
        });
      }
      
      // Also clear fallback storage
      localStorage.removeItem(this.STORAGE_KEY);
      sessionStorage.removeItem(this.STORAGE_KEY);
      
      this.updateStatus('üóëÔ∏è', 'All stored settings cleared (cross-domain)', false);
      this.hideSettingsPanel();
      this.updateConfigInfo();
      
      setTimeout(() => {
        this.updateStatus('üìÑ', 'Ready to capture content from this page', false);
      }, 2000);
    } catch (error) {
      this.updateStatus('‚ùå', 'Failed to clear all settings', false);
    }
  }
    
    // Close on overlay click
    this.overlay.addEventListener('click', (e) => {
      if (e.target === this.overlay) {
        this.hide();
      }
    });
    
    // Close on Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && this.isVisible) {
        this.hide();
      }
    });
  }

  async captureContent() {
    try {
      this.updateStatus('üì•', 'Extracting content from page...', true);
      
      // Extract content using DOM-based approach
      const content = await this.extractPageContent();
      
      this.updateStatus('üíæ', 'Processing and saving content...', true);
      
      // Save to GitHub
      const result = await this.saveToGitHub(content);
      
      if (result.success) {
        this.updateStatus('‚úÖ', \`Content saved successfully! \${result.filename || ''}\`, false);
        setTimeout(() => this.hide(), 3000);
      } else {
        this.updateStatus('‚ùå', \`Save failed: \${result.error}\`, false);
      }
      
    } catch (error) {
      this.updateStatus('‚ùå', \`Error: \${error.message}\`, false);
    }
  }

  updateStatus(icon, message, showProgress) {
    const statusEl = this.overlay.querySelector('#prismweave-status');
    const iconEl = statusEl.querySelector('.prismweave-icon');
    const messageEl = statusEl.querySelector('.prismweave-message');
    
    iconEl.textContent = icon;
    messageEl.textContent = message;
    
    // Remove existing progress bar
    const existingProgress = statusEl.querySelector('.prismweave-progress');
    if (existingProgress) {
      existingProgress.remove();
    }
    
    // Add progress bar if needed
    if (showProgress) {
      const progressBar = document.createElement('div');
      progressBar.className = 'prismweave-progress';
      progressBar.innerHTML = '<div class="prismweave-progress-bar"></div>';
      statusEl.appendChild(progressBar);
      
      // Animate progress
      setTimeout(() => {
        const bar = progressBar.querySelector('.prismweave-progress-bar');
        bar.style.width = '100%';
      }, 100);
    }
  }

  extractPageContent() {
    // Enhanced content extraction matching browser extension capabilities
    const title = document.title || 'Untitled';
    const url = window.location.href;
    const domain = window.location.hostname;
    
    // Find main content using semantic analysis (same as browser extension)
    const contentElement = this.findMainContentElement();
    if (!contentElement) {
      throw new Error('No suitable content found');
    }
    
    // Clean and process content with enhanced rules
    const cleanedElement = this.cleanContentEnhanced(contentElement.cloneNode(true));
    const htmlContent = cleanedElement.innerHTML;
    
    // Convert to markdown using enhanced converter with table/image support
    const markdown = this.htmlToMarkdownEnhanced(htmlContent);
    
    // Generate frontmatter
    const frontmatter = this.generateFrontmatter(title, url);
    
    // Extract images for reference
    const images = this.extractImages(cleanedElement);
    
    // Calculate metrics
    const textContent = cleanedElement.textContent || '';
    const wordCount = this.countWords(textContent);
    const readingTime = Math.ceil(wordCount / 200); // 200 words per minute
    
    return {
      title,
      url,
      domain,
      markdown,
      frontmatter,
      content: frontmatter + '\\n\\n' + markdown,
      images,
      wordCount,
      readingTime,
      extractedAt: new Date().toISOString()
    };
  }

  cleanContent(element) {
    // Remove unwanted elements
    const unwantedSelectors = [
      'script', 'style', 'nav', 'header', 'footer',
      '.advertisement', '.ad', '.ads', '.popup', '.modal',
      '.social-share', '.comments', '.related-posts'
    ];
    
    unwantedSelectors.forEach(selector => {
      const elements = element.querySelectorAll(selector);
      elements.forEach(el => el.remove());
    });
    
    return element;
  }

  // Enhanced content finding with semantic analysis (matches browser extension)
  findMainContentElement() {
    // Semantic content selectors (prioritized)
    const semanticSelectors = [
      'article[role="article"]',
      'main[role="main"]',
      '[role="article"]',
      '[role="main"]',
      'article',
      'main'
    ];
    
    // Try semantic selectors first
    for (const selector of semanticSelectors) {
      const element = document.querySelector(selector);
      if (element && this.hasSubstantialContent(element)) {
        return element;
      }
    }
    
    // Common content selectors
    const contentSelectors = [
      '.post-content',
      '.entry-content',
      '.article-content',
      '.content-body',
      '.post-body',
      '.entry-body',
      '.article-body',
      '.main-content',
      '.content-main',
      '.primary-content',
      '.content',
      '.post',
      '.entry',
      '.article',
      '#content',
      '#main',
      '#post',
      '#entry',
      '#article'
    ];
    
    for (const selector of contentSelectors) {
      const element = document.querySelector(selector);
      if (element && this.hasSubstantialContent(element)) {
        return element;
      }
    }
    
    // Fallback: analyze all containers and score them
    const containers = Array.from(document.querySelectorAll('div, section, aside'));
    let bestElement = null;
    let bestScore = 0;
    
    for (const container of containers) {
      const score = this.scoreContentElement(container);
      if (score > bestScore && score > 50) { // Minimum quality threshold
        bestScore = score;
        bestElement = container;
      }
    }
    
    return bestElement || document.body;
  }

  hasSubstantialContent(element) {
    const text = (element.textContent || '').trim();
    const wordCount = text.split(/\\s+/).filter(word => word.length > 2).length;
    return wordCount >= 50; // At least 50 meaningful words
  }

  scoreContentElement(element) {
    let score = 0;
    const text = element.textContent || '';
    const html = element.innerHTML || '';
    
    // Word count scoring (primary factor)
    const wordCount = this.countWords(text);
    score += Math.min(wordCount / 10, 100); // Max 100 points for word count
    
    // Content density scoring
    const textLength = text.length;
    const htmlLength = html.length;
    const density = htmlLength > 0 ? textLength / htmlLength : 0;
    score += density * 50; // Max 50 points for good text/html ratio
    
    // Paragraph scoring
    const paragraphs = element.querySelectorAll('p').length;
    score += paragraphs * 3; // 3 points per paragraph
    
    // Structural elements bonus
    const headers = element.querySelectorAll('h1, h2, h3, h4, h5, h6').length;
    score += headers * 5; // 5 points per header
    
    // Lists bonus
    const lists = element.querySelectorAll('ul, ol').length;
    score += lists * 2; // 2 points per list
    
    // Link density penalty (too many links = likely navigation)
    const links = element.querySelectorAll('a').length;
    const linkDensity = wordCount > 0 ? links / wordCount : 0;
    if (linkDensity > 0.1) {
      score -= linkDensity * 100; // Penalty for high link density
    }
    
    // Class name analysis
    const className = (element.className || '').toLowerCase();
    if (className.includes('content')) score += 15;
    if (className.includes('post')) score += 10;
    if (className.includes('article')) score += 10;
    if (className.includes('entry')) score += 8;
    if (className.includes('main')) score += 8;
    
    // Negative scoring for likely non-content areas
    if (className.includes('sidebar')) score -= 20;
    if (className.includes('footer')) score -= 25;
    if (className.includes('header')) score -= 25;
    if (className.includes('nav')) score -= 30;
    if (className.includes('menu')) score -= 20;
    if (className.includes('comment')) score -= 15;
    if (className.includes('ad')) score -= 50;
    
    return Math.max(score, 0);
  }

  cleanContentEnhanced(element) {
    // Enhanced cleaning with more comprehensive rules
    const unwantedSelectors = [
      'script', 'style', 'noscript', 'iframe', 'embed', 'object',
      'svg', 'canvas', 'audio', 'video',
      'nav', 'header', 'footer', 'aside',
      '.advertisement', '.ad', '.ads', '.popup', '.modal',
      '.social-share', '.share-buttons', '.comments', '.related-posts',
      '.sidebar', '.navigation', '.nav', '.menu',
      '[style*="display: none"]', '[style*="visibility: hidden"]',
      '.print-only', '.screen-reader-text', '.visually-hidden'
    ];
    
    // Remove unwanted elements
    unwantedSelectors.forEach(selector => {
      try {
        const elements = element.querySelectorAll(selector);
        elements.forEach(el => el.remove());
      } catch (e) {
        // Invalid selector, skip
      }
    });
    
    // Clean up empty elements
    const emptyElements = element.querySelectorAll('div, span, p, section, article');
    emptyElements.forEach(el => {
      if (!el.textContent.trim() && !el.querySelector('img, table, ul, ol, blockquote')) {
        el.remove();
      }
    });
    
    return element;
  }

  extractImages(element) {
    const images = [];
    const imgElements = element.querySelectorAll('img');
    
    imgElements.forEach(img => {
      const src = img.src;
      const alt = img.alt || '';
      
      if (src && !src.startsWith('data:') && src.length > 0) {
        try {
          const absoluteUrl = new URL(src, window.location.href).href;
          images.push({
            src: absoluteUrl,
            alt: alt
          });
        } catch (e) {
          // Invalid URL, skip
        }
      }
    });
    
    return images;
  }

  countWords(text) {
    if (!text) return 0;
    return text.split(/\\s+/).filter(word => word.length > 0).length;
  }

  htmlToMarkdown(html) {
    // Basic HTML to Markdown conversion
    let markdown = html;
    
    // Headers
    markdown = markdown.replace(/<h([1-6])[^>]*>(.*?)<\\/h[1-6]>/gi, (match, level, content) => {
      const headerLevel = '#'.repeat(parseInt(level));
      return \`\\n\${headerLevel} \${this.stripHtml(content).trim()}\\n\`;
    });
    
    // Paragraphs
    markdown = markdown.replace(/<p[^>]*>(.*?)<\\/p>/gi, '\\n$1\\n');
    
    // Bold/Strong
    markdown = markdown.replace(/<(strong|b)[^>]*>(.*?)<\\/(strong|b)>/gi, '**$2**');
    
    // Italic/Emphasis
    markdown = markdown.replace(/<(em|i)[^>]*>(.*?)<\\/(em|i)>/gi, '*$2*');
    
    // Links
    if (this.config.captureImages !== false) {
      markdown = markdown.replace(/<a[^>]*href=["']([^"']*)["'][^>]*>(.*?)<\\/a>/gi, '[$2]($1)');
    }
    
    // Line breaks
    markdown = markdown.replace(/<br[^>]*\\/?>/gi, '\\n');
    
    // Strip remaining HTML
    markdown = this.stripHtml(markdown);
    
    // Clean up whitespace
    markdown = markdown.replace(/\\n\\s*\\n\\s*\\n/g, '\\n\\n');
    
    return markdown.trim();
  }

  // Enhanced HTML to Markdown conversion with table and image support
  htmlToMarkdownEnhanced(html) {
    let markdown = html;
    
    // Convert headers (h1-h6)
    markdown = markdown.replace(/<h([1-6])[^>]*>(.*?)<\\/h[1-6]>/gi, (match, level, content) => {
      const headerLevel = '#'.repeat(parseInt(level));
      const cleanContent = this.stripHtml(content).trim();
      return \`\\n\${headerLevel} \${cleanContent}\\n\`;
    });
    
    // Convert tables (enhanced table support)
    markdown = this.convertTables(markdown);
    
    // Convert lists
    markdown = this.convertLists(markdown);
    
    // Convert blockquotes
    markdown = markdown.replace(/<blockquote[^>]*>(.*?)<\\/blockquote>/gis, (match, content) => {
      const cleanContent = this.stripHtml(content).trim();
      const lines = cleanContent.split('\\n');
      const quotedLines = lines.map(line => \`> \${line.trim()}\`);
      return \`\\n\${quotedLines.join('\\n')}\\n\`;
    });
    
    // Convert code blocks
    markdown = markdown.replace(/<pre[^>]*><code[^>]*>(.*?)<\\/code><\\/pre>/gis, (match, content) => {
      const cleanContent = this.decodeHtmlEntities(content);
      return \`\\n\\\`\\\`\\\`\\n\${cleanContent}\\n\\\`\\\`\\\`\\n\`;
    });
    
    // Convert inline code
    markdown = markdown.replace(/<code[^>]*>(.*?)<\\/code>/gi, (match, content) => {
      const cleanContent = this.stripHtml(content);
      return \`\\\`\${cleanContent}\\\`\`;
    });
    
    // Convert images (enhanced image support)
    markdown = markdown.replace(/<img[^>]*src=["']([^"']*)["'][^>]*alt=["']([^"']*)["'][^>]*>/gi, '![$2]($1)');
    markdown = markdown.replace(/<img[^>]*alt=["']([^"']*)["'][^>]*src=["']([^"']*)["'][^>]*>/gi, '![$1]($2)');
    markdown = markdown.replace(/<img[^>]*src=["']([^"']*)["'][^>]*>/gi, '![]($1)');
    
    // Convert links
    markdown = markdown.replace(/<a[^>]*href=["']([^"']*)["'][^>]*>(.*?)<\\/a>/gi, '[$2]($1)');
    
    // Convert text formatting
    markdown = markdown.replace(/<(strong|b)[^>]*>(.*?)<\\/(strong|b)>/gi, '**$2**');
    markdown = markdown.replace(/<(em|i)[^>]*>(.*?)<\\/(em|i)>/gi, '*$2*');
    markdown = markdown.replace(/<(del|s|strike)[^>]*>(.*?)<\\/(del|s|strike)>/gi, '~~$2~~');
    
    // Convert paragraphs
    markdown = markdown.replace(/<p[^>]*>(.*?)<\\/p>/gi, '\\n$1\\n');
    
    // Convert line breaks
    markdown = markdown.replace(/<br[^>]*\\/?>/gi, '\\n');
    
    // Convert horizontal rules
    markdown = markdown.replace(/<hr[^>]*\\/?>/gi, '\\n---\\n');
    
    // Strip remaining HTML
    markdown = this.stripHtml(markdown);
    
    // Clean up whitespace
    markdown = markdown.replace(/\\n\\s*\\n\\s*\\n/g, '\\n\\n'); // Remove excessive line breaks
    markdown = markdown.replace(/^\\s+|\\s+$/gm, ''); // Trim lines
    markdown = markdown.trim();
    
    return markdown;
  }

  // Enhanced table conversion matching browser extension capabilities
  convertTables(html) {
    return html.replace(/<table[^>]*>(.*?)<\\/table>/gis, (match, content) => {
      const rows = [];
      
      // Extract table rows
      const rowMatches = content.match(/<tr[^>]*>(.*?)<\\/tr>/gis);
      if (!rowMatches || rowMatches.length === 0) return match;
      
      let isFirstRow = true;
      for (const rowMatch of rowMatches) {
        const cells = [];
        const cellMatches = rowMatch.match(/<t[hd][^>]*>(.*?)<\\/t[hd]>/gis);
        
        if (cellMatches) {
          for (const cellMatch of cellMatches) {
            const cellContent = cellMatch.replace(/<t[hd][^>]*>(.*?)<\\/t[hd]>/i, '$1');
            const cleanContent = this.stripHtml(cellContent).trim();
            cells.push(cleanContent);
          }
          
          const row = \`| \${cells.join(' | ')} |\`;
          rows.push(row);
          
          // Add separator after header row
          if (isFirstRow && cells.length > 0) {
            const separator = \`| \${cells.map(() => '---').join(' | ')} |\`;
            rows.push(separator);
            isFirstRow = false;
          }
        }
      }
      
      return rows.length > 0 ? \`\\n\${rows.join('\\n')}\\n\` : '';
    });
  }

  convertLists(html) {
    // Convert unordered lists
    html = html.replace(/<ul[^>]*>(.*?)<\\/ul>/gis, (match, content) => {
      const items = content.replace(/<li[^>]*>(.*?)<\\/li>/gi, (liMatch, liContent) => {
        const cleanContent = this.stripHtml(liContent).trim();
        return \`- \${cleanContent}\\n\`;
      });
      return \`\\n\${items}\\n\`;
    });
    
    // Convert ordered lists
    html = html.replace(/<ol[^>]*>(.*?)<\\/ol>/gis, (match, content) => {
      let counter = 1;
      const items = content.replace(/<li[^>]*>(.*?)<\\/li>/gi, (liMatch, liContent) => {
        const cleanContent = this.stripHtml(liContent).trim();
        return \`\${counter++}. \${cleanContent}\\n\`;
      });
      return \`\\n\${items}\\n\`;
    });
    
    return html;
  }

  decodeHtmlEntities(text) {
    const entityMap = {
      '&lt;': '<',
      '&gt;': '>',
      '&amp;': '&',
      '&quot;': '"',
      '&#39;': "'",
      '&nbsp;': ' ',
      '&copy;': '¬©',
      '&reg;': '¬Æ',
      '&trade;': '‚Ñ¢'
    };
    
    return text.replace(/&(?:lt|gt|amp|quot|#39|nbsp|copy|reg|trade);/g, (entity) => {
      return entityMap[entity] || entity;
    });
  }

  stripHtml(html) {
    return html.replace(/<[^>]*>/g, '').trim();
  }

  generateFrontmatter(title, url) {
    const now = new Date();
    const dateStr = now.toISOString().split('T')[0];
    
    return \`---
title: "\${title.replace(/"/g, '\\"')}"
url: "\${url}"
date: "\${dateStr}"
captured: "\${now.toISOString()}"
tags: []
---\`;
  }

  async saveToGitHub(content) {
    // Use effective configuration (stored config takes precedence)
    const effectiveConfig = this.getEffectiveConfig();
    const { githubToken, githubRepo } = effectiveConfig;
    
    if (!githubToken || !githubRepo) {
      throw new Error('GitHub token and repository must be configured. Please click Settings to configure.');
    }
    
    // Generate filename
    const timestamp = new Date().toISOString().split('T')[0];
    const titleSlug = content.title
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '')
      .substring(0, 50);
    
    const filename = \`\${timestamp}-\${titleSlug}.md\`;
    const filePath = effectiveConfig.defaultFolder ? 
      \`\${effectiveConfig.defaultFolder}/\${filename}\` : 
      \`documents/\${filename}\`;
    
    // Commit to GitHub
    const [owner, repo] = githubRepo.split('/');
    const apiUrl = \`https://api.github.com/repos/\${owner}/\${repo}/contents/\${filePath}\`;
    
    const commitData = {
      message: effectiveConfig.commitMessageTemplate ? 
        effectiveConfig.commitMessageTemplate
          .replace('{title}', content.title)
          .replace('{domain}', new URL(content.url).hostname) :
        \`Add captured content: \${content.title}\`,
      content: btoa(unescape(encodeURIComponent(content.content))),
      branch: 'main'
    };
    
    const response = await fetch(apiUrl, {
      method: 'PUT',
      headers: {
        'Authorization': \`token \${githubToken}\`,
        'Content-Type': 'application/json',
        'User-Agent': 'PrismWeave-Bookmarklet'
      },
      body: JSON.stringify(commitData)
    });
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(\`GitHub API error: \${error.message || response.statusText}\`);
    }
    
    const result = await response.json();
    return {
      success: true,
      filename,
      url: result.content.html_url
    };
  }
}

// Make runtime available globally
window.prismweaveBookmarkletRuntime = PrismweaveBookmarkletRuntime;
`;
  }

  /**
   * Minify JavaScript code for bookmarklet
   */
  private static minifyScript(script: string): string {
    // Simple and safe minification for generated bookmarklet code
    let result = script;

    // Remove multi-line comments (/* ... */)
    result = result.replace(/\/\*[\s\S]*?\*\//g, '');

    // Don't remove single-line comments since they might break URLs with //
    // Our generated code doesn't have // comments anyway

    // Collapse multiple whitespace to single spaces
    result = result.replace(/\s+/g, ' ');

    // Remove spaces around operators and punctuation (be conservative)
    result = result.replace(/\s*{\s*/g, '{');
    result = result.replace(/\s*}\s*/g, '}');
    result = result.replace(/\s*;\s*/g, ';');
    result = result.replace(/\s*,\s*/g, ',');
    result = result.replace(/\s*\(\s*/g, '(');
    result = result.replace(/\s*\)\s*/g, ')');
    result = result.replace(/;\s*}/g, '}'); // Remove semicolons before closing braces

    return result.trim();
  }

  /**
   * Generate a user-friendly bookmarklet name
   */
  static generateBookmarkletName(config: IBookmarkletConfig): string {
    const repoName = config.githubRepo.split('/')[1] || 'repository';
    return `PrismWeave ‚Üí ${repoName}`;
  }

  /**
   * Generate installation instructions for the bookmarklet
   */
  static generateInstallationInstructions(bookmarkletCode: string, name: string): string {
    return `
## Install PrismWeave Bookmarklet

### Step 1: Copy the Bookmarklet
Click the button below to copy the bookmarklet code to your clipboard.

### Step 2: Create a New Bookmark
1. Right-click on your browser's bookmark bar
2. Select "Add page..." or "Add bookmark..."
3. Set the name to: **${name}**
4. Set the URL to the copied bookmarklet code
5. Save the bookmark

### Step 3: Use the Bookmarklet
1. Navigate to any webpage you want to capture
2. Click the "${name}" bookmark
3. The PrismWeave capture dialog will appear
4. Click "Capture Page" to save the content to your GitHub repository

### Troubleshooting
- Make sure your GitHub token has write access to the repository
- The bookmarklet works on most websites, but some may block it due to security policies
- If the bookmarklet doesn't appear, try refreshing the page and clicking again
`;
  }

  /**
   * Validate bookmarklet configuration
   */
  static validateConfig(config: IBookmarkletConfig): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (!config.githubToken || config.githubToken.trim().length === 0) {
      errors.push('GitHub token is required');
    }

    if (!config.githubRepo || config.githubRepo.trim().length === 0) {
      errors.push('GitHub repository is required');
    } else if (!/^[\w\-\.]+\/[\w\-\.]+$/.test(config.githubRepo)) {
      errors.push('GitHub repository must be in format: owner/repo');
    }

    if (config.githubToken && config.githubToken.length < 20) {
      errors.push('GitHub token appears to be invalid (too short)');
    }

    return {
      isValid: errors.length === 0,
      errors,
    };
  }
}
