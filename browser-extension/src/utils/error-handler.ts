// Generated by Copilot
// PrismWeave Error Handler - TypeScript version
// Centralized error handling with user-friendly messages

import { IErrorInfo } from '../types/index.js';

export class ErrorHandler {
  static readonly ERROR_TYPES = {
    NETWORK: 'network',
    AUTH: 'auth',
    PERMISSION: 'permission',
    CONTENT: 'content',
    STORAGE: 'storage',
    GITHUB: 'github'
  } as const;

  static createUserFriendlyError(error: Error, context: string = ''): IErrorInfo & { type: string; solution: string } {
    const errorInfo = this.categorizeError(error);
      return {
      message: errorInfo.userMessage,
      stack: error.stack || '',
      context,
      timestamp: new Date().toISOString(),
      url: typeof window !== 'undefined' ? window.location?.href || 'Unknown' : 'Unknown',
      type: errorInfo.type,
      solution: errorInfo.solution
    };
  }

  static categorizeError(error: Error): { type: string; userMessage: string; solution: string } {
    const message = error.message.toLowerCase();
    
    if (message.includes('token') || message.includes('unauthorized') || message.includes('401')) {
      return {
        type: this.ERROR_TYPES.AUTH,
        userMessage: 'Authentication failed. Please check your GitHub token.',
        solution: 'Go to Settings and verify your GitHub token is valid and has the necessary permissions.'
      };
    }
    
    if (message.includes('repository') || message.includes('repo')) {
      return {
        type: this.ERROR_TYPES.GITHUB,
        userMessage: 'Repository access failed.',
        solution: 'Verify the repository exists and you have write access. Check the repository name format (owner/repo).'
      };
    }
    
    if (message.includes('network') || message.includes('fetch') || message.includes('cors')) {
      return {
        type: this.ERROR_TYPES.NETWORK,
        userMessage: 'Network connection failed.',
        solution: 'Check your internet connection and try again.'
      };
    }
    
    if (message.includes('permission') || message.includes('blocked')) {
      return {
        type: this.ERROR_TYPES.PERMISSION,
        userMessage: 'Permission denied.',
        solution: 'Check browser permissions for the PrismWeave extension.'
      };
    }
    
    if (message.includes('storage') || message.includes('quota')) {
      return {
        type: this.ERROR_TYPES.STORAGE,
        userMessage: 'Storage operation failed.',
        solution: 'Check available storage space and try again.'
      };
    }
    
    if (message.includes('content') || message.includes('parse') || message.includes('extract')) {
      return {
        type: this.ERROR_TYPES.CONTENT,
        userMessage: 'Content processing failed.',
        solution: 'Try refreshing the page and capturing again.'
      };
    }
    
    return {
      type: 'unknown',
      userMessage: 'An unexpected error occurred.',
      solution: 'Please try again or contact support if the problem persists.'
    };
  }

  static handle(error: Error, context: string = 'Unknown'): IErrorInfo & { type: string; solution: string } {
    const errorInfo = this.createUserFriendlyError(error, context);

    console.error(`${context}:`, errorInfo);
    
    // Optionally send to background for logging
    if (typeof chrome !== 'undefined' && chrome.runtime) {
      chrome.runtime.sendMessage({
        type: 'LOG_ERROR',
        data: errorInfo
      }).catch(() => {
        // Ignore messaging errors to prevent recursive issues
      });
    }

    return errorInfo;
  }

  static async withErrorHandling<T>(
    asyncFn: () => Promise<T>, 
    context: string = 'Unknown'
  ): Promise<T> {
    try {
      return await asyncFn();
    } catch (error) {
      this.handle(error as Error, context);
      throw error;
    }
  }

  static wrapFunction<T extends (...args: any[]) => any>(
    fn: T, 
    context: string = 'Unknown'
  ): T {
    return ((...args: Parameters<T>) => {
      try {
        const result = fn(...args);
        
        // Handle async functions
        if (result instanceof Promise) {
          return result.catch((error: Error) => {
            this.handle(error, context);
            throw error;
          });
        }
        
        return result;
      } catch (error) {
        this.handle(error as Error, context);
        throw error;
      }
    }) as T;
  }

  static showUserNotification(error: IErrorInfo & { type: string; solution: string }, duration: number = 5000): void {
    // This would integrate with the UI notification system
    console.warn('User notification:', error.message, error.solution);
  }
}

// Make available globally for backward compatibility
if (typeof globalThis !== 'undefined') {
  (globalThis as any).ErrorHandler = ErrorHandler;
}
