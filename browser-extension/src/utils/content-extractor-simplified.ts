// Generated by Copilot
// Simplified Content Extractor - Refactored with separation of concerns
// Main orchestrator that uses specialized modules for different tasks

import { IDocumentMetadata } from '../types/index.js';
import { ContentCleaner, ICleaningOptions } from './content-cleaner';
import { ContentQualityAnalyzer, IQualityOptions } from './content-quality-analyzer';
import { ContentSelectorManager } from './content-selector-strategies';
import { createLogger } from './logger';
import { MetadataExtractor } from './metadata-extractor';

export interface IContentResult {
  content: string;
  metadata: IDocumentMetadata;
  cleanedContent: string;
  wordCount: number;
  readingTime: number;
}

export interface IExtractorOptions extends ICleaningOptions {
  customSelectors?: string[];
  waitForDynamicContent?: boolean;
}

/**
 * Main content extractor that orchestrates specialized modules
 */
export class ContentExtractor {
  private readonly logger = createLogger('ContentExtractor');
  private readonly selectorManager = new ContentSelectorManager();
  private readonly cleaner = new ContentCleaner();
  private readonly qualityAnalyzer = new ContentQualityAnalyzer();
  private readonly metadataExtractor = new MetadataExtractor();

  /**
   * Extract content from the current page
   */
  async extractContent(options: IExtractorOptions = {}): Promise<IContentResult> {
    try {
      this.logger.debug('Starting content extraction');

      // Wait for content to load if needed
      await this.waitForContentIfNeeded(options);

      // Extract metadata first
      const metadata = this.metadataExtractor.extractMetadata();
      this.logger.debug('Metadata extracted:', metadata);

      // Find main content element
      const contentElement = this.findMainContent(options);
      if (!contentElement) {
        throw new Error('No suitable content found on page');
      }

      // Clean the content
      const cleanedElement = this.cleaner.cleanContent(contentElement, options);
      const content = cleanedElement.innerHTML || '';
      const cleanedContent = this.cleanContent(content, options);

      // Calculate metrics
      const wordCount = this.countWords(cleanedContent);
      const readingTime = this.estimateReadingTime(wordCount);

      // Update metadata with calculated values
      metadata.wordCount = wordCount;
      metadata.estimatedReadingTime = readingTime;

      this.logger.debug('Content extraction complete', {
        contentLength: content.length,
        wordCount,
        readingTime,
      });

      return {
        content,
        metadata,
        cleanedContent,
        wordCount,
        readingTime,
      };
    } catch (error) {
      this.logger.error('Error during extraction:', error);
      throw error;
    }
  }

  /**
   * Find the main content element on the page
   */
  private findMainContent(options: IExtractorOptions): Element | null {
    const url = window.location.href;

    // Try custom selectors first
    if (options.customSelectors?.length) {
      for (const selector of options.customSelectors) {
        try {
          const element = document.querySelector(selector);
          if (element && this.isValidContent(element)) {
            this.logger.debug('Found content with custom selector:', selector);
            return element;
          }
        } catch (error) {
          this.logger.warn('Invalid custom selector:', selector, error);
        }
      }
    }

    // Use selector manager to find content
    const element = this.selectorManager.findContentElement(url, document);
    if (element) {
      this.logger.debug('Found content with selector strategy');
      return element;
    }

    // Fallback to largest content container
    const fallbackElement = this.findLargestContentContainer();
    if (fallbackElement) {
      this.logger.debug('Using largest content container as fallback');
      return fallbackElement;
    }

    // Final fallback to body
    this.logger.debug('Using body as final fallback');
    return document.body;
  }

  /**
   * Validate if element contains suitable content
   */
  private isValidContent(element: Element): boolean {
    const qualityOptions: IQualityOptions = {
      isDynamicSite: this.isDynamicSite(),
      minTextLength: 50,
      minTextRatio: 0.05,
      maxLinkDensity: 0.5,
    };

    const quality = this.qualityAnalyzer.analyzeContent(element, qualityOptions);

    this.logger.debug('Content quality analysis:', {
      score: quality.score,
      isContent: quality.isContent,
      reasons: quality.reasons,
    });

    return quality.isContent;
  }

  /**
   * Find largest content container as fallback
   */
  private findLargestContentContainer(): Element | null {
    const candidates = document.querySelectorAll(
      'div, section, article, main, aside, [role="main"], [role="article"]'
    );

    let bestCandidate: Element | null = null;
    let bestScore = 0;
    const minScore = this.isDynamicSite() ? 50 : 100;

    for (const candidate of Array.from(candidates)) {
      const quality = this.qualityAnalyzer.analyzeContent(candidate, {
        isDynamicSite: this.isDynamicSite(),
      });

      if (quality.score > bestScore && quality.score > minScore) {
        bestScore = quality.score;
        bestCandidate = candidate;
      }
    }

    return bestCandidate;
  }

  /**
   * Wait for dynamic content to load if needed
   */
  private async waitForContentIfNeeded(options: IExtractorOptions): Promise<void> {
    if (options.waitForDynamicContent === false) {
      return;
    }

    // Wait for document to be ready
    if (document.readyState !== 'complete') {
      this.logger.debug('Waiting for document to complete loading...');
      await new Promise<void>(resolve => {
        if (document.readyState === 'complete') {
          resolve();
        } else {
          window.addEventListener('load', () => resolve(), { once: true });
          setTimeout(() => resolve(), 3000); // Fallback timeout
        }
      });
    }

    // For dynamic sites, wait additional time
    if (this.isDynamicSite()) {
      this.logger.debug('Dynamic site detected, waiting for content...');
      await this.waitForDynamicContent();
    }
  }

  /**
   * Wait for dynamic content to stabilize - Enhanced with platform-specific handling
   */
  private async waitForDynamicContent(): Promise<void> {
    const maxWaitTime = 5000;
    const checkInterval = 500;
    const startTime = Date.now();
    let previousContentLength = 0;

    // First, try platform-specific waiting
    await this.waitForSpecificContent();

    // Then general content stabilization
    while (Date.now() - startTime < maxWaitTime) {
      const currentContentLength = document.body.textContent?.length || 0;

      if (currentContentLength > previousContentLength) {
        this.logger.debug('Content still loading...', currentContentLength, 'chars');
        previousContentLength = currentContentLength;
        await new Promise(resolve => setTimeout(resolve, checkInterval));
      } else if (previousContentLength > 1000) {
        this.logger.debug('Content appears stable');
        break;
      } else {
        await new Promise(resolve => setTimeout(resolve, checkInterval));
      }
    }
  }

  /**
   * Platform-specific content waiting logic
   */
  private async waitForSpecificContent(): Promise<void> {
    const url = window.location.href.toLowerCase();

    // Docker blog specific waiting logic
    if (url.includes('docker.com/blog')) {
      this.logger.debug('Waiting for Docker blog specific content...');

      const dockerSelectors = [
        '.post-content',
        '.entry-content',
        '.article-content',
        '.blog-content',
        'article',
        '.content',
        '[data-testid*="content"]',
      ];

      const maxWait = 5000;
      const startTime = Date.now();

      while (Date.now() - startTime < maxWait) {
        for (const selector of dockerSelectors) {
          const element = document.querySelector(selector);
          if (element && element.textContent && element.textContent.trim().length > 500) {
            this.logger.debug(`Found Docker content via selector: ${selector}`);
            return;
          }
        }
        await new Promise(resolve => setTimeout(resolve, 200));
      }

      this.logger.debug('Docker blog content wait timeout');
    }
  }

  /**
   * Check if current site is dynamic
   */
  private isDynamicSite(): boolean {
    const hostname = window.location.hostname.toLowerCase();
    const dynamicSites = [
      'docker.com',
      'medium.com',
      'dev.to',
      'hashnode.com',
      'substack.com',
      'wordpress.com',
      'ghost.org',
    ];

    const hasKnownDynamicSite = dynamicSites.some(site => hostname.includes(site));
    const hasModernFramework = !!(
      document.querySelector('[data-reactroot], [data-vue], [ng-version]') ||
      (window as any).React ||
      (window as any).Vue ||
      (window as any).angular
    );

    return hasKnownDynamicSite || hasModernFramework;
  }

  /**
   * Clean content string
   */
  private cleanContent(content: string, options: IExtractorOptions): string {
    if (options.preserveFormatting) {
      return content;
    }

    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = content;

    // Normalize whitespace in text nodes
    const walker = document.createTreeWalker(tempDiv, NodeFilter.SHOW_TEXT);
    const textNodes: Text[] = [];
    let node: Node | null;

    while ((node = walker.nextNode())) {
      textNodes.push(node as Text);
    }

    for (const textNode of textNodes) {
      if (textNode.textContent) {
        textNode.textContent = textNode.textContent.replace(/\s+/g, ' ').trim();
      }
    }

    return tempDiv.innerHTML;
  }

  /**
   * Count words in content
   */
  private countWords(content: string): number {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = content;
    const text = tempDiv.textContent || '';

    return text
      .trim()
      .split(/\s+/)
      .filter(word => word.length > 0).length;
  }

  /**
   * Estimate reading time
   */
  private estimateReadingTime(wordCount: number): number {
    const wordsPerMinute = 225;
    return Math.ceil(wordCount / wordsPerMinute);
  }

  // Utility methods for backward compatibility

  /**
   * Extract images from the page
   */
  extractImages(): Array<{ src: string; alt: string; title?: string }> {
    return Array.from(document.querySelectorAll('img'))
      .map(img => {
        const result: { src: string; alt: string; title?: string } = {
          src: img.src,
          alt: img.alt || '',
        };
        if (img.title) {
          result.title = img.title;
        }
        return result;
      })
      .filter(img => img.src && !img.src.startsWith('data:'));
  }

  /**
   * Extract links from the page
   */
  extractLinks(): Array<{ href: string; text: string; title?: string }> {
    return Array.from(document.querySelectorAll('a[href]'))
      .map(link => {
        const anchor = link as HTMLAnchorElement;
        const result: { href: string; text: string; title?: string } = {
          href: anchor.href,
          text: anchor.textContent?.trim() || '',
        };
        if (anchor.title) {
          result.title = anchor.title;
        }
        return result;
      })
      .filter(link => link.href && !link.href.startsWith('javascript:'));
  }

  /**
   * Get page structure information
   */
  getPageStructure(): { headings: string[]; sections: number; paragraphs: number } {
    const headings = Array.from(document.querySelectorAll('h1, h2, h3, h4, h5, h6'))
      .map(h => h.textContent?.trim() || '')
      .filter(text => text.length > 0);

    const sections = document.querySelectorAll('section, article, div.section').length;
    const paragraphs = document.querySelectorAll('p').length;

    return { headings, sections, paragraphs };
  }

  /**
   * Check if paywall is present
   */
  isPaywallPresent(): boolean {
    const paywallSelectors = [
      '.paywall',
      '.subscription-wall',
      '.premium-content',
      '[class*="paywall"]',
      '[id*="paywall"]',
      '.login-required',
      '.subscriber-only',
    ];

    return paywallSelectors.some(selector => document.querySelector(selector) !== null);
  }

  /**
   * Get content quality score
   */
  getContentQualityScore(): number {
    return this.qualityAnalyzer.getPageQualityScore();
  }
}
