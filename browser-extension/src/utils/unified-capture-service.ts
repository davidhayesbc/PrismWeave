// Generated by Copilot
// Unified Content Capture Service - Handles both HTML and PDF content detection and capture
// Provides a single interface for capturing any type of web content

import { ContentCaptureService } from './content-capture-service.js';
import { createLogger } from './logger.js';
import { PDFCaptureService } from './pdf-capture-service.js';
import { SettingsManager } from './settings-manager.js';

const logger = createLogger('UnifiedCaptureService');

/**
 * Content type detection result
 */
export interface IContentTypeInfo {
  contentType: 'html' | 'pdf' | 'unknown';
  isDetected: boolean;
  url: string;
  title?: string;
  confidence: number; // 0-1 scale
  indicators: string[]; // What made us detect this type
}

/**
 * Unified capture result that can handle both HTML and PDF
 */
export interface IUnifiedCaptureResult {
  success: boolean;
  message: string;
  contentType: 'html' | 'pdf' | 'unknown';
  data?: {
    filename: string;
    filePath: string;
    title?: string;
    url?: string;
    fileSize?: number;
    commitUrl?: string;
    status?: string;
    timestamp: string;
    contentType: 'html' | 'pdf';
    captureMethod: 'html-extraction' | 'pdf-download';
  };
  error?: string;
  warnings?: string[];
}

/**
 * Options for unified capture operations
 */
export interface IUnifiedCaptureOptions {
  validateSettings?: boolean;
  forceContentType?: 'html' | 'pdf'; // Override auto-detection
  customFilename?: string;
  folder?: string;
  autoDetectionTimeout?: number; // Timeout for content detection in ms
}

/**
 * Unified Content Capture Service
 *
 * Automatically detects content type (HTML or PDF) and routes to the appropriate
 * capture service. Provides enhanced logging and status reporting throughout the process.
 */
export class UnifiedCaptureService {
  private settingsManager: SettingsManager;
  private contentCaptureService: ContentCaptureService;
  private pdfCaptureService: PDFCaptureService;

  constructor(settingsManager: SettingsManager) {
    this.settingsManager = settingsManager;
    this.contentCaptureService = new ContentCaptureService(settingsManager);
    this.pdfCaptureService = new PDFCaptureService(settingsManager);

    logger.info('UnifiedCaptureService initialized');
  }

  /**
   * Main entry point for unified content capture
   * Automatically detects content type and captures accordingly
   */
  async captureContent(
    data?: Record<string, unknown>,
    options: IUnifiedCaptureOptions = {}
  ): Promise<IUnifiedCaptureResult> {
    const startTime = Date.now();

    try {
      logger.group('üöÄ Starting unified content capture');
      logger.info('üìã Input data:', {
        hasData: !!data,
        dataKeys: data ? Object.keys(data) : [],
        tabUrl: (data as any)?.tabInfo?.url,
        tabTitle: (data as any)?.tabInfo?.title,
      });
      logger.info('‚öôÔ∏è Capture options:', options);

      // Step 1: Detect content type (unless forced)
      logger.info('üîç Step 1: Detecting content type...');
      let contentTypeInfo: IContentTypeInfo;

      if (options.forceContentType) {
        logger.info('üéØ Content type forced to:', options.forceContentType);
        contentTypeInfo = {
          contentType: options.forceContentType,
          isDetected: true,
          url: (data as any)?.tabInfo?.url || (data as any)?.url || '',
          confidence: 1.0,
          indicators: ['forced-by-option'],
        };
      } else {
        logger.info('üïµÔ∏è Auto-detecting content type...');
        contentTypeInfo = await this.detectContentType(data, options.autoDetectionTimeout);
        logger.info('‚úÖ Content type detected:', {
          type: contentTypeInfo.contentType,
          confidence: contentTypeInfo.confidence,
          indicators: contentTypeInfo.indicators,
        });
      }

      // Step 2: Validate settings if required
      if (options.validateSettings) {
        logger.info('üîê Step 2: Validating settings before capture...');
        await this.validateCaptureSettings();
        logger.info('‚úÖ Settings validation passed');
      } else {
        logger.info('‚è≠Ô∏è Step 2: Skipping settings validation');
      }

      // Step 3: Route to appropriate capture service based on detected type
      logger.info('üéØ Step 3: Routing to appropriate capture service...');
      let result: IUnifiedCaptureResult;

      switch (contentTypeInfo.contentType) {
        case 'pdf':
          logger.info('üìÑ Routing to PDF capture service...');
          result = await this.capturePDFContent(data, options, contentTypeInfo);
          break;

        case 'html':
          logger.info('Routing to HTML capture service...');
          result = await this.captureHTMLContent(data, options, contentTypeInfo);
          break;

        default:
          logger.warn('Unknown or unsupported content type, attempting HTML capture as fallback');
          result = await this.captureHTMLContent(data, options, contentTypeInfo);
          if (result.success) {
            result.warnings = result.warnings || [];
            result.warnings.push(
              'Content type could not be determined - used HTML capture as fallback'
            );
          }
          break;
      }

      // Step 4: Add performance metrics
      const captureTime = Date.now() - startTime;
      logger.info(`Unified capture completed in ${captureTime}ms`, {
        success: result.success,
        contentType: result.contentType,
        captureMethod: result.data?.captureMethod,
      });

      return result;
    } catch (error) {
      const captureTime = Date.now() - startTime;
      logger.error('Unified capture failed:', error);
      logger.error(`Failed after ${captureTime}ms`);

      return {
        success: false,
        message: error instanceof Error ? error.message : 'Unknown error occurred',
        contentType: 'unknown',
        error: error instanceof Error ? error.message : String(error),
      };
    } finally {
      logger.groupEnd();
    }
  }

  /**
   * Detect the type of content on the current page
   */
  async detectContentType(
    data?: Record<string, unknown>,
    timeout: number = 5000
  ): Promise<IContentTypeInfo> {
    try {
      logger.info('Starting content type detection');

      // Get current tab information
      const tab = await this.getCurrentTab();
      const url = tab.url || '';
      const title = tab.title || '';

      logger.info('Analyzing tab:', { url, title, tabId: tab.id });

      const indicators: string[] = [];
      let confidence = 0;
      let contentType: 'html' | 'pdf' | 'unknown' = 'unknown';

      // Detection Method 1: URL-based detection
      const urlAnalysis = this.analyzeURLForContentType(url);
      if (urlAnalysis.isPDF) {
        contentType = 'pdf';
        confidence = Math.max(confidence, urlAnalysis.confidence);
        indicators.push(...urlAnalysis.indicators);
        logger.info('URL analysis indicates PDF:', urlAnalysis);
      } else if (urlAnalysis.isHTML) {
        contentType = 'html';
        confidence = Math.max(confidence, urlAnalysis.confidence);
        indicators.push(...urlAnalysis.indicators);
        logger.info('URL analysis indicates HTML:', urlAnalysis);
      }

      // Detection Method 2: Use PDF service to double-check
      if (contentType === 'pdf' || contentType === 'unknown') {
        try {
          logger.info('Using PDF service for additional verification...');
          const pdfCheck = await this.pdfCaptureService.checkIfPDF(tab.id);

          if (pdfCheck.isPDF) {
            contentType = 'pdf';
            confidence = Math.max(confidence, 0.9);
            indicators.push('pdf-service-verification');
            logger.info('PDF service confirms PDF content');
          } else if (contentType === 'unknown') {
            contentType = 'html';
            confidence = Math.max(confidence, 0.7);
            indicators.push('pdf-service-negative');
            logger.info('PDF service indicates HTML content');
          }
        } catch (error) {
          logger.warn('PDF service check failed, continuing with URL analysis:', error);
          indicators.push('pdf-service-failed');
        }
      }

      // Detection Method 3: Content-Type header check (if available)
      // This would require additional API calls which might be restricted

      // Default to HTML if still unknown
      if (contentType === 'unknown') {
        contentType = 'html';
        confidence = Math.max(confidence, 0.5);
        indicators.push('default-fallback-html');
        logger.info('Defaulting to HTML content type');
      }

      const result: IContentTypeInfo = {
        contentType,
        isDetected: confidence > 0.5,
        url,
        title,
        confidence,
        indicators,
      };

      logger.info('Content type detection complete:', result);
      return result;
    } catch (error) {
      logger.error('Content type detection failed:', error);

      // Return safe fallback
      return {
        contentType: 'html',
        isDetected: false,
        url: '',
        confidence: 0.3,
        indicators: ['detection-failed-fallback'],
      };
    }
  }

  /**
   * Analyze URL patterns to determine content type
   */
  private analyzeURLForContentType(url: string): {
    isPDF: boolean;
    isHTML: boolean;
    confidence: number;
    indicators: string[];
  } {
    const indicators: string[] = [];
    let isPDF = false;
    let isHTML = false;
    let confidence = 0;

    try {
      const urlObj = new URL(url);
      const pathname = urlObj.pathname.toLowerCase();
      const search = urlObj.search.toLowerCase();
      const fullUrl = url.toLowerCase();

      // Strong PDF indicators
      if (pathname.endsWith('.pdf')) {
        isPDF = true;
        confidence = 0.95;
        indicators.push('filename-ends-with-pdf');
      }

      // PDF viewer patterns
      const pdfViewerPatterns = [
        /\/pdf\//i,
        /\.pdf\?/i,
        /\.pdf#/i,
        /pdfjs/i,
        /viewer\.html.*\.pdf/i,
        /blob:.*pdf/i,
      ];

      for (const pattern of pdfViewerPatterns) {
        if (pattern.test(fullUrl)) {
          isPDF = true;
          confidence = Math.max(confidence, 0.8);
          indicators.push(`pdf-pattern-${pattern.source}`);
        }
      }

      // PDF URL parameters
      if (search.includes('pdf') || search.includes('application/pdf')) {
        isPDF = true;
        confidence = Math.max(confidence, 0.7);
        indicators.push('pdf-in-query-params');
      }

      // HTML indicators
      if (!isPDF) {
        if (pathname === '/' || pathname.endsWith('.html') || pathname.endsWith('.htm')) {
          isHTML = true;
          confidence = 0.8;
          indicators.push('html-file-extension-or-root');
        }

        // Common web page patterns
        const htmlPatterns = [/\/(blog|article|post|news|page)/i, /\.(html?|php|asp|jsp)$/i];

        for (const pattern of htmlPatterns) {
          if (pattern.test(pathname)) {
            isHTML = true;
            confidence = Math.max(confidence, 0.7);
            indicators.push(`html-pattern-${pattern.source}`);
          }
        }
      }

      // Default assumption for standard web URLs
      if (!isPDF && !isHTML && (urlObj.protocol === 'http:' || urlObj.protocol === 'https:')) {
        isHTML = true;
        confidence = 0.6;
        indicators.push('default-web-url');
      }
    } catch (error) {
      logger.warn('URL analysis failed:', error);
      indicators.push('url-parse-error');
    }

    return { isPDF, isHTML, confidence, indicators };
  }

  /**
   * Capture PDF content using the PDF service
   */
  private async capturePDFContent(
    data: Record<string, unknown> = {},
    options: IUnifiedCaptureOptions,
    contentTypeInfo: IContentTypeInfo
  ): Promise<IUnifiedCaptureResult> {
    try {
      logger.info('üìÑ Starting PDF content capture process');
      logger.info('üìä PDF Capture Step 1: Preparing PDF capture options');

      // Enhanced PDF capture options
      const pdfOptions: any = {
        validateSettings: options.validateSettings ?? false,
        forceGitHubCommit: true, // Always commit PDFs since they're binary files
      };

      if (options.customFilename) {
        pdfOptions.customFilename = options.customFilename;
      }
      if (options.folder) {
        pdfOptions.folder = options.folder;
      }

      logger.info('‚öôÔ∏è PDF Capture Step 2: PDF options prepared:', pdfOptions);
      logger.info('üîå PDF Capture Step 3: Calling PDF capture service...');
      const pdfResult = await this.pdfCaptureService.capturePDF(data, pdfOptions);

      logger.info('‚úÖ PDF Capture Step 4: PDF capture service completed:', {
        success: pdfResult.success,
        message: pdfResult.message,
        hasData: !!pdfResult.data,
        filename: pdfResult.data?.filename,
        fileSize: pdfResult.data?.fileSize,
      });

      logger.info('üîÑ PDF Capture Step 5: Converting PDF result to unified format...');
      // Convert PDF result to unified format with enhanced status reporting
      const unifiedResult: IUnifiedCaptureResult = {
        success: pdfResult.success,
        message: pdfResult.message,
        contentType: 'pdf',
      };

      if (pdfResult.error) {
        unifiedResult.error = pdfResult.error;
        logger.error('‚ùå PDF capture error details:', pdfResult.error);
      }

      if (pdfResult.data) {
        logger.info('üìã PDF Capture Step 6: Processing PDF result data...');
        unifiedResult.data = {
          ...pdfResult.data,
          contentType: 'pdf' as const,
          captureMethod: 'pdf-download' as const,
        };

        logger.info('üíæ PDF Capture Step 7: Creating save result for popup compatibility...');
        // Add save result information for popup status reporting
        const saveResult = {
          success: pdfResult.success,
          committed: !!pdfResult.data.commitUrl,
          url: pdfResult.data.commitUrl,
          sha: pdfResult.data.commitUrl ? 'committed' : undefined,
          reason:
            pdfResult.data.status === 'pending_sync' ? 'Stored locally - pending sync' : undefined,
        };

        // Add save result to the response for popup compatibility
        (unifiedResult as any).saveResult = saveResult;
        (unifiedResult as any).filename = pdfResult.data.filename;

        logger.info('‚úÖ PDF save result created:', saveResult);
      }

      // Add content detection info to warnings if confidence is low
      if (contentTypeInfo.confidence < 0.8) {
        unifiedResult.warnings = [
          `PDF detection confidence: ${Math.round(contentTypeInfo.confidence * 100)}%`,
        ];
      }

      logger.info('üéâ PDF Capture Complete - returning unified result:', {
        success: unifiedResult.success,
        contentType: unifiedResult.contentType,
        hasData: !!unifiedResult.data,
        hasSaveResult: !!(unifiedResult as any).saveResult,
      });

      return unifiedResult;
    } catch (error) {
      logger.error('PDF capture failed:', error);
      return {
        success: false,
        message: `PDF capture failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        contentType: 'pdf',
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Capture HTML content using the content service
   */
  private async captureHTMLContent(
    data: Record<string, unknown> = {},
    options: IUnifiedCaptureOptions,
    contentTypeInfo: IContentTypeInfo
  ): Promise<IUnifiedCaptureResult> {
    try {
      logger.info('Starting HTML content capture');

      // Enhanced HTML capture options
      const htmlOptions: any = {
        includeMarkdown: true,
        validateSettings: options.validateSettings ?? false,
      };

      if (options.customFilename) {
        htmlOptions.customFilename = options.customFilename;
      }
      if (options.folder) {
        htmlOptions.folder = options.folder;
      }

      logger.info('Calling content capture service with options:', htmlOptions);
      const htmlResult = await this.contentCaptureService.capturePage(data, htmlOptions);

      logger.info('HTML capture service result:', {
        success: htmlResult.success,
        message: htmlResult.message,
        hasData: !!htmlResult.data,
      });

      // Convert HTML result to unified format
      const unifiedResult: IUnifiedCaptureResult = {
        success: htmlResult.success,
        message: htmlResult.message,
        contentType: 'html',
      };

      if (!htmlResult.success) {
        unifiedResult.error = htmlResult.message;
      }

      if (htmlResult.data) {
        unifiedResult.data = {
          filename: htmlResult.data.filename || 'document.md',
          filePath: htmlResult.data.filePath || '',
          timestamp: htmlResult.data.timestamp || new Date().toISOString(),
          contentType: 'html' as const,
          captureMethod: 'html-extraction' as const,
        };

        // Add optional fields if they exist
        if (htmlResult.data.title) {
          unifiedResult.data.title = htmlResult.data.title;
        }
        if (htmlResult.data.url) {
          unifiedResult.data.url = htmlResult.data.url;
        }
        if (htmlResult.data.commitUrl) {
          unifiedResult.data.commitUrl = htmlResult.data.commitUrl;
        }
        if (htmlResult.data.status) {
          unifiedResult.data.status = htmlResult.data.status;
        }
      }

      // Add content detection info to warnings if confidence is low
      if (contentTypeInfo.confidence < 0.8) {
        unifiedResult.warnings = [
          `HTML detection confidence: ${Math.round(contentTypeInfo.confidence * 100)}%`,
        ];
      }

      logger.info('HTML capture completed successfully');
      return unifiedResult;
    } catch (error) {
      logger.error('HTML capture failed:', error);
      return {
        success: false,
        message: `HTML capture failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        contentType: 'html',
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Get current active tab
   */
  private async getCurrentTab(): Promise<chrome.tabs.Tab> {
    return new Promise((resolve, reject) => {
      chrome.tabs.query({ active: true, currentWindow: true }, tabs => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else if (!tabs.length || !tabs[0].id) {
          reject(new Error('No active tab found'));
        } else {
          resolve(tabs[0]);
        }
      });
    });
  }

  /**
   * Validate capture settings
   */
  private async validateCaptureSettings(): Promise<void> {
    const settings = await this.settingsManager.getSettings();
    const validation = this.settingsManager.validateSettings(settings);

    if (!validation.isValid) {
      throw new Error(`Invalid settings: ${validation.errors.join(', ')}`);
    }
  }

  /**
   * Get detailed status of the unified capture service
   */
  getStatus(): Record<string, unknown> {
    return {
      initialized: true,
      services: {
        settingsManager: !!this.settingsManager,
        contentCaptureService: !!this.contentCaptureService,
        pdfCaptureService: !!this.pdfCaptureService,
      },
      capabilities: {
        htmlCapture: true,
        pdfCapture: true,
        autoDetection: true,
        enhancedLogging: true,
      },
      version: '1.0.0',
      timestamp: new Date().toISOString(),
    };
  }
}
