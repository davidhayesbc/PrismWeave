// Generated by Copilot
// Standalone Content Extractor for PrismWeave Bookmarklet
// This module contains self-contained content extraction logic that can be used
// in both browser extension context and standalone bookmarklet context.

// Re-export types and interfaces for standalone use
export interface IDocumentMetadata {
  title: string;
  url: string;
  captureDate: string;
  tags: string[];
  author: string;
  wordCount: number;
  estimatedReadingTime: number;
}

export interface IContentResult {
  content: string;
  metadata: IDocumentMetadata;
  cleanedContent: string;
  wordCount: number;
  readingTime: number;
}

export interface IExtractorOptions {
  customSelectors?: string[];
  cleanHtml?: boolean;
  preserveFormatting?: boolean;
  waitForDynamicContent?: boolean;
  removeAds?: boolean;
  removeNavigation?: boolean;
  excludeSelectors?: string[];
}

export interface IPageStructure {
  headings: Array<{ level: number; text: string }>;
  sections: number;
  paragraphs: number;
}

export interface IImageInfo {
  src: string;
  alt: string;
}

export interface IConversionOptions {
  preserveFormatting?: boolean;
  includeMetadata?: boolean;
  generateFrontmatter?: boolean;
  customRules?: Array<{ filter: string; replacement: string | Function }>;
  includeImages?: boolean;
  includeLinks?: boolean;
}

export interface IConversionResult {
  markdown: string;
  frontmatter: string;
  metadata: Record<string, unknown>;
  warnings: string[];
}

/**
 * Standalone Content Extractor
 * Self-contained implementation that doesn't rely on browser extension APIs
 */
export class StandaloneContentExtractor {
  /**
   * Extract content from the current page
   */
  async extractContent(options: IExtractorOptions = {}): Promise<IContentResult> {
    try {
      // Wait for content to load if needed
      if (options.waitForDynamicContent !== false) {
        await this.waitForContent();
      }

      // Extract metadata first
      const metadata = this.extractMetadata();

      // Find main content element
      const contentElement = this.findMainContent(options);
      if (!contentElement) {
        throw new Error('No suitable content found on page');
      }

      // Clean the content
      const cleanedElement = this.cleanContent(contentElement, options);
      const content = cleanedElement.innerHTML || '';
      const textContent = cleanedElement.textContent || '';

      // Calculate metrics
      const wordCount = this.countWords(textContent);
      const readingTime = this.estimateReadingTime(wordCount);

      // Update metadata with calculated values
      metadata.wordCount = wordCount;
      metadata.estimatedReadingTime = readingTime;

      return {
        content,
        metadata,
        cleanedContent: textContent,
        wordCount,
        readingTime,
      };
    } catch (error) {
      console.error('Error during content extraction:', error);
      throw error;
    }
  }

  /**
   * Extract page metadata
   */
  extractMetadata(): IDocumentMetadata {
    const wordCount = this.countWords(document.body.textContent || '');
    return {
      title: this.extractTitle(),
      url: window.location.href,
      captureDate: new Date().toISOString(),
      tags: this.extractKeywords(),
      author: this.extractAuthor(),
      wordCount: wordCount,
      estimatedReadingTime: this.estimateReadingTime(wordCount),
    };
  }

  /**
   * Extract images from the page
   */
  extractImages(): IImageInfo[] {
    const images: IImageInfo[] = [];
    const imgElements = document.querySelectorAll('img');

    imgElements.forEach(img => {
      const src = img.src;
      if (src && !src.startsWith('data:') && src.length > 0) {
        // Convert relative URLs to absolute
        try {
          const absoluteUrl = new URL(src, window.location.href).href;
          images.push({
            src: absoluteUrl,
            alt: img.alt || '',
          });
        } catch (error) {
          // Skip invalid URLs
          console.warn('Invalid image URL:', src);
        }
      }
    });

    return images;
  }

  /**
   * Get page structure information
   */
  getPageStructure(): IPageStructure {
    const headings: Array<{ level: number; text: string }> = [];
    const headingElements = document.querySelectorAll('h1, h2, h3, h4, h5, h6');

    headingElements.forEach(heading => {
      const level = parseInt(heading.tagName.substring(1));
      const text = heading.textContent?.trim() || '';
      if (text) {
        headings.push({ level, text });
      }
    });

    const sections = document.querySelectorAll('section, article, main').length;
    const paragraphs = document.querySelectorAll('p').length;

    return { headings, sections, paragraphs };
  }

  /**
   * Convert HTML content to Markdown
   */
  convertToMarkdown(html: string, options: IConversionOptions = {}): IConversionResult {
    const warnings: string[] = [];
    
    let markdown = html;

    // Convert headers
    markdown = this.convertHeaders(markdown);
    
    // Convert lists
    markdown = this.convertLists(markdown);
    
    // Convert tables
    markdown = this.convertTables(markdown);
    
    // Convert code blocks
    markdown = this.convertCodeBlocks(markdown);
    
    // Convert blockquotes
    markdown = this.convertBlockquotes(markdown);
    
    // Convert images
    if (options.includeImages !== false) {
      markdown = this.convertImages(markdown);
    }
    
    // Convert links
    if (options.includeLinks !== false) {
      markdown = this.convertLinks(markdown);
    }
    
    // Convert text formatting
    markdown = this.convertTextFormatting(markdown);
    
    // Convert line breaks
    markdown = this.convertLineBreaks(markdown);
    
    // Clean up HTML
    markdown = this.cleanupHtml(markdown);
    
    // Normalize whitespace
    markdown = this.normalizeWhitespace(markdown);

    // Generate frontmatter
    const frontmatter = options.generateFrontmatter 
      ? this.generateFrontmatter()
      : '';

    // Generate metadata
    const metadata = options.includeMetadata 
      ? this.extractMetadata()
      : {};

    return {
      markdown,
      frontmatter,
      metadata,
      warnings
    };
  }

  // Private helper methods

  private async waitForContent(): Promise<void> {
    // Wait a bit for dynamic content to load
    await new Promise(resolve => setTimeout(resolve, 500));

    // Wait for images to finish loading
    const images = Array.from(document.images);
    if (images.length > 0) {
      await Promise.allSettled(
        images.map(img => {
          if (img.complete) return Promise.resolve();
          return new Promise(resolve => {
            img.onload = img.onerror = () => resolve(null);
            setTimeout(() => resolve(null), 3000); // 3 second timeout
          });
        })
      );
    }
  }

  private findMainContent(options: IExtractorOptions): Element | null {
    // Try custom selectors first
    if (options.customSelectors?.length) {
      for (const selector of options.customSelectors) {
        const element = document.querySelector(selector);
        if (element && this.hasSubstantialContent(element)) {
          return element;
        }
      }
    }

    // Common content selectors in order of preference
    const contentSelectors = [
      'article',
      'main',
      '[role="main"]',
      '.content',
      '.post-content',
      '.entry-content',
      '.article-content',
      '#content',
      '#main',
      '.post',
      '.entry',
    ];

    for (const selector of contentSelectors) {
      const element = document.querySelector(selector);
      if (element && this.hasSubstantialContent(element)) {
        return element;
      }
    }

    // Score-based fallback
    const candidates = Array.from(document.querySelectorAll('div, section, article'));
    let bestCandidate: { element: Element; score: number } | null = null;

    for (const candidate of candidates) {
      if (this.hasSubstantialContent(candidate)) {
        const score = this.scoreElement(candidate);
        if (!bestCandidate || score > bestCandidate.score) {
          bestCandidate = { element: candidate, score };
        }
      }
    }

    return bestCandidate?.element || document.body;
  }

  private hasSubstantialContent(element: Element): boolean {
    const textContent = element.textContent || '';
    const wordCount = this.countWords(textContent);
    return wordCount > 30; // Require at least 30 words
  }

  private scoreElement(element: Element): number {
    const text = element.textContent || '';
    const wordCount = this.countWords(text);
    let score = 0;

    // Word count scoring
    score += Math.min(wordCount / 10, 50);

    // Paragraph count scoring
    const paragraphs = element.querySelectorAll('p').length;
    score += paragraphs * 2;

    // Link density penalty
    const links = element.querySelectorAll('a').length;
    const linkDensity = links / Math.max(wordCount, 1);
    if (linkDensity > 0.3) score -= 20;

    // Semantic element bonus
    const tagName = element.tagName.toLowerCase();
    if (tagName === 'article') score += 15;
    if (tagName === 'main') score += 10;

    // Class name scoring
    const className = element.className.toLowerCase();
    if (className.includes('content')) score += 10;
    if (className.includes('post')) score += 8;
    if (className.includes('article')) score += 8;

    // Negative scoring
    if (className.includes('sidebar')) score -= 10;
    if (className.includes('footer')) score -= 10;
    if (className.includes('header')) score -= 10;
    if (className.includes('nav')) score -= 15;

    return Math.max(score, 0);
  }

  private cleanContent(element: Element, options: IExtractorOptions): Element {
    const cloned = element.cloneNode(true) as Element;

    // Default exclude selectors
    const defaultExcludeSelectors = [
      'script',
      'style',
      'noscript',
      'iframe',
      '.advertisement',
      '.ad',
      '.ads',
      '.popup',
      '.modal',
      '.social-share',
      '.comments',
      '.related-posts',
      '[style*="display: none"]',
      '[style*="visibility: hidden"]',
      // PrismWeave specific elements
      '#prismweave-notification',
      '[id*="prismweave"]',
      '[class*="prismweave"]',
    ];

    // Combine with custom exclude selectors
    const excludeSelectors = [...defaultExcludeSelectors, ...(options.excludeSelectors || [])];

    // Remove unwanted elements
    excludeSelectors.forEach(selector => {
      const elements = cloned.querySelectorAll(selector);
      elements.forEach(el => el.remove());
    });

    // Additional cleaning for ads and navigation
    if (options.removeAds !== false) {
      this.removeAds(cloned);
    }

    if (options.removeNavigation !== false) {
      this.removeNavigation(cloned);
    }

    return cloned;
  }

  private removeAds(element: Element): void {
    const adSelectors = [
      '[class*="ad"]',
      '[id*="ad"]',
      '[class*="banner"]',
      '[id*="banner"]',
      '[class*="promo"]',
      '[id*="promo"]',
      '[class*="sponsor"]',
      '[id*="sponsor"]',
    ];

    adSelectors.forEach(selector => {
      const elements = element.querySelectorAll(selector);
      elements.forEach(el => {
        // Only remove if it looks like an ad
        const text = el.textContent?.toLowerCase() || '';
        if (
          text.includes('advertisement') ||
          text.includes('sponsored') ||
          el.textContent!.length < 50
        ) {
          el.remove();
        }
      });
    });
  }

  private removeNavigation(element: Element): void {
    const navSelectors = [
      'nav',
      'header',
      'footer',
      '[role="navigation"]',
      '[role="banner"]',
      '[role="contentinfo"]',
      '.navigation',
      '.nav',
      '.menu',
      '.breadcrumb',
    ];

    navSelectors.forEach(selector => {
      const elements = element.querySelectorAll(selector);
      elements.forEach(el => el.remove());
    });
  }

  // Markdown conversion methods

  private convertHeaders(html: string): string {
    return html.replace(/<h([1-6])[^>]*>(.*?)<\/h[1-6]>/gi, (match, level, content) => {
      const headerLevel = '#'.repeat(parseInt(level));
      const cleanContent = this.stripHtml(content).trim();
      return `\n${headerLevel} ${cleanContent}\n`;
    });
  }

  private convertLists(html: string): string {
    // Unordered lists
    html = html.replace(/<ul[^>]*>(.*?)<\/ul>/gis, (match, content) => {
      const items = content.replace(/<li[^>]*>(.*?)<\/li>/gi, (liMatch: string, liContent: string) => {
        const cleanContent = this.stripHtml(liContent).trim();
        return `- ${cleanContent}\n`;
      });
      return `\n${items}\n`;
    });

    // Ordered lists
    html = html.replace(/<ol[^>]*>(.*?)<\/ol>/gis, (match, content) => {
      let counter = 1;
      const items = content.replace(/<li[^>]*>(.*?)<\/li>/gi, (liMatch: string, liContent: string) => {
        const cleanContent = this.stripHtml(liContent).trim();
        return `${counter++}. ${cleanContent}\n`;
      });
      return `\n${items}\n`;
    });

    return html;
  }

  private convertTables(html: string): string {
    return html.replace(/<table[^>]*>(.*?)<\/table>/gis, (match, content) => {
      const rows: string[] = [];
      
      // Process header
      const headerMatch = content.match(/<thead[^>]*>(.*?)<\/thead>/is);
      if (headerMatch) {
        const headerRow = this.convertTableRow(headerMatch[1]);
        if (headerRow) {
          rows.push(headerRow);
          // Add separator row
          const separatorCells = headerRow.split('|').length - 2; // Account for leading/trailing |
          const separator = '|' + '---|'.repeat(separatorCells);
          rows.push(separator);
        }
      }
      
      // Process body rows
      const bodyMatch = content.match(/<tbody[^>]*>(.*?)<\/tbody>/is) || [null, content];
      if (bodyMatch[1]) {
        const bodyRows = bodyMatch[1].match(/<tr[^>]*>(.*?)<\/tr>/gis);
        if (bodyRows) {
          bodyRows.forEach((row: string) => {
            const convertedRow = this.convertTableRow(row);
            if (convertedRow) rows.push(convertedRow);
          });
        }
      }
      
      // If no header was found but we have rows, add a separator after first row
      if (!headerMatch && rows.length > 0) {
        const separatorCells = rows[0].split('|').length - 2;
        const separator = '|' + '---|'.repeat(separatorCells);
        rows.splice(1, 0, separator);
      }
      
      return rows.length > 0 ? `\n${rows.join('\n')}\n` : '';
    });
  }

  private convertTableRow(rowHtml: string): string | null {
    const cells = rowHtml.match(/<t[hd][^>]*>(.*?)<\/t[hd]>/gis);
    if (!cells) return null;
    
    const convertedCells = cells.map(cell => {
      const content = cell.replace(/<t[hd][^>]*>(.*?)<\/t[hd]>/i, '$1');
      return this.stripHtml(content).trim();
    });
    
    return `|${convertedCells.join('|')}|`;
  }

  private convertCodeBlocks(html: string): string {
    // Pre + code blocks
    html = html.replace(/<pre[^>]*><code[^>]*>(.*?)<\/code><\/pre>/gis, (match, content) => {
      const cleanContent = this.decodeHtmlEntities(content).trim();
      return `\n\`\`\`\n${cleanContent}\n\`\`\`\n`;
    });

    // Inline code
    html = html.replace(/<code[^>]*>(.*?)<\/code>/gi, (match, content) => {
      const cleanContent = this.stripHtml(content);
      return `\`${cleanContent}\``;
    });

    return html;
  }

  private convertBlockquotes(html: string): string {
    return html.replace(/<blockquote[^>]*>(.*?)<\/blockquote>/gis, (match, content) => {
      const cleanContent = this.stripHtml(content).trim();
      const lines = cleanContent.split('\n');
      const quotedLines = lines.map(line => `> ${line.trim()}`);
      return `\n${quotedLines.join('\n')}\n`;
    });
  }

  private convertImages(html: string): string {
    return html.replace(/<img[^>]*src=["']([^"']*)["'][^>]*alt=["']([^"']*)["'][^>]*>/gi, '![$2]($1)')
               .replace(/<img[^>]*alt=["']([^"']*)["'][^>]*src=["']([^"']*)["'][^>]*>/gi, '![$1]($2)')
               .replace(/<img[^>]*src=["']([^"']*)["'][^>]*>/gi, '![]($1)');
  }

  private convertLinks(html: string): string {
    return html.replace(/<a[^>]*href=["']([^"']*)["'][^>]*>(.*?)<\/a>/gi, '[$2]($1)');
  }

  private convertTextFormatting(html: string): string {
    // Bold/Strong
    html = html.replace(/<(strong|b)[^>]*>(.*?)<\/(strong|b)>/gi, '**$2**');
    
    // Italic/Emphasis  
    html = html.replace(/<(em|i)[^>]*>(.*?)<\/(em|i)>/gi, '*$2*');
    
    // Strikethrough
    html = html.replace(/<(del|s|strike)[^>]*>(.*?)<\/(del|s|strike)>/gi, '~~$2~~');
    
    return html;
  }

  private convertLineBreaks(html: string): string {
    return html.replace(/<br[^>]*\/?>/gi, '\n');
  }

  private cleanupHtml(html: string): string {
    // Remove remaining HTML tags
    return html.replace(/<[^>]*>/g, '');
  }

  private normalizeWhitespace(markdown: string): string {
    // Remove excessive blank lines
    markdown = markdown.replace(/\n\s*\n\s*\n/g, '\n\n');
    
    // Trim leading/trailing whitespace
    markdown = markdown.trim();
    
    // Ensure single newline at end
    return markdown + '\n';
  }

  private stripHtml(html: string): string {
    return html.replace(/<[^>]*>/g, '').trim();
  }

  private decodeHtmlEntities(text: string): string {
    const entityMap: Record<string, string> = {
      '&lt;': '<',
      '&gt;': '>',
      '&amp;': '&',
      '&quot;': '"',
      '&#39;': "'",
      '&nbsp;': ' '
    };

    return text.replace(/&(?:lt|gt|amp|quot|#39|nbsp);/g, (entity) => {
      return entityMap[entity] || entity;
    });
  }

  private generateFrontmatter(): string {
    const title = this.extractTitle();
    const url = window.location.href;
    const now = new Date();
    const dateStr = now.toISOString().split('T')[0];
    
    return `---
title: "${title.replace(/"/g, '\\"')}"
url: "${url}"
date: "${dateStr}"
captured: "${now.toISOString()}"
tags: []
---`;
  }

  // Metadata extraction methods

  private extractTitle(): string {
    // Try multiple title sources in order of preference
    const titleSources = [
      () => document.querySelector('[property="og:title"]')?.getAttribute('content'),
      () => document.querySelector('[name="twitter:title"]')?.getAttribute('content'),
      () => document.querySelector('h1')?.textContent,
      () => document.title,
    ];

    for (const source of titleSources) {
      const title = source();
      if (title && title.trim().length > 0) {
        return title.trim();
      }
    }

    return 'Untitled';
  }

  private extractKeywords(): string[] {
    const keywordsMeta = document.querySelector('[name="keywords"]')?.getAttribute('content');
    if (keywordsMeta) {
      return keywordsMeta
        .split(',')
        .map(k => k.trim())
        .filter(k => k.length > 0);
    }
    return [];
  }

  private extractAuthor(): string {
    const authorSources = [
      () => document.querySelector('[property="article:author"]')?.getAttribute('content'),
      () => document.querySelector('[name="author"]')?.getAttribute('content'),
      () => document.querySelector('[rel="author"]')?.textContent,
      () => document.querySelector('.author')?.textContent,
      () => document.querySelector('.byline')?.textContent,
    ];

    for (const source of authorSources) {
      const author = source();
      if (author && author.trim().length > 0) {
        return author.trim();
      }
    }

    return '';
  }

  private countWords(text: string): number {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }

  private estimateReadingTime(wordCount: number): number {
    // Average reading speed: 200 words per minute
    return Math.ceil(wordCount / 200);
  }
}

// Create a function that provides the same interface as the browser extension's content extraction
export async function extractPageContentStandalone(options: IExtractorOptions = {}): Promise<{
  html: string;
  title: string;
  url: string;
  metadata: Record<string, unknown>;
  markdown: string;
  frontmatter: string;
  images: string[];
}> {
  const extractor = new StandaloneContentExtractor();
  
  // Extract content
  const contentResult = await extractor.extractContent(options);
  
  // Convert to markdown
  const markdownResult = extractor.convertToMarkdown(contentResult.content, {
    preserveFormatting: true,
    includeMetadata: true,
    generateFrontmatter: true,
    includeImages: true,
    includeLinks: true,
  });
  
  // Extract images
  const images = extractor.extractImages();
  const imageUrls = images.map(img => img.src);
  
  return {
    html: contentResult.content,
    title: contentResult.metadata.title,
    url: contentResult.metadata.url,
    metadata: {
      ...contentResult.metadata,
      extractedAt: new Date().toISOString(),
      domain: window.location.hostname,
      wordCount: contentResult.wordCount,
      readingTime: contentResult.readingTime,
      qualityScore: extractor.getPageStructure().paragraphs > 0 ? 85 : 50, // Simple quality score
    },
    markdown: markdownResult.markdown,
    frontmatter: markdownResult.frontmatter,
    images: imageUrls,
  };
}