// Generated by Copilot
// Unified notification API that automatically selects the best implementation based on execution environment.
// Falls back gracefully: Popup status UI → In-page toast → Chrome notifications → Console
// This is the ONLY public notification API - use this instead of calling toast.ts or popup status directly

import { showToast, ToastType } from './toast-internal';

export type NotificationType = 'success' | 'error' | 'info' | 'warning' | 'progress';

export interface INotificationAction {
  label: string;
  action: () => void;
  primary?: boolean;
}

export interface INotificationOptions {
  // Common options
  type?: NotificationType;
  message?: string; // Secondary message/details
  duration?: number; // Auto-hide duration (0 = persistent)
  dismissible?: boolean;

  // Advanced options (popup status UI)
  showProgress?: boolean;
  progressValue?: number; // 0-100
  actions?: INotificationAction[];
  details?: string[];

  // Toast-specific options
  clickUrl?: string;
  linkLabel?: string;
  openInNewTab?: boolean;
  onClick?: () => void;

  // Environment hints
  preferPopupStatus?: boolean; // Force popup status UI if available
  preferToast?: boolean; // Force toast if available
}

export interface INotificationContext {
  isPopup?: boolean; // Running in popup.html context
  isContentScript?: boolean; // Running in content script (has DOM)
  isServiceWorker?: boolean; // Running in service worker (no DOM)
  popupStatusHandler?: (
    title: string,
    message: string | undefined,
    type: NotificationType,
    options: INotificationOptions
  ) => void;
}

// Global context - can be updated by different environments
let notificationContext: INotificationContext = {
  isPopup: false,
  isContentScript: false,
  isServiceWorker: false,
  popupStatusHandler: undefined,
};

/**
 * Configure the notification context for the current environment
 * Call this from popup, content script, or service worker to set up the right handlers
 */
export function configureNotificationContext(context: Partial<INotificationContext>): void {
  notificationContext = { ...notificationContext, ...context };
}

/**
 * Unified notification function that selects the best display method
 * @param title Main notification title
 * @param options Notification options
 */
export function notify(title: string, options: INotificationOptions = {}): void {
  const {
    type = 'info',
    message,
    duration = 4000,
    dismissible = true,
    showProgress,
    progressValue,
    actions,
    clickUrl,
    linkLabel,
    openInNewTab,
    onClick,
    preferPopupStatus,
    preferToast,
  } = options;

  // Strategy 1: Use popup status UI if available and appropriate
  if (
    notificationContext.isPopup &&
    notificationContext.popupStatusHandler &&
    (preferPopupStatus || showProgress || actions || type === 'progress')
  ) {
    try {
      notificationContext.popupStatusHandler(title, message, type, options);
      return;
    } catch (error) {
      console.warn('Popup status handler failed, falling back:', error);
    }
  }

  // Strategy 2: Use toast for content scripts and extension pages with DOM
  if (typeof document !== 'undefined' && typeof window !== 'undefined' && !preferPopupStatus) {
    try {
      // Convert notification type to toast type
      const toastType: ToastType =
        type === 'warning' ? 'info' : type === 'progress' ? 'info' : (type as ToastType);

      // Combine title and message for toast
      const toastMessage = message ? `${title}: ${message}` : title;

      showToast(toastMessage, {
        type: toastType,
        duration,
        dismissible,
        clickUrl,
        linkLabel,
        openInNewTab,
        onClick,
      });
      return;
    } catch (error) {
      console.warn('Toast notification failed, falling back:', error);
    }
  }

  // Strategy 3: Use Chrome notifications API (service worker, or if toast unavailable)
  if (typeof chrome !== 'undefined' && chrome.notifications) {
    try {
      // Map notification type to icon
      const iconMap = {
        success: '../../icons/icon128.png',
        error: '../../icons/icon128.png',
        warning: '../../icons/icon128.png',
        info: '../../icons/icon128.png',
        progress: '../../icons/icon128.png',
      };

      chrome.notifications.create(
        {
          type: 'basic',
          iconUrl: iconMap[type] || iconMap.info,
          title,
          message: message || '',
          priority: type === 'error' ? 2 : type === 'warning' ? 1 : 0,
        },
        notificationId => {
          if (chrome.runtime.lastError) {
            console.warn('Chrome notification failed:', chrome.runtime.lastError.message);
          } else if (duration > 0) {
            // Auto-clear notification after duration
            setTimeout(() => {
              chrome.notifications.clear(notificationId, () => {
                // Ignore errors on clear
              });
            }, duration);
          }
        }
      );
      return;
    } catch (error) {
      console.warn('Chrome notification API failed, falling back:', error);
    }
  }

  // Strategy 4: Fallback to console logging
  const consoleMethod = type === 'error' ? 'error' : type === 'warning' ? 'warn' : 'log';
  console[consoleMethod](`[${type.toUpperCase()}] ${title}${message ? `: ${message}` : ''}`);
}

/**
 * Convenience methods for common notification types
 */
export const notification = {
  success: (title: string, options: Omit<INotificationOptions, 'type'> = {}) =>
    notify(title, { ...options, type: 'success' }),

  error: (title: string, options: Omit<INotificationOptions, 'type'> = {}) =>
    notify(title, { ...options, type: 'error' }),

  info: (title: string, options: Omit<INotificationOptions, 'type'> = {}) =>
    notify(title, { ...options, type: 'info' }),

  warning: (title: string, options: Omit<INotificationOptions, 'type'> = {}) =>
    notify(title, { ...options, type: 'warning' }),

  progress: (
    title: string,
    options: Omit<INotificationOptions, 'type'> & { progressValue: number }
  ) => notify(title, { ...options, type: 'progress', showProgress: true }),
};

// Make available globally for bookmarklet/debugging
if (typeof window !== 'undefined') {
  (window as any).prismweaveNotify = notify;
  (window as any).prismweaveNotification = notification;
}
