// Generated by Copilot
// Content script for PrismWeave browser extension
// Handles keyboard shortcuts and page content extraction

import {
  IContentExtractionData,
  IContentExtractionResult,
  IMessageData,
  IMessageResponse,
  MESSAGE_TYPES,
} from '../types/index.js';
import { ContentExtractor } from '../utils/content-extractor.js';
import { createLogger } from '../utils/logger.js';
import { MarkdownConverter } from '../utils/markdown-converter.js';
import { StackOverflowBlogExtractor } from '../utils/stackoverflow-blog-extractor.js';

console.log('üöÄ PrismWeave content script loading...');
console.log('üìç Current URL:', window.location.href);
console.log('üìÑ Page title:', document.title);

// Enhanced message response interface for better commit URL handling
interface IEnhancedMessageResponse extends IMessageResponse {
  commitUrl?: string;
  url?: string;
  saveResult?: {
    url?: string;
    commitUrl?: string;
    [key: string]: unknown;
  };
  warnings?: string[];
}
interface IContentScriptState {
  isInitialized: boolean;
  keyboardShortcutsEnabled: boolean;
  isCapturing: boolean;
}

interface IKeyboardShortcut {
  ctrlKey: boolean;
  shiftKey: boolean;
  altKey: boolean;
  metaKey: boolean;
  key: string;
  action: string;
}

// Content script state
let contentScriptState: IContentScriptState = {
  isInitialized: false,
  keyboardShortcutsEnabled: true,
  isCapturing: false,
};

// Initialize logger
const logger = createLogger('ContentScript');

// Keyboard shortcuts configuration
const KEYBOARD_SHORTCUTS: IKeyboardShortcut[] = [
  {
    ctrlKey: true,
    shiftKey: false,
    altKey: true,
    metaKey: false,
    key: 'S',
    action: 'capture-page',
  },
  // Add more shortcuts here as needed
];

// Initialize content script
async function initializeContentScript(): Promise<void> {
  try {
    console.log('üöÄ Initializing PrismWeave content script...');
    logger.info('Initializing PrismWeave content script...');

    // Load settings to check if keyboard shortcuts are enabled
    await loadKeyboardShortcutSettings();
    console.log('‚öôÔ∏è Keyboard shortcut settings loaded');

    // Set up keyboard event listeners
    setupKeyboardListeners();
    console.log('üîë Keyboard listeners set up');

    // Set up message listeners for communication with service worker
    setupMessageListeners();
    console.log('üì° Message listeners set up');

    contentScriptState.isInitialized = true;
    console.log('‚úÖ PrismWeave content script initialized successfully');
    logger.info('PrismWeave content script initialized successfully');
  } catch (error) {
    console.error('‚ùå Failed to initialize content script:', error);
    logger.error('Failed to initialize content script:', error);
  }
}

// Load keyboard shortcut settings from storage
async function loadKeyboardShortcutSettings(): Promise<void> {
  try {
    const response = await sendMessageToBackground(MESSAGE_TYPES.GET_SETTINGS);
    if (response.success && response.data) {
      const settings = response.data as any;
      contentScriptState.keyboardShortcutsEnabled = settings.enableKeyboardShortcuts ?? true;
      logger.info('Keyboard shortcuts enabled:', contentScriptState.keyboardShortcutsEnabled);
    }
  } catch (error) {
    logger.warn('Failed to load settings, using defaults:', error);
    contentScriptState.keyboardShortcutsEnabled = true;
  }
}

// Set up keyboard event listeners
function setupKeyboardListeners(): void {
  document.addEventListener('keydown', handleKeyboardEvent, true);
  logger.info('Keyboard event listeners set up');
}

// Handle keyboard events
function handleKeyboardEvent(event: KeyboardEvent): void {
  // Log all keyboard events for debugging
  if (event.ctrlKey && event.altKey) {
    console.log('üîë Keyboard event detected:', {
      key: event.key,
      ctrlKey: event.ctrlKey,
      altKey: event.altKey,
      shiftKey: event.shiftKey,
      shortcutsEnabled: contentScriptState.keyboardShortcutsEnabled,
      isCapturing: contentScriptState.isCapturing,
      target: (event.target as Element)?.nodeName,
    });
  }

  // Skip if shortcuts are disabled
  if (!contentScriptState.keyboardShortcutsEnabled) {
    console.log('‚ö†Ô∏è Keyboard shortcuts disabled');
    return;
  }

  // Skip if already capturing to prevent multiple simultaneous captures
  if (contentScriptState.isCapturing) {
    console.log('‚ö†Ô∏è Already capturing, skipping shortcut');
    return;
  }

  // Skip if user is typing in an input field
  if (isTypingInInputField(event.target as Element)) {
    console.log('‚ö†Ô∏è User typing in input field, skipping shortcut');
    return;
  }

  // Check if the event matches any of our shortcuts
  for (const shortcut of KEYBOARD_SHORTCUTS) {
    if (matchesShortcut(event, shortcut)) {
      console.log('‚úÖ Shortcut matched:', shortcut);
      event.preventDefault();
      event.stopPropagation();
      handleShortcutAction(shortcut.action);
      break;
    }
  }
}

// Check if user is typing in an input field
function isTypingInInputField(target: Element | null): boolean {
  if (!target) return false;

  const tagName = target.tagName.toLowerCase();
  const inputTypes = ['input', 'textarea', 'select'];

  // Check if it's an input element
  if (inputTypes.includes(tagName)) {
    return true;
  }

  // Check if it's a contentEditable element
  const element = target as HTMLElement;
  if (element.contentEditable === 'true') {
    return true;
  }

  // Check if we're inside a contentEditable element
  let parent = target.parentElement;
  while (parent) {
    if (parent.contentEditable === 'true') {
      return true;
    }
    parent = parent.parentElement;
  }

  return false;
}

// Check if keyboard event matches a shortcut
function matchesShortcut(event: KeyboardEvent, shortcut: IKeyboardShortcut): boolean {
  // Normalize key comparison
  const eventKey = event.key.toUpperCase();
  const shortcutKey = shortcut.key.toUpperCase();

  return (
    event.ctrlKey === shortcut.ctrlKey &&
    event.shiftKey === shortcut.shiftKey &&
    event.altKey === shortcut.altKey &&
    event.metaKey === shortcut.metaKey &&
    eventKey === shortcutKey
  );
}

// Handle shortcut actions
async function handleShortcutAction(action: string): Promise<void> {
  logger.info('Handling shortcut action:', action);

  try {
    switch (action) {
      case 'capture-page':
        await handleCapturePageShortcut();
        break;
      default:
        logger.warn('Unknown shortcut action:', action);
    }
  } catch (error) {
    logger.error('Error handling shortcut action:', error);
    showNotification('Failed to execute shortcut: ' + (error as Error).message, 'error');
  }
}

// Enhanced commit URL extraction function
function extractCommitUrlFromResponse(response: IEnhancedMessageResponse): string | undefined {
  // Try all possible locations for the commit URL
  const possibleUrls = [
    response.commitUrl,
    (response.data as any)?.commitUrl,
    (response.data as any)?.url,
    response.saveResult?.commitUrl,
    response.saveResult?.url,
    (response.data as any)?.saveResult?.commitUrl,
    (response.data as any)?.saveResult?.url,
    (response.data as any)?.githubResult?.url,
    (response.data as any)?.githubResult?.html_url,
    (response.data as any)?.content?.html_url,
    response.url,
  ];

  // Find the first valid URL
  for (const url of possibleUrls) {
    if (url && typeof url === 'string' && url.startsWith('http')) {
      console.log('üîó Found commit URL:', url);
      return url;
    }
  }

  // If no URL found, log the response structure for debugging
  console.warn('üö´ No commit URL found in response. Response structure:', {
    hasCommitUrl: !!response.commitUrl,
    hasData: !!response.data,
    hasDataCommitUrl: !!(response.data as any)?.commitUrl,
    hasDataUrl: !!(response.data as any)?.url,
    hasSaveResult: !!response.saveResult,
    hasSaveResultUrl: !!response.saveResult?.url,
    responseKeys: Object.keys(response),
    dataKeys: response.data ? Object.keys(response.data) : [],
    saveResultKeys: response.saveResult ? Object.keys(response.saveResult) : [],
  });

  return undefined;
}

// Handle capture page shortcut
async function handleCapturePageShortcut(): Promise<void> {
  console.log('üéØ Keyboard shortcut triggered!');
  logger.info('Keyboard shortcut triggered - starting capture process');

  if (contentScriptState.isCapturing) {
    console.log('‚ö†Ô∏è Capture already in progress');
    logger.warn('Page capture already in progress');
    return;
  }

  try {
    contentScriptState.isCapturing = true;
    console.log('üì± Showing capture notification...');

    // Show user feedback (without click URL initially since capture hasn't completed)
    showNotification('Capturing content...', 'info', 3000);

    // Check if current page is a PDF
    const isPDFPage = checkIfCurrentPageIsPDF();
    console.log('üîç PDF detection result:', isPDFPage);

    if (isPDFPage) {
      console.log('üìÑ PDF page detected - using unified capture service');
      logger.info('PDF page detected - using unified capture service via background');

      // For PDF pages, send capture request directly to background service
      const messageData = {
        url: window.location.href,
        title: document.title,
        contentType: 'pdf',
      };

      const response = await sendMessageToBackground(MESSAGE_TYPES.CAPTURE_CONTENT, messageData);

      if (response.success) {
        // Enhanced commit URL extraction with comprehensive fallback
        const commitUrl = extractCommitUrlFromResponse(response);

        // Debug logging for troubleshooting
        console.log('üîç DEBUG: PDF Full response structure:', response);
        console.log('üîç DEBUG: Extracted commit URL:', commitUrl);

        if (commitUrl) {
          showNotification(
            'PDF captured successfully! Click to view on GitHub.',
            'success',
            5000,
            commitUrl
          );
          logger.info('PDF capture completed successfully via keyboard shortcut', {
            commitUrl,
            hasCommitUrl: true,
          });
        } else {
          showNotification('PDF captured successfully!', 'success', 5000);
          logger.warn('PDF capture completed but no commit URL found', {
            responseKeys: Object.keys(response),
            dataKeys: response.data ? Object.keys(response.data) : [],
            saveResultKeys: response.saveResult ? Object.keys(response.saveResult) : [],
          });
        }
      } else {
        throw new Error(response.error || 'PDF capture failed');
      }
    } else {
      logger.info('HTML page detected - extracting content locally then sending to background');

      // Extract content first for HTML pages
      const extractedContent = await extractPageContentWithUtilities();
      logger.info('Content extracted successfully for keyboard shortcut', {
        hasMarkdown: !!extractedContent.markdown,
        markdownLength: extractedContent.markdown?.length || 0,
        hasHtml: !!extractedContent.html,
        htmlLength: extractedContent.html?.length || 0,
        hasTitle: !!extractedContent.title,
        title: extractedContent.title || 'no title',
        keys: Object.keys(extractedContent),
      });

      // Send capture request with extracted content to service worker
      const messageData = {
        url: window.location.href,
        title: document.title,
        extractedContent,
        contentType: 'html',
      };

      const response = await sendMessageToBackground(MESSAGE_TYPES.CAPTURE_CONTENT, messageData);

      if (response.success) {
        // Enhanced commit URL extraction with comprehensive fallback
        const commitUrl = extractCommitUrlFromResponse(response);

        // Debug logging for troubleshooting
        console.log('üîç DEBUG: Full response structure:', response);
        console.log('üîç DEBUG: Extracted commit URL:', commitUrl);

        if (commitUrl) {
          showNotification(
            'Page captured successfully! Click to view on GitHub.',
            'success',
            5000,
            commitUrl
          );
          logger.info('Page capture completed successfully via keyboard shortcut', {
            commitUrl,
            hasCommitUrl: true,
          });
        } else {
          showNotification('Page captured successfully!', 'success', 5000);
          logger.warn('Page capture completed but no commit URL found', {
            responseKeys: Object.keys(response),
            dataKeys: response.data ? Object.keys(response.data) : [],
            saveResultKeys: response.saveResult ? Object.keys(response.saveResult) : [],
          });
        }
      } else {
        throw new Error(response.error || 'Page capture failed');
      }
    }
  } catch (error) {
    logger.error('Keyboard shortcut capture failed:', error);
    showNotification('Capture failed: ' + (error as Error).message, 'error');
  } finally {
    contentScriptState.isCapturing = false;
  }
}

// Check if current page is a PDF document
function checkIfCurrentPageIsPDF(): boolean {
  const url = window.location.href;

  // Check if URL ends with .pdf
  if (url.toLowerCase().endsWith('.pdf')) {
    return true;
  }

  // Check if URL contains PDF indicators
  if (url.toLowerCase().includes('.pdf')) {
    return true;
  }

  // Check for common PDF viewer URL patterns
  const pdfPatterns = [
    /\/pdf\//i,
    /\.pdf$/i,
    /\.pdf\?/i,
    /\.pdf#/i,
    /application\/pdf/i,
    /chrome-extension:\/\/.*\/web\/viewer\.html/i, // Chrome PDF viewer
  ];

  const isPDFByPattern = pdfPatterns.some(pattern => pattern.test(url));

  if (isPDFByPattern) {
    return true;
  }

  // Check document MIME type if available
  try {
    if (document.contentType && document.contentType.includes('pdf')) {
      return true;
    }
  } catch (error) {
    // Ignore contentType access errors
  }

  // Check for PDF viewer indicators in the DOM
  const pdfViewerSelectors = [
    'embed[type="application/pdf"]',
    'object[type="application/pdf"]',
    '#viewer', // Common PDF viewer element
    '.pdfViewer', // Common PDF viewer class
    '[data-pdf-viewer]', // PDF viewer data attribute
  ];

  const hasPDFViewerElements = pdfViewerSelectors.some(selector => {
    try {
      return document.querySelector(selector) !== null;
    } catch (error) {
      return false;
    }
  });

  logger.info('PDF detection result:', {
    url,
    isPDFByPattern,
    hasPDFViewerElements,
    documentContentType: document.contentType || 'unknown',
    finalResult: hasPDFViewerElements,
  });

  return hasPDFViewerElements;
}

// Set up message listeners for communication with service worker
function setupMessageListeners(): void {
  chrome.runtime.onMessage.addListener(
    (
      message: IMessageData,
      sender: chrome.runtime.MessageSender,
      sendResponse: (response: IMessageResponse) => void
    ) => {
      handleMessage(message, sender)
        .then(result => sendResponse({ success: true, data: result }))
        .catch(error => {
          logger.error('Content script message error:', error);
          sendResponse({ success: false, error: error.message });
        });

      return true; // Keep message channel open for async response
    }
  );
}

// Handle messages from service worker
async function handleMessage(
  message: IMessageData,
  sender: chrome.runtime.MessageSender
): Promise<unknown> {
  switch (message.type) {
    case 'PING':
      return { status: 'ready', timestamp: Date.now() };

    case 'UPDATE_KEYBOARD_SHORTCUTS':
      if (message.data && typeof message.data.enabled === 'boolean') {
        contentScriptState.keyboardShortcutsEnabled = message.data.enabled;
        logger.info('Keyboard shortcuts updated:', contentScriptState.keyboardShortcutsEnabled);
      }
      return { success: true };

    case 'GET_PAGE_INFO':
      return {
        title: document.title,
        url: window.location.href,
        domain: window.location.hostname,
      };

    case 'SHOW_NOTIFICATION':
      if (message.data && typeof message.data.message === 'string') {
        const notificationType = (message.data.type as 'success' | 'error' | 'info') || 'info';
        const duration = (message.data.duration as number) || 5000;
        const clickUrl = (message.data.clickUrl || message.data.url) as string | undefined;
        showNotification(message.data.message, notificationType, duration, clickUrl);
        logger.info('Notification shown:', message.data.message, { clickUrl });
      }
      return { success: true };

    case 'EXTRACT_AND_CONVERT_TO_MARKDOWN':
      // This is called by the service worker for content extraction
      try {
        const extractedContent = await extractPageContentWithUtilities(message.data);
        return {
          success: true,
          data: extractedContent,
          extractionMethod: 'content-script',
          timestamp: new Date().toISOString(),
        } as IContentExtractionResult;
      } catch (error) {
        logger.error('Content extraction failed:', error);
        return {
          success: false,
          error: (error as Error).message,
          extractionMethod: 'content-script',
          timestamp: new Date().toISOString(),
        } as IContentExtractionResult;
      }

    default:
      throw new Error(`Unknown message type: ${message.type}`);
  }
}

// Extract page content using existing utilities
async function extractPageContentWithUtilities(options?: any): Promise<IContentExtractionData> {
  try {
    logger.info('Extracting page content using ContentExtractor...');

    // Check if this is a Stack Overflow blog and use dedicated extractor
    const soExtractor = new StackOverflowBlogExtractor();
    if (soExtractor.isStackOverflowBlog()) {
      logger.info('Detected Stack Overflow blog, using specialized extractor...');

      const soResult = soExtractor.extractBlogContent();
      if (soResult && soResult.content.length > 500) {
        logger.info('Successfully extracted SO blog content', {
          contentLength: soResult.content.length,
          title: soResult.title,
          author: soResult.author,
        });

        // Convert to markdown using our converter
        const markdownConverter = new MarkdownConverter();
        const markdownResult = markdownConverter.convertToMarkdown(soResult.content, {
          preserveFormatting: true,
          generateFrontmatter: true,
        });

        // Prepare frontmatter with SO-specific metadata
        const frontmatter = [
          '---',
          `title: "${soResult.title.replace(/"/g, '\\"')}"`,
          `url: "${window.location.href}"`,
          `domain: "${window.location.hostname}"`,
          `extracted_at: "${new Date().toISOString()}"`,
          soResult.author ? `author: "${soResult.author.replace(/"/g, '\\"')}"` : '',
          soResult.publishDate ? `published: "${soResult.publishDate}"` : '',
          soResult.readingTime ? `reading_time: ${soResult.readingTime}` : '',
          soResult.tags.length > 0
            ? `tags: [${soResult.tags.map(tag => `"${tag.replace(/"/g, '\\"')}"`).join(', ')}]`
            : '',
          'source: "stackoverflow.blog"',
          '---',
        ]
          .filter(line => line.length > 0)
          .join('\n');

        return {
          html: soResult.content,
          title: soResult.title,
          url: window.location.href,
          metadata: {
            title: soResult.title,
            url: window.location.href,
            domain: window.location.hostname,
            extractedAt: new Date().toISOString(),
            author: soResult.author,
            publishDate: soResult.publishDate,
            tags: soResult.tags,
            readingTime: soResult.readingTime,
            wordCount: soResult.content.split(/\s+/).length,
            source: 'stackoverflow.blog',
          },
          markdown: markdownResult.markdown,
          frontmatter: frontmatter,
          images: [], // SO extractor doesn't extract images yet, but could be added
        };
      } else {
        logger.warn(
          'SO extractor failed or returned insufficient content, falling back to generic extractor'
        );
      }
    }

    // Initialize utilities with error handling for extension context invalidation
    let contentExtractor: ContentExtractor;
    let markdownConverter: MarkdownConverter;

    try {
      contentExtractor = new ContentExtractor();
      markdownConverter = new MarkdownConverter();
    } catch (error) {
      // If utilities fail to initialize (e.g., extension context invalidated),
      // fall back to basic content extraction
      if (error instanceof Error && error.message.includes('Extension context invalidated')) {
        logger.warn('Extension context invalidated, falling back to basic extraction');
        showNotification('Extension reloaded - using basic capture mode', 'info', 3000);
        return await basicContentExtraction();
      }
      throw error;
    }

    // Extract content using the existing utility
    const extractorOptions = {
      customSelectors: options?.customSelectors,
      cleanHtml: options?.cleanHtml !== false,
      preserveFormatting: options?.preserveFormatting === true,
      waitForDynamicContent: options?.waitForDynamicContent !== false,
      // Enhanced cleaning for Stack Overflow blog
      removeAds: true,
      removeNavigation: true,
      excludeSelectors: [
        // Specific elements to exclude from Stack Overflow blog
        '.s-navigation',
        '.s-topbar',
        '.js-header',
        '.js-footer',
        '.recent-articles',
        '.latest-podcast',
        '.add-to-discussion',
        '.blog-sidebar',
        '.blog-nav',
        '.site-header',
        '.site-footer',
        '.products-nav',
        // Generic promotional content
        '[href*="/teams/"]',
        '[href*="/advertising/"]',
        '[href*="/talent/"]',
        '.promo',
        '.newsletter',
        '.subscribe',
        '.signup',
        '.cta',
        '.call-to-action',
        // Our own notification elements
        '#prismweave-notification',
        '[id*="prismweave"]',
        '[class*="prismweave"]',
      ],
    };

    const contentResult = await contentExtractor.extractContent(extractorOptions);

    // Convert to markdown with enhanced cleaning
    const markdownResult = markdownConverter.convertToMarkdown(contentResult.content, {
      preserveFormatting: options?.preserveFormatting === true,
      includeMetadata: true,
      generateFrontmatter: true,
    });

    // Post-process markdown to remove any remaining unwanted content
    let cleanedMarkdown = markdownResult.markdown;

    // Remove our own "Capturing page..." text and similar notifications
    cleanedMarkdown = cleanedMarkdown.replace(/Capturing page\.\.\./gi, '');
    cleanedMarkdown = cleanedMarkdown.replace(/PrismWeave[^.\n]*\./gi, '');

    // Remove Stack Overflow promotional content patterns
    const removePatterns = [
      /Products\s*\n+\s*\*\*Stack Overflow for Teams\*\*[^]*?technologists\./gi,
      /\[Blog\]\(\/\)/gi,
      /\[\]\(https:\/\/stackoverflow\.com\)/gi,
      /\[.*?\]\(\/feed\)/gi,
      /Recent articles\s*\n+.*?\d{4}/gims,
      /Latest Podcast\s*\n+.*?\d{4}/gims,
      /Add to the discussion\s*\n+.*?take part in the discussion\./gims,
      /Login with your.*?account to take part/gi,
    ];

    removePatterns.forEach(pattern => {
      cleanedMarkdown = cleanedMarkdown.replace(pattern, '');
    });

    // Clean up excessive whitespace
    cleanedMarkdown = cleanedMarkdown.replace(/\n{3,}/g, '\n\n').trim();

    // Extract images using the utility
    const images = contentExtractor.extractImages();
    const imageUrls = images.map(img => img.src);

    // Get page structure for additional metadata
    const pageStructure = contentExtractor.getPageStructure();

    // Prepare the result data
    const extractionData: IContentExtractionData = {
      html: contentResult.content,
      title: contentResult.metadata.title,
      url: window.location.href,
      metadata: {
        ...contentResult.metadata,
        extractedAt: new Date().toISOString(),
        domain: window.location.hostname,
        wordCount: contentResult.wordCount,
        readingTime: contentResult.readingTime,
        headings: pageStructure.headings,
        sections: pageStructure.sections,
        paragraphs: pageStructure.paragraphs,
        qualityScore: contentExtractor.getContentQualityScore(),
        isPaywallPresent: contentExtractor.isPaywallPresent(),
      },
      markdown: cleanedMarkdown,
      frontmatter: markdownResult.frontmatter,
      images: imageUrls,
    };

    logger.info('Content extraction completed successfully using utilities', {
      wordCount: contentResult.wordCount,
      imageCount: imageUrls.length,
      markdownLength: cleanedMarkdown.length,
    });

    return extractionData;
  } catch (error) {
    logger.error('Page content extraction failed with utilities:', error);

    // If the main extraction failed, try basic fallback
    if (error instanceof Error && error.message.includes('Extension context invalidated')) {
      logger.warn('Falling back to basic content extraction due to extension context invalidation');
      showNotification('Extension reloaded - using basic capture mode', 'info', 3000);
      return await basicContentExtraction();
    }

    throw error;
  }
}

// Basic content extraction fallback for when extension context is invalidated
async function basicContentExtraction(): Promise<IContentExtractionData> {
  try {
    // Basic content selectors
    const contentSelectors = [
      'article',
      'main',
      '[role="main"]',
      '.content',
      '.post',
      '.entry',
      '#content',
    ];

    let contentElement: Element | null = null;

    // Try to find main content element
    for (const selector of contentSelectors) {
      contentElement = document.querySelector(selector);
      if (
        contentElement &&
        contentElement.textContent &&
        contentElement.textContent.trim().length > 100
      ) {
        break;
      }
    }

    // Fall back to body if no content area found
    if (!contentElement) {
      contentElement = document.body;
    }

    const html = contentElement?.innerHTML || '';
    const textContent = contentElement?.textContent || '';
    const title = document.title || 'Untitled';

    // Basic word count
    const wordCount = textContent.split(/\s+/).filter(word => word.length > 0).length;

    // Basic image extraction
    const images = Array.from(document.images)
      .map(img => img.src)
      .filter(src => src && !src.startsWith('data:'));

    // Simple markdown conversion (very basic)
    let markdown = textContent;
    if (title) {
      markdown = `# ${title}\n\n${textContent}`;
    }

    const extractionData: IContentExtractionData = {
      html,
      title,
      url: window.location.href,
      metadata: {
        extractedAt: new Date().toISOString(),
        domain: window.location.hostname,
        wordCount,
        readingTime: Math.ceil(wordCount / 200),
        extractionMethod: 'basic-fallback',
      },
      markdown,
      frontmatter: `---\ntitle: ${title}\nurl: ${window.location.href}\ncaptured: ${new Date().toISOString()}\n---\n`,
      images,
    };

    return extractionData;
  } catch (error) {
    throw new Error(
      `Basic content extraction failed: ${error instanceof Error ? error.message : 'Unknown error'}`
    );
  }
}

// Send message to background script
function sendMessageToBackground(type: string, data?: any): Promise<IEnhancedMessageResponse> {
  return new Promise<IEnhancedMessageResponse>((resolve, reject) => {
    const message: IMessageData = { type, data, timestamp: Date.now() };

    chrome.runtime.sendMessage(message, (response: IEnhancedMessageResponse) => {
      if (chrome.runtime.lastError) {
        reject(new Error(chrome.runtime.lastError.message));
      } else if (!response) {
        reject(new Error('No response received from background script'));
      } else {
        resolve(response);
      }
    });
  });
}

// Show user notification
function showNotification(
  message: string,
  type: 'success' | 'error' | 'info' = 'info',
  duration: number = 4000,
  clickUrl?: string
): void {
  // Skip notification if we're in a problematic context (like about:blank or sandboxed frame)
  try {
    if (!document.body || window.location.href === 'about:blank') {
      console.log(
        'üö´ PrismWeave: Skipping notification in problematic context:',
        window.location.href
      );
      return;
    }
  } catch (error) {
    console.log('üö´ PrismWeave: Skipping notification due to context error:', error);
    return;
  }

  // Create or update notification element
  let notification = document.getElementById('prismweave-notification');

  if (!notification) {
    try {
      notification = document.createElement('div');
      notification.id = 'prismweave-notification';
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 10000;
        padding: 12px 16px;
        border-radius: 4px;
        color: white;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        font-size: 14px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        max-width: 300px;
        word-wrap: break-word;
        opacity: 0;
        transform: translateX(100%);
        transition: all 0.3s ease;
        ${clickUrl ? 'cursor: pointer;' : ''}
      `;
      document.body.appendChild(notification);
    } catch (error) {
      console.error('üö´ PrismWeave: Failed to create notification element:', error);
      return;
    }
  }

  // Set notification style based on type
  const colors = {
    success: '#10b981',
    error: '#ef4444',
    info: '#3b82f6',
  };

  notification.style.backgroundColor = colors[type];
  notification.textContent = message;

  // Add click handler if URL is provided
  if (clickUrl) {
    console.log('üîó PrismWeave: Setting up clickable notification with URL:', clickUrl);
    notification.style.cursor = 'pointer';

    // Clear any existing event listeners
    notification.onclick = null;
    notification.onmouseenter = null;
    notification.onmouseleave = null;

    // Add single click handler to prevent duplicate tab opening
    let isProcessingClick = false; // Prevent multiple rapid clicks

    notification.addEventListener(
      'click',
      event => {
        // Prevent multiple clicks being processed simultaneously
        if (isProcessingClick) {
          console.log('ÔøΩ PrismWeave: Click already being processed, ignoring duplicate');
          return;
        }

        isProcessingClick = true;
        console.log('ÔøΩüñ±Ô∏è PrismWeave: Click event fired!', {
          event,
          target: event.target,
          currentTarget: event.currentTarget,
          clickUrl,
          timestamp: new Date().toISOString(),
        });

        event.preventDefault();
        event.stopPropagation();

        console.log('üöÄ PrismWeave: Attempting to open URL:', clickUrl);

        try {
          // Use window.open - even if it returns null, the tab usually opens successfully
          console.log('üöÄ PrismWeave: Opening URL with window.open...');
          window.open(clickUrl, '_blank', 'noopener,noreferrer');

          // Always consider it successful and hide notification
          // (window.open may return null even when successful due to popup blockers)
          console.log('‚úÖ PrismWeave: URL opening attempted, hiding notification');
          hideNotification(notification);
        } catch (error) {
          console.error('üí• PrismWeave: Error opening URL:', error);
          // Show user-friendly error
          showNotification('Could not open link. Check browser popup settings.', 'error', 3000);
        } finally {
          // Reset click processing flag after a short delay
          setTimeout(() => {
            isProcessingClick = false;
          }, 1000);
        }
      },
      { passive: false }
    );

    // DO NOT add onclick handler to prevent duplicate event handling
    notification.onclick = null;

    // Add hover effect for clickable notifications with better visual feedback
    notification.onmouseenter = () => {
      console.log('üéØ PrismWeave: Mouse entered notification');
      notification!.style.transform = 'scale(1.05)';
      notification!.style.boxShadow = '0 8px 20px rgba(0, 0, 0, 0.3)';
      notification!.style.backgroundColor = '#059669'; // Slightly darker green on hover
    };
    notification.onmouseleave = () => {
      console.log('üéØ PrismWeave: Mouse left notification');
      notification!.style.transform = 'scale(1)';
      notification!.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.15)';
      notification!.style.backgroundColor = colors[type]; // Reset to original color
    };

    // Add visual indicator that it's clickable
    notification.title = `Click to open: ${clickUrl}`;

    // Make the notification more obviously clickable
    notification.style.border = '2px solid rgba(255, 255, 255, 0.3)';
    notification.style.transition = 'all 0.2s ease';

    console.log('üîó PrismWeave: Clickable notification setup complete');
  } else {
    console.log('‚ÑπÔ∏è PrismWeave: No click URL provided, notification will not be clickable');
    // Remove click handler if no URL
    notification.onclick = null;
    notification.onmouseenter = null;
    notification.onmouseleave = null;
    notification.style.cursor = 'default';
    notification.title = '';
  }

  // Show notification
  requestAnimationFrame(() => {
    if (notification) {
      notification.style.opacity = '1';
      notification.style.transform = 'translateX(0)';
    }
  });

  // Hide notification after specified duration
  setTimeout(() => {
    hideNotification(notification);
  }, duration);
}

// Helper function to hide notification
function hideNotification(notification: HTMLElement | null): void {
  if (notification) {
    notification.style.opacity = '0';
    notification.style.transform = 'translateX(100%)';

    setTimeout(() => {
      if (notification && notification.parentNode) {
        notification.parentNode.removeChild(notification);
      }
    }, 300);
  }
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeContentScript);
} else {
  initializeContentScript();
}

// Export for debugging (optional)
if (typeof window !== 'undefined') {
  (window as any).prismweaveContentScript = {
    state: contentScriptState,
    handleCapturePageShortcut,
    loadKeyboardShortcutSettings,
    version: '1.0.0',
  };
}

console.log('PrismWeave content script loaded successfully');
