// Generated by Copilot
// PrismWeave Content Script - TypeScript version
// Runs on web pages to assist with content extraction and user interactions

import { IMessageData, IMessageResponse, IContentScriptMessage } from '../types/index.js';

interface IContentExtractor {
  extractPageContent(): Promise<any>;
  extractSelection(): Promise<any>;
  highlightContent(selector?: string): void;
}

export class PrismWeaveContent {
  private isCapturing: boolean = false;
  private contentExtractor: IContentExtractor | null = null;
  private captureIndicator: HTMLElement | null = null;

  constructor() {
    this.initializeContentScript();
  }

  private initializeContentScript(): void {
    // Listen for messages from background script
    chrome.runtime.onMessage.addListener((
      message: IContentScriptMessage, 
      sender: chrome.runtime.MessageSender, 
      sendResponse: (response: IMessageResponse) => void
    ) => {
      this.handleMessage(message, sender, sendResponse);
      return true;
    });

    // Add keyboard shortcut listener
    document.addEventListener('keydown', (event: KeyboardEvent) => {
      // Ctrl+Shift+S to capture page
      if (event.ctrlKey && event.shiftKey && event.key === 'S') {
        event.preventDefault();
        this.captureCurrentPage();
      }

      // Ctrl+Shift+H to highlight content
      if (event.ctrlKey && event.shiftKey && event.key === 'H') {
        event.preventDefault();
        this.highlightMainContent();
      }

      // Escape to cancel capture
      if (event.key === 'Escape' && this.isCapturing) {
        event.preventDefault();
        this.cancelCapture();
      }
    });

    // Add visual feedback for capturing
    this.createCaptureIndicator();

    // Load content extractor when needed
    this.loadContentExtractor();
  }

  private async loadContentExtractor(): Promise<void> {
    if (!(window as any).ContentExtractor) {
      // Content extractor will be injected by background script when needed
      return;
    }
    this.contentExtractor = new (window as any).ContentExtractor();
  }

  private async handleMessage(
    message: IContentScriptMessage, 
    sender: chrome.runtime.MessageSender, 
    sendResponse: (response: IMessageResponse) => void
  ): Promise<void> {
    try {
      switch (message.type) {
        case 'CAPTURE_PAGE':
          const pageResult = await this.captureCurrentPage();
          sendResponse({ success: true, data: pageResult });
          break;

        case 'CAPTURE_SELECTION':
          const selectionResult = await this.captureSelection();
          sendResponse({ success: true, data: selectionResult });
          break;

        case 'HIGHLIGHT_CONTENT':
          this.highlightMainContent();
          sendResponse({ success: true, data: { highlighted: true } });
          break;

        case 'GET_PAGE_INFO':
          const pageInfo = this.getPageInfo();
          sendResponse({ success: true, data: pageInfo });
          break;

        case 'INJECT_STYLES':
          this.injectStyles(message.data?.styles as string);
          sendResponse({ success: true, data: { injected: true } });
          break;

        default:
          throw new Error(`Unknown message type: ${message.type}`);
      }
    } catch (error) {
      console.error('PrismWeaveContent: Message handling error:', error);
      sendResponse({ 
        success: false, 
        error: (error as Error).message 
      });
    }
  }

  private async captureCurrentPage(): Promise<any> {
    if (this.isCapturing) {
      console.warn('Capture already in progress');
      return { error: 'Capture already in progress' };
    }

    try {
      this.isCapturing = true;
      this.showCaptureIndicator('Capturing page...');

      // Ensure content extractor is loaded
      if (!this.contentExtractor) {
        await this.loadContentExtractor();
      }

      if (!this.contentExtractor) {
        throw new Error('Content extractor not available');
      }

      const content = await this.contentExtractor.extractPageContent();
      
      this.showCaptureIndicator('Capture completed!', 'success');
      setTimeout(() => this.hideCaptureIndicator(), 2000);

      return content;
    } catch (error) {
      console.error('Error capturing page:', error);
      this.showCaptureIndicator('Capture failed!', 'error');
      setTimeout(() => this.hideCaptureIndicator(), 3000);
      throw error;
    } finally {
      this.isCapturing = false;
    }
  }

  private async captureSelection(): Promise<any> {
    try {
      this.showCaptureIndicator('Capturing selection...');

      if (!this.contentExtractor) {
        await this.loadContentExtractor();
      }

      if (!this.contentExtractor) {
        throw new Error('Content extractor not available');
      }

      const selection = window.getSelection();
      if (!selection || selection.rangeCount === 0) {
        throw new Error('No content selected');
      }

      const content = await this.contentExtractor.extractSelection();
      
      this.showCaptureIndicator('Selection captured!', 'success');
      setTimeout(() => this.hideCaptureIndicator(), 2000);

      return content;
    } catch (error) {
      console.error('Error capturing selection:', error);
      this.showCaptureIndicator('Selection capture failed!', 'error');
      setTimeout(() => this.hideCaptureIndicator(), 3000);
      throw error;
    }
  }

  private highlightMainContent(): void {
    try {
      if (!this.contentExtractor) {
        console.warn('Content extractor not loaded for highlighting');
        return;
      }

      this.contentExtractor.highlightContent();
      this.showCaptureIndicator('Content highlighted', 'info');
      setTimeout(() => this.hideCaptureIndicator(), 2000);
    } catch (error) {
      console.error('Error highlighting content:', error);
    }
  }

  private cancelCapture(): void {
    this.isCapturing = false;
    this.hideCaptureIndicator();
    console.log('Capture cancelled');
  }

  private getPageInfo(): any {
    return {
      title: document.title,
      url: window.location.href,
      domain: window.location.hostname,
      timestamp: new Date().toISOString(),
      hasSelection: (window.getSelection()?.toString().length || 0) > 0,
      wordCount: this.estimateWordCount(),
      language: document.documentElement.lang || 'en'
    };
  }

  private estimateWordCount(): number {
    const textContent = document.body.textContent || '';
    return textContent.trim().split(/\s+/).filter(word => word.length > 0).length;
  }

  private injectStyles(styles: string): void {
    const styleElement = document.createElement('style');
    styleElement.textContent = styles;
    styleElement.id = 'prismweave-injected-styles';
    
    // Remove existing injected styles
    const existing = document.getElementById('prismweave-injected-styles');
    if (existing) {
      existing.remove();
    }
    
    document.head.appendChild(styleElement);
  }

  private createCaptureIndicator(): void {
    this.captureIndicator = document.createElement('div');
    this.captureIndicator.id = 'prismweave-capture-indicator';
    this.captureIndicator.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: #4A90E2;
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 14px;
      font-weight: 500;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      z-index: 10000;
      display: none;
      transition: all 0.3s ease;
      max-width: 300px;
    `;
    
    document.body.appendChild(this.captureIndicator);
  }

  private showCaptureIndicator(message: string, type: 'info' | 'success' | 'error' = 'info'): void {
    if (!this.captureIndicator) return;

    const colors = {
      info: '#4A90E2',
      success: '#7ED321',
      error: '#D0021B'
    };

    this.captureIndicator.textContent = message;
    this.captureIndicator.style.backgroundColor = colors[type];
    this.captureIndicator.style.display = 'block';
  }

  private hideCaptureIndicator(): void {
    if (!this.captureIndicator) return;
    this.captureIndicator.style.display = 'none';
  }
}

// Initialize content script when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    new PrismWeaveContent();
  });
} else {
  new PrismWeaveContent();
}
