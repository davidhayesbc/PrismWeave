// Generated by Copilot
// PrismWeave Content Script - TypeScript version
// Runs on web pages to assist with content extraction and user interactions

import { IMessageData, IMessageResponse, IContentScriptMessage } from '../types/index.js';
import { ContentExtractor } from '../utils/content-extractor.js';
import { MarkdownConverter } from '../utils/markdown-converter.js';

interface IContentExtractor {
  extractPageContent(): Promise<any>;
  extractSelection(): Promise<any>;
  highlightContent(selector?: string): void;
}

export class PrismWeaveContent {
  private isCapturing: boolean = false;
  private contentExtractor: ContentExtractor;
  private markdownConverter: MarkdownConverter;
  private captureIndicator: HTMLElement | null = null;

  constructor() {
    // Initialize extractors immediately
    this.contentExtractor = new ContentExtractor();
    this.markdownConverter = new MarkdownConverter();
    this.initializeContentScript();
  }

  private initializeContentScript(): void {
    // Listen for messages from background script and popup
    chrome.runtime.onMessage.addListener((
      message: IContentScriptMessage, 
      sender: chrome.runtime.MessageSender, 
      sendResponse: (response: IMessageResponse) => void
    ) => {
      this.handleMessage(message, sender, sendResponse);
      return true; // Keep message channel open for async response
    });

    // Add keyboard shortcut listener
    document.addEventListener('keydown', (event: KeyboardEvent) => {
      // Ctrl+Shift+S to capture page
      if (event.ctrlKey && event.shiftKey && event.key === 'S') {
        event.preventDefault();
        this.captureCurrentPage();
      }

      // Ctrl+Shift+H to highlight content
      if (event.ctrlKey && event.shiftKey && event.key === 'H') {
        event.preventDefault();
        this.highlightMainContent();
      }

      // Escape to cancel capture
      if (event.key === 'Escape' && this.isCapturing) {
        event.preventDefault();
        this.cancelCapture();
      }
    });

    // Add visual feedback for capturing
    this.createCaptureIndicator();

    console.log('PrismWeave content script initialized');
  }

  private async handleMessage(
    message: IContentScriptMessage, 
    sender: chrome.runtime.MessageSender, 
    sendResponse: (response: IMessageResponse) => void
  ): Promise<void> {
    try {
      switch (message.type) {
        case 'CAPTURE_PAGE':
          const pageResult = await this.captureCurrentPage();
          sendResponse({ success: true, data: pageResult });
          break;

        case 'CAPTURE_SELECTION':
          const selectionResult = await this.captureSelection();
          sendResponse({ success: true, data: selectionResult });
          break;

        case 'HIGHLIGHT_CONTENT':
          this.highlightMainContent();
          sendResponse({ success: true, data: { highlighted: true } });
          break;

        case 'GET_PAGE_INFO':
          const pageInfo = this.getPageInfo();
          sendResponse({ success: true, data: pageInfo });
          break;

        case 'INJECT_STYLES':
          this.injectStyles(message.data?.styles as string);
          sendResponse({ success: true, data: { injected: true } });
          break;

        default:
          throw new Error(`Unknown message type: ${message.type}`);
      }
    } catch (error) {
      console.error('PrismWeaveContent: Message handling error:', error);
      sendResponse({ 
        success: false, 
        error: (error as Error).message 
      });
    }
  }
  private async captureCurrentPage(): Promise<any> {
    if (this.isCapturing) {
      console.warn('Capture already in progress');
      return { error: 'Capture already in progress' };
    }

    try {
      this.isCapturing = true;
      this.showCaptureIndicator('Capturing page...');

      // Extract page content using ContentExtractor
      const extractedContent = await this.contentExtractor.extractContent({
        preserveFormatting: true,
        removeAds: true,
        removeNavigation: true
      });      // Convert to markdown
      const conversionResult = await this.markdownConverter.convertToMarkdown(
        extractedContent.content,
        extractedContent.metadata,
        {
          preserveFormatting: true,
          includeMetadata: true,
          generateFrontmatter: true
        }
      );

      // Prepare result with metadata
      const result = {
        markdown: conversionResult.markdown,
        frontmatter: conversionResult.frontmatter,
        metadata: conversionResult.metadata,
        images: conversionResult.images,
        cleanedContent: extractedContent.cleanedContent,
        wordCount: conversionResult.wordCount,
        readingTime: extractedContent.readingTime,
        captureDate: new Date().toISOString(),
        url: window.location.href,
        title: document.title
      };
      
      this.showCaptureIndicator('Capture completed!', 'success');
      setTimeout(() => this.hideCaptureIndicator(), 2000);

      return result;
    } catch (error) {
      console.error('Error capturing page:', error);
      this.showCaptureIndicator('Capture failed!', 'error');
      setTimeout(() => this.hideCaptureIndicator(), 3000);
      throw error;
    } finally {
      this.isCapturing = false;
    }
  }

  private async captureSelection(): Promise<any> {
    try {
      this.showCaptureIndicator('Capturing selection...');

      const selection = window.getSelection();
      if (!selection || selection.rangeCount === 0) {
        throw new Error('No content selected');
      }

      // Get the selected content as HTML
      const range = selection.getRangeAt(0);
      const container = document.createElement('div');
      container.appendChild(range.cloneContents());
      const selectedHtml = container.innerHTML;

      if (!selectedHtml.trim()) {
        throw new Error('Selected content is empty');
      }      // Convert selected content to markdown
      const metadata = {
        title: `Selection from ${document.title}`,
        url: window.location.href,
        captureDate: new Date().toISOString(),
        tags: ['selection'],
        wordCount: selectedHtml.split(/\s+/).length,
        estimatedReadingTime: Math.ceil(selectedHtml.split(/\s+/).length / 200)
      };

      const conversionResult = await this.markdownConverter.convertToMarkdown(
        selectedHtml,
        metadata,
        {
          preserveFormatting: true,
          includeMetadata: false
        }
      );

      const result = {
        markdown: conversionResult.markdown,
        metadata: conversionResult.metadata,
        selectedText: selection.toString(),
        captureDate: new Date().toISOString(),
        url: window.location.href,
        title: document.title
      };
      
      this.showCaptureIndicator('Selection captured!', 'success');
      setTimeout(() => this.hideCaptureIndicator(), 2000);

      return result;
    } catch (error) {
      console.error('Error capturing selection:', error);
      this.showCaptureIndicator('Selection capture failed!', 'error');
      setTimeout(() => this.hideCaptureIndicator(), 3000);
      throw error;
    }
  }

  private highlightMainContent(): void {
    try {
      // Find main content using similar logic to ContentExtractor
      const readabilitySelectors = [
        'article',
        'main',
        '[role="main"]',
        '.content',
        '.post-content',
        '.entry-content',
        '.article-content'
      ];

      let mainElement: Element | null = null;
      for (const selector of readabilitySelectors) {
        mainElement = document.querySelector(selector);
        if (mainElement) break;
      }

      if (mainElement) {
        // Add highlight styling
        const originalStyle = (mainElement as HTMLElement).style.cssText;
        (mainElement as HTMLElement).style.cssText += `
          outline: 3px solid #667eea !important;
          background: rgba(102, 126, 234, 0.1) !important;
          transition: all 0.3s ease !important;
        `;

        // Remove highlight after 3 seconds
        setTimeout(() => {
          (mainElement as HTMLElement).style.cssText = originalStyle;
        }, 3000);

        this.showCaptureIndicator('Content highlighted', 'info');
      } else {
        this.showCaptureIndicator('Main content not found', 'error');
      }
      
      setTimeout(() => this.hideCaptureIndicator(), 2000);
    } catch (error) {
      console.error('Error highlighting content:', error);
    }
  }

  private cancelCapture(): void {
    this.isCapturing = false;
    this.hideCaptureIndicator();
    console.log('Capture cancelled');
  }

  private getPageInfo(): any {
    return {
      title: document.title,
      url: window.location.href,
      domain: window.location.hostname,
      timestamp: new Date().toISOString(),
      hasSelection: (window.getSelection()?.toString().length || 0) > 0,
      wordCount: this.estimateWordCount(),
      language: document.documentElement.lang || 'en'
    };
  }

  private estimateWordCount(): number {
    const textContent = document.body.textContent || '';
    return textContent.trim().split(/\s+/).filter(word => word.length > 0).length;
  }

  private injectStyles(styles: string): void {
    const styleElement = document.createElement('style');
    styleElement.textContent = styles;
    styleElement.id = 'prismweave-injected-styles';
    
    // Remove existing injected styles
    const existing = document.getElementById('prismweave-injected-styles');
    if (existing) {
      existing.remove();
    }
    
    document.head.appendChild(styleElement);
  }

  private createCaptureIndicator(): void {
    this.captureIndicator = document.createElement('div');
    this.captureIndicator.id = 'prismweave-capture-indicator';
    this.captureIndicator.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: #4A90E2;
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 14px;
      font-weight: 500;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      z-index: 10000;
      display: none;
      transition: all 0.3s ease;
      max-width: 300px;
    `;
    
    document.body.appendChild(this.captureIndicator);
  }

  private showCaptureIndicator(message: string, type: 'info' | 'success' | 'error' = 'info'): void {
    if (!this.captureIndicator) return;

    const colors = {
      info: '#4A90E2',
      success: '#7ED321',
      error: '#D0021B'
    };

    this.captureIndicator.textContent = message;
    this.captureIndicator.style.backgroundColor = colors[type];
    this.captureIndicator.style.display = 'block';
  }

  private hideCaptureIndicator(): void {
    if (!this.captureIndicator) return;
    this.captureIndicator.style.display = 'none';
  }
}

// Initialize content script when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    new PrismWeaveContent();
  });
} else {
  new PrismWeaveContent();
}
