// Generated by Copilot
// Content script for PrismWeave browser extension
// Handles keyboard shortcuts and page content extraction

import {
  IContentExtractionData,
  IContentExtractionResult,
  IMessageData,
  IMessageResponse,
  MESSAGE_TYPES,
} from '../types/index.js';
import { ContentExtractor } from '../utils/content-extractor.js';
import { createLogger } from '../utils/logger.js';
import { MarkdownConverter } from '../utils/markdown-converter.js';
import { StackOverflowBlogExtractor } from '../utils/stackoverflow-blog-extractor.js';

console.log('ðŸš€ PrismWeave content script loading...');

// Enhanced message response interface for better commit URL handling
interface IEnhancedMessageResponse extends IMessageResponse {
  commitUrl?: string;
  url?: string;
  saveResult?: {
    url?: string;
    commitUrl?: string;
    [key: string]: unknown;
  };
  warnings?: string[];
}
interface IContentScriptState {
  isInitialized: boolean;
  keyboardShortcutsEnabled: boolean;
  isCapturing: boolean;
}

interface IKeyboardShortcut {
  ctrlKey: boolean;
  shiftKey: boolean;
  altKey: boolean;
  metaKey: boolean;
  key: string;
  action: string;
}

// Content script state
let contentScriptState: IContentScriptState = {
  isInitialized: false,
  keyboardShortcutsEnabled: true,
  isCapturing: false,
};

// Initialize logger
const logger = createLogger('ContentScript');

// Keyboard shortcuts configuration
const KEYBOARD_SHORTCUTS: IKeyboardShortcut[] = [
  {
    ctrlKey: false,
    shiftKey: false,
    altKey: true,
    metaKey: false,
    key: 'S',
    action: 'capture-page',
  },
  // Add more shortcuts here as needed
];

// Initialize content script
async function initializeContentScript(): Promise<void> {
  try {
    logger.info('Initializing PrismWeave content script...');

    // Load settings to check if keyboard shortcuts are enabled
    await loadKeyboardShortcutSettings();

    // Set up keyboard event listeners
    setupKeyboardListeners();

    // Set up message listeners for communication with service worker
    setupMessageListeners();

    contentScriptState.isInitialized = true;
    logger.info('PrismWeave content script initialized successfully');
  } catch (error) {
    logger.error('Failed to initialize content script:', error);
  }
}

// Load keyboard shortcut settings from storage
async function loadKeyboardShortcutSettings(): Promise<void> {
  try {
    const response = await sendMessageToBackground(MESSAGE_TYPES.GET_SETTINGS);
    if (response.success && response.data) {
      const settings = response.data as any;
      contentScriptState.keyboardShortcutsEnabled = settings.enableKeyboardShortcuts ?? true;
      logger.info('Keyboard shortcuts enabled:', contentScriptState.keyboardShortcutsEnabled);
    }
  } catch (error) {
    logger.warn('Failed to load settings, using defaults:', error);
    contentScriptState.keyboardShortcutsEnabled = true;
  }
}

// Set up keyboard event listeners
function setupKeyboardListeners(): void {
  document.addEventListener('keydown', handleKeyboardEvent, true);
  logger.info('Keyboard event listeners set up');
}

// Handle keyboard events
function handleKeyboardEvent(event: KeyboardEvent): void {
  // Skip if shortcuts are disabled
  if (!contentScriptState.keyboardShortcutsEnabled) {
    return;
  }

  // Skip if already capturing to prevent multiple simultaneous captures
  if (contentScriptState.isCapturing) {
    return;
  }

  // Skip if user is typing in an input field
  if (isTypingInInputField(event.target as Element)) {
    return;
  }

  // Check if the event matches any of our shortcuts
  for (const shortcut of KEYBOARD_SHORTCUTS) {
    if (matchesShortcut(event, shortcut)) {
      // Only log when a shortcut is actually triggered
      logger.info('Keyboard shortcut matched:', {
        key: event.key,
        ctrlKey: event.ctrlKey,
        altKey: event.altKey,
        shiftKey: event.shiftKey,
        action: shortcut.action,
      });

      event.preventDefault();
      event.stopPropagation();
      handleShortcutAction(shortcut.action);
      break;
    }
  }
}

// Check if user is typing in an input field
function isTypingInInputField(target: Element | null): boolean {
  if (!target) return false;

  const tagName = target.tagName.toLowerCase();
  const inputTypes = ['input', 'textarea', 'select'];

  // Check if it's an input element
  if (inputTypes.includes(tagName)) {
    return true;
  }

  // Check if it's a contentEditable element
  const element = target as HTMLElement;
  if (element.contentEditable === 'true') {
    return true;
  }

  // Check if we're inside a contentEditable element
  let parent = target.parentElement;
  while (parent) {
    if (parent.contentEditable === 'true') {
      return true;
    }
    parent = parent.parentElement;
  }

  return false;
}

// Check if keyboard event matches a shortcut
function matchesShortcut(event: KeyboardEvent, shortcut: IKeyboardShortcut): boolean {
  // Normalize key comparison
  const eventKey = event.key.toUpperCase();
  const shortcutKey = shortcut.key.toUpperCase();

  return (
    event.ctrlKey === shortcut.ctrlKey &&
    event.shiftKey === shortcut.shiftKey &&
    event.altKey === shortcut.altKey &&
    event.metaKey === shortcut.metaKey &&
    eventKey === shortcutKey
  );
}

// Handle shortcut actions
async function handleShortcutAction(action: string): Promise<void> {
  logger.info('Handling shortcut action:', action);

  try {
    switch (action) {
      case 'capture-page':
        await handleCapturePageShortcut();
        break;
      default:
        logger.warn('Unknown shortcut action:', action);
    }
  } catch (error) {
    logger.error('Error handling shortcut action:', error);
    showNotification('Failed to execute shortcut: ' + (error as Error).message, 'error');
  }
}

// Enhanced commit URL extraction function
function extractCommitUrlFromResponse(response: IEnhancedMessageResponse): string | undefined {
  // Try all possible locations for the commit URL
  const possibleUrls = [
    response.commitUrl,
    (response.data as any)?.commitUrl,
    (response.data as any)?.url,
    response.saveResult?.commitUrl,
    response.saveResult?.url,
    (response.data as any)?.saveResult?.commitUrl,
    (response.data as any)?.saveResult?.url,
    (response.data as any)?.githubResult?.url,
    (response.data as any)?.githubResult?.html_url,
    (response.data as any)?.content?.html_url,
    response.url,
  ];

  // Find the first valid URL
  for (const url of possibleUrls) {
    if (url && typeof url === 'string' && url.startsWith('http')) {
      return url;
    }
  }

  // If no URL found, log minimal warning
  logger.warn('No commit URL found in response');
  return undefined;
}

// Handle capture page shortcut
async function handleCapturePageShortcut(): Promise<void> {
  logger.info('Keyboard shortcut triggered - starting capture process');

  if (contentScriptState.isCapturing) {
    logger.warn('Page capture already in progress');
    return;
  }

  try {
    contentScriptState.isCapturing = true;

    // Show "capturing" notification that stays until capture completes (no auto-hide)
    showNotification('Capturing content...', 'info', 0); // 0 duration = no auto-hide

    // Check if current page is a PDF
    const isPDFPage = checkIfCurrentPageIsPDF();
    logger.debug('PDF detection result:', isPDFPage);

    if (isPDFPage) {
      logger.info('PDF page detected - using unified capture service via background');

      // For PDF pages, send capture request directly to background service
      const messageData = {
        url: window.location.href,
        title: document.title,
        contentType: 'pdf',
      };

      const response = await sendMessageToBackground(MESSAGE_TYPES.CAPTURE_CONTENT, messageData);

      if (response.success) {
        // Enhanced commit URL extraction with comprehensive fallback
        const commitUrl = extractCommitUrlFromResponse(response);

        if (commitUrl) {
          // Hide the "capturing" notification and show success with longer duration
          hideNotification(document.getElementById('prismweave-notification'));
          showNotification(
            'PDF captured successfully! Click to view on GitHub.',
            'success',
            8000,
            commitUrl
          );
          logger.info('PDF capture completed successfully via keyboard shortcut', {
            commitUrl,
            hasCommitUrl: true,
          });
        } else {
          // Hide the "capturing" notification and show success with longer duration
          hideNotification(document.getElementById('prismweave-notification'));
          showNotification('PDF captured successfully!', 'success', 8000);
          logger.warn('PDF capture completed but no commit URL found');
        }
      } else {
        throw new Error(response.error || 'PDF capture failed');
      }
    } else {
      logger.info('HTML page detected - extracting content locally then sending to background');

      // Extract content first for HTML pages
      const extractedContent = await extractPageContentWithUtilities();
      logger.info('Content extracted successfully for keyboard shortcut', {
        hasMarkdown: !!extractedContent.markdown,
        markdownLength: extractedContent.markdown?.length || 0,
        hasHtml: !!extractedContent.html,
        htmlLength: extractedContent.html?.length || 0,
        hasTitle: !!extractedContent.title,
        title: extractedContent.title || 'no title',
      });

      // Send capture request with extracted content to service worker
      const messageData = {
        url: window.location.href,
        title: document.title,
        extractedContent,
        contentType: 'html',
      };

      const response = await sendMessageToBackground(MESSAGE_TYPES.CAPTURE_CONTENT, messageData);

      if (response.success) {
        // Enhanced commit URL extraction with comprehensive fallback
        const commitUrl = extractCommitUrlFromResponse(response);

        if (commitUrl) {
          // Hide the "capturing" notification and show success with longer duration
          hideNotification(document.getElementById('prismweave-notification'));
          showNotification(
            'Page captured successfully! Click to view on GitHub.',
            'success',
            8000,
            commitUrl
          );
          logger.info('Page capture completed successfully via keyboard shortcut', {
            commitUrl,
            hasCommitUrl: true,
          });
        } else {
          // Hide the "capturing" notification and show success with longer duration
          hideNotification(document.getElementById('prismweave-notification'));
          showNotification('Page captured successfully!', 'success', 8000);
          logger.warn('Page capture completed but no commit URL found');
        }
      } else {
        throw new Error(response.error || 'Page capture failed');
      }
    }
  } catch (error) {
    logger.error('Keyboard shortcut capture failed:', error);
    // Hide the "capturing" notification and show error
    hideNotification(document.getElementById('prismweave-notification'));
    showNotification('Capture failed: ' + (error as Error).message, 'error', 8000);
  } finally {
    contentScriptState.isCapturing = false;
  }
}

// Check if current page is a PDF document
function checkIfCurrentPageIsPDF(): boolean {
  const url = window.location.href;

  // Check if URL ends with .pdf
  if (url.toLowerCase().endsWith('.pdf')) {
    return true;
  }

  // Check if URL contains PDF indicators
  if (url.toLowerCase().includes('.pdf')) {
    return true;
  }

  // Check for common PDF viewer URL patterns
  const pdfPatterns = [
    /\/pdf\//i,
    /\.pdf$/i,
    /\.pdf\?/i,
    /\.pdf#/i,
    /application\/pdf/i,
    /chrome-extension:\/\/.*\/web\/viewer\.html/i, // Chrome PDF viewer
  ];

  const isPDFByPattern = pdfPatterns.some(pattern => pattern.test(url));

  if (isPDFByPattern) {
    return true;
  }

  // Check document MIME type if available
  try {
    if (document.contentType && document.contentType.includes('pdf')) {
      return true;
    }
  } catch (error) {
    // Ignore contentType access errors
  }

  // Check for PDF viewer indicators in the DOM
  const pdfViewerSelectors = [
    'embed[type="application/pdf"]',
    'object[type="application/pdf"]',
    '#viewer', // Common PDF viewer element
    '.pdfViewer', // Common PDF viewer class
    '[data-pdf-viewer]', // PDF viewer data attribute
  ];

  const hasPDFViewerElements = pdfViewerSelectors.some(selector => {
    try {
      return document.querySelector(selector) !== null;
    } catch (error) {
      return false;
    }
  });

  logger.info('PDF detection result:', {
    url,
    isPDFByPattern,
    hasPDFViewerElements,
    documentContentType: document.contentType || 'unknown',
    finalResult: hasPDFViewerElements,
  });

  return hasPDFViewerElements;
}

// Set up message listeners for communication with service worker
function setupMessageListeners(): void {
  chrome.runtime.onMessage.addListener(
    (
      message: IMessageData,
      sender: chrome.runtime.MessageSender,
      sendResponse: (response: IMessageResponse) => void
    ) => {
      handleMessage(message, sender)
        .then(result => sendResponse({ success: true, data: result }))
        .catch(error => {
          logger.error('Content script message error:', error);
          sendResponse({ success: false, error: error.message });
        });

      return true; // Keep message channel open for async response
    }
  );
}

// Handle messages from service worker
async function handleMessage(
  message: IMessageData,
  sender: chrome.runtime.MessageSender
): Promise<unknown> {
  switch (message.type) {
    case 'PING':
      return { status: 'ready', timestamp: Date.now() };

    case 'UPDATE_KEYBOARD_SHORTCUTS':
      if (message.data && typeof message.data.enabled === 'boolean') {
        contentScriptState.keyboardShortcutsEnabled = message.data.enabled;
        logger.info('Keyboard shortcuts updated:', contentScriptState.keyboardShortcutsEnabled);
      }
      return { success: true };

    case 'GET_PAGE_INFO':
      return {
        title: document.title,
        url: window.location.href,
        domain: window.location.hostname,
      };

    case 'SHOW_NOTIFICATION':
      if (message.data && typeof message.data.message === 'string') {
        const notificationType = (message.data.type as 'success' | 'error' | 'info') || 'info';
        const duration = (message.data.duration as number) || 8000; // Increased default duration
        const clickUrl = (message.data.clickUrl || message.data.url) as string | undefined;
        showNotification(message.data.message, notificationType, duration, clickUrl);
        logger.info('Notification shown:', message.data.message);
      }
      return { success: true };

    case 'TRIGGER_CAPTURE_SHORTCUT':
      // Handle keyboard shortcut trigger from service worker
      try {
        await handleCapturePageShortcut();
        return { success: true };
      } catch (error) {
        logger.error('Failed to handle capture shortcut:', error);
        return { success: false, error: (error as Error).message };
      }

    case 'EXTRACT_AND_CONVERT_TO_MARKDOWN':
      // This is called by the service worker for content extraction
      try {
        const extractedContent = await extractPageContentWithUtilities(message.data);
        return {
          success: true,
          data: extractedContent,
          extractionMethod: 'content-script',
          timestamp: new Date().toISOString(),
        } as IContentExtractionResult;
      } catch (error) {
        logger.error('Content extraction failed:', error);
        return {
          success: false,
          error: (error as Error).message,
          extractionMethod: 'content-script',
          timestamp: new Date().toISOString(),
        } as IContentExtractionResult;
      }

    default:
      throw new Error(`Unknown message type: ${message.type}`);
  }
}

// Extract page content using existing utilities
async function extractPageContentWithUtilities(options?: any): Promise<IContentExtractionData> {
  try {
    logger.info('Extracting page content using ContentExtractor...');

    // Check if this is a Stack Overflow blog and use dedicated extractor
    const soExtractor = new StackOverflowBlogExtractor();
    if (soExtractor.isStackOverflowBlog()) {
      logger.info('Detected Stack Overflow blog, using specialized extractor...');

      const soResult = soExtractor.extractBlogContent();
      if (soResult && soResult.content.length > 500) {
        logger.info('Successfully extracted SO blog content', {
          contentLength: soResult.content.length,
          title: soResult.title,
          author: soResult.author,
        });

        // Convert to markdown using our converter
        const markdownConverter = new MarkdownConverter();
        const markdownResult = markdownConverter.convertToMarkdown(soResult.content, {
          preserveFormatting: true,
          generateFrontmatter: true,
        });

        // Prepare frontmatter with SO-specific metadata
        const frontmatter = [
          '---',
          `title: "${soResult.title.replace(/"/g, '\\"')}"`,
          `url: "${window.location.href}"`,
          `domain: "${window.location.hostname}"`,
          `extracted_at: "${new Date().toISOString()}"`,
          soResult.author ? `author: "${soResult.author.replace(/"/g, '\\"')}"` : '',
          soResult.publishDate ? `published: "${soResult.publishDate}"` : '',
          soResult.readingTime ? `reading_time: ${soResult.readingTime}` : '',
          soResult.tags.length > 0
            ? `tags: [${soResult.tags.map(tag => `"${tag.replace(/"/g, '\\"')}"`).join(', ')}]`
            : '',
          'source: "stackoverflow.blog"',
          '---',
        ]
          .filter(line => line.length > 0)
          .join('\n');

        return {
          html: soResult.content,
          title: soResult.title,
          url: window.location.href,
          metadata: {
            title: soResult.title,
            url: window.location.href,
            domain: window.location.hostname,
            extractedAt: new Date().toISOString(),
            author: soResult.author,
            publishDate: soResult.publishDate,
            tags: soResult.tags,
            readingTime: soResult.readingTime,
            wordCount: soResult.content.split(/\s+/).length,
            source: 'stackoverflow.blog',
          },
          markdown: markdownResult.markdown,
          frontmatter: frontmatter,
          images: [], // SO extractor doesn't extract images yet, but could be added
        };
      } else {
        logger.warn(
          'SO extractor failed or returned insufficient content, falling back to generic extractor'
        );
      }
    }

    // Initialize utilities with error handling for extension context invalidation
    let contentExtractor: ContentExtractor;
    let markdownConverter: MarkdownConverter;

    try {
      contentExtractor = new ContentExtractor();
      markdownConverter = new MarkdownConverter();
    } catch (error) {
      // If utilities fail to initialize (e.g., extension context invalidated),
      // fall back to basic content extraction
      if (error instanceof Error && error.message.includes('Extension context invalidated')) {
        logger.warn('Extension context invalidated, falling back to basic extraction');
        showNotification('Extension reloaded - using basic capture mode', 'info', 3000);
        return await basicContentExtraction();
      }
      throw error;
    }

    // Extract content using the existing utility
    const extractorOptions = {
      customSelectors: options?.customSelectors,
      cleanHtml: options?.cleanHtml !== false,
      preserveFormatting: options?.preserveFormatting === true,
      waitForDynamicContent: options?.waitForDynamicContent !== false,
      // Enhanced cleaning for Stack Overflow blog
      removeAds: true,
      removeNavigation: true,
      excludeSelectors: [
        // Specific elements to exclude from Stack Overflow blog
        '.s-navigation',
        '.s-topbar',
        '.js-header',
        '.js-footer',
        '.recent-articles',
        '.latest-podcast',
        '.add-to-discussion',
        '.blog-sidebar',
        '.blog-nav',
        '.site-header',
        '.site-footer',
        '.products-nav',
        // Generic promotional content
        '[href*="/teams/"]',
        '[href*="/advertising/"]',
        '[href*="/talent/"]',
        '.promo',
        '.newsletter',
        '.subscribe',
        '.signup',
        '.cta',
        '.call-to-action',
        // Our own notification elements
        '#prismweave-notification',
        '[id*="prismweave"]',
        '[class*="prismweave"]',
      ],
    };

    const contentResult = await contentExtractor.extractContent(extractorOptions);

    // Convert to markdown with enhanced cleaning
    const markdownResult = markdownConverter.convertToMarkdown(contentResult.content, {
      preserveFormatting: options?.preserveFormatting === true,
      includeMetadata: true,
      generateFrontmatter: true,
    });

    // Post-process markdown to remove any remaining unwanted content
    let cleanedMarkdown = markdownResult.markdown;

    // Remove our own "Capturing page..." text and similar notifications
    cleanedMarkdown = cleanedMarkdown.replace(/Capturing page\.\.\./gi, '');
    cleanedMarkdown = cleanedMarkdown.replace(/PrismWeave[^.\n]*\./gi, '');

    // Remove Stack Overflow promotional content patterns
    const removePatterns = [
      /Products\s*\n+\s*\*\*Stack Overflow for Teams\*\*[^]*?technologists\./gi,
      /\[Blog\]\(\/\)/gi,
      /\[\]\(https:\/\/stackoverflow\.com\)/gi,
      /\[.*?\]\(\/feed\)/gi,
      /Recent articles\s*\n+.*?\d{4}/gims,
      /Latest Podcast\s*\n+.*?\d{4}/gims,
      /Add to the discussion\s*\n+.*?take part in the discussion\./gims,
      /Login with your.*?account to take part/gi,
    ];

    removePatterns.forEach(pattern => {
      cleanedMarkdown = cleanedMarkdown.replace(pattern, '');
    });

    // Clean up excessive whitespace
    cleanedMarkdown = cleanedMarkdown.replace(/\n{3,}/g, '\n\n').trim();

    // Extract images using the utility
    const images = contentExtractor.extractImages();
    const imageUrls = images.map(img => img.src);

    // Get page structure for additional metadata
    const pageStructure = contentExtractor.getPageStructure();

    // Prepare the result data
    const extractionData: IContentExtractionData = {
      html: contentResult.content,
      title: contentResult.metadata.title,
      url: window.location.href,
      metadata: {
        ...contentResult.metadata,
        extractedAt: new Date().toISOString(),
        domain: window.location.hostname,
        wordCount: contentResult.wordCount,
        readingTime: contentResult.readingTime,
        headings: pageStructure.headings,
        sections: pageStructure.sections,
        paragraphs: pageStructure.paragraphs,
        qualityScore: contentExtractor.getContentQualityScore(),
        isPaywallPresent: contentExtractor.isPaywallPresent(),
      },
      markdown: cleanedMarkdown,
      frontmatter: markdownResult.frontmatter,
      images: imageUrls,
    };

    logger.info('Content extraction completed successfully using utilities', {
      wordCount: contentResult.wordCount,
      imageCount: imageUrls.length,
      markdownLength: cleanedMarkdown.length,
    });

    return extractionData;
  } catch (error) {
    logger.error('Page content extraction failed with utilities:', error);

    // If the main extraction failed, try basic fallback
    if (error instanceof Error && error.message.includes('Extension context invalidated')) {
      logger.warn('Falling back to basic content extraction due to extension context invalidation');
      showNotification('Extension reloaded - using basic capture mode', 'info', 3000);
      return await basicContentExtraction();
    }

    throw error;
  }
}

// Basic content extraction fallback for when extension context is invalidated
async function basicContentExtraction(): Promise<IContentExtractionData> {
  try {
    // Basic content selectors
    const contentSelectors = [
      'article',
      'main',
      '[role="main"]',
      '.content',
      '.post',
      '.entry',
      '#content',
    ];

    let contentElement: Element | null = null;

    // Try to find main content element
    for (const selector of contentSelectors) {
      contentElement = document.querySelector(selector);
      if (
        contentElement &&
        contentElement.textContent &&
        contentElement.textContent.trim().length > 100
      ) {
        break;
      }
    }

    // Fall back to body if no content area found
    if (!contentElement) {
      contentElement = document.body;
    }

    const html = contentElement?.innerHTML || '';
    const textContent = contentElement?.textContent || '';
    const title = document.title || 'Untitled';

    // Basic word count
    const wordCount = textContent.split(/\s+/).filter(word => word.length > 0).length;

    // Basic image extraction
    const images = Array.from(document.images)
      .map(img => img.src)
      .filter(src => src && !src.startsWith('data:'));

    // Simple markdown conversion (very basic)
    let markdown = textContent;
    if (title) {
      markdown = `# ${title}\n\n${textContent}`;
    }

    const extractionData: IContentExtractionData = {
      html,
      title,
      url: window.location.href,
      metadata: {
        extractedAt: new Date().toISOString(),
        domain: window.location.hostname,
        wordCount,
        readingTime: Math.ceil(wordCount / 200),
        extractionMethod: 'basic-fallback',
      },
      markdown,
      frontmatter: `---\ntitle: ${title}\nurl: ${window.location.href}\ncaptured: ${new Date().toISOString()}\n---\n`,
      images,
    };

    return extractionData;
  } catch (error) {
    throw new Error(
      `Basic content extraction failed: ${error instanceof Error ? error.message : 'Unknown error'}`
    );
  }
}

// Send message to background script
function sendMessageToBackground(type: string, data?: any): Promise<IEnhancedMessageResponse> {
  return new Promise<IEnhancedMessageResponse>((resolve, reject) => {
    const message: IMessageData = { type, data, timestamp: Date.now() };

    chrome.runtime.sendMessage(message, (response: IEnhancedMessageResponse) => {
      if (chrome.runtime.lastError) {
        reject(new Error(chrome.runtime.lastError.message));
      } else if (!response) {
        reject(new Error('No response received from background script'));
      } else {
        resolve(response);
      }
    });
  });
}

// Show user notification
function showNotification(
  message: string,
  type: 'success' | 'error' | 'info' = 'info',
  duration: number = 4000,
  clickUrl?: string
): void {
  logger.info('showNotification called:', { message, type, duration, clickUrl });

  // Simple guard clause
  if (!document.body) return;

  // Remove existing notification
  const existingNotification = document.getElementById('prismweave-notification');
  if (existingNotification) {
    existingNotification.remove();
  }

  // Create notification element
  const notification = document.createElement('div');
  notification.id = 'prismweave-notification';

  // Set base styles
  const colors = {
    success: '#10b981',
    error: '#ef4444',
    info: '#3b82f6',
  };

  notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 2147483647;
    padding: 16px 20px;
    border-radius: 6px;
    color: white;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    font-size: 14px;
    font-weight: 500;
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
    max-width: 320px;
    word-wrap: break-word;
    background-color: ${colors[type]};
    opacity: 0;
    transform: translateX(100%);
    transition: all 0.3s ease;
    user-select: none;
    pointer-events: auto;
    cursor: ${clickUrl ? 'pointer' : 'default'};
  `;

  // Create notification content
  if (clickUrl) {
    const documentTitle = document.title || 'this page';
    const urlDomain = new URL(clickUrl).hostname;
    const displayText =
      documentTitle.length > 50 ? documentTitle.substring(0, 47) + '...' : documentTitle;

    notification.innerHTML = `
      <div style="display: flex; flex-direction: column; gap: 8px;">
        <div style="font-size: 13px; opacity: 0.9;">${message}</div>
        <div style="
          padding: 8px 12px;
          background: rgba(255, 255, 255, 0.15);
          border-radius: 4px;
          border: 1px solid rgba(255, 255, 255, 0.2);
          font-weight: 600;
          display: flex;
          align-items: center;
          gap: 6px;
          cursor: pointer;
        " onclick="window.open('${clickUrl}', '_blank')">
          <span style="font-size: 16px;">ðŸ”—</span>
          <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${displayText}</span>
        </div>
        <div style="font-size: 11px; opacity: 0.7; text-align: center;">
          Click to open â€¢ 
          <a href="${clickUrl}" 
             target="_blank" 
             rel="noopener noreferrer" 
             style="color: rgba(255, 255, 255, 0.9); text-decoration: underline; cursor: pointer;">
            ${urlDomain}
          </a>
        </div>
      </div>
    `;
  } else {
    notification.textContent = message;
  }

  // Add to DOM
  document.body.appendChild(notification);

  // Show notification with animation
  requestAnimationFrame(() => {
    notification.style.opacity = '1';
    notification.style.transform = 'translateX(0)';
  });

  // Auto-hide notification after specified duration
  if (duration > 0) {
    setTimeout(() => {
      hideNotification(notification);
    }, duration);
  }
}

// Helper function to hide notification
function hideNotification(notification: HTMLElement | null): void {
  if (notification && notification.parentNode) {
    logger.debug('Hiding notification');
    // Smoothly fade out the notification
    notification.style.opacity = '0';
    notification.style.transform = 'translateX(100%)';
    notification.style.pointerEvents = 'none'; // Prevent interaction during fade out

    // Remove the element after animation completes
    setTimeout(() => {
      if (notification && notification.parentNode) {
        notification.parentNode.removeChild(notification);
        logger.debug('Notification element removed from DOM');
      }
    }, 300);
  } else {
    logger.debug('No notification to hide or no parent node');
  }
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeContentScript);
} else {
  initializeContentScript();
}

// Export for debugging (optional) - Make available immediately
if (typeof window !== 'undefined') {
  (window as any).prismweaveContentScript = {
    state: contentScriptState,
    handleCapturePageShortcut,
    loadKeyboardShortcutSettings,
    showNotification,
    hideNotification,
    testNotification: () => {
      // Test function to debug notification clicks
      showNotification(
        'Test notification - Click me!',
        'success',
        10000,
        'https://github.com/davidhayesbc/PrismWeaveDocs'
      );
    },
    version: '1.0.0',
  };

  // Dispatch a custom event to notify the page that the extension is ready
  const readyEvent = new CustomEvent('prismweave-ready', {
    detail: { version: '1.0.0' },
  });
  document.dispatchEvent(readyEvent);

  console.log('PrismWeave content script API exposed to window');
}

console.log('PrismWeave content script loaded successfully');
