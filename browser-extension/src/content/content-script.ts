// Generated by Copilot
// Content script for PrismWeave browser extension
// Handles keyboard shortcuts and page content extraction

import { IMessageData, IMessageResponse, MESSAGE_TYPES } from '../types/index.js';
import { createLogger } from '../utils/logger.js';

console.log('PrismWeave content script loading...');

// Type definitions for content script
interface IContentScriptState {
  isInitialized: boolean;
  keyboardShortcutsEnabled: boolean;
  isCapturing: boolean;
}

interface IKeyboardShortcut {
  ctrlKey: boolean;
  shiftKey: boolean;
  altKey: boolean;
  metaKey: boolean;
  key: string;
  action: string;
}

// Content script state
let contentScriptState: IContentScriptState = {
  isInitialized: false,
  keyboardShortcutsEnabled: true,
  isCapturing: false,
};

// Initialize logger
const logger = createLogger('ContentScript');

// Keyboard shortcuts configuration
const KEYBOARD_SHORTCUTS: IKeyboardShortcut[] = [
  {
    ctrlKey: true,
    shiftKey: true,
    altKey: false,
    metaKey: false,
    key: 'S',
    action: 'capture-page',
  },
  // Add more shortcuts here as needed
];

// Initialize content script
async function initializeContentScript(): Promise<void> {
  try {
    logger.info('Initializing PrismWeave content script...');

    // Load settings to check if keyboard shortcuts are enabled
    await loadKeyboardShortcutSettings();

    // Set up keyboard event listeners
    setupKeyboardListeners();

    // Set up message listeners for communication with service worker
    setupMessageListeners();

    contentScriptState.isInitialized = true;
    logger.info('PrismWeave content script initialized successfully');
  } catch (error) {
    logger.error('Failed to initialize content script:', error);
  }
}

// Load keyboard shortcut settings from storage
async function loadKeyboardShortcutSettings(): Promise<void> {
  try {
    const response = await sendMessageToBackground(MESSAGE_TYPES.GET_SETTINGS);
    if (response.success && response.data) {
      const settings = response.data as any;
      contentScriptState.keyboardShortcutsEnabled = settings.enableKeyboardShortcuts ?? true;
      logger.info('Keyboard shortcuts enabled:', contentScriptState.keyboardShortcutsEnabled);
    }
  } catch (error) {
    logger.warn('Failed to load settings, using defaults:', error);
    contentScriptState.keyboardShortcutsEnabled = true;
  }
}

// Set up keyboard event listeners
function setupKeyboardListeners(): void {
  document.addEventListener('keydown', handleKeyboardEvent, true);
  logger.info('Keyboard event listeners set up');
}

// Handle keyboard events
function handleKeyboardEvent(event: KeyboardEvent): void {
  // Skip if shortcuts are disabled
  if (!contentScriptState.keyboardShortcutsEnabled) {
    return;
  }

  // Skip if already capturing to prevent multiple simultaneous captures
  if (contentScriptState.isCapturing) {
    return;
  }

  // Skip if user is typing in an input field
  if (isTypingInInputField(event.target as Element)) {
    return;
  }

  // Check if the event matches any of our shortcuts
  for (const shortcut of KEYBOARD_SHORTCUTS) {
    if (matchesShortcut(event, shortcut)) {
      event.preventDefault();
      event.stopPropagation();
      handleShortcutAction(shortcut.action);
      break;
    }
  }
}

// Check if user is typing in an input field
function isTypingInInputField(target: Element | null): boolean {
  if (!target) return false;

  const tagName = target.tagName.toLowerCase();
  const inputTypes = ['input', 'textarea', 'select'];

  // Check if it's an input element
  if (inputTypes.includes(tagName)) {
    return true;
  }

  // Check if it's a contentEditable element
  const element = target as HTMLElement;
  if (element.contentEditable === 'true') {
    return true;
  }

  // Check if we're inside a contentEditable element
  let parent = target.parentElement;
  while (parent) {
    if (parent.contentEditable === 'true') {
      return true;
    }
    parent = parent.parentElement;
  }

  return false;
}

// Check if keyboard event matches a shortcut
function matchesShortcut(event: KeyboardEvent, shortcut: IKeyboardShortcut): boolean {
  // Normalize key comparison
  const eventKey = event.key.toUpperCase();
  const shortcutKey = shortcut.key.toUpperCase();

  return (
    event.ctrlKey === shortcut.ctrlKey &&
    event.shiftKey === shortcut.shiftKey &&
    event.altKey === shortcut.altKey &&
    event.metaKey === shortcut.metaKey &&
    eventKey === shortcutKey
  );
}

// Handle shortcut actions
async function handleShortcutAction(action: string): Promise<void> {
  logger.info('Handling shortcut action:', action);

  try {
    switch (action) {
      case 'capture-page':
        await handleCapturePageShortcut();
        break;
      default:
        logger.warn('Unknown shortcut action:', action);
    }
  } catch (error) {
    logger.error('Error handling shortcut action:', error);
    showNotification('Failed to execute shortcut: ' + (error as Error).message, 'error');
  }
}

// Handle capture page shortcut
async function handleCapturePageShortcut(): Promise<void> {
  if (contentScriptState.isCapturing) {
    logger.warn('Page capture already in progress');
    return;
  }

  try {
    contentScriptState.isCapturing = true;

    // Show user feedback
    showNotification('Capturing page...', 'info');

    // Send capture request to service worker
    const response = await sendMessageToBackground(MESSAGE_TYPES.CAPTURE_PAGE, {
      url: window.location.href,
      title: document.title,
      source: 'keyboard-shortcut',
    });

    if (response.success) {
      showNotification('Page captured successfully!', 'success');
      logger.info('Page captured successfully via keyboard shortcut');
    } else {
      throw new Error(response.error || 'Capture failed');
    }
  } catch (error) {
    logger.error('Page capture failed:', error);
    showNotification('Capture failed: ' + (error as Error).message, 'error');
  } finally {
    contentScriptState.isCapturing = false;
  }
}

// Set up message listeners for communication with service worker
function setupMessageListeners(): void {
  chrome.runtime.onMessage.addListener(
    (
      message: IMessageData,
      sender: chrome.runtime.MessageSender,
      sendResponse: (response: IMessageResponse) => void
    ) => {
      handleMessage(message, sender)
        .then(result => sendResponse({ success: true, data: result }))
        .catch(error => {
          logger.error('Content script message error:', error);
          sendResponse({ success: false, error: error.message });
        });

      return true; // Keep message channel open for async response
    }
  );
}

// Handle messages from service worker
async function handleMessage(
  message: IMessageData,
  sender: chrome.runtime.MessageSender
): Promise<unknown> {
  switch (message.type) {
    case 'PING':
      return { status: 'ready', timestamp: Date.now() };

    case 'UPDATE_KEYBOARD_SHORTCUTS':
      if (message.data && typeof message.data.enabled === 'boolean') {
        contentScriptState.keyboardShortcutsEnabled = message.data.enabled;
        logger.info('Keyboard shortcuts updated:', contentScriptState.keyboardShortcutsEnabled);
      }
      return { success: true };

    case 'GET_PAGE_INFO':
      return {
        title: document.title,
        url: window.location.href,
        domain: window.location.hostname,
      };

    default:
      throw new Error(`Unknown message type: ${message.type}`);
  }
}

// Send message to background script
function sendMessageToBackground(type: string, data?: any): Promise<IMessageResponse> {
  return new Promise<IMessageResponse>((resolve, reject) => {
    const message: IMessageData = { type, data, timestamp: Date.now() };

    chrome.runtime.sendMessage(message, (response: IMessageResponse) => {
      if (chrome.runtime.lastError) {
        reject(new Error(chrome.runtime.lastError.message));
      } else if (!response) {
        reject(new Error('No response received from background script'));
      } else {
        resolve(response);
      }
    });
  });
}

// Show user notification
function showNotification(message: string, type: 'success' | 'error' | 'info' = 'info'): void {
  // Create or update notification element
  let notification = document.getElementById('prismweave-notification');

  if (!notification) {
    notification = document.createElement('div');
    notification.id = 'prismweave-notification';
    notification.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10000;
      padding: 12px 16px;
      border-radius: 4px;
      color: white;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 14px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      max-width: 300px;
      word-wrap: break-word;
      opacity: 0;
      transform: translateX(100%);
      transition: all 0.3s ease;
    `;
    document.body.appendChild(notification);
  }

  // Set notification style based on type
  const colors = {
    success: '#10b981',
    error: '#ef4444',
    info: '#3b82f6',
  };

  notification.style.backgroundColor = colors[type];
  notification.textContent = message;

  // Show notification
  requestAnimationFrame(() => {
    notification!.style.opacity = '1';
    notification!.style.transform = 'translateX(0)';
  });

  // Hide notification after 4 seconds
  setTimeout(() => {
    if (notification) {
      notification.style.opacity = '0';
      notification.style.transform = 'translateX(100%)';

      setTimeout(() => {
        if (notification && notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 300);
    }
  }, 4000);
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeContentScript);
} else {
  initializeContentScript();
}

// Export for debugging (optional)
if (typeof window !== 'undefined') {
  (window as any).prismweaveContentScript = {
    state: contentScriptState,
    handleCapturePageShortcut,
    loadKeyboardShortcutSettings,
    version: '1.0.0',
  };
}

console.log('PrismWeave content script loaded successfully');
