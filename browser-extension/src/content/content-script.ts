// Generated by Copilot
// Content script for PrismWeave browser extension
// Handles keyboard shortcuts and page content extraction

import {
  IContentExtractionData,
  IContentExtractionResult,
  IMessageData,
  IMessageResponse,
  MESSAGE_TYPES,
} from '../types/index.js';
import { ContentExtractor } from '../utils/content-extractor.js';
import { createLogger } from '../utils/logger.js';
import { MarkdownConverter } from '../utils/markdown-converter.js';

console.log('PrismWeave content script loading...');

// Type definitions for content script
interface IContentScriptState {
  isInitialized: boolean;
  keyboardShortcutsEnabled: boolean;
  isCapturing: boolean;
}

interface IKeyboardShortcut {
  ctrlKey: boolean;
  shiftKey: boolean;
  altKey: boolean;
  metaKey: boolean;
  key: string;
  action: string;
}

// Content script state
let contentScriptState: IContentScriptState = {
  isInitialized: false,
  keyboardShortcutsEnabled: true,
  isCapturing: false,
};

// Initialize logger
const logger = createLogger('ContentScript');

// Keyboard shortcuts configuration
const KEYBOARD_SHORTCUTS: IKeyboardShortcut[] = [
  {
    ctrlKey: true,
    shiftKey: false,
    altKey: true,
    metaKey: false,
    key: 'S',
    action: 'capture-page',
  },
  // Add more shortcuts here as needed
];

// Initialize content script
async function initializeContentScript(): Promise<void> {
  try {
    logger.info('Initializing PrismWeave content script...');

    // Load settings to check if keyboard shortcuts are enabled
    await loadKeyboardShortcutSettings();

    // Set up keyboard event listeners
    setupKeyboardListeners();

    // Set up message listeners for communication with service worker
    setupMessageListeners();

    contentScriptState.isInitialized = true;
    logger.info('PrismWeave content script initialized successfully');
  } catch (error) {
    logger.error('Failed to initialize content script:', error);
  }
}

// Load keyboard shortcut settings from storage
async function loadKeyboardShortcutSettings(): Promise<void> {
  try {
    const response = await sendMessageToBackground(MESSAGE_TYPES.GET_SETTINGS);
    if (response.success && response.data) {
      const settings = response.data as any;
      contentScriptState.keyboardShortcutsEnabled = settings.enableKeyboardShortcuts ?? true;
      logger.info('Keyboard shortcuts enabled:', contentScriptState.keyboardShortcutsEnabled);
    }
  } catch (error) {
    logger.warn('Failed to load settings, using defaults:', error);
    contentScriptState.keyboardShortcutsEnabled = true;
  }
}

// Set up keyboard event listeners
function setupKeyboardListeners(): void {
  document.addEventListener('keydown', handleKeyboardEvent, true);
  logger.info('Keyboard event listeners set up');
}

// Handle keyboard events
function handleKeyboardEvent(event: KeyboardEvent): void {
  // Skip if shortcuts are disabled
  if (!contentScriptState.keyboardShortcutsEnabled) {
    return;
  }

  // Skip if already capturing to prevent multiple simultaneous captures
  if (contentScriptState.isCapturing) {
    return;
  }

  // Skip if user is typing in an input field
  if (isTypingInInputField(event.target as Element)) {
    return;
  }

  // Check if the event matches any of our shortcuts
  for (const shortcut of KEYBOARD_SHORTCUTS) {
    if (matchesShortcut(event, shortcut)) {
      event.preventDefault();
      event.stopPropagation();
      handleShortcutAction(shortcut.action);
      break;
    }
  }
}

// Check if user is typing in an input field
function isTypingInInputField(target: Element | null): boolean {
  if (!target) return false;

  const tagName = target.tagName.toLowerCase();
  const inputTypes = ['input', 'textarea', 'select'];

  // Check if it's an input element
  if (inputTypes.includes(tagName)) {
    return true;
  }

  // Check if it's a contentEditable element
  const element = target as HTMLElement;
  if (element.contentEditable === 'true') {
    return true;
  }

  // Check if we're inside a contentEditable element
  let parent = target.parentElement;
  while (parent) {
    if (parent.contentEditable === 'true') {
      return true;
    }
    parent = parent.parentElement;
  }

  return false;
}

// Check if keyboard event matches a shortcut
function matchesShortcut(event: KeyboardEvent, shortcut: IKeyboardShortcut): boolean {
  // Normalize key comparison
  const eventKey = event.key.toUpperCase();
  const shortcutKey = shortcut.key.toUpperCase();

  return (
    event.ctrlKey === shortcut.ctrlKey &&
    event.shiftKey === shortcut.shiftKey &&
    event.altKey === shortcut.altKey &&
    event.metaKey === shortcut.metaKey &&
    eventKey === shortcutKey
  );
}

// Handle shortcut actions
async function handleShortcutAction(action: string): Promise<void> {
  logger.info('Handling shortcut action:', action);

  try {
    switch (action) {
      case 'capture-page':
        await handleCapturePageShortcut();
        break;
      default:
        logger.warn('Unknown shortcut action:', action);
    }
  } catch (error) {
    logger.error('Error handling shortcut action:', error);
    showNotification('Failed to execute shortcut: ' + (error as Error).message, 'error');
  }
}

// Handle capture page shortcut
async function handleCapturePageShortcut(): Promise<void> {
  if (contentScriptState.isCapturing) {
    logger.warn('Page capture already in progress');
    return;
  }

  try {
    contentScriptState.isCapturing = true;

    // Show user feedback
    showNotification('Capturing page...', 'info');

    // Extract content first
    logger.info('Extracting content for keyboard shortcut capture...');
    const extractedContent = await extractPageContentWithUtilities();
    logger.info('Content extracted successfully for keyboard shortcut', {
      hasMarkdown: !!extractedContent.markdown,
      markdownLength: extractedContent.markdown?.length || 0,
      hasHtml: !!extractedContent.html,
      htmlLength: extractedContent.html?.length || 0,
      hasTitle: !!extractedContent.title,
      title: extractedContent.title || 'no title',
      keys: Object.keys(extractedContent),
    });

    // Send capture request with extracted content to service worker
    const messageData = {
      url: window.location.href,
      title: document.title,
      source: 'keyboard-shortcut',
      extractedContent: extractedContent, // Include the extracted content
    };

    logger.debug('Sending CAPTURE_PAGE message with data:', {
      hasExtractedContent: !!messageData.extractedContent,
      extractedContentKeys: Object.keys(messageData.extractedContent),
      extractedContentMarkdownLength: messageData.extractedContent.markdown?.length || 0,
    });

    try {
      logger.info('About to send CAPTURE_PAGE message to service worker...');
      const response = await sendMessageToBackground(MESSAGE_TYPES.CAPTURE_PAGE, messageData);
      logger.info('Received response from service worker:', {
        success: response.success,
        error: response.error,
        hasData: !!response.data,
      });

      if (response.success) {
        showNotification('Page captured successfully!', 'success');
        logger.info('Page captured successfully via keyboard shortcut');
      } else {
        throw new Error(response.error || 'Capture failed');
      }
    } catch (messageError) {
      logger.error('Error sending message to service worker:', messageError);
      throw messageError;
    }
  } catch (error) {
    logger.error('Page capture failed:', error);
    showNotification('Capture failed: ' + (error as Error).message, 'error');
  } finally {
    contentScriptState.isCapturing = false;
  }
}

// Set up message listeners for communication with service worker
function setupMessageListeners(): void {
  chrome.runtime.onMessage.addListener(
    (
      message: IMessageData,
      sender: chrome.runtime.MessageSender,
      sendResponse: (response: IMessageResponse) => void
    ) => {
      handleMessage(message, sender)
        .then(result => sendResponse({ success: true, data: result }))
        .catch(error => {
          logger.error('Content script message error:', error);
          sendResponse({ success: false, error: error.message });
        });

      return true; // Keep message channel open for async response
    }
  );
}

// Handle messages from service worker
async function handleMessage(
  message: IMessageData,
  sender: chrome.runtime.MessageSender
): Promise<unknown> {
  switch (message.type) {
    case 'PING':
      return { status: 'ready', timestamp: Date.now() };

    case 'UPDATE_KEYBOARD_SHORTCUTS':
      if (message.data && typeof message.data.enabled === 'boolean') {
        contentScriptState.keyboardShortcutsEnabled = message.data.enabled;
        logger.info('Keyboard shortcuts updated:', contentScriptState.keyboardShortcutsEnabled);
      }
      return { success: true };

    case 'GET_PAGE_INFO':
      return {
        title: document.title,
        url: window.location.href,
        domain: window.location.hostname,
      };

    case 'SHOW_NOTIFICATION':
      if (message.data && typeof message.data.message === 'string') {
        const notificationType = (message.data.type as 'success' | 'error' | 'info') || 'info';
        showNotification(message.data.message, notificationType);
        logger.info('Notification shown:', message.data.message);
      }
      return { success: true };

    case 'EXTRACT_AND_CONVERT_TO_MARKDOWN':
      // This is called by the service worker for content extraction
      try {
        const extractedContent = await extractPageContentWithUtilities(message.data);
        return {
          success: true,
          data: extractedContent,
          extractionMethod: 'content-script',
          timestamp: new Date().toISOString(),
        } as IContentExtractionResult;
      } catch (error) {
        logger.error('Content extraction failed:', error);
        return {
          success: false,
          error: (error as Error).message,
          extractionMethod: 'content-script',
          timestamp: new Date().toISOString(),
        } as IContentExtractionResult;
      }

    default:
      throw new Error(`Unknown message type: ${message.type}`);
  }
}

// Extract page content using existing utilities
async function extractPageContentWithUtilities(options?: any): Promise<IContentExtractionData> {
  try {
    logger.info('Extracting page content using ContentExtractor...');

    // Initialize utilities
    const contentExtractor = new ContentExtractor();
    const markdownConverter = new MarkdownConverter();

    // Extract content using the existing utility
    const extractorOptions = {
      customSelectors: options?.customSelectors,
      cleanHtml: options?.cleanHtml !== false,
      preserveFormatting: options?.preserveFormatting === true,
      waitForDynamicContent: options?.waitForDynamicContent !== false,
    };

    const contentResult = await contentExtractor.extractContent(extractorOptions);

    // Convert to markdown
    const markdownResult = markdownConverter.convertToMarkdown(contentResult.content, {
      preserveFormatting: options?.preserveFormatting === true,
      includeMetadata: true,
      generateFrontmatter: true,
    });

    // Extract images using the utility
    const images = contentExtractor.extractImages();
    const imageUrls = images.map(img => img.src);

    // Get page structure for additional metadata
    const pageStructure = contentExtractor.getPageStructure();

    // Prepare the result data
    const extractionData: IContentExtractionData = {
      html: contentResult.content,
      title: contentResult.metadata.title,
      url: window.location.href,
      metadata: {
        ...contentResult.metadata,
        extractedAt: new Date().toISOString(),
        domain: window.location.hostname,
        wordCount: contentResult.wordCount,
        readingTime: contentResult.readingTime,
        headings: pageStructure.headings,
        sections: pageStructure.sections,
        paragraphs: pageStructure.paragraphs,
        qualityScore: contentExtractor.getContentQualityScore(),
        isPaywallPresent: contentExtractor.isPaywallPresent(),
      },
      markdown: markdownResult.markdown,
      frontmatter: markdownResult.frontmatter,
      images: imageUrls,
    };

    logger.info('Content extraction completed successfully using utilities', {
      wordCount: contentResult.wordCount,
      imageCount: imageUrls.length,
      markdownLength: markdownResult.markdown.length,
    });

    return extractionData;
  } catch (error) {
    logger.error('Page content extraction failed with utilities:', error);
    throw error;
  }
}

// Send message to background script
function sendMessageToBackground(type: string, data?: any): Promise<IMessageResponse> {
  return new Promise<IMessageResponse>((resolve, reject) => {
    const message: IMessageData = { type, data, timestamp: Date.now() };

    chrome.runtime.sendMessage(message, (response: IMessageResponse) => {
      if (chrome.runtime.lastError) {
        reject(new Error(chrome.runtime.lastError.message));
      } else if (!response) {
        reject(new Error('No response received from background script'));
      } else {
        resolve(response);
      }
    });
  });
}

// Show user notification
function showNotification(message: string, type: 'success' | 'error' | 'info' = 'info'): void {
  // Create or update notification element
  let notification = document.getElementById('prismweave-notification');

  if (!notification) {
    notification = document.createElement('div');
    notification.id = 'prismweave-notification';
    notification.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10000;
      padding: 12px 16px;
      border-radius: 4px;
      color: white;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 14px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      max-width: 300px;
      word-wrap: break-word;
      opacity: 0;
      transform: translateX(100%);
      transition: all 0.3s ease;
    `;
    document.body.appendChild(notification);
  }

  // Set notification style based on type
  const colors = {
    success: '#10b981',
    error: '#ef4444',
    info: '#3b82f6',
  };

  notification.style.backgroundColor = colors[type];
  notification.textContent = message;

  // Show notification
  requestAnimationFrame(() => {
    notification!.style.opacity = '1';
    notification!.style.transform = 'translateX(0)';
  });

  // Hide notification after 4 seconds
  setTimeout(() => {
    if (notification) {
      notification.style.opacity = '0';
      notification.style.transform = 'translateX(100%)';

      setTimeout(() => {
        if (notification && notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 300);
    }
  }, 4000);
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeContentScript);
} else {
  initializeContentScript();
}

// Export for debugging (optional)
if (typeof window !== 'undefined') {
  (window as any).prismweaveContentScript = {
    state: contentScriptState,
    handleCapturePageShortcut,
    loadKeyboardShortcutSettings,
    version: '1.0.0',
  };
}

console.log('PrismWeave content script loaded successfully');
