// Generated by Copilot
// PrismWeave Options/Settings Page Script - TypeScript version

import { ISettings, IMessageData, IMessageResponse } from '../types/index.js';

export class PrismWeaveOptions {
  private settings: Partial<ISettings> = {};

  constructor() {
    this.initializeOptions();
  }

  private async initializeOptions(): Promise<void> {
    console.log('PrismWeaveOptions: Initializing options page');
    await this.loadSettings();
    console.log('PrismWeaveOptions: Settings loaded:', this.settings);
    this.populateForm();
    console.log('PrismWeaveOptions: Form populated');
    this.setupEventListeners();
    console.log('PrismWeaveOptions: Event listeners setup complete');
  }

  private async loadSettings(): Promise<void> {
    try {
      console.log('PrismWeaveOptions: Requesting settings from background...');
      const response = await this.sendMessage('GET_SETTINGS');
      console.log('PrismWeaveOptions: Received response:', response);
      
      if (response.success) {
        this.settings = response.data as Partial<ISettings>;
        console.log('PrismWeaveOptions: Settings updated:', this.settings);
      } else {
        console.warn('PrismWeaveOptions: Failed to load settings, using defaults');
        this.settings = {};
      }
    } catch (error) {
      console.error('PrismWeaveOptions: Failed to load settings:', error);
      this.settings = {};
    }
  }

  private populateForm(): void {
    // Repository Settings
    this.setInputValue('repositoryPath', this.settings.repositoryPath || '');
    this.setInputValue('githubToken', this.settings.githubToken || '');
    this.setInputValue('githubRepo', this.settings.githubRepo || '');

    // File Organization
    this.setSelectValue('defaultFolder', this.settings.defaultFolder || 'unsorted');
    this.setInputValue('customFolder', this.settings.customFolder || '');
    this.setSelectValue('fileNamingPattern', this.settings.fileNamingPattern || 'YYYY-MM-DD-domain-title');
    this.setInputValue('customNamingPattern', this.settings.customNamingPattern || '');

    // Automation Settings
    this.setCheckboxValue('autoCommit', this.settings.autoCommit ?? true);
    this.setCheckboxValue('autoPush', this.settings.autoPush ?? false);

    // Content Processing
    this.setCheckboxValue('captureImages', this.settings.captureImages ?? true);
    this.setCheckboxValue('removeAds', this.settings.removeAds ?? true);
    this.setCheckboxValue('removeNavigation', this.settings.removeNavigation ?? true);
    this.setCheckboxValue('preserveFormatting', this.settings.preserveFormatting ?? true);

    // Content Enhancement
    this.setCheckboxValue('generateTags', this.settings.generateTags ?? true);
    this.setCheckboxValue('generateSummary', this.settings.generateSummary ?? false);
    this.setCheckboxValue('enhanceMetadata', this.settings.enhanceMetadata ?? true);

    // Performance & Debugging
    this.setCheckboxValue('debugMode', this.settings.debugMode ?? false);
    this.setCheckboxValue('performanceMonitoring', this.settings.performanceMonitoring ?? false);
    this.setInputValue('maxImageSize', (this.settings.maxImageSize || 5).toString());

    // UI Preferences
    this.setCheckboxValue('showNotifications', this.settings.showNotifications ?? true);
    this.setCheckboxValue('darkMode', this.settings.darkMode ?? false);
  }

  private setupEventListeners(): void {
    // Save button
    const saveBtn = document.getElementById('save-settings');
    if (saveBtn) {
      saveBtn.addEventListener('click', () => this.saveSettings());
    }

    // Reset button
    const resetBtn = document.getElementById('reset-settings');
    if (resetBtn) {
      resetBtn.addEventListener('click', () => this.resetSettings());
    }

    // Export button
    const exportBtn = document.getElementById('export-settings');
    if (exportBtn) {
      exportBtn.addEventListener('click', () => this.exportSettings());
    }

    // Import button
    const importBtn = document.getElementById('import-settings');
    if (importBtn) {
      importBtn.addEventListener('click', () => this.importSettings());
    }

    // Test connection button
    const testBtn = document.getElementById('test-connection');
    if (testBtn) {
      testBtn.addEventListener('click', () => this.testConnection());
    }

    // Show/hide custom fields based on selections
    this.setupConditionalFields();
  }

  private setupConditionalFields(): void {
    // Show custom folder field when 'custom' is selected
    const defaultFolderSelect = document.getElementById('defaultFolder') as HTMLSelectElement;
    const customFolderField = document.getElementById('customFolderField');
    
    if (defaultFolderSelect && customFolderField) {
      const toggleCustomFolder = () => {
        customFolderField.style.display = defaultFolderSelect.value === 'custom' ? 'block' : 'none';
      };
      
      defaultFolderSelect.addEventListener('change', toggleCustomFolder);
      toggleCustomFolder(); // Initial state
    }

    // Show custom naming pattern field when 'custom' is selected
    const namingPatternSelect = document.getElementById('fileNamingPattern') as HTMLSelectElement;
    const customNamingField = document.getElementById('customNamingField');
    
    if (namingPatternSelect && customNamingField) {
      const toggleCustomNaming = () => {
        customNamingField.style.display = namingPatternSelect.value === 'custom' ? 'block' : 'none';
      };
      
      namingPatternSelect.addEventListener('change', toggleCustomNaming);
      toggleCustomNaming(); // Initial state
    }
  }

  private async saveSettings(): Promise<void> {
    try {
      const formData = this.collectFormData();
      const response = await this.sendMessage('UPDATE_SETTINGS', formData);
      
      if (response.success) {
        this.showMessage('Settings saved successfully!', 'success');
        this.settings = { ...this.settings, ...formData };
      } else {
        throw new Error(response.error || 'Failed to save settings');
      }
    } catch (error) {
      console.error('Failed to save settings:', error);
      this.showMessage('Failed to save settings: ' + (error as Error).message, 'error');
    }
  }

  private async resetSettings(): Promise<void> {
    if (!confirm('Are you sure you want to reset all settings to defaults?')) {
      return;
    }

    try {
      const response = await this.sendMessage('RESET_SETTINGS');
      
      if (response.success) {
        this.showMessage('Settings reset to defaults', 'success');
        await this.loadSettings();
        this.populateForm();
      } else {
        throw new Error(response.error || 'Failed to reset settings');
      }
    } catch (error) {
      console.error('Failed to reset settings:', error);
      this.showMessage('Failed to reset settings: ' + (error as Error).message, 'error');
    }
  }

  private async exportSettings(): Promise<void> {
    try {
      const response = await this.sendMessage('EXPORT_SETTINGS');
      
      if (response.success) {
        const blob = new Blob([response.data as string], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'prismweave-settings.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        this.showMessage('Settings exported successfully!', 'success');
      } else {
        throw new Error(response.error || 'Failed to export settings');
      }
    } catch (error) {
      console.error('Failed to export settings:', error);
      this.showMessage('Failed to export settings: ' + (error as Error).message, 'error');
    }
  }

  private async importSettings(): Promise<void> {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    
    input.onchange = async (e) => {
      const file = (e.target as HTMLInputElement).files?.[0];
      if (!file) return;

      try {
        const text = await file.text();
        const response = await this.sendMessage('IMPORT_SETTINGS', { settings: text });
        
        if (response.success) {
          this.showMessage('Settings imported successfully!', 'success');
          await this.loadSettings();
          this.populateForm();
        } else {
          throw new Error(response.error || 'Failed to import settings');
        }
      } catch (error) {
        console.error('Failed to import settings:', error);
        this.showMessage('Failed to import settings: ' + (error as Error).message, 'error');
      }
    };
    
    input.click();
  }

  private async testConnection(): Promise<void> {
    try {
      this.showMessage('Testing connection...', 'info');
      const response = await this.sendMessage('TEST_CONNECTION');
      
      if (response.success) {
        this.showMessage('Connection test successful!', 'success');
      } else {
        throw new Error(response.error || 'Connection test failed');
      }
    } catch (error) {
      console.error('Connection test failed:', error);
      this.showMessage('Connection test failed: ' + (error as Error).message, 'error');
    }
  }

  private collectFormData(): Partial<ISettings> {
    return {
      repositoryPath: this.getInputValue('repositoryPath'),
      githubToken: this.getInputValue('githubToken'),
      githubRepo: this.getInputValue('githubRepo'),
      defaultFolder: this.getSelectValue('defaultFolder'),
      customFolder: this.getInputValue('customFolder'),
      fileNamingPattern: this.getSelectValue('fileNamingPattern'),
      customNamingPattern: this.getInputValue('customNamingPattern'),
      autoCommit: this.getCheckboxValue('autoCommit'),
      autoPush: this.getCheckboxValue('autoPush'),
      captureImages: this.getCheckboxValue('captureImages'),
      removeAds: this.getCheckboxValue('removeAds'),
      removeNavigation: this.getCheckboxValue('removeNavigation'),
      preserveFormatting: this.getCheckboxValue('preserveFormatting'),
      generateTags: this.getCheckboxValue('generateTags'),
      generateSummary: this.getCheckboxValue('generateSummary'),
      enhanceMetadata: this.getCheckboxValue('enhanceMetadata'),
      debugMode: this.getCheckboxValue('debugMode'),
      performanceMonitoring: this.getCheckboxValue('performanceMonitoring'),
      maxImageSize: parseInt(this.getInputValue('maxImageSize')) || 5,
      showNotifications: this.getCheckboxValue('showNotifications'),
      darkMode: this.getCheckboxValue('darkMode'),
    };
  }

  // Helper methods for form manipulation
  private setInputValue(id: string, value: string): void {
    const element = document.getElementById(id) as HTMLInputElement;
    if (element) element.value = value;
  }

  private setSelectValue(id: string, value: string): void {
    const element = document.getElementById(id) as HTMLSelectElement;
    if (element) element.value = value;
  }

  private setCheckboxValue(id: string, value: boolean): void {
    const element = document.getElementById(id) as HTMLInputElement;
    if (element) element.checked = value;
  }

  private getInputValue(id: string): string {
    const element = document.getElementById(id) as HTMLInputElement;
    return element ? element.value : '';
  }

  private getSelectValue(id: string): string {
    const element = document.getElementById(id) as HTMLSelectElement;
    return element ? element.value : '';
  }

  private getCheckboxValue(id: string): boolean {
    const element = document.getElementById(id) as HTMLInputElement;
    return element ? element.checked : false;
  }

  private showMessage(message: string, type: 'success' | 'error' | 'info'): void {
    const messageElement = document.getElementById('message');
    if (messageElement) {
      messageElement.textContent = message;
      messageElement.className = `message ${type}`;
      messageElement.style.display = 'block';
      
      // Auto-hide after 5 seconds
      setTimeout(() => {
        messageElement.style.display = 'none';
      }, 5000);
    }
  }

  private async sendMessage(type: string, data?: any): Promise<IMessageResponse> {
    return new Promise<IMessageResponse>((resolve, reject) => {
      const message: IMessageData = { type, data };
      
      chrome.runtime.sendMessage(message, (response: IMessageResponse) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve(response);
        }
      });
    });
  }
}

// Initialize options page when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  new PrismWeaveOptions();
});
