// Generated by Copilot
// Bookmarklet options page functionality for PrismWeave Browser Extension

import { extractBookmarkletSettings, IBookmarkletSettings, ISettings } from '../types/index.js';
import { BookmarkletManager } from '../utils/bookmarklet-manager.js';
import { BookmarkletStorageValidator } from '../utils/bookmarklet-storage-validator.js';
import { createLogger } from '../utils/logger.js';
import { SettingsManager } from '../utils/settings-manager.js';

const logger = createLogger('BookmarkletOptions');

interface IBookmarkletElements {
  // Status elements
  statusIndicator: HTMLElement;
  enableBookmarklet: HTMLInputElement;

  // Configuration elements
  configSection: HTMLElement;
  customDomain: HTMLInputElement;
  bookmarkletVersion: HTMLInputElement;
  includeImages: HTMLInputElement;
  includeLinks: HTMLInputElement;
  cleanAds: HTMLInputElement;
  autoInstall: HTMLInputElement;
  customIncludeSelectors: HTMLTextAreaElement;
  customExcludeSelectors: HTMLTextAreaElement;

  // Bookmarklet elements
  bookmarkletSection: HTMLElement;
  bookmarkletPreview: HTMLElement;
  copyBookmarklet: HTMLButtonElement;
  testBookmarklet: HTMLButtonElement;
  regenerateBookmarklet: HTMLButtonElement;

  // Test results
  testResultsSection: HTMLElement;
  testResults: HTMLElement;

  // Action buttons
  saveSettings: HTMLButtonElement;
  resetSettings: HTMLButtonElement;
  exportBookmarklet: HTMLButtonElement;

  // Sharing elements
  exportConfig: HTMLButtonElement;
  importConfig: HTMLButtonElement;
  configFileInput: HTMLInputElement;
  generateShareLink: HTMLButtonElement;
  shareResults: HTMLElement;
  shareLinkDisplay: HTMLInputElement;
  copyShareLink: HTMLButtonElement;

  // Statistics elements
  totalUses: HTMLElement;
  successfulCaptures: HTMLElement;
  failedCaptures: HTMLElement;
  averageContentLength: HTMLElement;
  topDomains: HTMLElement;
  refreshStats: HTMLButtonElement;
  clearStats: HTMLButtonElement;
  exportStats: HTMLButtonElement;

  // Validation and testing elements
  validateStorage: HTMLButtonElement;
  validationResults: HTMLElement;
  runStorageTests: HTMLButtonElement;
  testBookmarkletStorage: HTMLButtonElement;

  // Status messages
  statusMessages: HTMLElement;
}

export class BookmarkletOptionsPage {
  private _settingsManager: SettingsManager;
  private _bookmarkletManager: BookmarkletManager;
  private _elements: IBookmarkletElements | null = null;
  private _currentBookmarklet: string = '';
  private _currentSettings: IBookmarkletSettings | null = null;

  constructor() {
    this._settingsManager = new SettingsManager();
    this._bookmarkletManager = new BookmarkletManager();
  }

  async initialize(): Promise<void> {
    try {
      logger.info('Initializing bookmarklet options page');

      await this._collectElements();
      await this._loadCurrentSettings();
      this._bindEventListeners();
      this._updateUI();
      await this._loadUsageStatistics(); // Load statistics on initialization

      logger.info('Bookmarklet options page initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize bookmarklet options page:', error);
      this._showError('Failed to initialize page. Please refresh and try again.');
    }
  }

  private async _collectElements(): Promise<void> {
    const getElementById = <T extends HTMLElement>(id: string): T => {
      const element = document.getElementById(id) as T;
      if (!element) {
        throw new Error(`Required element not found: ${id}`);
      }
      return element;
    };

    this._elements = {
      // Status elements
      statusIndicator: getElementById('bookmarklet-status'),
      enableBookmarklet: getElementById('enable-bookmarklet'),

      // Configuration elements
      configSection: getElementById('config-section'),
      customDomain: getElementById('custom-domain'),
      bookmarkletVersion: getElementById('bookmarklet-version'),
      includeImages: getElementById('include-images'),
      includeLinks: getElementById('include-links'),
      cleanAds: getElementById('clean-ads'),
      autoInstall: getElementById('auto-install'),
      customIncludeSelectors: getElementById('custom-include-selectors'),
      customExcludeSelectors: getElementById('custom-exclude-selectors'),

      // Bookmarklet elements
      bookmarkletSection: getElementById('bookmarklet-section'),
      bookmarkletPreview: getElementById('bookmarklet-preview'),
      copyBookmarklet: getElementById('copy-bookmarklet'),
      testBookmarklet: getElementById('test-bookmarklet'),
      regenerateBookmarklet: getElementById('regenerate-bookmarklet'),

      // Test results
      testResultsSection: getElementById('test-results-section'),
      testResults: getElementById('test-results'),

      // Action buttons
      saveSettings: getElementById('save-bookmarklet-settings'),
      resetSettings: getElementById('reset-bookmarklet-settings'),
      exportBookmarklet: getElementById('export-bookmarklet'),

      // Sharing elements
      exportConfig: getElementById('export-config'),
      importConfig: getElementById('import-config'),
      configFileInput: getElementById('config-file-input'),
      generateShareLink: getElementById('generate-share-link'),
      shareResults: getElementById('share-results'),
      shareLinkDisplay: getElementById('share-link-display'),
      copyShareLink: getElementById('copy-share-link'),

      // Statistics elements
      totalUses: getElementById('total-uses'),
      successfulCaptures: getElementById('successful-captures'),
      failedCaptures: getElementById('failed-captures'),
      averageContentLength: getElementById('average-content-length'),
      topDomains: getElementById('top-domains'),
      refreshStats: getElementById('refresh-stats'),
      clearStats: getElementById('clear-stats'),
      exportStats: getElementById('export-stats'),

      // Validation and testing elements
      validateStorage: getElementById('validate-storage'),
      validationResults: getElementById('validation-results'),
      runStorageTests: getElementById('run-storage-tests'),
      testBookmarkletStorage: getElementById('test-bookmarklet-storage'),

      // Status messages
      statusMessages: getElementById('status-messages'),
    };
  }

  private async _loadCurrentSettings(): Promise<void> {
    try {
      const settings = await this._settingsManager.getSettingsWithDefaults();
      this._currentSettings = extractBookmarkletSettings(settings);
      logger.debug('Loaded bookmarklet settings:', this._currentSettings);
    } catch (error) {
      logger.error('Failed to load settings:', error);
      this._showError('Failed to load settings');

      // Use defaults if loading fails
      this._currentSettings = extractBookmarkletSettings({});
    }
  }

  private _bindEventListeners(): void {
    if (!this._elements) return;

    // Enable/disable bookmarklet
    this._elements.enableBookmarklet.addEventListener('change', () => {
      this._handleBookmarkletToggle();
    });

    // Configuration changes
    const configInputs = [
      this._elements.customDomain,
      this._elements.includeImages,
      this._elements.includeLinks,
      this._elements.cleanAds,
      this._elements.autoInstall,
      this._elements.customIncludeSelectors,
      this._elements.customExcludeSelectors,
    ];

    configInputs.forEach(input => {
      input.addEventListener('change', () => {
        this._handleConfigurationChange();
      });
    });

    // Bookmarklet actions
    this._elements.copyBookmarklet.addEventListener('click', () => {
      this._copyBookmarkletToClipboard();
    });

    this._elements.testBookmarklet.addEventListener('click', () => {
      this._testBookmarklet();
    });

    this._elements.regenerateBookmarklet.addEventListener('click', () => {
      this._regenerateBookmarklet();
    });

    // Main actions
    this._elements.saveSettings.addEventListener('click', () => {
      this._saveSettings();
    });

    this._elements.resetSettings.addEventListener('click', () => {
      this._resetSettings();
    });

    this._elements.exportBookmarklet.addEventListener('click', () => {
      this._exportConfiguration();
    });

    // Sharing event listeners
    this._elements.exportConfig.addEventListener('click', () => {
      this._exportConfigurationFile();
    });

    this._elements.importConfig.addEventListener('click', () => {
      this._elements?.configFileInput.click();
    });

    this._elements.configFileInput.addEventListener('change', event => {
      this._importConfigurationFile(event);
    });

    this._elements.generateShareLink.addEventListener('click', () => {
      this._generateShareableLink();
    });

    this._elements.copyShareLink.addEventListener('click', () => {
      this._copyShareLink();
    });

    // Statistics event listeners
    this._elements.refreshStats.addEventListener('click', () => {
      this._refreshUsageStatistics();
    });

    this._elements.clearStats.addEventListener('click', () => {
      this._clearUsageStatistics();
    });

    this._elements.exportStats.addEventListener('click', () => {
      this._exportUsageStatistics();
    });

    // Validation event listeners
    this._elements.validateStorage.addEventListener('click', () => {
      this._validateBookmarkletStorage();
    });

    this._elements.runStorageTests.addEventListener('click', () => {
      this._runStorageTests();
    });

    this._elements.testBookmarkletStorage.addEventListener('click', () => {
      this._testBookmarkletStorageIntegration();
    });
  }

  private _updateUI(): void {
    if (!this._elements || !this._currentSettings) return;

    // Update status indicator
    const isEnabled = this._currentSettings.enabled;
    this._elements.statusIndicator.className = `status-indicator ${isEnabled ? 'enabled' : 'disabled'}`;
    this._elements.statusIndicator.querySelector('span')!.textContent = isEnabled
      ? 'Enabled'
      : 'Disabled';

    // Update form values
    this._elements.enableBookmarklet.checked = isEnabled;
    this._elements.customDomain.value = this._currentSettings.customDomain || '';
    this._elements.bookmarkletVersion.value = this._currentSettings.version;
    this._elements.includeImages.checked = this._currentSettings.includeImages;
    this._elements.includeLinks.checked = this._currentSettings.includeLinks;
    this._elements.cleanAds.checked = this._currentSettings.cleanAds;
    this._elements.autoInstall.checked = this._currentSettings.autoInstall;
    this._elements.customIncludeSelectors.value = this._currentSettings.customSelectors.join(', ');
    this._elements.customExcludeSelectors.value = this._currentSettings.excludeSelectors.join(', ');

    // Show/hide sections based on enabled state
    this._elements.configSection.style.display = isEnabled ? 'block' : 'none';
    this._elements.bookmarkletSection.style.display = isEnabled ? 'block' : 'none';

    // Generate bookmarklet if enabled
    if (isEnabled) {
      this._generateBookmarklet();
    }
  }

  private _handleBookmarkletToggle(): void {
    if (!this._elements || !this._currentSettings) return;

    const isEnabled = this._elements.enableBookmarklet.checked;
    this._currentSettings.enabled = isEnabled;

    this._updateUI();

    if (isEnabled) {
      this._showSuccess('Bookmarklet enabled. Configure settings below and save.');
    } else {
      this._showInfo('Bookmarklet disabled.');
    }
  }

  private _handleConfigurationChange(): void {
    if (!this._elements || !this._currentSettings) return;

    // Update current settings from form
    this._currentSettings.customDomain = this._elements.customDomain.value.trim();
    this._currentSettings.includeImages = this._elements.includeImages.checked;
    this._currentSettings.includeLinks = this._elements.includeLinks.checked;
    this._currentSettings.cleanAds = this._elements.cleanAds.checked;
    this._currentSettings.autoInstall = this._elements.autoInstall.checked;

    // Parse selectors
    this._currentSettings.customSelectors = this._parseSelectors(
      this._elements.customIncludeSelectors.value
    );
    this._currentSettings.excludeSelectors = this._parseSelectors(
      this._elements.customExcludeSelectors.value
    );

    // Regenerate bookmarklet with new settings
    if (this._currentSettings.enabled) {
      this._generateBookmarklet();
    }
  }

  private _parseSelectors(value: string): string[] {
    return value
      .split(',')
      .map(s => s.trim())
      .filter(s => s.length > 0);
  }

  private async _generateBookmarklet(): Promise<void> {
    if (!this._elements || !this._currentSettings) return;

    try {
      logger.debug('Generating bookmarklet with settings:', this._currentSettings);

      this._elements.bookmarkletPreview.innerHTML = `
        <div class="loading">
          <div class="status-dot"></div>
          Generating bookmarklet...
        </div>
      `;

      // Get GitHub settings for the bookmarklet
      const allSettings = await this._settingsManager.getSettingsWithDefaults();

      const customConfig = {
        githubToken: allSettings.githubToken || '',
        githubRepo: allSettings.githubRepo || '',
        defaultFolder: allSettings.defaultFolder || 'unsorted',
        extractionOptions: {
          includeImages: this._currentSettings.includeImages,
          includeLinks: this._currentSettings.includeLinks,
          cleanAds: this._currentSettings.cleanAds,
          customSelectors: this._currentSettings.customSelectors,
          excludeSelectors: this._currentSettings.excludeSelectors,
        },
        customEndpoint: this._currentSettings.customDomain || undefined,
      };

      const result = await this._bookmarkletManager.generateBookmarklet(customConfig);

      if (!result.success) {
        throw new Error(result.error || 'Failed to generate bookmarklet');
      }

      this._currentBookmarklet = result.bookmarkletCode || '';

      // Display the bookmarklet
      this._elements.bookmarkletPreview.innerHTML = `<code>${this._escapeHtml(this._currentBookmarklet)}</code>`;

      logger.debug('Bookmarklet generated successfully');
    } catch (error) {
      logger.error('Failed to generate bookmarklet:', error);
      this._elements.bookmarkletPreview.innerHTML = `
        <div class="error">
          Failed to generate bookmarklet: ${error instanceof Error ? error.message : 'Unknown error'}
        </div>
      `;
    }
  }

  private _escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  private async _copyBookmarkletToClipboard(): Promise<void> {
    if (!this._currentBookmarklet) {
      this._showError('No bookmarklet available to copy');
      return;
    }

    try {
      await navigator.clipboard.writeText(this._currentBookmarklet);
      this._showSuccess('Bookmarklet copied to clipboard!');
      logger.debug('Bookmarklet copied to clipboard');
    } catch (error) {
      logger.error('Failed to copy to clipboard:', error);
      this._showError('Failed to copy to clipboard. Please select and copy manually.');
    }
  }

  private async _testBookmarklet(): Promise<void> {
    if (!this._elements || !this._currentBookmarklet) {
      this._showError('No bookmarklet available to test');
      return;
    }

    try {
      logger.debug('Testing bookmarklet on current page');

      this._elements.testResults.innerHTML = `
        <div class="loading">
          <div class="status-dot"></div>
          Testing bookmarklet...
        </div>
      `;
      this._elements.testResultsSection.style.display = 'block';

      // Execute the bookmarklet core logic for testing
      const testResult = await this._executeBookmarkletTest();

      this._elements.testResults.innerHTML = `
        <div class="success">
          <h4>Test Successful!</h4>
          <p><strong>Title:</strong> ${this._escapeHtml(testResult.title)}</p>
          <p><strong>URL:</strong> ${this._escapeHtml(testResult.url)}</p>
          <p><strong>Content Length:</strong> ${testResult.contentLength} characters</p>
          <p><strong>Word Count:</strong> ${testResult.wordCount} words</p>
          <p><strong>Images Found:</strong> ${testResult.imageCount}</p>
        </div>
      `;

      this._showSuccess('Bookmarklet test completed successfully!');
      logger.debug('Bookmarklet test successful:', testResult);
    } catch (error) {
      logger.error('Bookmarklet test failed:', error);

      this._elements.testResults.innerHTML = `
        <div class="error">
          <h4>Test Failed</h4>
          <p>${error instanceof Error ? error.message : 'Unknown error occurred'}</p>
        </div>
      `;

      this._showError('Bookmarklet test failed. Check configuration and try again.');
    }
  }

  private async _executeBookmarkletTest(): Promise<{
    title: string;
    url: string;
    contentLength: number;
    wordCount: number;
    imageCount: number;
  }> {
    // Use the bookmarklet manager's test functionality
    const testResult = await this._bookmarkletManager.testBookmarklet();

    if (!testResult.success || !testResult.data) {
      throw new Error(testResult.error || 'Test failed');
    }

    return {
      title: testResult.data.pageTitle,
      url: testResult.data.pageUrl,
      contentLength: testResult.data.contentLength,
      wordCount: testResult.data.wordCount,
      imageCount: testResult.data.imageCount,
    };
  }

  private async _regenerateBookmarklet(): Promise<void> {
    if (!this._currentSettings?.enabled) {
      this._showError('Bookmarklet is not enabled');
      return;
    }

    this._showInfo('Regenerating bookmarklet...');
    await this._generateBookmarklet();
    this._showSuccess('Bookmarklet regenerated successfully!');
  }

  private async _saveSettings(): Promise<void> {
    if (!this._currentSettings) {
      this._showError('No settings to save');
      return;
    }

    try {
      logger.debug('Saving bookmarklet settings:', this._currentSettings);

      // Convert to flat settings format
      const settingsUpdate: Partial<ISettings> = {
        'bookmarklet.enabled': this._currentSettings.enabled,
        'bookmarklet.customDomain': this._currentSettings.customDomain || '',
        'bookmarklet.includeImages': this._currentSettings.includeImages,
        'bookmarklet.includeLinks': this._currentSettings.includeLinks,
        'bookmarklet.cleanAds': this._currentSettings.cleanAds,
        'bookmarklet.customSelectors': this._currentSettings.customSelectors,
        'bookmarklet.excludeSelectors': this._currentSettings.excludeSelectors,
        'bookmarklet.autoInstall': this._currentSettings.autoInstall,
        'bookmarklet.version': this._currentSettings.version,
      };

      const success = await this._settingsManager.updateSettings(settingsUpdate);

      if (success) {
        this._showSuccess('Bookmarklet settings saved successfully!');
        logger.info('Bookmarklet settings saved');
      } else {
        this._showError('Failed to save settings. Please check your configuration.');
      }
    } catch (error) {
      logger.error('Failed to save settings:', error);
      this._showError(
        'Failed to save settings: ' + (error instanceof Error ? error.message : 'Unknown error')
      );
    }
  }

  private async _resetSettings(): Promise<void> {
    if (!confirm('Are you sure you want to reset bookmarklet settings to defaults?')) {
      return;
    }

    try {
      logger.debug('Resetting bookmarklet settings to defaults');

      // Reset to default bookmarklet settings
      this._currentSettings = extractBookmarkletSettings({});
      this._updateUI();

      this._showSuccess('Bookmarklet settings reset to defaults. Remember to save your changes.');
      logger.info('Bookmarklet settings reset to defaults');
    } catch (error) {
      logger.error('Failed to reset settings:', error);
      this._showError('Failed to reset settings');
    }
  }

  private async _exportConfiguration(): Promise<void> {
    if (!this._currentSettings) {
      this._showError('No configuration to export');
      return;
    }

    try {
      const result = await this._bookmarkletManager.exportConfiguration();

      if (!result.success) {
        throw new Error(result.error || 'Export failed');
      }

      const blob = new Blob([result.configData || ''], { type: 'application/json' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = `prismweave-bookmarklet-config-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      this._showSuccess('Configuration exported successfully!');
      logger.info('Bookmarklet configuration exported');
    } catch (error) {
      logger.error('Failed to export configuration:', error);
      this._showError('Failed to export configuration');
    }
  }

  private _showMessage(message: string, type: 'success' | 'error' | 'info' | 'warning'): void {
    if (!this._elements) return;

    const messageElement = document.createElement('div');
    messageElement.className = type;
    messageElement.textContent = message;

    this._elements.statusMessages.appendChild(messageElement);

    // Auto-remove after 5 seconds
    setTimeout(() => {
      if (messageElement.parentNode) {
        messageElement.parentNode.removeChild(messageElement);
      }
    }, 5000);
  }

  private _showSuccess(message: string): void {
    this._showMessage(message, 'success');
  }

  private _showError(message: string): void {
    this._showMessage(message, 'error');
  }

  private _showInfo(message: string): void {
    this._showMessage(message, 'info');
  }

  private _showWarning(message: string): void {
    this._showMessage(message, 'warning');
  }

  // Sharing functionality
  private async _exportConfigurationFile(): Promise<void> {
    try {
      logger.info('Exporting bookmarklet configuration to file');
      const result = await this._bookmarkletManager.exportConfiguration();

      if (!result.success || !result.configData) {
        this._showError(result.error || 'Failed to export configuration');
        return;
      }

      // Create and download file
      const blob = new Blob([result.configData], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `prismweave-bookmarklet-config-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      this._showSuccess('Configuration file exported successfully!');
    } catch (error) {
      logger.error('Failed to export configuration file:', error);
      this._showError('Failed to export configuration file');
    }
  }

  private async _importConfigurationFile(event: Event): Promise<void> {
    try {
      const input = event.target as HTMLInputElement;
      const file = input.files?.[0];

      if (!file) {
        return;
      }

      logger.info('Importing bookmarklet configuration from file');

      const text = await file.text();
      const result = await this._bookmarkletManager.importConfiguration(text);

      if (result.success) {
        this._showSuccess('Configuration imported successfully! Reloading settings...');
        // Reload settings and update UI
        await this._loadCurrentSettings();
        this._updateUI();
        await this._loadUsageStatistics();
      } else {
        this._showError(result.error || 'Failed to import configuration');
      }

      // Clear the file input
      input.value = '';
    } catch (error) {
      logger.error('Failed to import configuration file:', error);
      this._showError('Failed to import configuration file');
    }
  }

  private async _generateShareableLink(): Promise<void> {
    try {
      logger.info('Generating shareable bookmarklet link');
      const result = await this._bookmarkletManager.exportConfiguration();

      if (!result.success || !result.configData) {
        this._showError(result.error || 'Failed to generate share link');
        return;
      }

      // Create a base64 encoded URL parameter
      const configString = btoa(result.configData);
      const shareUrl = `${window.location.origin}/bookmarklet.html?config=${encodeURIComponent(configString)}`;

      if (this._elements) {
        this._elements.shareLinkDisplay.value = shareUrl;
        this._elements.shareResults.classList.remove('hidden');
      }

      this._showSuccess('Share link generated successfully!');
    } catch (error) {
      logger.error('Failed to generate share link:', error);
      this._showError('Failed to generate share link');
    }
  }

  private async _copyShareLink(): Promise<void> {
    try {
      if (!this._elements) return;

      const shareLink = this._elements.shareLinkDisplay.value;
      if (!shareLink) {
        this._showWarning('No share link to copy. Generate one first.');
        return;
      }

      await navigator.clipboard.writeText(shareLink);
      this._showSuccess('Share link copied to clipboard!');

      // Temporary visual feedback
      const originalText = this._elements.copyShareLink.textContent;
      this._elements.copyShareLink.textContent = '✅ Copied!';
      setTimeout(() => {
        if (this._elements) {
          this._elements.copyShareLink.textContent = originalText;
        }
      }, 2000);
    } catch (error) {
      logger.error('Failed to copy share link:', error);
      this._showError('Failed to copy share link to clipboard');
    }
  }

  // Statistics functionality
  private async _loadUsageStatistics(): Promise<void> {
    try {
      logger.info('Loading usage statistics');
      const stats = await this._bookmarkletManager.getUsageStats();
      this._updateStatisticsUI(stats);
    } catch (error) {
      logger.error('Failed to load usage statistics:', error);
      this._showError('Failed to load usage statistics');
    }
  }

  private _updateStatisticsUI(
    stats: import('../utils/bookmarklet-manager.js').IBookmarkletUsageStats
  ): void {
    if (!this._elements) return;

    // Update stat cards
    this._elements.totalUses.textContent = stats.totalUses.toString();
    this._elements.successfulCaptures.textContent = stats.successfulCaptures.toString();
    this._elements.failedCaptures.textContent = stats.failedCaptures.toString();
    this._elements.averageContentLength.textContent =
      stats.averageContentLength > 0 ? `${Math.round(stats.averageContentLength / 1000)}K` : '-';

    // Update top domains
    const domainsContainer = this._elements.topDomains;
    domainsContainer.innerHTML = '';

    if (stats.mostCapturedDomains.length === 0) {
      domainsContainer.innerHTML = '<div class="loading">No usage data available yet.</div>';
    } else {
      stats.mostCapturedDomains.forEach(domain => {
        const domainItem = document.createElement('div');
        domainItem.className = 'domain-item';
        domainItem.innerHTML = `
          <span class="domain-name">${domain.domain}</span>
          <span class="domain-count">${domain.count}</span>
        `;
        domainsContainer.appendChild(domainItem);
      });
    }
  }

  private async _refreshUsageStatistics(): Promise<void> {
    try {
      logger.info('Refreshing usage statistics');

      // Show loading state
      if (this._elements) {
        this._elements.topDomains.innerHTML = '<div class="loading">Refreshing statistics...</div>';
      }

      await this._loadUsageStatistics();
      this._showSuccess('Statistics refreshed successfully!');
    } catch (error) {
      logger.error('Failed to refresh statistics:', error);
      this._showError('Failed to refresh statistics');
    }
  }

  private async _clearUsageStatistics(): Promise<void> {
    try {
      // Confirm with user first
      const confirmed = confirm(
        'Are you sure you want to clear all usage statistics? This action cannot be undone.'
      );

      if (!confirmed) {
        return;
      }

      logger.info('Clearing usage statistics');

      // Clear statistics from storage (implementation would go here)
      // For now, just reset the UI to empty state
      const emptyStats = {
        totalUses: 0,
        successfulCaptures: 0,
        failedCaptures: 0,
        averageContentLength: 0,
        mostCapturedDomains: [],
      };

      this._updateStatisticsUI(emptyStats);
      this._showSuccess('Usage statistics cleared successfully!');
    } catch (error) {
      logger.error('Failed to clear statistics:', error);
      this._showError('Failed to clear statistics');
    }
  }

  private async _exportUsageStatistics(): Promise<void> {
    try {
      logger.info('Exporting usage statistics');
      const stats = await this._bookmarkletManager.getUsageStats();

      // Create CSV data
      const csvData = [
        'Metric,Value',
        `Total Uses,${stats.totalUses}`,
        `Successful Captures,${stats.successfulCaptures}`,
        `Failed Captures,${stats.failedCaptures}`,
        `Average Content Length,${stats.averageContentLength}`,
        '',
        'Domain,Capture Count',
        ...stats.mostCapturedDomains.map(d => `${d.domain},${d.count}`),
      ].join('\n');

      // Create and download file
      const blob = new Blob([csvData], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `prismweave-bookmarklet-stats-${new Date().toISOString().split('T')[0]}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      this._showSuccess('Statistics exported successfully!');
    } catch (error) {
      logger.error('Failed to export statistics:', error);
      this._showError('Failed to export statistics');
    }
  }

  // Storage Validation Methods
  private async _validateBookmarkletStorage(): Promise<void> {
    if (!this._elements) return;

    try {
      logger.info('Starting bookmarklet storage validation');

      this._elements.validationResults.innerHTML = `
        <div class="loading">
          <div class="status-dot"></div>
          Validating storage system...
        </div>
      `;

      const validationResults = await BookmarkletStorageValidator.validateStorageSystem();

      // Display results
      let resultHtml = '<div class="validation-results">';

      if (validationResults.isValid) {
        resultHtml += '<div class="success"><h4>✅ Storage Validation Passed</h4></div>';
      } else {
        resultHtml += '<div class="error"><h4>❌ Storage Validation Failed</h4></div>';
      }

      // Add summary
      resultHtml += `
        <div class="test-summary">
          <p><strong>Tests:</strong> ${validationResults.summary.passed}/${validationResults.summary.totalTests} passed</p>
        </div>
      `;

      // Add detailed results
      validationResults.tests.forEach((test: any) => {
        const statusClass = test.success ? 'success' : 'error';
        const statusIcon = test.success ? '✅' : '❌';

        resultHtml += `
          <div class="${statusClass} test-result">
            <p><strong>${statusIcon} ${test.testName}</strong></p>
            <p>Duration: ${test.duration}ms</p>
            ${test.error ? `<p class="error">Error: ${test.error}</p>` : ''}
            ${test.result ? `<pre><code>${JSON.stringify(test.result, null, 2)}</code></pre>` : ''}
          </div>
        `;
      });

      // Add recommendations if any
      if (validationResults.recommendations.length > 0) {
        resultHtml += '<div class="recommendations"><h5>Recommendations:</h5><ul>';
        validationResults.recommendations.forEach(rec => {
          resultHtml += `<li>${rec}</li>`;
        });
        resultHtml += '</ul></div>';
      }

      resultHtml += '</div>';

      this._elements.validationResults.innerHTML = resultHtml;

      if (validationResults.isValid) {
        this._showSuccess('Storage validation completed successfully!');
      } else {
        this._showError('Storage validation found issues. Check results above.');
      }

      logger.info('Storage validation completed:', validationResults);
    } catch (error) {
      logger.error('Storage validation failed:', error);

      this._elements.validationResults.innerHTML = `
        <div class="error">
          <h4>Validation Failed</h4>
          <p>${error instanceof Error ? error.message : 'Unknown error occurred'}</p>
        </div>
      `;

      this._showError('Storage validation failed');
    }
  }

  private async _runStorageTests(): Promise<void> {
    if (!this._elements) return;

    try {
      logger.info('Running comprehensive storage tests');

      this._elements.validationResults.innerHTML = `
        <div class="loading">
          <div class="status-dot"></div>
          Running comprehensive storage tests...
        </div>
      `;

      // Use the comprehensive validation which runs all tests
      const validationResults = await BookmarkletStorageValidator.validateStorageSystem();

      let resultHtml = '<div class="comprehensive-test-results">';
      resultHtml += '<h4>🧪 Comprehensive Storage Tests</h4>';

      // Display each test result
      validationResults.tests.forEach(test => {
        const statusClass = test.success ? 'success' : 'error';
        const statusIcon = test.success ? '✅' : '❌';

        resultHtml += `
          <div class="${statusClass} test-result">
            <p><strong>${statusIcon} ${test.testName}</strong></p>
            <p>Duration: ${test.duration}ms</p>
            ${test.error ? `<p class="error">Error: ${test.error}</p>` : ''}
            ${test.result ? `<p class="result">${test.result}</p>` : ''}
          </div>
        `;
      });

      // Add summary
      const { summary } = validationResults;
      resultHtml += `
        <div class="test-summary ${summary.passed === summary.totalTests ? 'success' : 'warning'}">
          <h5>Test Summary: ${summary.passed}/${summary.totalTests} tests passed</h5>
        </div>
      `;

      // Add recommendations
      if (validationResults.recommendations.length > 0) {
        resultHtml += '<div class="recommendations"><h5>Recommendations:</h5><ul>';
        validationResults.recommendations.forEach(rec => {
          resultHtml += `<li>${rec}</li>`;
        });
        resultHtml += '</ul></div>';
      }

      resultHtml += '</div>';

      this._elements.validationResults.innerHTML = resultHtml;

      if (summary.passed === summary.totalTests) {
        this._showSuccess(`All ${summary.totalTests} storage tests passed!`);
      } else {
        this._showWarning(
          `${summary.passed}/${summary.totalTests} storage tests passed. Check failed tests above.`
        );
      }

      logger.info('Comprehensive storage tests completed:', validationResults);
    } catch (error) {
      logger.error('Comprehensive storage tests failed:', error);

      this._elements.validationResults.innerHTML = `
        <div class="error">
          <h4>Tests Failed</h4>
          <p>${error instanceof Error ? error.message : 'Unknown error occurred'}</p>
        </div>
      `;

      this._showError('Comprehensive storage tests failed');
    }
  }

  private async _testBookmarkletStorageIntegration(): Promise<void> {
    if (!this._elements || !this._currentSettings) return;

    try {
      logger.info('Testing bookmarklet storage integration');

      this._elements.validationResults.innerHTML = `
        <div class="loading">
          <div class="status-dot"></div>
          Testing bookmarklet storage integration...
        </div>
      `;

      // Generate test bookmarklet
      const testBookmarklet = BookmarkletStorageValidator.generateTestBookmarklet();

      // Run validation to test storage functionality
      const validationResults = await BookmarkletStorageValidator.validateStorageSystem();
      const storageTests = validationResults.tests.filter(
        t => t.testName.includes('Storage') || t.testName.includes('storage')
      );

      let resultHtml = '<div class="integration-test-results">';
      resultHtml += '<h4>🔗 Bookmarklet Storage Integration Test</h4>';

      // Display test bookmarklet
      resultHtml += `
        <div class="info test-result">
          <p><strong>📋 Generated Test Bookmarklet</strong></p>
          <p>Bookmarklet generated successfully (${testBookmarklet.length} characters)</p>
          <pre><code>${this._escapeHtml(testBookmarklet.substring(0, 200))}...</code></pre>
        </div>
      `;

      // Display storage-related test results
      storageTests.forEach(test => {
        const statusClass = test.success ? 'success' : 'error';
        const statusIcon = test.success ? '✅' : '❌';

        resultHtml += `
          <div class="${statusClass} test-result">
            <p><strong>${statusIcon} ${test.testName}</strong></p>
            <p>Duration: ${test.duration}ms</p>
            ${test.error ? `<p class="error">Error: ${test.error}</p>` : ''}
            ${test.result ? `<p class="result">${test.result}</p>` : ''}
          </div>
        `;
      });

      // Show current stored config
      const storedConfig = BookmarkletStorageValidator.getCurrentStoredConfig();
      resultHtml += `
        <div class="info test-result">
          <p><strong>💾 Current Stored Configuration</strong></p>
          <pre><code>${JSON.stringify(storedConfig, null, 2)}</code></pre>
        </div>
      `;

      resultHtml += '</div>';

      this._elements.validationResults.innerHTML = resultHtml;

      const allStorageTestsPassed = storageTests.every(t => t.success);
      if (allStorageTestsPassed) {
        this._showSuccess('Bookmarklet storage integration tests passed!');
      } else {
        this._showError('Some integration tests failed. Check results above.');
      }

      logger.info('Bookmarklet storage integration tests completed:', {
        allStorageTestsPassed,
        storedConfig,
      });
    } catch (error) {
      logger.error('Bookmarklet storage integration test failed:', error);

      this._elements.validationResults.innerHTML = `
        <div class="error">
          <h4>Integration Test Failed</h4>
          <p>${error instanceof Error ? error.message : 'Unknown error occurred'}</p>
        </div>
      `;

      this._showError('Bookmarklet storage integration test failed');
    }
  }
}

// Initialize the bookmarklet options page when DOM is ready
document.addEventListener('DOMContentLoaded', async () => {
  try {
    const bookmarkletOptions = new BookmarkletOptionsPage();
    await bookmarkletOptions.initialize();
  } catch (error) {
    console.error('Failed to initialize bookmarklet options:', error);
  }
});
