// Generated by Copilot
// Bookmarklet options page functionality for PrismWeave Browser Extension

import { extractBookmarkletSettings, IBookmarkletSettings, ISettings } from '../types/index.js';
import { BookmarkletGenerator } from '../utils/bookmarklet-generator.js';
import { createLogger } from '../utils/logger.js';
import { SettingsManager } from '../utils/settings-manager.js';

const logger = createLogger('BookmarkletOptions');

interface IBookmarkletElements {
  // Status elements
  statusIndicator: HTMLElement;
  enableBookmarklet: HTMLInputElement;

  // Configuration elements
  configSection: HTMLElement;
  customDomain: HTMLInputElement;
  bookmarkletVersion: HTMLInputElement;
  includeImages: HTMLInputElement;
  includeLinks: HTMLInputElement;
  cleanAds: HTMLInputElement;
  autoInstall: HTMLInputElement;
  customIncludeSelectors: HTMLTextAreaElement;
  customExcludeSelectors: HTMLTextAreaElement;

  // Bookmarklet elements
  bookmarkletSection: HTMLElement;
  bookmarkletPreview: HTMLElement;
  copyBookmarklet: HTMLButtonElement;
  testBookmarklet: HTMLButtonElement;
  regenerateBookmarklet: HTMLButtonElement;

  // Test results
  testResultsSection: HTMLElement;
  testResults: HTMLElement;

  // Action buttons
  saveSettings: HTMLButtonElement;
  resetSettings: HTMLButtonElement;
  exportBookmarklet: HTMLButtonElement;

  // Status messages
  statusMessages: HTMLElement;
}

export class BookmarkletOptionsPage {
  private _settingsManager: SettingsManager;
  private _elements: IBookmarkletElements | null = null;
  private _currentBookmarklet: string = '';
  private _currentSettings: IBookmarkletSettings | null = null;

  constructor() {
    this._settingsManager = new SettingsManager();
  }

  async initialize(): Promise<void> {
    try {
      logger.info('Initializing bookmarklet options page');

      await this._collectElements();
      await this._loadCurrentSettings();
      this._bindEventListeners();
      this._updateUI();

      logger.info('Bookmarklet options page initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize bookmarklet options page:', error);
      this._showError('Failed to initialize page. Please refresh and try again.');
    }
  }

  private async _collectElements(): Promise<void> {
    const getElementById = <T extends HTMLElement>(id: string): T => {
      const element = document.getElementById(id) as T;
      if (!element) {
        throw new Error(`Required element not found: ${id}`);
      }
      return element;
    };

    this._elements = {
      // Status elements
      statusIndicator: getElementById('bookmarklet-status'),
      enableBookmarklet: getElementById('enable-bookmarklet'),

      // Configuration elements
      configSection: getElementById('config-section'),
      customDomain: getElementById('custom-domain'),
      bookmarkletVersion: getElementById('bookmarklet-version'),
      includeImages: getElementById('include-images'),
      includeLinks: getElementById('include-links'),
      cleanAds: getElementById('clean-ads'),
      autoInstall: getElementById('auto-install'),
      customIncludeSelectors: getElementById('custom-include-selectors'),
      customExcludeSelectors: getElementById('custom-exclude-selectors'),

      // Bookmarklet elements
      bookmarkletSection: getElementById('bookmarklet-section'),
      bookmarkletPreview: getElementById('bookmarklet-preview'),
      copyBookmarklet: getElementById('copy-bookmarklet'),
      testBookmarklet: getElementById('test-bookmarklet'),
      regenerateBookmarklet: getElementById('regenerate-bookmarklet'),

      // Test results
      testResultsSection: getElementById('test-results-section'),
      testResults: getElementById('test-results'),

      // Action buttons
      saveSettings: getElementById('save-bookmarklet-settings'),
      resetSettings: getElementById('reset-bookmarklet-settings'),
      exportBookmarklet: getElementById('export-bookmarklet'),

      // Status messages
      statusMessages: getElementById('status-messages'),
    };
  }

  private async _loadCurrentSettings(): Promise<void> {
    try {
      const settings = await this._settingsManager.getSettingsWithDefaults();
      this._currentSettings = extractBookmarkletSettings(settings);
      logger.debug('Loaded bookmarklet settings:', this._currentSettings);
    } catch (error) {
      logger.error('Failed to load settings:', error);
      this._showError('Failed to load settings');

      // Use defaults if loading fails
      this._currentSettings = extractBookmarkletSettings({});
    }
  }

  private _bindEventListeners(): void {
    if (!this._elements) return;

    // Enable/disable bookmarklet
    this._elements.enableBookmarklet.addEventListener('change', () => {
      this._handleBookmarkletToggle();
    });

    // Configuration changes
    const configInputs = [
      this._elements.customDomain,
      this._elements.includeImages,
      this._elements.includeLinks,
      this._elements.cleanAds,
      this._elements.autoInstall,
      this._elements.customIncludeSelectors,
      this._elements.customExcludeSelectors,
    ];

    configInputs.forEach(input => {
      input.addEventListener('change', () => {
        this._handleConfigurationChange();
      });
    });

    // Bookmarklet actions
    this._elements.copyBookmarklet.addEventListener('click', () => {
      this._copyBookmarkletToClipboard();
    });

    this._elements.testBookmarklet.addEventListener('click', () => {
      this._testBookmarklet();
    });

    this._elements.regenerateBookmarklet.addEventListener('click', () => {
      this._regenerateBookmarklet();
    });

    // Main actions
    this._elements.saveSettings.addEventListener('click', () => {
      this._saveSettings();
    });

    this._elements.resetSettings.addEventListener('click', () => {
      this._resetSettings();
    });

    this._elements.exportBookmarklet.addEventListener('click', () => {
      this._exportConfiguration();
    });
  }

  private _updateUI(): void {
    if (!this._elements || !this._currentSettings) return;

    // Update status indicator
    const isEnabled = this._currentSettings.enabled;
    this._elements.statusIndicator.className = `status-indicator ${isEnabled ? 'enabled' : 'disabled'}`;
    this._elements.statusIndicator.querySelector('span')!.textContent = isEnabled
      ? 'Enabled'
      : 'Disabled';

    // Update form values
    this._elements.enableBookmarklet.checked = isEnabled;
    this._elements.customDomain.value = this._currentSettings.customDomain || '';
    this._elements.bookmarkletVersion.value = this._currentSettings.version;
    this._elements.includeImages.checked = this._currentSettings.includeImages;
    this._elements.includeLinks.checked = this._currentSettings.includeLinks;
    this._elements.cleanAds.checked = this._currentSettings.cleanAds;
    this._elements.autoInstall.checked = this._currentSettings.autoInstall;
    this._elements.customIncludeSelectors.value = this._currentSettings.customSelectors.join(', ');
    this._elements.customExcludeSelectors.value = this._currentSettings.excludeSelectors.join(', ');

    // Show/hide sections based on enabled state
    this._elements.configSection.style.display = isEnabled ? 'block' : 'none';
    this._elements.bookmarkletSection.style.display = isEnabled ? 'block' : 'none';

    // Generate bookmarklet if enabled
    if (isEnabled) {
      this._generateBookmarklet();
    }
  }

  private _handleBookmarkletToggle(): void {
    if (!this._elements || !this._currentSettings) return;

    const isEnabled = this._elements.enableBookmarklet.checked;
    this._currentSettings.enabled = isEnabled;

    this._updateUI();

    if (isEnabled) {
      this._showSuccess('Bookmarklet enabled. Configure settings below and save.');
    } else {
      this._showInfo('Bookmarklet disabled.');
    }
  }

  private _handleConfigurationChange(): void {
    if (!this._elements || !this._currentSettings) return;

    // Update current settings from form
    this._currentSettings.customDomain = this._elements.customDomain.value.trim();
    this._currentSettings.includeImages = this._elements.includeImages.checked;
    this._currentSettings.includeLinks = this._elements.includeLinks.checked;
    this._currentSettings.cleanAds = this._elements.cleanAds.checked;
    this._currentSettings.autoInstall = this._elements.autoInstall.checked;

    // Parse selectors
    this._currentSettings.customSelectors = this._parseSelectors(
      this._elements.customIncludeSelectors.value
    );
    this._currentSettings.excludeSelectors = this._parseSelectors(
      this._elements.customExcludeSelectors.value
    );

    // Regenerate bookmarklet with new settings
    if (this._currentSettings.enabled) {
      this._generateBookmarklet();
    }
  }

  private _parseSelectors(value: string): string[] {
    return value
      .split(',')
      .map(s => s.trim())
      .filter(s => s.length > 0);
  }

  private async _generateBookmarklet(): Promise<void> {
    if (!this._elements || !this._currentSettings) return;

    try {
      logger.debug('Generating bookmarklet with settings:', this._currentSettings);

      this._elements.bookmarkletPreview.innerHTML = `
        <div class="loading">
          <div class="status-dot"></div>
          Generating bookmarklet...
        </div>
      `;

      // Get GitHub settings for the bookmarklet
      const allSettings = await this._settingsManager.getSettingsWithDefaults();

      const config = {
        githubToken: allSettings.githubToken || '',
        githubRepo: allSettings.githubRepo || '',
        defaultFolder: allSettings.defaultFolder || 'unsorted',
        extractionOptions: {
          includeImages: this._currentSettings.includeImages,
          includeLinks: this._currentSettings.includeLinks,
          cleanAds: this._currentSettings.cleanAds,
          customSelectors: this._currentSettings.customSelectors,
          excludeSelectors: this._currentSettings.excludeSelectors,
        },
        customEndpoint: this._currentSettings.customDomain || undefined,
      };

      this._currentBookmarklet = await BookmarkletGenerator.generateBookmarklet(config);

      // Display the bookmarklet
      this._elements.bookmarkletPreview.innerHTML = `<code>${this._escapeHtml(this._currentBookmarklet)}</code>`;

      logger.debug('Bookmarklet generated successfully');
    } catch (error) {
      logger.error('Failed to generate bookmarklet:', error);
      this._elements.bookmarkletPreview.innerHTML = `
        <div class="error">
          Failed to generate bookmarklet: ${error instanceof Error ? error.message : 'Unknown error'}
        </div>
      `;
    }
  }

  private _escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  private async _copyBookmarkletToClipboard(): Promise<void> {
    if (!this._currentBookmarklet) {
      this._showError('No bookmarklet available to copy');
      return;
    }

    try {
      await navigator.clipboard.writeText(this._currentBookmarklet);
      this._showSuccess('Bookmarklet copied to clipboard!');
      logger.debug('Bookmarklet copied to clipboard');
    } catch (error) {
      logger.error('Failed to copy to clipboard:', error);
      this._showError('Failed to copy to clipboard. Please select and copy manually.');
    }
  }

  private async _testBookmarklet(): Promise<void> {
    if (!this._elements || !this._currentBookmarklet) {
      this._showError('No bookmarklet available to test');
      return;
    }

    try {
      logger.debug('Testing bookmarklet on current page');

      this._elements.testResults.innerHTML = `
        <div class="loading">
          <div class="status-dot"></div>
          Testing bookmarklet...
        </div>
      `;
      this._elements.testResultsSection.style.display = 'block';

      // Execute the bookmarklet core logic for testing
      const testResult = await this._executeBookmarkletTest();

      this._elements.testResults.innerHTML = `
        <div class="success">
          <h4>Test Successful!</h4>
          <p><strong>Title:</strong> ${this._escapeHtml(testResult.title)}</p>
          <p><strong>URL:</strong> ${this._escapeHtml(testResult.url)}</p>
          <p><strong>Content Length:</strong> ${testResult.contentLength} characters</p>
          <p><strong>Word Count:</strong> ${testResult.wordCount} words</p>
          <p><strong>Images Found:</strong> ${testResult.imageCount}</p>
        </div>
      `;

      this._showSuccess('Bookmarklet test completed successfully!');
      logger.debug('Bookmarklet test successful:', testResult);
    } catch (error) {
      logger.error('Bookmarklet test failed:', error);

      this._elements.testResults.innerHTML = `
        <div class="error">
          <h4>Test Failed</h4>
          <p>${error instanceof Error ? error.message : 'Unknown error occurred'}</p>
        </div>
      `;

      this._showError('Bookmarklet test failed. Check configuration and try again.');
    }
  }

  private async _executeBookmarkletTest(): Promise<{
    title: string;
    url: string;
    contentLength: number;
    wordCount: number;
    imageCount: number;
  }> {
    // Simulate bookmarklet execution for testing
    const title = document.title || 'Untitled';
    const url = window.location.href;

    // Find main content
    const contentSelectors = ['article', 'main', '.content', '#content', 'body'];
    let mainContent = '';

    for (const selector of contentSelectors) {
      const element = document.querySelector(selector);
      if (element && element.textContent && element.textContent.length > 100) {
        mainContent = element.textContent;
        break;
      }
    }

    if (!mainContent) {
      mainContent = document.body.textContent || '';
    }

    const wordCount = mainContent.trim().split(/\s+/).length;
    const imageCount = document.querySelectorAll('img').length;

    return {
      title,
      url,
      contentLength: mainContent.length,
      wordCount,
      imageCount,
    };
  }

  private async _regenerateBookmarklet(): Promise<void> {
    if (!this._currentSettings?.enabled) {
      this._showError('Bookmarklet is not enabled');
      return;
    }

    this._showInfo('Regenerating bookmarklet...');
    await this._generateBookmarklet();
    this._showSuccess('Bookmarklet regenerated successfully!');
  }

  private async _saveSettings(): Promise<void> {
    if (!this._currentSettings) {
      this._showError('No settings to save');
      return;
    }

    try {
      logger.debug('Saving bookmarklet settings:', this._currentSettings);

      // Convert to flat settings format
      const settingsUpdate: Partial<ISettings> = {
        'bookmarklet.enabled': this._currentSettings.enabled,
        'bookmarklet.customDomain': this._currentSettings.customDomain || '',
        'bookmarklet.includeImages': this._currentSettings.includeImages,
        'bookmarklet.includeLinks': this._currentSettings.includeLinks,
        'bookmarklet.cleanAds': this._currentSettings.cleanAds,
        'bookmarklet.customSelectors': this._currentSettings.customSelectors,
        'bookmarklet.excludeSelectors': this._currentSettings.excludeSelectors,
        'bookmarklet.autoInstall': this._currentSettings.autoInstall,
        'bookmarklet.version': this._currentSettings.version,
      };

      const success = await this._settingsManager.updateSettings(settingsUpdate);

      if (success) {
        this._showSuccess('Bookmarklet settings saved successfully!');
        logger.info('Bookmarklet settings saved');
      } else {
        this._showError('Failed to save settings. Please check your configuration.');
      }
    } catch (error) {
      logger.error('Failed to save settings:', error);
      this._showError(
        'Failed to save settings: ' + (error instanceof Error ? error.message : 'Unknown error')
      );
    }
  }

  private async _resetSettings(): Promise<void> {
    if (!confirm('Are you sure you want to reset bookmarklet settings to defaults?')) {
      return;
    }

    try {
      logger.debug('Resetting bookmarklet settings to defaults');

      // Reset to default bookmarklet settings
      this._currentSettings = extractBookmarkletSettings({});
      this._updateUI();

      this._showSuccess('Bookmarklet settings reset to defaults. Remember to save your changes.');
      logger.info('Bookmarklet settings reset to defaults');
    } catch (error) {
      logger.error('Failed to reset settings:', error);
      this._showError('Failed to reset settings');
    }
  }

  private async _exportConfiguration(): Promise<void> {
    if (!this._currentSettings) {
      this._showError('No configuration to export');
      return;
    }

    try {
      const exportData = {
        bookmarklet: this._currentSettings,
        exported: new Date().toISOString(),
        version: '1.0.0',
      };

      const dataStr = JSON.stringify(exportData, null, 2);
      const blob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = `prismweave-bookmarklet-config-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      this._showSuccess('Configuration exported successfully!');
      logger.info('Bookmarklet configuration exported');
    } catch (error) {
      logger.error('Failed to export configuration:', error);
      this._showError('Failed to export configuration');
    }
  }

  private _showMessage(message: string, type: 'success' | 'error' | 'info' | 'warning'): void {
    if (!this._elements) return;

    const messageElement = document.createElement('div');
    messageElement.className = type;
    messageElement.textContent = message;

    this._elements.statusMessages.appendChild(messageElement);

    // Auto-remove after 5 seconds
    setTimeout(() => {
      if (messageElement.parentNode) {
        messageElement.parentNode.removeChild(messageElement);
      }
    }, 5000);
  }

  private _showSuccess(message: string): void {
    this._showMessage(message, 'success');
  }

  private _showError(message: string): void {
    this._showMessage(message, 'error');
  }

  private _showInfo(message: string): void {
    this._showMessage(message, 'info');
  }

  private _showWarning(message: string): void {
    this._showMessage(message, 'warning');
  }
}

// Initialize the bookmarklet options page when DOM is ready
document.addEventListener('DOMContentLoaded', async () => {
  try {
    const bookmarkletOptions = new BookmarkletOptionsPage();
    await bookmarkletOptions.initialize();
  } catch (error) {
    console.error('Failed to initialize bookmarklet options:', error);
  }
});
