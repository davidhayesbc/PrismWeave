// Generated by Copilot
// Settings Manager Extended Tests - Improve from 67% to 90% coverage
// Tests H.1.1 - H.3.3 for comprehensive settings management functionality

import { SettingsManager } from '../../utils/settings-manager';
import { cleanupTest, mockChromeAPIs } from '../test-helpers';

describe('SettingsManager - Extended Functionality', () => {
  let manager: SettingsManager;
  let mockChrome: any;

  beforeEach(() => {
    mockChrome = mockChromeAPIs();
    (global as any).chrome = mockChrome;
    manager = new SettingsManager();
  });

  afterEach(() => {
    cleanupTest();
  });

  describe('Schema Operations', () => {
    test('H.1.1 - Get setting definition by key', () => {
      const githubTokenDef = manager.getSettingDefinition('githubToken');
      expect(githubTokenDef).toBeDefined();
      expect(githubTokenDef?.type).toBe('string');
      expect(githubTokenDef?.sensitive).toBe(true);
      expect(githubTokenDef?.description).toContain('GitHub');
      expect(githubTokenDef?.default).toBe('');

      const repoDef = manager.getSettingDefinition('githubRepo');
      expect(repoDef).toBeDefined();
      expect(repoDef?.type).toBe('string');
      expect(repoDef?.pattern).toBeDefined();
      expect(repoDef?.description).toContain('repository');

      // Test non-existent setting
      const nonExistent = manager.getSettingDefinition('nonExistentSetting');
      expect(nonExistent).toBeNull();
    });

    test('H.1.2 - Get all setting definitions', () => {
      const allDefinitions = manager.getAllSettingDefinitions();

      // Verify structure
      expect(typeof allDefinitions).toBe('object');
      expect(allDefinitions).not.toBeNull();

      // Check for expected keys
      const expectedKeys = [
        'githubToken',
        'githubRepo',
        'defaultFolder',
        'customFolder',
        'fileNamingPattern',
        'autoCommit',
        'captureImages',
        'removeAds',
        'removeNavigation',
        'customSelectors',
        'commitMessageTemplate',
        'debugMode',
        'showNotifications',
        'enableKeyboardShortcuts',
      ];

      expectedKeys.forEach(key => {
        expect(allDefinitions).toHaveProperty(key);
        expect(allDefinitions[key]).toHaveProperty('type');
        expect(allDefinitions[key]).toHaveProperty('default');
        expect(allDefinitions[key]).toHaveProperty('description');
      });

      // Verify schema is a copy (not reference to internal schema)
      const originalCount = Object.keys(allDefinitions).length;
      delete allDefinitions.githubToken;
      const newDefinitions = manager.getAllSettingDefinitions();
      expect(Object.keys(newDefinitions).length).toBe(originalCount);
    });

    test('H.1.3 - Validate setting dependencies', async () => {
      // Test settings without dependencies
      const simpleSettings = {
        githubToken: 'test-token',
        autoCommit: true,
      };

      const noDependencies = await manager.checkRequiredDependencies(simpleSettings);
      expect(noDependencies).toEqual([]);

      // Test custom folder requiring defaultFolder to be 'custom'
      const customFolderWithoutDefault = {
        customFolder: 'my-custom-folder',
      };

      const customDependencies = await manager.checkRequiredDependencies(
        customFolderWithoutDefault
      );
      expect(customDependencies).toEqual([]); // customFolder doesn't have explicit dependencies in current schema

      // Test empty settings
      const emptyDependencies = await manager.checkRequiredDependencies({});
      expect(emptyDependencies).toEqual([]);
    });

    test('H.1.4 - Check required dependencies', async () => {
      // Create a settings object with dependency scenarios
      const settingsWithDefaults = {
        defaultFolder: 'custom',
        customFolder: 'my-folder',
        githubToken: 'token123',
      };

      const dependencies = await manager.checkRequiredDependencies(settingsWithDefaults);
      expect(Array.isArray(dependencies)).toBe(true);

      // Test with null/undefined values
      const settingsWithNulls: any = {
        defaultFolder: null,
        customFolder: '',
        githubToken: undefined,
      };

      const nullDependencies = await manager.checkRequiredDependencies(settingsWithNulls);
      expect(Array.isArray(nullDependencies)).toBe(true);
    });
  });

  describe('Advanced Validation', () => {
    test('H.2.1 - Validate number ranges (min/max)', () => {
      // Note: Current schema doesn't have number fields with min/max
      // Testing the validation logic with hypothetical number settings
      const settingsWithNumbers = {};

      const validationResult = manager.validateSettings(settingsWithNumbers);
      expect(validationResult.isValid).toBe(true);
      expect(validationResult.errors).toEqual([]);

      // Test with invalid types that would fail range validation
      const invalidTypeSettings: any = {
        githubToken: 123, // Should be string, not number
      };

      const invalidResult = manager.validateSettings(invalidTypeSettings);
      expect(invalidResult.isValid).toBe(false);
      expect(invalidResult.errors.length).toBeGreaterThan(0);
      expect(invalidResult.errors[0]).toContain('Invalid type');
    });

    test('H.2.2 - Validate pattern matching', () => {
      // Test GitHub repository pattern validation
      const validRepoSettings = {
        githubRepo: 'user/repository-name',
      };
      const validResult = manager.validateSettings(validRepoSettings);
      expect(validResult.isValid).toBe(true);
      expect(validResult.errors).toEqual([]);

      // Test invalid repository patterns
      const invalidRepoFormats = [
        { githubRepo: 'invalid-format' },
        { githubRepo: 'user/' },
        { githubRepo: '/repository' },
        { githubRepo: 'user space/repo' },
        { githubRepo: 'user/repo/extra' },
      ];

      invalidRepoFormats.forEach(settings => {
        const result = manager.validateSettings(settings);
        expect(result.isValid).toBe(false);
        expect(result.errors.some(error => error.includes('pattern'))).toBe(true);
      });

      // Test empty string (should be valid for optional fields)
      const emptyRepoSettings = { githubRepo: '' };
      const emptyResult = manager.validateSettings(emptyRepoSettings);
      expect(emptyResult.isValid).toBe(true);
    });

    test('H.2.3 - Validate enum options', () => {
      // Test valid defaultFolder options
      const validFolderOptions = [
        'tech',
        'business',
        'research',
        'news',
        'tutorial',
        'reference',
        'blog',
        'social',
        'unsorted',
        'custom',
      ];

      validFolderOptions.forEach(folder => {
        const settings = { defaultFolder: folder };
        const result = manager.validateSettings(settings);
        expect(result.isValid).toBe(true);
      });

      // Test invalid defaultFolder options
      const invalidFolderOptions = ['invalid-folder', 'random', 'documents', 'downloads'];

      invalidFolderOptions.forEach(folder => {
        const settings = { defaultFolder: folder };
        const result = manager.validateSettings(settings);
        expect(result.isValid).toBe(false);
        expect(result.errors.some(error => error.includes('must be one of'))).toBe(true);
      });

      // Test valid fileNamingPattern options
      const validNamingPatterns = [
        'YYYY-MM-DD-domain-title',
        'YYYY-MM-DD-title',
        'domain-YYYY-MM-DD-title',
        'title-YYYY-MM-DD',
      ];

      validNamingPatterns.forEach(pattern => {
        const settings = { fileNamingPattern: pattern };
        const result = manager.validateSettings(settings);
        expect(result.isValid).toBe(true);
      });
    });

    test('H.2.4 - Cross-field validation', () => {
      // Test multiple field validation simultaneously
      const multiFieldSettings = {
        githubToken: 'valid-token',
        githubRepo: 'user/repo',
        defaultFolder: 'tech',
        autoCommit: true,
        captureImages: false,
      };

      const validResult = manager.validateSettings(multiFieldSettings);
      expect(validResult.isValid).toBe(true);
      expect(validResult.errors).toEqual([]);

      // Test multiple validation failures
      const multipleErrorSettings: any = {
        githubToken: 123, // Wrong type
        githubRepo: 'invalid format', // Wrong pattern
        defaultFolder: 'invalid-folder', // Wrong enum
        autoCommit: 'yes', // Wrong type
        captureImages: 'true', // Wrong type
      };

      const invalidResult = manager.validateSettings(multipleErrorSettings);
      expect(invalidResult.isValid).toBe(false);
      expect(invalidResult.errors.length).toBeGreaterThan(4); // Should have multiple errors

      // Check that each type of error is present
      const errorString = invalidResult.errors.join(' ');
      expect(errorString).toContain('Invalid type');
      expect(errorString).toContain('pattern');
      expect(errorString).toContain('must be one of');
    });
  });

  describe('Storage Edge Cases', () => {
    test('H.3.1 - Handle Chrome storage unavailable', async () => {
      // Simulate Chrome storage API not available
      (global as any).chrome = undefined;

      // SettingsManager handles Chrome API unavailability gracefully
      // by returning empty objects/false instead of throwing errors
      const settings = await manager.getSettings();
      expect(settings).toEqual({});

      const updateResult = await manager.updateSettings({ autoCommit: true });
      expect(updateResult).toBe(false);

      const resetResult = await manager.resetSettings();
      expect(resetResult).toBe(false);

      // Test partial Chrome API availability
      (global as any).chrome = { runtime: {} }; // Missing storage
      const partialSettings = await manager.getSettings();
      expect(partialSettings).toEqual({});

      // Test with empty Chrome object
      (global as any).chrome = {};
      const emptySettings = await manager.getSettings();
      expect(emptySettings).toEqual({});
    });

    test('H.3.2 - Handle storage corruption', async () => {
      // Test case 1: Invalid JSON structure in storage
      mockChrome.storage.sync.get.mockImplementation((keys: any, callback: any) => {
        // Simulate corrupted data that's not a valid settings object
        callback({
          prismWeaveSettings: 'invalid-json-string-that-parsed-somehow',
        });
      });

      const corruptedSettings = await manager.getSettings();
      expect(corruptedSettings).toEqual('invalid-json-string-that-parsed-somehow');

      // Test case 2: Storage returns null/undefined
      mockChrome.storage.sync.get.mockImplementation((keys: any, callback: any) => {
        callback(null);
      });

      const nullSettings = await manager.getSettings();
      expect(nullSettings).toEqual({});

      // Test case 3: Storage throws error during get operation
      mockChrome.storage.sync.get.mockImplementation((keys: any, callback: any) => {
        mockChrome.runtime.lastError = { message: 'Storage corrupted' };
        callback({});
      });

      const errorSettings = await manager.getSettings();
      expect(errorSettings).toEqual({});

      // Reset lastError for other tests
      mockChrome.runtime.lastError = null;

      // Test case 4: Storage returns unexpected structure
      mockChrome.storage.sync.get.mockImplementation((keys: any, callback: any) => {
        callback({
          prismWeaveSettings: {
            someRandomField: 'value',
            anotherField: 123,
            validField: 'but mostly invalid',
          },
        });
      });

      const unexpectedSettings = await manager.getSettings();
      expect(typeof unexpectedSettings).toBe('object');
      expect(unexpectedSettings).not.toBeNull();
    });

    test('H.3.3 - Test storage with large data', async () => {
      // Create large settings object to test storage limits
      const largeSettings = {
        githubToken: 'a'.repeat(100), // Moderately long token
        customSelectors: 'selector1,'.repeat(50) + 'selector2', // Long selector string
        commitMessageTemplate: 'X'.repeat(100), // Long commit template
        githubRepo: 'user/repository-with-very-long-name',
      };

      // Mock get operation for updateSettings internal call
      mockChrome.storage.sync.get.mockImplementation((keys: any, callback: any) => {
        callback({ prismWeaveSettings: {} }); // Return empty current settings
      });

      // Test successful storage of large data
      mockChrome.storage.sync.set.mockImplementation((data: any, callback: any) => {
        callback(); // Simulate success
      });

      const updateResult = await manager.updateSettings(largeSettings);
      expect(updateResult).toBe(true);
      expect(mockChrome.storage.sync.set).toHaveBeenCalled();

      // Test storage quota exceeded error
      mockChrome.storage.sync.set.mockImplementation((data: any, callback: any) => {
        mockChrome.runtime.lastError = { message: 'QUOTA_BYTES quota exceeded' };
        callback();
      });

      const quotaExceededResult = await manager.updateSettings(largeSettings);
      expect(quotaExceededResult).toBe(false);

      // Reset lastError for cleanup
      mockChrome.runtime.lastError = null;
    });
  });

  describe('Edge Cases and Error Handling', () => {
    test('Should handle malformed schema gracefully', () => {
      // Test validation with unusual data types
      const edgeCaseSettings: any = {
        githubToken: null,
        githubRepo: undefined,
        autoCommit: 0, // Falsy but not boolean
        defaultFolder: ['array', 'instead', 'of', 'string'],
        captureImages: {},
      };

      const result = manager.validateSettings(edgeCaseSettings);
      expect(result.isValid).toBe(false);
      expect(result.errors.length).toBeGreaterThan(0);
    });

    test('Should handle concurrent storage operations', async () => {
      // Mock get operation to return empty settings for all internal calls
      mockChrome.storage.sync.get.mockImplementation((keys: any, callback: any) => {
        callback({ prismWeaveSettings: {} });
      });

      let callCount = 0;
      mockChrome.storage.sync.set.mockImplementation((data: any, callback: any) => {
        callCount++;
        callback(); // Complete immediately without delay
      });

      // Start multiple update operations simultaneously
      const promises = [
        manager.updateSettings({ autoCommit: true }),
        manager.updateSettings({ captureImages: false }),
        manager.updateSettings({ debugMode: true }),
      ];

      const results = await Promise.all(promises);
      expect(results).toEqual([true, true, true]);
      expect(callCount).toBe(3);
    });

    test('Should preserve data integrity during partial failures', async () => {
      // Test update with some valid and some invalid fields
      const mixedSettings: any = {
        githubToken: 'valid-token', // Valid
        githubRepo: 'invalid format', // Invalid pattern
        autoCommit: true, // Valid
      };

      const result = await manager.updateSettings(mixedSettings);
      expect(result).toBe(false); // Should fail validation

      // Verify storage was not called due to validation failure
      expect(mockChrome.storage.sync.set).not.toHaveBeenCalled();
    });
  });
});
