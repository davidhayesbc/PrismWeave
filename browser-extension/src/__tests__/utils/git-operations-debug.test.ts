// Generated by Copilot
// Git Operations Debug Test - Specific Overwrite Issue

import { IDocumentMetadata, ISettings } from '../../types/index';
import { GitOperations } from '../../utils/git-operations';

// Mock fetch for testing
global.fetch = jest.fn();

describe('GitOperations Debug - File Overwrite Issue', () => {
  let gitOps: GitOperations;
  let mockSettings: ISettings;
  let mockMetadata: IDocumentMetadata;

  beforeEach(() => {
    gitOps = new GitOperations();

    mockSettings = {
      githubToken: 'test-token-123',
      githubRepo: 'testuser/test-repo',
      defaultFolder: 'auto',
      customFolder: '',
    } as ISettings;

    mockMetadata = {
      title: 'Test Document',
      url: 'https://example.com/test',
      captureDate: new Date().toISOString(),
      tags: ['test'],
      author: 'Test Author',
      wordCount: 100,
      estimatedReadingTime: 2,
    } as IDocumentMetadata;

    jest.clearAllMocks();
  });

  test('REAL SCENARIO: File exists, should overwrite correctly', async () => {
    await gitOps.initialize(mockSettings);

    const existingFileSha = 'abc123def456';

    // Scenario: File exists with specific SHA
    (fetch as jest.Mock)
      .mockResolvedValueOnce({
        ok: true,
        status: 200,
        json: async () => ({
          sha: existingFileSha,
          content: 'ZXhpc3RpbmcgY29udGVudA==', // "existing content" in base64
          encoding: 'base64',
          name: 'test-file.md',
          path: 'documents/test/test-file.md',
        }),
      })
      // Mock successful update response
      .mockResolvedValueOnce({
        ok: true,
        status: 200,
        json: async () => ({
          content: {
            sha: 'new-content-sha-999',
            html_url: 'https://github.com/testuser/test-repo/blob/main/documents/test/test-file.md',
          },
          commit: {
            sha: 'new-commit-sha-888',
            html_url: 'https://github.com/testuser/test-repo/commit/new-commit-sha-888',
          },
        }),
      });

    const result = await gitOps.saveToGitHub(
      '# Updated Content\n\nThis is the new content that should overwrite the existing file.',
      'test-file.md',
      mockMetadata
    );

    // Log the result for debugging
    console.log('DEBUG - Save result:', JSON.stringify(result, null, 2));

    expect(result.success).toBe(true);
    expect(result.sha).toBe('new-commit-sha-888');

    // Check that fetch was called twice
    expect(fetch).toHaveBeenCalledTimes(2);

    // Examine the first call (file existence check)
    const [existenceCheckUrl, existenceCheckOptions] = (fetch as jest.Mock).mock.calls[0];
    console.log('DEBUG - Existence check URL:', existenceCheckUrl);
    console.log('DEBUG - Existence check method:', existenceCheckOptions.method);

    // Examine the second call (file update)
    const [updateUrl, updateOptions] = (fetch as jest.Mock).mock.calls[1];
    const updateBody = JSON.parse(updateOptions.body);

    console.log('DEBUG - Update URL:', updateUrl);
    console.log('DEBUG - Update method:', updateOptions.method);
    console.log('DEBUG - Update body SHA:', updateBody.sha);
    console.log('DEBUG - Update body message:', updateBody.message);

    // Critical verification: The SHA MUST be included for overwrite
    expect(updateBody.sha).toBe(existingFileSha);
    expect(updateBody.message).toContain('Update captured content');
    expect(updateOptions.method).toBe('PUT');
  });

  test('REAL SCENARIO: Simulate actual GitHub API error for existing file without SHA', async () => {
    await gitOps.initialize(mockSettings);

    const existingFileSha = 'correct-sha-123';

    // File exists with SHA
    (fetch as jest.Mock)
      .mockResolvedValueOnce({
        ok: true,
        status: 200,
        json: async () => ({
          sha: existingFileSha,
          content: 'ZXhpc3RpbmcgY29udGVudA==',
          encoding: 'base64',
        }),
      })
      // Try to update without SHA - GitHub returns 409 Conflict
      .mockResolvedValueOnce({
        ok: false,
        status: 409,
        statusText: 'Conflict',
        text: async () =>
          JSON.stringify({
            message: 'SHA does not match',
            documentation_url:
              'https://docs.github.com/rest/repos/contents#create-or-update-file-contents',
          }),
      });

    // Force the SHA to be missing by mocking getFileInfo to return no SHA
    const originalCreateOrUpdate = (gitOps as any).createOrUpdateFile;
    (gitOps as any).createOrUpdateFile = jest.fn(
      async (repoInfo, path, content, commitOptions, existingSha) => {
        // Simulate the bug: call without SHA even though file exists
        return originalCreateOrUpdate.call(
          gitOps,
          repoInfo,
          path,
          content,
          commitOptions,
          undefined
        );
      }
    );

    const result = await gitOps.saveToGitHub('New content', 'existing-file.md', mockMetadata);

    expect(result.success).toBe(false);
    expect(result.error).toContain('409');
  });

  test('EDGE CASE: Test the actual problem - missing SHA handling', async () => {
    await gitOps.initialize(mockSettings);

    // This tests if the issue is that existingFile?.sha is undefined
    // when it should have a value

    // Mock: getFileInfo returns file info but with undefined SHA
    (fetch as jest.Mock)
      .mockResolvedValueOnce({
        ok: true,
        status: 200,
        json: async () => ({
          // Missing sha field - this could be the bug!
          content: 'ZXhpc3RpbmcgY29udGVudA==',
          encoding: 'base64',
          name: 'test.md',
        }),
      })
      .mockResolvedValueOnce({
        ok: false,
        status: 409,
        statusText: 'Conflict',
        text: async () => 'SHA required for update',
      });

    const result = await gitOps.saveToGitHub('New content', 'test.md', mockMetadata);

    // This should fail because we didn't provide SHA for existing file
    expect(result.success).toBe(false);

    // Check the actual API call made
    const updateCall = (fetch as jest.Mock).mock.calls[1];
    const updateBody = JSON.parse(updateCall[1].body);

    // The problem: sha is undefined when it should have a value
    console.log('DEBUG - SHA in request body:', updateBody.sha);
    expect(updateBody.sha).toBeUndefined();
  });
});
