// Generated by Copilot
// Git Operations Tests - Consolidated Test Suite
// Phase 1.3: Consolidates git-operations.test.ts, git-operations-fix.test.ts, and git-operations-debug.test.ts

import { IDocumentMetadata, ISettings } from '../../types/index';
import { GitOperations } from '../../utils/git-operations';
import { createLogger } from '../../utils/logger';

// Mock fetch for testing
global.fetch = jest.fn();

// Create logger for testing
const logger = createLogger('GitOperationsTest');

describe('GitOperations - Consolidated Test Suite', () => {
  let gitOps: GitOperations;
  let mockSettings: ISettings;
  let mockMetadata: IDocumentMetadata;

  beforeEach(() => {
    gitOps = new GitOperations();

    mockSettings = {
      githubToken: 'test-token-123',
      githubRepo: 'testuser/test-repo',
      defaultFolder: 'auto',
      customFolder: '',
    } as ISettings;

    mockMetadata = {
      title: 'Test Document',
      url: 'https://example.com/test',
      captureDate: new Date().toISOString(),
      tags: ['test'],
      author: 'Test Author',
      wordCount: 100,
      estimatedReadingTime: 2,
    } as IDocumentMetadata;

    // Clear all mocks
    jest.clearAllMocks();
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  describe('I. File Creation and Updates', () => {
    test('I.1 - Should create new file when file does not exist', async () => {
      await gitOps.initialize(mockSettings);

      // Mock: File doesn't exist (404 response)
      (fetch as jest.Mock)
        .mockResolvedValueOnce({
          status: 404,
          ok: false,
          statusText: 'Not Found',
        })
        // Mock: Successful file creation
        .mockResolvedValueOnce({
          ok: true,
          status: 201,
          json: async () => ({
            commit: {
              sha: 'new-commit-sha-123',
              html_url: 'https://github.com/testuser/test-repo/commit/new-commit-sha-123',
            },
          }),
        });

      const result = await gitOps.saveToGitHub('Test content', 'test-file.md', mockMetadata);

      expect(result.success).toBe(true);
      expect(result.sha).toBe('new-commit-sha-123');

      // Verify fetch calls
      expect(fetch).toHaveBeenCalledTimes(2);

      // First call: Check if file exists
      expect(fetch).toHaveBeenNthCalledWith(
        1,
        expect.stringContaining('/contents/documents/'),
        expect.objectContaining({
          method: 'GET',
          headers: expect.objectContaining({
            Authorization: 'token test-token-123',
          }),
        })
      );

      // Second call: Create file (no SHA in body)
      expect(fetch).toHaveBeenNthCalledWith(
        2,
        expect.stringContaining('/contents/documents/'),
        expect.objectContaining({
          method: 'PUT',
          body: expect.not.stringContaining('"sha"'),
        })
      );
    });

    test('I.2 - Should update existing file with correct SHA', async () => {
      await gitOps.initialize(mockSettings);

      const existingFileSha = 'existing-file-sha-456';

      // Mock: File exists with SHA
      (fetch as jest.Mock)
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          json: async () => ({
            sha: existingFileSha,
            content: 'ZXhpc3RpbmcgY29udGVudA==', // base64 for "existing content"
            encoding: 'base64',
          }),
        })
        // Mock: Successful file update
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          json: async () => ({
            commit: {
              sha: 'updated-commit-sha-789',
              html_url: 'https://github.com/testuser/test-repo/commit/updated-commit-sha-789',
            },
          }),
        });

      const result = await gitOps.saveToGitHub('Updated content', 'existing-file.md', mockMetadata);

      expect(result.success).toBe(true);
      expect(result.sha).toBe('updated-commit-sha-789');

      // Verify fetch calls
      expect(fetch).toHaveBeenCalledTimes(2);

      // First call: Get existing file info
      expect(fetch).toHaveBeenNthCalledWith(
        1,
        expect.stringContaining('/contents/documents/'),
        expect.objectContaining({
          method: 'GET',
        })
      );

      // Second call: Update file WITH SHA
      const updateCall = (fetch as jest.Mock).mock.calls[1];
      const updateBody = JSON.parse(updateCall[1].body);

      expect(updateCall[1].method).toBe('PUT');
      expect(updateBody.sha).toBe(existingFileSha);
      expect(updateBody.message).toContain('Update captured content');
    });

    test('I.3 - Should properly handle file overwrite with valid SHA', async () => {
      await gitOps.initialize(mockSettings);

      const validSha = 'abc123def456789';

      // Mock: Valid GitHub response with SHA
      (fetch as jest.Mock)
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          json: async () => ({
            sha: validSha,
            content: 'b2xkIGNvbnRlbnQ=', // "old content" in base64
            encoding: 'base64',
            name: 'test.md',
            path: 'documents/test/test.md',
          }),
        })
        // Mock: Successful update
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          json: async () => ({
            content: {
              sha: 'new-content-sha',
              html_url: 'https://github.com/testuser/test-repo/blob/main/documents/test/test.md',
            },
            commit: {
              sha: 'new-commit-sha',
              html_url: 'https://github.com/testuser/test-repo/commit/new-commit-sha',
            },
          }),
        });

      const result = await gitOps.saveToGitHub(
        '# Updated Content\n\nThis content should overwrite the existing file.',
        'test.md',
        mockMetadata
      );

      expect(result.success).toBe(true);
      expect(result.sha).toBe('new-commit-sha');

      // Verify the update request included the SHA
      const updateCall = (fetch as jest.Mock).mock.calls[1];
      const updateBody = JSON.parse(updateCall[1].body);
      expect(updateBody.sha).toBe(validSha);
      expect(updateBody.message).toContain('Update captured content');
    });

    test('I.4 - Should handle successful creation of new file', async () => {
      await gitOps.initialize(mockSettings);

      // Mock: File doesn't exist
      (fetch as jest.Mock)
        .mockResolvedValueOnce({
          status: 404,
          ok: false,
          statusText: 'Not Found',
        })
        // Mock: Successful creation
        .mockResolvedValueOnce({
          ok: true,
          status: 201,
          json: async () => ({
            content: {
              sha: 'new-file-sha',
              html_url:
                'https://github.com/testuser/test-repo/blob/main/documents/test/new-file.md',
            },
            commit: {
              sha: 'creation-commit-sha',
              html_url: 'https://github.com/testuser/test-repo/commit/creation-commit-sha',
            },
          }),
        });

      const result = await gitOps.saveToGitHub(
        '# New File\n\nThis is a completely new file.',
        'new-file.md',
        mockMetadata
      );

      expect(result.success).toBe(true);
      expect(result.sha).toBe('creation-commit-sha');

      // Verify the creation request did NOT include SHA
      const createCall = (fetch as jest.Mock).mock.calls[1];
      const createBody = JSON.parse(createCall[1].body);
      expect(createBody.sha).toBeUndefined();
      expect(createBody.message).toContain('Add captured content');
    });
  });

  describe('II. Error Handling and Edge Cases', () => {
    test('II.1 - Should handle file existence check errors gracefully', async () => {
      await gitOps.initialize(mockSettings);

      // Mock: Network error on file existence check
      (fetch as jest.Mock)
        .mockRejectedValueOnce(new Error('Network error'))
        // Mock: Still try to create file (will fail if file exists)
        .mockResolvedValueOnce({
          ok: false,
          status: 422,
          statusText: 'Unprocessable Entity',
          text: async () => 'File already exists',
        });

      const result = await gitOps.saveToGitHub('Test content', 'test-file.md', mockMetadata);

      expect(result.success).toBe(false);
      // Network error from getFileInfo is propagated directly
      expect(result.error).toContain('Network error');
    });

    test('II.2 - Should reject malformed GitHub response missing SHA', async () => {
      await gitOps.initialize(mockSettings);

      // Mock: Malformed GitHub response (missing SHA)
      (fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        status: 200,
        json: async () => ({
          // Missing sha field - this should be caught now
          content: 'b2xkIGNvbnRlbnQ=',
          encoding: 'base64',
          name: 'test.md',
        }),
      });

      const result = await gitOps.saveToGitHub('New content', 'test.md', mockMetadata);

      expect(result.success).toBe(false);
      expect(result.error).toContain('missing SHA');
    });

    test('II.3 - Should provide helpful error messages for common failures', async () => {
      await gitOps.initialize(mockSettings);

      const testCases = [
        {
          name: 'Conflict error',
          mockResponse: {
            ok: false,
            status: 409,
            statusText: 'Conflict',
            text: async () => 'SHA does not match',
          },
          expectedError: 'File update conflict',
        },
        {
          name: 'Validation error',
          mockResponse: {
            ok: false,
            status: 422,
            statusText: 'Unprocessable Entity',
            text: async () => 'Invalid input',
          },
          expectedError: 'Invalid request',
        },
        {
          name: 'Not found error',
          mockResponse: {
            ok: false,
            status: 404,
            statusText: 'Not Found',
            text: async () => 'Repository not found',
          },
          expectedError: 'Repository not found',
        },
      ];

      for (const testCase of testCases) {
        jest.clearAllMocks();

        // Mock file exists
        (fetch as jest.Mock)
          .mockResolvedValueOnce({
            ok: true,
            status: 200,
            json: async () => ({
              sha: 'test-sha',
              content: 'content',
              encoding: 'base64',
            }),
          })
          // Mock the specific error
          .mockResolvedValueOnce(testCase.mockResponse);

        const result = await gitOps.saveToGitHub('content', 'test.md', mockMetadata);

        expect(result.success).toBe(false);
        expect(result.error).toContain(testCase.expectedError);
      }
    });

    test('II.4 - Should handle network errors gracefully', async () => {
      await gitOps.initialize(mockSettings);

      // Mock: Network error during file existence check
      (fetch as jest.Mock).mockRejectedValueOnce(new Error('Network timeout'));

      const result = await gitOps.saveToGitHub('content', 'test.md', mockMetadata);

      expect(result.success).toBe(false);
      expect(result.error).toContain('Network timeout');
    });

    test('II.5 - Should handle missing SHA in existing file response', async () => {
      await gitOps.initialize(mockSettings);

      // Mock: File exists but response is malformed (no SHA)
      (fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        status: 200,
        json: async () => ({
          // Missing sha field
          content: 'content',
          encoding: 'base64',
        }),
      });

      const result = await gitOps.saveToGitHub('content', 'file.md', mockMetadata);

      // Should fail due to missing SHA validation
      expect(result.success).toBe(false);
      expect(result.error).toContain('missing SHA');
    });

    test('II.6 - Should handle empty content', async () => {
      await gitOps.initialize(mockSettings);

      (fetch as jest.Mock).mockResolvedValueOnce({ status: 404, ok: false }).mockResolvedValueOnce({
        ok: true,
        status: 201,
        json: async () => ({ commit: { sha: 'sha', html_url: 'url' } }),
      });

      const result = await gitOps.saveToGitHub('', 'empty.md', mockMetadata);

      expect(result.success).toBe(true);

      const createCall = (fetch as jest.Mock).mock.calls[1];
      const createBody = JSON.parse(createCall[1].body);
      const decodedContent = decodeURIComponent(escape(atob(createBody.content)));

      // Should still have frontmatter even with empty content
      expect(decodedContent).toContain('---');
      expect(decodedContent).toContain('title: "Test Document"');
    });
  });

  describe('III. Content Processing and Encoding', () => {
    test('III.1 - Should generate correct commit message for updates vs creates', async () => {
      await gitOps.initialize(mockSettings);

      // Test update scenario
      (fetch as jest.Mock)
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          json: async () => ({
            sha: 'existing-sha',
            content: 'content',
            encoding: 'base64',
          }),
        })
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          json: async () => ({
            commit: { sha: 'commit-sha', html_url: 'url' },
          }),
        });

      await gitOps.saveToGitHub('content', 'file.md', mockMetadata);

      const updateCall = (fetch as jest.Mock).mock.calls[1];
      const updateBody = JSON.parse(updateCall[1].body);

      expect(updateBody.message).toContain('Update captured content');
      expect(updateBody.message).toContain('Test Document');
      expect(updateBody.message).toContain('example.com');

      jest.clearAllMocks();

      // Test create scenario
      (fetch as jest.Mock)
        .mockResolvedValueOnce({
          status: 404,
          ok: false,
        })
        .mockResolvedValueOnce({
          ok: true,
          status: 201,
          json: async () => ({
            commit: { sha: 'new-commit-sha', html_url: 'url' },
          }),
        });

      await gitOps.saveToGitHub('content', 'new-file.md', mockMetadata);

      const createCall = (fetch as jest.Mock).mock.calls[1];
      const createBody = JSON.parse(createCall[1].body);

      expect(createBody.message).toContain('Add captured content');
      expect(createBody.message).toContain('Test Document');
    });

    test('III.2 - Should properly encode content for GitHub API', async () => {
      await gitOps.initialize(mockSettings);

      const testContent = 'Test content with unicode: 🚀 and special chars: <>&"\'';

      (fetch as jest.Mock).mockResolvedValueOnce({ status: 404, ok: false }).mockResolvedValueOnce({
        ok: true,
        status: 201,
        json: async () => ({
          commit: { sha: 'sha', html_url: 'url' },
        }),
      });

      await gitOps.saveToGitHub(testContent, 'test.md', mockMetadata);

      const createCall = (fetch as jest.Mock).mock.calls[1];
      const createBody = JSON.parse(createCall[1].body);

      // Decode the content to verify it was encoded correctly
      const decodedContent = decodeURIComponent(escape(atob(createBody.content)));

      expect(decodedContent).toContain('Test content with unicode: 🚀');
      expect(decodedContent).toContain('special chars: <>&"\'');
      expect(decodedContent).toContain('title: "Test Document"');
      expect(decodedContent).toContain('url: "https://example.com/test"');
    });

    test('III.3 - Should handle different repository path formats', async () => {
      // Test with GitHub URL format
      const urlSettings = {
        ...mockSettings,
        githubRepo: 'https://github.com/testuser/test-repo.git',
      };

      await gitOps.initialize(urlSettings);

      (fetch as jest.Mock).mockResolvedValueOnce({ status: 404, ok: false }).mockResolvedValueOnce({
        ok: true,
        status: 201,
        json: async () => ({ commit: { sha: 'sha', html_url: 'url' } }),
      });

      await gitOps.saveToGitHub('content', 'test.md', mockMetadata);

      // Verify the API endpoint was constructed correctly
      expect(fetch).toHaveBeenCalledWith(
        expect.stringContaining('/repos/testuser/test-repo/contents/'),
        expect.any(Object)
      );
    });
  });

  describe('IV. Integration and Workflow Tests', () => {
    test('IV.1 - Complete overwrite workflow integration test', async () => {
      await gitOps.initialize(mockSettings);

      const originalSha = 'original-file-sha-123';
      const newCommitSha = 'updated-commit-sha-456';

      // Complete workflow: Check -> Update -> Success
      (fetch as jest.Mock)
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          json: async () => ({
            sha: originalSha,
            content: btoa('# Original Content\n\nThis is the original content.'),
            encoding: 'base64',
            name: 'integration-test.md',
            path: 'documents/tutorial/integration-test.md',
          }),
        })
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          json: async () => ({
            content: {
              sha: 'new-content-sha',
              html_url:
                'https://github.com/testuser/test-repo/blob/main/documents/tutorial/integration-test.md',
            },
            commit: {
              sha: newCommitSha,
              html_url: `https://github.com/testuser/test-repo/commit/${newCommitSha}`,
            },
          }),
        });

      const newContent = `# Updated Content

This is the completely new content that should replace the original file.

## Features
- Full file replacement
- Proper SHA handling  
- Commit message generation
- Metadata frontmatter

The old content should be completely overwritten.`;

      const result = await gitOps.saveToGitHub(newContent, 'integration-test.md', mockMetadata);

      // Verify success
      expect(result.success).toBe(true);
      expect(result.sha).toBe(newCommitSha);
      expect(result.url).toContain(newCommitSha);

      // Verify the complete workflow
      expect(fetch).toHaveBeenCalledTimes(2);

      // Check existence call
      const [existenceUrl, existenceOptions] = (fetch as jest.Mock).mock.calls[0];
      expect(existenceUrl).toContain('/contents/documents/tutorial/integration-test.md');
      expect(existenceOptions.method).toBe('GET');

      // Update call
      const [updateUrl, updateOptions] = (fetch as jest.Mock).mock.calls[1];
      const updateBody = JSON.parse(updateOptions.body);

      expect(updateUrl).toContain('/contents/documents/tutorial/integration-test.md');
      expect(updateOptions.method).toBe('PUT');
      expect(updateBody.sha).toBe(originalSha);
      expect(updateBody.message).toBe('Update captured content: Test Document (example.com)');

      // Verify content is properly encoded
      const decodedContent = decodeURIComponent(escape(atob(updateBody.content)));
      expect(decodedContent).toContain('Updated Content');
      expect(decodedContent).toContain('title: "Test Document"');
      expect(decodedContent).toContain('Full file replacement');
    });

    test('IV.2 - Real scenario simulation with proper SHA handling', async () => {
      await gitOps.initialize(mockSettings);

      const existingFileSha = 'abc123def456';

      // Scenario: File exists with specific SHA
      (fetch as jest.Mock)
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          json: async () => ({
            sha: existingFileSha,
            content: 'ZXhpc3RpbmcgY29udGVudA==', // "existing content" in base64
            encoding: 'base64',
            name: 'test-file.md',
            path: 'documents/test/test-file.md',
          }),
        })
        // Mock successful update response
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          json: async () => ({
            content: {
              sha: 'new-content-sha-999',
              html_url:
                'https://github.com/testuser/test-repo/blob/main/documents/test/test-file.md',
            },
            commit: {
              sha: 'new-commit-sha-888',
              html_url: 'https://github.com/testuser/test-repo/commit/new-commit-sha-888',
            },
          }),
        });

      const result = await gitOps.saveToGitHub(
        '# Updated Content\n\nThis is the new content that should overwrite the existing file.',
        'test-file.md',
        mockMetadata
      );

      expect(result.success).toBe(true);
      expect(result.sha).toBe('new-commit-sha-888');

      // Check that fetch was called twice
      expect(fetch).toHaveBeenCalledTimes(2);

      // Examine the first call (file existence check)
      const [existenceCheckUrl, existenceCheckOptions] = (fetch as jest.Mock).mock.calls[0];
      expect(existenceCheckOptions.method).toBe('GET');

      // Examine the second call (file update)
      const [updateUrl, updateOptions] = (fetch as jest.Mock).mock.calls[1];
      const updateBody = JSON.parse(updateOptions.body);

      // Critical verification: The SHA MUST be included for overwrite
      expect(updateBody.sha).toBe(existingFileSha);
      expect(updateBody.message).toContain('Update captured content');
      expect(updateOptions.method).toBe('PUT');
    });

    test('IV.3 - Simulate GitHub API error for conflicting updates', async () => {
      await gitOps.initialize(mockSettings);

      const existingFileSha = 'correct-sha-123';

      // File exists with SHA
      (fetch as jest.Mock)
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          json: async () => ({
            sha: existingFileSha,
            content: 'ZXhpc3RpbmcgY29udGVudA==',
            encoding: 'base64',
          }),
        })
        // Try to update without SHA - GitHub returns 409 Conflict
        .mockResolvedValueOnce({
          ok: false,
          status: 409,
          statusText: 'Conflict',
          text: async () =>
            JSON.stringify({
              message: 'SHA does not match',
              documentation_url:
                'https://docs.github.com/rest/repos/contents#create-or-update-file-contents',
            }),
        });

      // This should fail with conflict error if SHA handling is incorrect
      const result = await gitOps.saveToGitHub('New content', 'existing-file.md', mockMetadata);

      // Since our implementation properly handles SHA, this should succeed
      // If it fails, it indicates an issue with SHA handling
      expect(result.success).toBe(false);
      expect(result.error).toContain('409');
    });
  });

  describe('V. Debug and Edge Case Verification', () => {
    test('V.1 - Test missing SHA handling in existing file response', async () => {
      await gitOps.initialize(mockSettings);

      // This tests if the issue is that existingFile?.sha is undefined
      // when it should have a value

      // Mock: getFileInfo returns file info but with undefined SHA
      (fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        status: 200,
        json: async () => ({
          // Missing sha field - this could be the bug!
          content: 'ZXhpc3RpbmcgY29udGVudA==',
          encoding: 'base64',
          name: 'test.md',
        }),
      });

      const result = await gitOps.saveToGitHub('New content', 'test.md', mockMetadata);

      // This should fail because we didn't provide SHA for existing file
      expect(result.success).toBe(false);
      expect(result.error).toContain('missing SHA');

      // Since the operation fails early, there should only be one fetch call (getFileInfo)
      expect((fetch as jest.Mock).mock.calls.length).toBe(1);
    });

    test('V.2 - Verify all error scenarios are handled correctly', async () => {
      await gitOps.initialize(mockSettings);

      const errorScenarios = [
        {
          description: 'Network timeout',
          mockError: new Error('Network timeout'),
          expectedError: 'Network timeout',
        },
        {
          description: 'Invalid token',
          mockError: { ok: false, status: 401, text: async () => 'Unauthorized' },
          expectedError: '401',
        },
        {
          description: 'Rate limit exceeded',
          mockError: { ok: false, status: 403, text: async () => 'Rate limit exceeded' },
          expectedError: '403',
        },
      ];

      for (const scenario of errorScenarios) {
        jest.clearAllMocks();

        if (scenario.mockError instanceof Error) {
          (fetch as jest.Mock).mockRejectedValueOnce(scenario.mockError);
        } else {
          (fetch as jest.Mock).mockResolvedValueOnce(scenario.mockError);
        }

        const result = await gitOps.saveToGitHub('test content', 'test.md', mockMetadata);

        expect(result.success).toBe(false);
        expect(result.error).toContain(scenario.expectedError);
      }
    });

    test('V.3 - Verify proper cleanup and state management', async () => {
      await gitOps.initialize(mockSettings);

      // Test that the GitOperations instance can handle multiple operations
      // without state pollution

      // First operation: successful creation
      (fetch as jest.Mock).mockResolvedValueOnce({ status: 404, ok: false }).mockResolvedValueOnce({
        ok: true,
        status: 201,
        json: async () => ({ commit: { sha: 'sha1', html_url: 'url1' } }),
      });

      const result1 = await gitOps.saveToGitHub('content1', 'file1.md', mockMetadata);
      expect(result1.success).toBe(true);
      expect(result1.sha).toBe('sha1');

      jest.clearAllMocks();

      // Second operation: successful update
      (fetch as jest.Mock)
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          json: async () => ({ sha: 'existing-sha', content: 'content', encoding: 'base64' }),
        })
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          json: async () => ({ commit: { sha: 'sha2', html_url: 'url2' } }),
        });

      const result2 = await gitOps.saveToGitHub('content2', 'file2.md', mockMetadata);
      expect(result2.success).toBe(true);
      expect(result2.sha).toBe('sha2');

      // Both operations should be independent
      expect(result1.sha).not.toBe(result2.sha);
    });
  });
});
