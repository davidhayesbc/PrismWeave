// Test our enhanced code block processing specifically for shell scripts
// Generated by Copilot
// Tests for shell script code block issues and markdown conversion improvements

import { describe, expect, jest, test } from '@jest/globals';
import { MarkdownConverter } from '../../utils/markdown-converter.js';
import { JSDOM } from 'jsdom';

// Local helper functions (copied to avoid build issues during testing)
function removeLineNumbers(code: string): string {
  if (!code) return code;
  
  const lines = code.split('\n');
  const processedLines: string[] = [];

  for (const line of lines) {
    // Skip empty lines
    if (line.trim() === '') {
      processedLines.push(line);
      continue;
    }

    // More sophisticated line number detection
    const lineNumberPatterns = [
      { pattern: /^(\s*)(\d{1,4})\s+(.+)$/, groups: [1, 3] },           // "  42 content"
      { pattern: /^(\s*)(\d{1,4})\.(\s*)(.+)$/, groups: [1, 3, 4] },    // "  42. content" 
      { pattern: /^(\s*)(\d{1,4}):(\s*)(.+)$/, groups: [1, 3, 4] },     // "  42: content"
      { pattern: /^(\s*)(\d{1,4})\|(\s*)(.+)$/, groups: [1, 3, 4] },    // "  42| content"
      { pattern: /^(\s*)(\d{1,4})\)(\s*)(.+)$/, groups: [1, 3, 4] }     // "  42) content"
    ];

    let processed = false;
    for (const { pattern, groups } of lineNumberPatterns) {
      const match = line.match(pattern);
      if (match) {
        const lineNumber = parseInt(match[2], 10);
        
        // Only treat as line number if reasonable range
        if (lineNumber >= 1 && lineNumber <= 9999) {
          const leadingWhitespace = match[groups[0]];
          const content = match[groups[groups.length - 1]];
          const contentStart = content.trim();
          
          // Don't remove if it looks like actual numbered content
          if (contentStart.match(/^(Step|Chapter|Section|Part|Phase)/i) ||
              contentStart.match(/^\w+\s+(files?|items?|times?|seconds?|minutes?)/i)) {
            processedLines.push(line);
            processed = true;
            break;
          }
          
          // Preserve indentation
          const preservedIndent = leadingWhitespace + (groups.length > 2 ? match[groups[1]] || '  ' : '  ');
          processedLines.push(preservedIndent + content);
          processed = true;
          break;
        }
      }
    }

    if (!processed) {
      processedLines.push(line);
    }
  }

  return processedLines.join('\n');
}

function extractLanguageFromClass(className: string): string {
  if (!className) return '';
  
  const patterns = [
    /(?:language|lang)-([a-zA-Z0-9_+-]+)/i,
    /highlight-([a-zA-Z0-9_+-]+)/i,
    /code-([a-zA-Z0-9_+-]+)/i,
    /([a-zA-Z0-9_+-]+)-code/i
  ];
  
  for (const pattern of patterns) {
    const match = className.match(pattern);
    if (match) {
      return normalizeLanguage(match[1]);
    }
  }
  
  return '';
}

function normalizeLanguage(lang: string): string {
  if (!lang) return '';
  
  const normalized = lang.toLowerCase();
  const languageMap: { [key: string]: string } = {
    'js': 'javascript',
    'ts': 'typescript',
    'sh': 'bash',
    'shell': 'bash',
    'zsh': 'bash',
    'fish': 'bash',
    'unison': 'unison'
  };
  
  return languageMap[normalized] || normalized;
}

function decodeHtmlEntities(str: string): string {
  if (!str) return str;
  
  return str
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&amp;/g, '&')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&nbsp;/g, ' ')
    .replace(/&#x27;/g, "'")
    .replace(/&#x2F;/g, '/');
}

function simpleMarkdownConversion(htmlContent: string, title: string, url: string): { content: string; title: string; url: string } {
  let markdown = '';
  
  const dom = new JSDOM(htmlContent);
  const doc = dom.window.document;
  
  const codeBlocks = doc.querySelectorAll('pre code, pre, code');
  codeBlocks.forEach(block => {
    const isPreBlock = block.tagName === 'PRE' || block.parentElement?.tagName === 'PRE';
    
    if (isPreBlock) {
      const codeElement = block.tagName === 'CODE' ? block : block.querySelector('code');
      const actualCodeElement = codeElement || block;
      
      const className = actualCodeElement.className || '';
      const language = extractLanguageFromClass(className);
      
      let content = actualCodeElement.textContent || '';
      content = decodeHtmlEntities(content);
      content = removeLineNumbers(content);
      
      markdown += '\n```' + language + '\n' + content + '\n```\n\n';
    } else {
      let content = block.textContent || '';
      content = decodeHtmlEntities(content);
      markdown += '`' + content.replace(/`/g, '\\`') + '`';
    }
  });
  
  if (!codeBlocks.length) {
    markdown = doc.body?.textContent || htmlContent;
  }
  
  return {
    content: markdown.trim(),
    title: title,
    url: url
  };
}

// Since this is a browser extension test, we need to mock some browser APIs
(globalThis as any).chrome = {
  runtime: {
    sendMessage: jest.fn(),
    lastError: null,
  },
  storage: {
    sync: {
      get: jest.fn(),
      set: jest.fn(),
    },
  },
};

// Mock DOMParser for test environment
(globalThis as any).DOMParser = class MockDOMParser {
  parseFromString(htmlString: string, mimeType: string) {
    return {
      body: {
        textContent: htmlString.replace(/<[^>]+>/g, '').replace(/\s+/g, ' ').trim(),
      },
      querySelectorAll: (selector: string) => {
        const elements: any[] = [];
        
        // Mock pre code blocks
        if (selector === 'pre code, pre, code') {
          const codeBlockRegex = /<pre[^>]*>[\s\S]*?<code[^>]*class="([^"]*)"[^>]*>([\s\S]*?)<\/code>[\s\S]*?<\/pre>/gi;
          const inlineCodeRegex = /<code[^>]*>([\s\S]*?)<\/code>/gi;
          
          let match;
          while ((match = codeBlockRegex.exec(htmlString)) !== null) {
            elements.push({
              tagName: 'CODE',
              className: match[1],
              textContent: match[2],
              parentElement: { tagName: 'PRE' },
            });
          }
          
          while ((match = inlineCodeRegex.exec(htmlString)) !== null) {
            // Only include if not already captured in pre blocks
            if (!htmlString.substring(0, match.index).includes('<pre')) {
              elements.push({
                tagName: 'CODE',
                className: '',
                textContent: match[1],
                parentElement: null,
              });
            }
          }
        }
        
        return elements;
      },
    };
  }
};

describe('Shell Script Code Block Processing', () => {
  describe('Service Worker Markdown Conversion', () => {
    test('S.1.1 - Handle shell script code blocks with special characters', () => {
      // Arrange: HTML with shell script containing special characters
      const htmlInput = `
        <pre><code class="language-bash">#!/usr/bin/env zsh
# Fail the transcript if any command fails
set -e

# Load utility functions and variables for user credentials
source "../../transcript_helpers.sh"

# Run a UCM transcript to upload some code to load in projects.
transcript_ucm transcript prelude.md

# I should be able to see the fixture project as an unauthenticated user.
fetch "$unauthenticated_user" GET project-get-simple '/users/test/projects/publictestproject'

# I should be able to create a new project as an authenticated user.
fetch "$transcripts_user" POST project-create '/users/transcripts/projects/containers' '{
    "summary": "This is my project",
    "visibility": "private",
    "tags": []
}'</code></pre>
      `;

      // Act: Convert HTML to markdown
      const result = simpleMarkdownConversion(
        htmlInput,
        'Test Shell Script',
        'https://example.com'
      );

      // Assert: Verify shell script content is preserved
      expect(result.content).toContain('```bash');
      expect(result.content).toContain('#!/usr/bin/env zsh');
      expect(result.content).toContain('set -e');
      expect(result.content).toContain('source "../../transcript_helpers.sh"');
      expect(result.content).toContain('fetch "$unauthenticated_user"');
      expect(result.content).toContain('"summary": "This is my project"');

      // Verify special characters are preserved
      expect(result.content).toContain('$');
      expect(result.content).toContain('"');
      expect(result.content).toContain("'");
      expect(result.content).toContain('{');
      expect(result.content).toContain('}');

      // Verify no HTML entities remain
      expect(result.content).not.toContain('&lt;');
      expect(result.content).not.toContain('&gt;');
      expect(result.content).not.toContain('&amp;');
      expect(result.content).not.toContain('&quot;');
    });

    test('S.1.2 - Handle code blocks without language specification', () => {
      // Arrange: HTML with unspecified language code block
      const htmlInput = `
        <pre><code>#!/bin/bash
echo "This is a shell script without language tag"
for i in {1..5}; do
  echo "Iteration $i"
done</code></pre>
      `;

      // Act: Convert HTML to markdown
      const result = simpleMarkdownConversion(htmlInput, 'Test Script', 'https://example.com');

      // Assert: Verify code block is created without language tag
      expect(result.content).toContain('```\n#!/bin/bash');
      expect(result.content).toContain('echo "This is a shell script without language tag"');
      expect(result.content).toContain('for i in {1..5}; do');
      expect(result.content).toContain('echo "Iteration $i"');
      expect(result.content).toContain('done\n```');
    });

    test('S.1.3 - Handle inline code with special characters', () => {
      // Arrange: HTML with inline code containing special characters
      const htmlInput = `
        <p>Use the command <code>grep -r "pattern" /path/to/dir</code> to search files.</p>
        <p>The variable <code>$HOME</code> contains your home directory path.</p>
        <p>JSON format: <code>{"key": "value"}</code></p>
      `;

      // Act: Convert HTML to markdown
      const result = simpleMarkdownConversion(htmlInput, 'Test Inline Code', 'https://example.com');

      // Assert: Verify inline code preservation
      expect(result.content).toContain('`grep -r "pattern" /path/to/dir`');
      expect(result.content).toContain('`$HOME`');
      expect(result.content).toContain('`{"key": "value"}`');

      // Verify special characters are preserved in inline code
      expect(result.content).not.toContain('&lt;');
      expect(result.content).not.toContain('&gt;');
      expect(result.content).not.toContain('&amp;');
      expect(result.content).not.toContain('&quot;');
    });

    test('S.1.4 - Handle nested code blocks (code within markdown example)', () => {
      // Arrange: HTML representing markdown that contains code blocks
      const htmlInput = `
        <pre><code class="language-markdown"># Testing the \`view\` command

First, let's write a simple definition to view:

\`\`\` unison
isZero = cases
  0 -> true
  _ -> false
\`\`\`

Now we add the definition to the codebase, and view it.

\`\`\` ucm
scratch/main> update
scratch/main> view isZero
\`\`\`</code></pre>
      `;

      // Act: Convert HTML to markdown
      const result = simpleMarkdownConversion(htmlInput, 'Test Nested Code', 'https://example.com');

      // Assert: Verify nested structure is preserved
      expect(result.content).toContain('```markdown');
      expect(result.content).toContain('# Testing the `view` command');
      expect(result.content).toContain('``` unison');
      expect(result.content).toContain('isZero = cases');
      expect(result.content).toContain('``` ucm');
      expect(result.content).toContain('scratch/main> update');
      expect(result.content).toContain('scratch/main> view isZero');
    });

    test('S.1.5 - Handle multiple language-specific code blocks', () => {
      // Arrange: HTML with multiple different language code blocks
      const htmlInput = `
        <h2>Different Languages</h2>
        <pre><code class="language-javascript">const message = "Hello, World!";
console.log(message);</code></pre>
        
        <pre><code class="language-python">message = "Hello, World!"
print(message)</code></pre>
        
        <pre><code class="language-sql">SELECT * FROM users WHERE active = true;</code></pre>
        
        <pre><code class="language-dockerfile">FROM node:16-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install</code></pre>
      `;

      // Act: Convert HTML to markdown
      const result = simpleMarkdownConversion(
        htmlInput,
        'Test Multiple Languages',
        'https://example.com'
      );

      // Assert: Verify all language tags are preserved
      expect(result.content).toContain('```javascript');
      expect(result.content).toContain('const message = "Hello, World!";');
      expect(result.content).toContain('```python');
      expect(result.content).toContain('message = "Hello, World!"');
      expect(result.content).toContain('```sql');
      expect(result.content).toContain('SELECT * FROM users WHERE active = true;');
      expect(result.content).toContain('```dockerfile');
      expect(result.content).toContain('FROM node:16-alpine');
    });

    test('S.1.6 - Handle code blocks with line numbers', () => {
      // Arrange: HTML with code blocks containing line numbers (like Docker blog posts)
      const htmlInput = `
        <pre><code class="language-bash">1  #!/bin/bash
2  echo "Starting deployment"
3  
4  # Deploy to production
5  docker run -d --name myapp \\
6    -p 8080:8080 \\
7    myapp:latest
8  
9  echo "Deployment complete"</code></pre>
      `;

      // Act: Convert HTML to markdown
      const result = simpleMarkdownConversion(htmlInput, 'Test Line Numbers', 'https://example.com');

      // Assert: Verify line numbers are removed but content is preserved
      expect(result.content).toContain('```bash');
      expect(result.content).toContain('#!/bin/bash');
      expect(result.content).toContain('echo "Starting deployment"');
      expect(result.content).toContain('# Deploy to production');
      expect(result.content).toContain('docker run -d --name myapp \\');
      expect(result.content).toContain('-p 8080:8080 \\');
      expect(result.content).toContain('myapp:latest');
      expect(result.content).toContain('echo "Deployment complete"');

      // Verify line numbers are removed
      expect(result.content).not.toContain('1  #!/bin/bash');
      expect(result.content).not.toContain('2  echo');
      expect(result.content).not.toContain('3  ');
      expect(result.content).not.toContain('4  #');
      expect(result.content).not.toContain('5  docker');
    });
  });

  describe('Language Detection', () => {
    test('L.1.1 - Extract language from various class patterns', () => {
      // Test various class name patterns
      const testCases = [
        { className: 'language-bash', expected: 'bash' },
        { className: 'language-shell', expected: 'bash' },
        { className: 'language-zsh', expected: 'bash' },
        { className: 'highlight-javascript', expected: 'javascript' },
        { className: 'hljs-python', expected: 'python' },
        { className: 'prism-typescript', expected: 'typescript' },
        { className: 'language-unison', expected: 'unison' },
        { className: 'language-ucm', expected: 'unison' },
        { className: 'console', expected: 'console' },
        { className: 'terminal', expected: 'terminal' },
        { className: '', expected: '' },
        { className: 'unknown-language', expected: 'unknown-language' },
      ];

      testCases.forEach(({ className, expected }) => {
        const result = extractLanguageFromClass(className);
        expect(result).toBe(expected);
      });
    });
  });

  describe('HTML Entity Handling', () => {
    test('H.1.1 - Decode HTML entities in code blocks', () => {
      const htmlInput = `
        <pre><code>&lt;script&gt;
  const data = {
    &quot;name&quot;: &quot;test&quot;,
    &quot;value&quot;: 123
  };
  if (data.value &gt; 100) {
    console.log(&quot;High value&quot;);
  }
&lt;/script&gt;</code></pre>
      `;

      // Act: Convert HTML to markdown
      const result = simpleMarkdownConversion(
        htmlInput,
        'Test HTML Entities',
        'https://example.com'
      );

      // Assert: Verify HTML entities are decoded
      expect(result.content).toContain('<script>');
      expect(result.content).toContain('</script>');
      expect(result.content).toContain('"name": "test"');
      expect(result.content).toContain('data.value > 100');
      expect(result.content).toContain('console.log("High value");');

      // Verify no HTML entities remain
      expect(result.content).not.toContain('&lt;');
      expect(result.content).not.toContain('&gt;');
      expect(result.content).not.toContain('&quot;');
      expect(result.content).not.toContain('&amp;');
    });

    test('H.1.2 - Handle mixed content with entities and regular text', () => {
      const htmlInput = `
        <p>Here's how to use grep:</p>
        <pre><code>grep -E "pattern.*&amp;.*" file.txt
echo "Found &gt; 5 matches"</code></pre>
        <p>The &amp; symbol is used for boolean AND operations.</p>
      `;

      // Act: Convert HTML to markdown
      const result = simpleMarkdownConversion(
        htmlInput,
        'Test Mixed Content',
        'https://example.com'
      );

      // Assert: Verify proper entity handling
      expect(result.content).toContain('grep -E "pattern.*&.*" file.txt');
      expect(result.content).toContain('echo "Found > 5 matches"');
      expect(result.content).toContain('The & symbol is used for boolean AND operations.');
    });
  });

  describe('Line Number Removal', () => {
    test('R.1.1 - Remove simple line numbers', () => {
      const codeWithNumbers = `1  #!/bin/bash
2  echo "Hello"
3  exit 0`;
      
      const result = removeLineNumbers(codeWithNumbers);
      
      expect(result).toBe(`#!/bin/bash
echo "Hello"
exit 0`);
    });

    test('R.1.2 - Remove line numbers with different formats', () => {
      const testCases = [
        {
          input: `1. echo "test"
2. ls -la
3. exit`,
          expected: `echo "test"
ls -la
exit`
        },
        {
          input: `1: echo "test"
2: ls -la
3: exit`,
          expected: `echo "test"
ls -la
exit`
        },
        {
          input: `[1] echo "test"
[2] ls -la
[3] exit`,
          expected: `echo "test"
ls -la
exit`
        }
      ];

      testCases.forEach(({ input, expected }) => {
        const result = removeLineNumbers(input);
        expect(result).toBe(expected);
      });
    });

    test('R.1.3 - Preserve indentation and special content', () => {
      const codeWithNumbers = `1    if [ -f file.txt ]; then
2      echo "File exists"
3    fi
4  
5    # Comment line
6    echo "Done"`;
      
      const result = removeLineNumbers(codeWithNumbers);
      
      expect(result).toContain('if [ -f file.txt ]; then');
      expect(result).toContain('  echo "File exists"');  // Preserve indentation
      expect(result).toContain('fi');
      expect(result).toContain('# Comment line');
      expect(result).toContain('echo "Done"');
    });
  });
});
