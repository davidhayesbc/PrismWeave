// Generated by Copilot
// Tests for MarkdownConverter - TurndownService integration

import { IDocumentMetadata } from '../../types/index.js';
import { MarkdownConverter } from '../../utils/markdown-converter';

// Mock the global TurndownService for testing
const mockTurndownService = {
  turndown: jest.fn(),
  addRule: jest.fn(),
  remove: jest.fn(),
  use: jest.fn(),
};

// Helper function to create test metadata
const createTestMetadata = (url: string = 'https://example.com'): IDocumentMetadata => ({
  title: 'Test Title',
  url,
  captureDate: new Date().toISOString(),
  tags: ['test'],
  author: 'Test Author',
  wordCount: 100,
  estimatedReadingTime: 1,
});

describe('MarkdownConverter - TurndownService Integration', () => {
  let markdownConverter: MarkdownConverter;
  let originalWindow: any;
  let originalGlobalThis: any;
  beforeEach(() => {
    jest.clearAllMocks();

    // Store original values
    originalWindow = (global as any).window;
    originalGlobalThis = (global as any).globalThis;

    // Reset console spy
    jest.spyOn(console, 'warn').mockImplementation(() => {});
    jest.spyOn(console, 'info').mockImplementation(() => {});

    // Reset TurndownService mock
    mockTurndownService.turndown.mockClear();
    mockTurndownService.addRule.mockClear();
    mockTurndownService.remove.mockClear();
    mockTurndownService.use.mockClear();
  });

  afterEach(() => {
    jest.restoreAllMocks();

    // Restore original values
    (global as any).window = originalWindow;
    (global as any).globalThis = originalGlobalThis;
  });

  describe('TurndownService Availability', () => {
    it('should use fallback conversion when TurndownService is not available', async () => {
      // Setup: No TurndownService available
      (global as any).window = undefined;

      markdownConverter = new MarkdownConverter();

      const testHtml = '<h1>Test Title</h1><p>Test paragraph with <strong>bold</strong> text.</p>';
      const testMetadata = createTestMetadata();
      const result = await markdownConverter.convertToMarkdown(testHtml, testMetadata);
      expect(result.markdown).toContain('# Test Title');
      expect(result.markdown).toContain('**bold**');
      expect(console.warn).toHaveBeenCalledWith(
        'TurndownService not available, attempting to load library dynamically'
      );
    });
    it('should initialize TurndownService when available in window', async () => {
      // Setup: TurndownService available in window
      const mockTurndownServiceConstructor = jest
        .fn()
        .mockImplementation(() => mockTurndownService);

      // Save original window
      const originalWindow = global.window;

      // Create a new window object with TurndownService
      const windowWithTurndown = {
        ...originalWindow,
        TurndownService: mockTurndownServiceConstructor,
      };

      // Set the global window AND make sure it's accessible to the MarkdownConverter
      (global as any).window = windowWithTurndown;

      // Also set global property for good measure
      (global as any).TurndownService = mockTurndownServiceConstructor;

      // Ensure globalThis doesn't have TurndownService to test window fallback
      (global as any).globalThis = { ...global.globalThis };
      delete (global as any).globalThis.TurndownService;

      mockTurndownService.turndown.mockReturnValue(
        '# Test Title\n\nTest paragraph with **bold** text.'
      );

      // Debug logging
      console.log('Test setup:', {
        windowHasTurndown: !!(global as any).window?.TurndownService,
        globalThisHasTurndown: !!(global as any).globalThis?.TurndownService,
        typeofWindow: typeof (global as any).window,
        windowUndefined: typeof (global as any).window === 'undefined',
        globalTurndown: !!(global as any).TurndownService,
      });

      markdownConverter = new MarkdownConverter();
      const testHtml = '<h1>Test Title</h1><p>Test paragraph with <strong>bold</strong> text.</p>';
      const testMetadata = createTestMetadata();
      const result = await markdownConverter.convertToMarkdown(testHtml, testMetadata);

      // Debug the result instead of using expect for now
      console.log('Mock was called?', mockTurndownServiceConstructor.mock.calls.length > 0);
      console.log('AddRule was called?', mockTurndownService.addRule.mock.calls.length > 0);

      // Use traditional Jest assertions
      if (mockTurndownServiceConstructor.mock.calls.length === 0) {
        throw new Error('TurndownService constructor was not called');
      }

      if (mockTurndownService.addRule.mock.calls.length === 0) {
        throw new Error('TurndownService addRule was not called');
      }

      // Restore original window
      (global as any).window = originalWindow;
      delete (global as any).TurndownService;
    });

    it('should initialize TurndownService when available in globalThis', async () => {
      // Setup: TurndownService available in globalThis but not window
      (global as any).window = {};
      const mockTurndownServiceConstructor = jest
        .fn()
        .mockImplementation(() => mockTurndownService);
      (global as any).globalThis = {
        TurndownService: mockTurndownServiceConstructor,
      };

      mockTurndownService.turndown.mockReturnValue('# Test Title\n\nTest paragraph.');

      markdownConverter = new MarkdownConverter();
      const testHtml = '<h1>Test Title</h1><p>Test paragraph.</p>';
      const testMetadata = createTestMetadata();
      const result = await markdownConverter.convertToMarkdown(testHtml, testMetadata);

      // Manual assertions to avoid Jest environment issues
      if (!mockTurndownServiceConstructor.mock.calls.length) {
        throw new Error('Expected TurndownService constructor to have been called');
      }
      console.log('âœ“ TurndownService constructor was called successfully');
    });
  });

  describe('Fallback Conversion', () => {
    beforeEach(() => {
      // Setup: No TurndownService available - use fallback
      (global as any).window = undefined;
      markdownConverter = new MarkdownConverter();
    });

    it('should convert basic HTML elements with fallback converter', async () => {
      const testHtml = `
        <h1>Main Title</h1>
        <h2>Subtitle</h2>
        <p>This is a paragraph with <strong>bold</strong> and <em>italic</em> text.</p>
        <ul>
          <li>First item</li>
          <li>Second item</li>
        </ul>
        <a href="https://example.com">Link text</a>
      `;

      const result = await markdownConverter.convertToMarkdown(testHtml, createTestMetadata());

      expect(result.markdown).toContain('# Main Title');
      expect(result.markdown).toContain('## Subtitle');
      expect(result.markdown).toContain('**bold**');
      expect(result.markdown).toContain('*italic*');
      expect(result.markdown).toContain('- First item');
      expect(result.markdown).toContain('[Link text](https://example.com)');
    });

    it('should handle code blocks with fallback converter', async () => {
      const testHtml = `
        <pre><code class="language-javascript">console.log('Hello, World!');</code></pre>
        <p>Inline <code>code</code> example.</p>
      `;

      const result = await markdownConverter.convertToMarkdown(testHtml, createTestMetadata()); // Fallback converter doesn't extract language from class, just uses basic ```
      // Be flexible with whitespace and formatting
      expect(result.markdown).toContain('```');
      expect(result.markdown).toContain("console.log('Hello, World!');");
      expect(result.markdown).toContain('`code`');
    });

    it('should handle images with fallback converter', async () => {
      const testHtml =
        '<img src="https://example.com/image.jpg" alt="Test Image" title="Image Title">';

      const result = await markdownConverter.convertToMarkdown(testHtml, createTestMetadata());

      // Fallback converter doesn't handle title attribute
      expect(result.markdown).toContain('![Test Image](https://example.com/image.jpg)');
    });

    it('should handle tables with fallback converter', async () => {
      const testHtml = `
        <table>
          <thead>
            <tr>
              <th>Header 1</th>
              <th>Header 2</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Cell 1</td>
              <td>Cell 2</td>
            </tr>
          </tbody>
        </table>
      `;

      const result = await markdownConverter.convertToMarkdown(testHtml, createTestMetadata());

      // Fallback converter doesn't handle tables - just extracts text content
      expect(result.markdown).toContain('Header 1');
      expect(result.markdown).toContain('Header 2');
      expect(result.markdown).toContain('Cell 1');
      expect(result.markdown).toContain('Cell 2');
    });
  });

  describe('Error Handling', () => {
    it('should handle malformed HTML gracefully', async () => {
      (global as any).window = undefined;
      markdownConverter = new MarkdownConverter();

      const malformedHtml =
        '<h1>Unclosed header<p>Missing closing tags<div>Nested improperly</h1></p>';
      const result = await markdownConverter.convertToMarkdown(malformedHtml, createTestMetadata());

      expect(result.markdown).toBeDefined();
      expect(typeof result.markdown).toBe('string');
    });

    it('should handle empty or null input', async () => {
      (global as any).window = undefined;
      markdownConverter = new MarkdownConverter();

      const result1 = await markdownConverter.convertToMarkdown('', createTestMetadata());
      const result2 = await markdownConverter.convertToMarkdown('   ', createTestMetadata());

      expect(result1.markdown).toBeDefined();
      expect(result2.markdown).toBeDefined();
    });
  });
});
