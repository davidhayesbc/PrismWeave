// Generated by Copilot
// Tests for ContentCaptureService - Consolidated manager functionality
// Tests content extraction, document processing, and page capture workflow

// Mock all external dependencies first
jest.mock('../../utils/settings-manager');
jest.mock('../../utils/github-file-manager');
jest.mock('../../utils/logger', () => ({
  createLogger: jest.fn(() => ({
    debug: jest.fn(),
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn(),
  })),
}));
jest.mock('../../utils/shared-utils', () => ({
  __esModule: true,
  default: {
    generateFilename: jest.fn(
      (title, url) => `${new Date().toISOString().split('T')[0]}-test-file.md`
    ),
    sanitizeFilename: jest.fn(name => name.replace(/[<>:"/\\|?*]/g, '-')),
    sanitizeForFilename: jest.fn(name =>
      name
        .toLowerCase()
        .replace(/[^a-z0-9-]/g, '-')
        .replace(/-+/g, '-')
    ),
    sanitizeDomain: jest.fn(domain => domain.replace(/[^a-z0-9-]/g, '-')),
    formatDateForFilename: jest.fn(() => '2024-01-15'),
    extractDomain: jest.fn(url => {
      try {
        return new URL(url).hostname;
      } catch {
        return 'unknown';
      }
    }),
    generateFrontmatter: jest.fn(
      metadata => `---\ntitle: "${metadata.title}"\nurl: "${metadata.url}"\n---\n`
    ),
    formatYamlValue: jest.fn(value => {
      if (typeof value === 'string') {
        return `"${value}"`;
      }
      if (Array.isArray(value)) {
        return `[${value.map(v => `"${v}"`).join(', ')}]`;
      }
      return String(value);
    }),
    isValidUrl: jest.fn(url => {
      try {
        new URL(url);
        return true;
      } catch {
        return false;
      }
    }),
    autoDetectFolder: jest.fn(content => {
      if (
        content.toLowerCase().includes('javascript') ||
        content.toLowerCase().includes('programming')
      ) {
        return 'tech';
      }
      return 'general';
    }),
  },
}));

import { ContentCaptureService } from '../../utils/content-capture-service';
import { GitHubFileManager } from '../../utils/github-file-manager';
import { SettingsManager } from '../../utils/settings-manager';

// Mock Chrome APIs
const mockChrome = {
  tabs: {
    get: jest.fn(),
    query: jest.fn(),
    sendMessage: jest.fn(),
  },
  scripting: {
    executeScript: jest.fn(),
  },
  storage: {
    local: {
      set: jest.fn(),
      get: jest.fn(),
    },
    sync: {
      set: jest.fn(),
      get: jest.fn(),
    },
  },
  runtime: {
    lastError: null,
    getURL: jest.fn(),
  },
};

(global as any).chrome = mockChrome;

// Mock SettingsManager

describe('ContentCaptureService - Consolidated Manager Tests', () => {
  let service: ContentCaptureService;
  let mockSettingsManager: jest.Mocked<SettingsManager>;
  let mockGitHubManager: jest.Mocked<GitHubFileManager>;

  beforeEach(() => {
    jest.clearAllMocks();

    // Reset Chrome API mocks
    mockChrome.runtime.lastError = null;
    mockChrome.tabs.get.mockClear();
    mockChrome.tabs.query.mockClear();
    mockChrome.tabs.sendMessage.mockClear();
    mockChrome.scripting.executeScript.mockClear();
    mockChrome.storage.local.set.mockClear();
    mockChrome.storage.local.get.mockClear();
    mockChrome.storage.sync.set.mockClear();
    mockChrome.storage.sync.get.mockClear();

    // Setup mock settings manager
    mockSettingsManager = new SettingsManager() as jest.Mocked<SettingsManager>;
    mockSettingsManager.getSettings.mockResolvedValue({
      githubToken: 'test-token',
      githubRepo: 'test-user/test-repo',
      defaultFolder: 'auto',
      customFolder: '',
      autoCommit: true,
      fileNamingPattern: 'YYYY-MM-DD-domain-title',
      captureImages: true,
      removeAds: true,
      removeNavigation: true,
      customSelectors: '',
      commitMessageTemplate: 'Add captured content: {title} ({domain})',
      debugMode: false,
      showNotifications: true,
      enableKeyboardShortcuts: true,
    });

    mockSettingsManager.validateSettings.mockReturnValue({
      isValid: true,
      errors: [],
    });

    // Create service with mocked dependencies
    service = new ContentCaptureService(mockSettingsManager);

    // Setup GitHub manager mock after service creation
    mockGitHubManager = (service as any).githubManager;
    if (mockGitHubManager) {
      mockGitHubManager.commitToGitHub = jest.fn();
      mockGitHubManager.testConnection = jest.fn();
    }
  });

  describe('I. Content Extraction', () => {
    const mockTab = {
      id: 123,
      url: 'https://example.com/test-article',
      title: 'Test Article',
    };

    beforeEach(() => {
      mockChrome.tabs.get.mockResolvedValue(mockTab);
    });

    test('I.1 - Should extract content using content script strategy', async () => {
      // Mock successful content script injection and response
      mockChrome.tabs.sendMessage
        .mockImplementationOnce((tabId, message, callback) => {
          // First call: PING - respond with success
          callback({ success: true });
        })
        .mockImplementationOnce((tabId, message, callback) => {
          // Second call: EXTRACT_AND_CONVERT_TO_MARKDOWN
          callback({
            success: true,
            data: {
              markdown: '# Test Article\n\nThis is test content.',
              frontmatter: '---\ntitle: "Test Article"\n---\n',
              title: 'Test Article',
              url: 'https://example.com/test-article',
              html: '<h1>Test Article</h1><p>This is test content.</p>',
              metadata: { author: 'Test Author' },
              images: [],
            },
            extractionMethod: 'content-script',
            timestamp: new Date().toISOString(),
          });
        });

      const result = await service.extractContent(123);

      expect(result.success).toBe(true);
      expect(result.data?.title).toBe('Test Article');
      expect(result.data?.markdown).toContain('# Test Article');
      expect(result.extractionMethod).toBe('content-script');
    });

    test('I.2 - Should fallback to direct extraction when content script fails', async () => {
      // Mock content script ping failure
      mockChrome.tabs.sendMessage.mockImplementation((tabId, message, callback) => {
        // Simulate timeout/failure
        setTimeout(() => callback(null), 100);
      });

      // Mock successful direct extraction
      mockChrome.scripting.executeScript.mockResolvedValue([
        {
          result: {
            title: 'Test Article',
            url: 'https://example.com/test-article',
            html: '<h1>Test Article</h1><p>Direct extraction content.</p>',
            metadata: { description: 'Test description' },
          },
        },
      ]);

      const result = await service.extractContent(123);

      expect(result.success).toBe(true);
      expect(result.data?.title).toBe('Test Article');
      expect(result.extractionMethod).toBe('direct');
    });

    test('I.3 - Should use basic fallback when all extraction methods fail', async () => {
      // Mock all extraction methods failing
      mockChrome.tabs.sendMessage.mockImplementation((tabId, message, callback) => {
        setTimeout(() => callback(null), 100);
      });

      mockChrome.scripting.executeScript.mockRejectedValue(new Error('Script execution failed'));

      const result = await service.extractContent(123);

      expect(result.success).toBe(true);
      expect(result.data?.title).toBe('Test Article');
      expect(result.extractionMethod).toBe('basic-fallback');
      expect(result.data?.markdown).toContain('Content extraction failed');
    });

    test('I.4 - Should reject special pages (chrome://, extension pages)', async () => {
      const specialTab = {
        id: 123,
        url: 'chrome://settings',
        title: 'Settings',
      };

      mockChrome.tabs.get.mockResolvedValue(specialTab);

      await expect(service.extractContent(123)).rejects.toThrow(
        'Cannot extract content from special pages'
      );
    });
  });

  describe('II. Document Processing', () => {
    const mockSettings = {
      defaultFolder: 'auto',
      customFolder: '',
      fileNamingPattern: 'YYYY-MM-DD-domain-title',
    };

    test('II.1 - Should process document with all metadata', () => {
      const content = '# Test Article\n\nThis is test content.';
      const title = 'Test Article';
      const url = 'https://example.com/test-article';
      const metadata = {
        author: 'Test Author',
        description: 'Test description',
        keywords: 'test, article, tutorial',
      };

      const result = service.processDocument(content, title, url, metadata, mockSettings);

      expect(result.filename).toMatch(/\d{4}-\d{2}-\d{2}.*test-article\.md/);
      expect(result.folder).toBeDefined();
      expect(result.filePath).toContain('documents/');
      expect(result.content).toContain('---\n'); // Has frontmatter
      expect(result.content).toContain('title: "Test Article"');
      expect(result.content).toContain('url: "https://example.com/test-article"');
      expect(result.metadata.title).toBe(title);
      expect(result.metadata.url).toBe(url);
      expect(result.metadata.tags).toEqual(['test', 'article', 'tutorial']);
    });

    test('II.2 - Should auto-detect folder based on content', () => {
      const content = '# JavaScript Tutorial\n\nLearn JavaScript programming.';
      const title = 'JavaScript Tutorial';
      const url = 'https://developer.mozilla.org/javascript-tutorial';
      const metadata = { keywords: 'javascript, programming, tutorial' };

      const result = service.processDocument(content, title, url, metadata, mockSettings);

      expect(result.folder).toBe('tech'); // Should detect as tech content
    });

    test('II.3 - Should use custom folder when specified', () => {
      const customSettings = {
        ...mockSettings,
        defaultFolder: 'custom',
        customFolder: 'my-custom-folder',
      };

      const result = service.processDocument(
        '# Test',
        'Test',
        'https://example.com',
        {},
        customSettings
      );

      expect(result.folder).toBe('my-custom-folder');
    });

    test('II.4 - Should handle filename generation edge cases', () => {
      const title = 'Article with Special Characters: <>&"\'';
      const url = 'https://example.com/special-chars?param=value';

      const result = service.processDocument(title, title, url, {}, mockSettings);

      // Should sanitize special characters
      expect(result.filename).not.toMatch(/[<>&"']/);
      expect(result.filename).toMatch(/\.md$/);
    });

    test('II.5 - Should generate proper frontmatter', () => {
      const metadata = {
        author: 'Test Author',
        wordCount: 500,
        estimatedReadingTime: 3,
      };

      const result = service.processDocument(
        '# Test',
        'Test Article',
        'https://example.com',
        metadata,
        mockSettings
      );

      expect(result.content).toContain('author: "Test Author"');
      expect(result.content).toContain('wordCount: 500');
      expect(result.content).toContain('readingTime: "3 min"');
    });
  });

  describe('III. Page Capture Workflow', () => {
    const mockActiveTab = {
      id: 123,
      url: 'https://example.com/test-article',
      title: 'Test Article',
    };

    beforeEach(() => {
      mockChrome.tabs.query.mockResolvedValue([mockActiveTab]);
      mockChrome.tabs.get.mockResolvedValue(mockActiveTab);

      // Mock successful content extraction
      mockChrome.tabs.sendMessage.mockImplementation((tabId, message, callback) => {
        if (message.type === 'PING') {
          callback({ success: true });
        } else if (message.type === 'EXTRACT_AND_CONVERT_TO_MARKDOWN') {
          callback({
            success: true,
            data: {
              markdown: '# Test Article\n\nTest content.',
              frontmatter: '---\ntitle: "Test Article"\n---\n',
              title: 'Test Article',
              url: 'https://example.com/test-article',
              metadata: {},
              images: [],
            },
          });
        }
      });
    });

    test('III.1 - Should complete full capture workflow with GitHub commit', async () => {
      // Mock successful GitHub commit
      mockGitHubManager.commitToGitHub = jest.fn().mockResolvedValue({
        success: true,
        data: { html_url: 'https://github.com/test-user/test-repo/commit/abc123' },
      });

      const result = await service.capturePage({}, { forceGitHubCommit: true });

      expect(result.success).toBe(true);
      expect(result.message).toContain('captured and committed');
      expect(result.data?.commitUrl).toContain('github.com');
      expect(mockGitHubManager.commitToGitHub).toHaveBeenCalled();
    });

    test('III.2 - Should fallback to local storage when GitHub commit fails', async () => {
      // Mock GitHub commit failure
      mockGitHubManager.commitToGitHub = jest.fn().mockResolvedValue({
        success: false,
        error: 'GitHub API error',
      });

      // Mock local storage
      mockChrome.storage.local.set.mockResolvedValue(undefined);

      const result = await service.capturePage({}, { forceGitHubCommit: true });

      expect(result.success).toBe(true);
      expect(result.message).toContain('stored locally');
      expect(result.data?.status).toBe('pending_sync');
      expect(mockChrome.storage.local.set).toHaveBeenCalled();
    });

    test('III.3 - Should validate settings when requested', async () => {
      mockSettingsManager.validateSettings.mockReturnValue({
        isValid: false,
        errors: ['Invalid GitHub token'],
      });

      const result = await service.capturePage({}, { validateSettings: true });

      expect(result.success).toBe(false);
      expect(result.message).toContain('Invalid settings');
    });

    test('III.4 - Should include markdown in response when requested', async () => {
      mockGitHubManager.commitToGitHub = jest.fn().mockResolvedValue({
        success: true,
        data: { html_url: 'https://github.com/test-user/test-repo/commit/abc123' },
      });

      const result = await service.capturePage(
        {},
        {
          forceGitHubCommit: true,
          includeMarkdown: true,
        }
      );

      expect(result.success).toBe(true);
      expect(result.data?.markdown).toBeDefined();
      expect(result.data?.markdown).toContain('# Test Article');
    });

    test('III.5 - Should handle no active tab scenario', async () => {
      mockChrome.tabs.query.mockResolvedValue([]);

      const result = await service.capturePage();

      expect(result.success).toBe(false);
      expect(result.message).toContain('No active tab found');
    });
  });

  describe('IV. GitHub Integration', () => {
    test('IV.1 - Should test GitHub connection successfully', async () => {
      mockGitHubManager.testConnection = jest.fn().mockResolvedValue({
        success: true,
        status: 'connected',
        message: 'Connection successful',
      });

      const result = await service.testGitHubConnection();

      expect(result).toEqual(
        expect.objectContaining({
          success: true,
          status: 'connected',
          timestamp: expect.any(String),
        })
      );
    });

    test('IV.2 - Should handle missing GitHub credentials', async () => {
      mockSettingsManager.getSettings.mockResolvedValue({
        githubToken: '',
        githubRepo: '',
      } as any);

      const result = await service.testGitHubConnection();

      expect(result).toEqual(
        expect.objectContaining({
          success: false,
          status: 'failed',
          error: 'GitHub token and repository are required',
        })
      );
    });

    test('IV.3 - Should handle GitHub connection errors', async () => {
      mockGitHubManager.testConnection = jest.fn().mockRejectedValue(new Error('Network error'));

      const result = await service.testGitHubConnection();

      expect(result).toEqual(
        expect.objectContaining({
          success: false,
          status: 'failed',
          error: 'Network error',
        })
      );
    });
  });

  describe('V. Error Handling and Edge Cases', () => {
    test('V.1 - Should handle extraction timeout gracefully', async () => {
      mockChrome.tabs.sendMessage.mockImplementation((tabId, message, callback) => {
        // Simulate timeout by never calling callback
      });

      mockChrome.scripting.executeScript.mockRejectedValue(new Error('Script timeout'));

      const result = await service.extractContent(123);

      expect(result.success).toBe(true);
      expect(result.extractionMethod).toBe('basic-fallback');
    });

    test('V.2 - Should handle malformed URLs in document processing', () => {
      const result = service.processDocument(
        '# Test',
        'Test',
        'not-a-valid-url',
        {},
        { defaultFolder: 'auto' }
      );

      expect(result.filename).toContain('unknown'); // Should use unknown domain
      expect(result.filePath).toBeDefined();
    });

    test('V.3 - Should handle empty content gracefully', () => {
      const result = service.processDocument(
        '',
        '',
        'https://example.com',
        {},
        { defaultFolder: 'auto' }
      );

      expect(result.filename).toMatch(/\.md$/);
      expect(result.content).toContain('---\n'); // Should still have frontmatter
    });

    test('V.4 - Should handle Chrome API errors', async () => {
      mockChrome.tabs.get.mockRejectedValue(new Error('Tab not found'));

      await expect(service.extractContent(999)).rejects.toThrow('Tab not found');
    });
  });

  describe('VI. Performance and Optimization', () => {
    test('VI.1 - Should reuse content script when already injected', async () => {
      // Mock content script already active for this test
      const localMockChrome = {
        ...mockChrome,
        tabs: {
          ...mockChrome.tabs,
          get: jest.fn().mockResolvedValue({
            id: 123,
            url: 'https://example.com/test-article',
            title: 'Test Article',
          }),
          sendMessage: jest
            .fn()
            .mockImplementationOnce((tabId, message, callback) => {
              callback({ success: true }); // PING success
            })
            .mockImplementationOnce((tabId, message, callback) => {
              callback({
                success: true,
                data: { markdown: '# Test', title: 'Test' },
              });
            }),
        },
        scripting: {
          ...mockChrome.scripting,
          executeScript: jest.fn(),
        },
      };

      // Temporarily replace chrome for this test
      const originalChrome = (global as any).chrome;
      (global as any).chrome = localMockChrome;

      const localService = new ContentCaptureService(mockSettingsManager);
      await localService.extractContent(123);

      // Should not inject script if already active
      expect(localMockChrome.scripting.executeScript).not.toHaveBeenCalled();

      // Restore original chrome
      (global as any).chrome = originalChrome;
    });

    test('VI.2 - Should handle concurrent extraction requests', async () => {
      const mockExtractionResponse = {
        success: true,
        data: { markdown: '# Test', title: 'Test' },
      };

      mockChrome.tabs.get.mockResolvedValue({
        id: 123,
        url: 'https://example.com/test-article',
        title: 'Test Article',
      });

      mockChrome.tabs.sendMessage.mockImplementation((tabId, message, callback) => {
        if (message.type === 'PING') {
          callback({ success: true });
        } else {
          callback(mockExtractionResponse);
        }
      });

      // Make multiple concurrent requests
      const promises = [
        service.extractContent(123),
        service.extractContent(123),
        service.extractContent(123),
      ];

      const results = await Promise.all(promises);

      results.forEach(result => {
        expect(result.success).toBe(true);
      });
    });
  });
});
