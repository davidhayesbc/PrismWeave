// Generated by Copilot
// Git Operations Tests - File Overwrite Functionality

import { IDocumentMetadata, ISettings } from '../../types/index';
import { GitOperations } from '../../utils/git-operations';

// Mock fetch for testing
global.fetch = jest.fn();

describe('GitOperations - File Overwrite', () => {
  let gitOps: GitOperations;
  let mockSettings: ISettings;
  let mockMetadata: IDocumentMetadata;

  beforeEach(() => {
    gitOps = new GitOperations();

    mockSettings = {
      githubToken: 'test-token-123',
      githubRepo: 'testuser/test-repo',
      defaultFolder: 'auto',
      customFolder: '',
    } as ISettings;

    mockMetadata = {
      title: 'Test Document',
      url: 'https://example.com/test',
      captureDate: new Date().toISOString(),
      tags: ['test'],
      author: 'Test Author',
      wordCount: 100,
      estimatedReadingTime: 2,
    } as IDocumentMetadata;

    // Clear all mocks
    jest.clearAllMocks();
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  describe('File Overwrite Logic', () => {
    test('should create new file when file does not exist', async () => {
      await gitOps.initialize(mockSettings);

      // Mock: File doesn't exist (404 response)
      (fetch as jest.Mock)
        .mockResolvedValueOnce({
          status: 404,
          ok: false,
          statusText: 'Not Found',
        })
        // Mock: Successful file creation
        .mockResolvedValueOnce({
          ok: true,
          status: 201,
          json: async () => ({
            commit: {
              sha: 'new-commit-sha-123',
              html_url: 'https://github.com/testuser/test-repo/commit/new-commit-sha-123',
            },
          }),
        });

      const result = await gitOps.saveToGitHub('Test content', 'test-file.md', mockMetadata);

      expect(result.success).toBe(true);
      expect(result.sha).toBe('new-commit-sha-123');

      // Verify fetch calls
      expect(fetch).toHaveBeenCalledTimes(2);

      // First call: Check if file exists
      expect(fetch).toHaveBeenNthCalledWith(
        1,
        expect.stringContaining('/contents/documents/'),
        expect.objectContaining({
          method: 'GET',
          headers: expect.objectContaining({
            Authorization: 'token test-token-123',
          }),
        })
      );

      // Second call: Create file (no SHA in body)
      expect(fetch).toHaveBeenNthCalledWith(
        2,
        expect.stringContaining('/contents/documents/'),
        expect.objectContaining({
          method: 'PUT',
          body: expect.not.stringContaining('"sha"'),
        })
      );
    });

    test('should update existing file with correct SHA', async () => {
      await gitOps.initialize(mockSettings);

      const existingFileSha = 'existing-file-sha-456';

      // Mock: File exists with SHA
      (fetch as jest.Mock)
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          json: async () => ({
            sha: existingFileSha,
            content: 'ZXhpc3RpbmcgY29udGVudA==', // base64 for "existing content"
            encoding: 'base64',
          }),
        })
        // Mock: Successful file update
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          json: async () => ({
            commit: {
              sha: 'updated-commit-sha-789',
              html_url: 'https://github.com/testuser/test-repo/commit/updated-commit-sha-789',
            },
          }),
        });

      const result = await gitOps.saveToGitHub('Updated content', 'existing-file.md', mockMetadata);

      expect(result.success).toBe(true);
      expect(result.sha).toBe('updated-commit-sha-789');

      // Verify fetch calls
      expect(fetch).toHaveBeenCalledTimes(2);

      // First call: Get existing file info
      expect(fetch).toHaveBeenNthCalledWith(
        1,
        expect.stringContaining('/contents/documents/'),
        expect.objectContaining({
          method: 'GET',
        })
      );

      // Second call: Update file WITH SHA
      const updateCall = (fetch as jest.Mock).mock.calls[1];
      const updateBody = JSON.parse(updateCall[1].body);

      expect(updateCall[1].method).toBe('PUT');
      expect(updateBody.sha).toBe(existingFileSha);
      expect(updateBody.message).toContain('Update captured content');
    });

    test('should handle file existence check errors gracefully', async () => {
      await gitOps.initialize(mockSettings);

      // Mock: Network error on file existence check
      (fetch as jest.Mock)
        .mockRejectedValueOnce(new Error('Network error'))
        // Mock: Still try to create file (will fail if file exists)
        .mockResolvedValueOnce({
          ok: false,
          status: 422,
          statusText: 'Unprocessable Entity',
          text: async () => 'File already exists',
        });

      const result = await gitOps.saveToGitHub('Test content', 'test-file.md', mockMetadata);

      expect(result.success).toBe(false);
      expect(result.error).toContain('GitHub API error: 422');
    });

    test('should generate correct commit message for updates vs creates', async () => {
      await gitOps.initialize(mockSettings);

      // Test update scenario
      (fetch as jest.Mock)
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          json: async () => ({
            sha: 'existing-sha',
            content: 'content',
            encoding: 'base64',
          }),
        })
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          json: async () => ({
            commit: { sha: 'commit-sha', html_url: 'url' },
          }),
        });

      await gitOps.saveToGitHub('content', 'file.md', mockMetadata);

      const updateCall = (fetch as jest.Mock).mock.calls[1];
      const updateBody = JSON.parse(updateCall[1].body);

      expect(updateBody.message).toContain('Update captured content');
      expect(updateBody.message).toContain('Test Document');
      expect(updateBody.message).toContain('example.com');

      jest.clearAllMocks();

      // Test create scenario
      (fetch as jest.Mock)
        .mockResolvedValueOnce({
          status: 404,
          ok: false,
        })
        .mockResolvedValueOnce({
          ok: true,
          status: 201,
          json: async () => ({
            commit: { sha: 'new-commit-sha', html_url: 'url' },
          }),
        });

      await gitOps.saveToGitHub('content', 'new-file.md', mockMetadata);

      const createCall = (fetch as jest.Mock).mock.calls[1];
      const createBody = JSON.parse(createCall[1].body);

      expect(createBody.message).toContain('Add captured content');
      expect(createBody.message).toContain('Test Document');
    });

    test('should properly encode content for GitHub API', async () => {
      await gitOps.initialize(mockSettings);

      const testContent = 'Test content with unicode: ðŸš€ and special chars: <>&"\'';

      (fetch as jest.Mock).mockResolvedValueOnce({ status: 404, ok: false }).mockResolvedValueOnce({
        ok: true,
        status: 201,
        json: async () => ({
          commit: { sha: 'sha', html_url: 'url' },
        }),
      });

      await gitOps.saveToGitHub(testContent, 'test.md', mockMetadata);

      const createCall = (fetch as jest.Mock).mock.calls[1];
      const createBody = JSON.parse(createCall[1].body);

      // Decode the content to verify it was encoded correctly
      const decodedContent = decodeURIComponent(escape(atob(createBody.content)));

      expect(decodedContent).toContain('Test content with unicode: ðŸš€');
      expect(decodedContent).toContain('special chars: <>&"\'');
      expect(decodedContent).toContain('title: "Test Document"');
      expect(decodedContent).toContain('url: "https://example.com/test"');
    });

    test('should handle different repository path formats', async () => {
      // Test with GitHub URL format
      const urlSettings = {
        ...mockSettings,
        githubRepo: 'https://github.com/testuser/test-repo.git',
      };

      await gitOps.initialize(urlSettings);

      (fetch as jest.Mock).mockResolvedValueOnce({ status: 404, ok: false }).mockResolvedValueOnce({
        ok: true,
        status: 201,
        json: async () => ({ commit: { sha: 'sha', html_url: 'url' } }),
      });

      await gitOps.saveToGitHub('content', 'test.md', mockMetadata);

      // Verify the API endpoint was constructed correctly
      expect(fetch).toHaveBeenCalledWith(
        expect.stringContaining('/repos/testuser/test-repo/contents/'),
        expect.any(Object)
      );
    });
  });

  describe('Edge Cases', () => {
    test('should handle empty content', async () => {
      await gitOps.initialize(mockSettings);

      (fetch as jest.Mock).mockResolvedValueOnce({ status: 404, ok: false }).mockResolvedValueOnce({
        ok: true,
        status: 201,
        json: async () => ({ commit: { sha: 'sha', html_url: 'url' } }),
      });

      const result = await gitOps.saveToGitHub('', 'empty.md', mockMetadata);

      expect(result.success).toBe(true);

      const createCall = (fetch as jest.Mock).mock.calls[1];
      const createBody = JSON.parse(createCall[1].body);
      const decodedContent = decodeURIComponent(escape(atob(createBody.content)));

      // Should still have frontmatter even with empty content
      expect(decodedContent).toContain('---');
      expect(decodedContent).toContain('title: "Test Document"');
    });

    test('should handle missing SHA in existing file response', async () => {
      await gitOps.initialize(mockSettings);

      // Mock: File exists but response is malformed (no SHA)
      (fetch as jest.Mock)
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          json: async () => ({
            // Missing sha field
            content: 'content',
            encoding: 'base64',
          }),
        })
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          json: async () => ({
            commit: { sha: 'commit-sha', html_url: 'url' },
          }),
        });

      const result = await gitOps.saveToGitHub('content', 'file.md', mockMetadata);

      expect(result.success).toBe(true);

      // Should attempt update but without SHA (GitHub will handle this)
      const updateCall = (fetch as jest.Mock).mock.calls[1];
      const updateBody = JSON.parse(updateCall[1].body);

      expect(updateBody.sha).toBeUndefined();
    });
  });
});
