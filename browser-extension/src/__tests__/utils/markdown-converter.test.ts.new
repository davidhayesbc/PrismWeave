// Generated by Copilot
// Tests for MarkdownConverter - TurndownService integration

import { IDocumentMetadata } from '../../types/index.js';
import { MarkdownConverter } from '../../utils/markdown-converter';

// Mock the global TurndownService for testing
const mockTurndownService = {
  turndown: jest.fn(),
  addRule: jest.fn(),
  remove: jest.fn(),
  use: jest.fn(),
};

// Helper function to create test metadata
const createTestMetadata = (url: string = 'https://example.com'): IDocumentMetadata => ({
  title: 'Test Title',
  url,
  captureDate: new Date().toISOString(),
  tags: ['test'],
  author: 'Test Author',
  wordCount: 100,
  estimatedReadingTime: 1,
});

describe('MarkdownConverter - TurndownService Integration', () => {
  let markdownConverter: MarkdownConverter;
  let originalWindow: any;
  let originalGlobalThis: any;

  beforeEach(() => {
    jest.clearAllMocks();

    // Store original values
    originalWindow = (global as any).window;
    originalGlobalThis = (global as any).globalThis;

    // Reset console spy
    jest.spyOn(console, 'warn').mockImplementation(() => {});
    jest.spyOn(console, 'info').mockImplementation(() => {});
  });

  afterEach(() => {
    jest.restoreAllMocks();
    
    // Restore original values
    (global as any).window = originalWindow;
    (global as any).globalThis = originalGlobalThis;
  });

  describe('TurndownService Availability', () => {
    it('should use fallback conversion when TurndownService is not available', async () => {
      // Setup: No TurndownService available
      (global as any).window = undefined;

      markdownConverter = new MarkdownConverter();

      const testHtml = '<h1>Test Title</h1><p>Test paragraph with <strong>bold</strong> text.</p>';
      const testMetadata = createTestMetadata();
      const result = await markdownConverter.convertToMarkdown(testHtml, testMetadata);

      expect(result.markdown).toContain('# Test Title');
      expect(result.markdown).toContain('**bold**');
      expect(console.warn).toHaveBeenCalledWith(
        'TurndownService not available, using enhanced fallback conversion'
      );
    });

    it('should initialize TurndownService when available in window', async () => {
      // Setup: TurndownService available in window
      (global as any).window = {
        TurndownService: jest.fn().mockImplementation(() => mockTurndownService),
      };

      mockTurndownService.turndown.mockReturnValue(
        '# Test Title\n\nTest paragraph with **bold** text.'
      );

      markdownConverter = new MarkdownConverter();
      const testHtml = '<h1>Test Title</h1><p>Test paragraph with <strong>bold</strong> text.</p>';
      const testMetadata = createTestMetadata();
      const result = await markdownConverter.convertToMarkdown(testHtml, testMetadata);

      expect((global as any).window.TurndownService).toHaveBeenCalled();
      expect(mockTurndownService.addRule).toHaveBeenCalled();
      expect(console.info).toHaveBeenCalledWith(
        'MarkdownConverter: Initializing TurndownService with enhanced rules'
      );
    });

    it('should initialize TurndownService when available in globalThis', async () => {
      // Setup: TurndownService available in globalThis but not window
      (global as any).window = {};
      (global as any).globalThis = {
        TurndownService: jest.fn().mockImplementation(() => mockTurndownService),
      };

      mockTurndownService.turndown.mockReturnValue('# Test Title\n\nTest paragraph.');

      markdownConverter = new MarkdownConverter();
      const testHtml = '<h1>Test Title</h1><p>Test paragraph.</p>';
      const testMetadata = createTestMetadata();
      const result = await markdownConverter.convertToMarkdown(testHtml, testMetadata);

      expect((global as any).globalThis.TurndownService).toHaveBeenCalled();
      expect(console.info).toHaveBeenCalledWith(
        'MarkdownConverter: Initializing TurndownService with enhanced rules'
      );
    });
  });

  describe('Fallback Conversion', () => {
    beforeEach(() => {
      // Setup: No TurndownService available - use fallback
      (global as any).window = undefined;
      markdownConverter = new MarkdownConverter();
    });

    it('should convert basic HTML elements with fallback converter', async () => {
      const testHtml = `
        <h1>Main Title</h1>
        <h2>Subtitle</h2>
        <p>This is a paragraph with <strong>bold</strong> and <em>italic</em> text.</p>
        <ul>
          <li>First item</li>
          <li>Second item</li>
        </ul>
        <a href="https://example.com">Link text</a>
      `;

      const result = await markdownConverter.convertToMarkdown(testHtml, createTestMetadata());

      expect(result.markdown).toContain('# Main Title');
      expect(result.markdown).toContain('## Subtitle');
      expect(result.markdown).toContain('**bold**');
      expect(result.markdown).toContain('*italic*');
      expect(result.markdown).toContain('- First item');
      expect(result.markdown).toContain('[Link text](https://example.com)');
    });

    it('should handle code blocks with fallback converter', async () => {
      const testHtml = `
        <pre><code class="language-javascript">console.log('Hello, World!');</code></pre>
        <p>Inline <code>code</code> example.</p>
      `;

      const result = await markdownConverter.convertToMarkdown(testHtml, createTestMetadata());

      expect(result.markdown).toContain("```javascript\nconsole.log('Hello, World!');\n```");
      expect(result.markdown).toContain('`code`');
    });

    it('should handle images with fallback converter', async () => {
      const testHtml =
        '<img src="https://example.com/image.jpg" alt="Test Image" title="Image Title">';

      const result = await markdownConverter.convertToMarkdown(testHtml, createTestMetadata());

      expect(result.markdown).toContain(
        '![Test Image](https://example.com/image.jpg "Image Title")'
      );
    });

    it('should handle tables with fallback converter', async () => {
      const testHtml = `
        <table>
          <thead>
            <tr>
              <th>Header 1</th>
              <th>Header 2</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Cell 1</td>
              <td>Cell 2</td>
            </tr>
          </tbody>
        </table>
      `;

      const result = await markdownConverter.convertToMarkdown(testHtml, createTestMetadata());

      expect(result.markdown).toContain('| Header 1 | Header 2 |');
      expect(result.markdown).toContain('|----------|----------|');
      expect(result.markdown).toContain('| Cell 1 | Cell 2 |');
    });
  });

  describe('Error Handling', () => {
    it('should handle malformed HTML gracefully', async () => {
      (global as any).window = undefined;
      markdownConverter = new MarkdownConverter();

      const malformedHtml =
        '<h1>Unclosed header<p>Missing closing tags<div>Nested improperly</h1></p>';
      const result = await markdownConverter.convertToMarkdown(malformedHtml, createTestMetadata());
      
      expect(result.markdown).toBeDefined();
      expect(typeof result.markdown).toBe('string');
    });

    it('should handle empty or null input', async () => {
      (global as any).window = undefined;
      markdownConverter = new MarkdownConverter();

      const result1 = await markdownConverter.convertToMarkdown('', createTestMetadata());
      const result2 = await markdownConverter.convertToMarkdown('   ', createTestMetadata());
      
      expect(result1.markdown).toBeDefined();
      expect(result2.markdown).toBeDefined();
    });
  });
});
