// Generated by Copilot
// Git Operations Fix Verification Test

import { IDocumentMetadata, ISettings } from '../../types/index';
import { GitOperations } from '../../utils/git-operations';

// Mock fetch for testing
global.fetch = jest.fn();

describe('GitOperations - File Overwrite Fix Verification', () => {
  let gitOps: GitOperations;
  let mockSettings: ISettings;
  let mockMetadata: IDocumentMetadata;

  beforeEach(() => {
    gitOps = new GitOperations();

    mockSettings = {
      githubToken: 'test-token-123',
      githubRepo: 'testuser/test-repo',
      defaultFolder: 'auto',
      customFolder: '',
    } as ISettings;

    mockMetadata = {
      title: 'Test Document',
      url: 'https://example.com/test',
      captureDate: new Date().toISOString(),
      tags: ['test'],
      author: 'Test Author',
      wordCount: 100,
      estimatedReadingTime: 2,
    } as IDocumentMetadata;

    jest.clearAllMocks();
  });

  test('FIXED: Should properly handle file overwrite with valid SHA', async () => {
    await gitOps.initialize(mockSettings);

    const validSha = 'abc123def456789';

    // Mock: Valid GitHub response with SHA
    (fetch as jest.Mock)
      .mockResolvedValueOnce({
        ok: true,
        status: 200,
        json: async () => ({
          sha: validSha,
          content: 'b2xkIGNvbnRlbnQ=', // "old content" in base64
          encoding: 'base64',
          name: 'test.md',
          path: 'documents/test/test.md',
        }),
      })
      // Mock: Successful update
      .mockResolvedValueOnce({
        ok: true,
        status: 200,
        json: async () => ({
          content: {
            sha: 'new-content-sha',
            html_url: 'https://github.com/testuser/test-repo/blob/main/documents/test/test.md',
          },
          commit: {
            sha: 'new-commit-sha',
            html_url: 'https://github.com/testuser/test-repo/commit/new-commit-sha',
          },
        }),
      });

    const result = await gitOps.saveToGitHub(
      '# Updated Content\n\nThis content should overwrite the existing file.',
      'test.md',
      mockMetadata
    );

    expect(result.success).toBe(true);
    expect(result.sha).toBe('new-commit-sha');

    // Verify the update request included the SHA
    const updateCall = (fetch as jest.Mock).mock.calls[1];
    const updateBody = JSON.parse(updateCall[1].body);
    expect(updateBody.sha).toBe(validSha);
    expect(updateBody.message).toContain('Update captured content');
  });

  test('FIXED: Should reject malformed GitHub response missing SHA', async () => {
    await gitOps.initialize(mockSettings);

    // Mock: Malformed GitHub response (missing SHA)
    (fetch as jest.Mock).mockResolvedValueOnce({
      ok: true,
      status: 200,
      json: async () => ({
        // Missing sha field - this should be caught now
        content: 'b2xkIGNvbnRlbnQ=',
        encoding: 'base64',
        name: 'test.md',
      }),
    });

    const result = await gitOps.saveToGitHub('New content', 'test.md', mockMetadata);

    expect(result.success).toBe(false);
    expect(result.error).toContain('missing SHA');
  });

  test('FIXED: Should provide helpful error messages for common failures', async () => {
    await gitOps.initialize(mockSettings);

    const testCases = [
      {
        name: 'Conflict error',
        mockResponse: {
          ok: false,
          status: 409,
          statusText: 'Conflict',
          text: async () => 'SHA does not match',
        },
        expectedError: 'File update conflict',
      },
      {
        name: 'Validation error',
        mockResponse: {
          ok: false,
          status: 422,
          statusText: 'Unprocessable Entity',
          text: async () => 'Invalid input',
        },
        expectedError: 'Invalid request',
      },
      {
        name: 'Not found error',
        mockResponse: {
          ok: false,
          status: 404,
          statusText: 'Not Found',
          text: async () => 'Repository not found',
        },
        expectedError: 'Repository not found',
      },
    ];

    for (const testCase of testCases) {
      jest.clearAllMocks();

      // Mock file exists
      (fetch as jest.Mock)
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          json: async () => ({
            sha: 'test-sha',
            content: 'content',
            encoding: 'base64',
          }),
        })
        // Mock the specific error
        .mockResolvedValueOnce(testCase.mockResponse);

      const result = await gitOps.saveToGitHub('content', 'test.md', mockMetadata);

      expect(result.success).toBe(false);
      expect(result.error).toContain(testCase.expectedError);
    }
  });

  test('FIXED: Should handle successful creation of new file', async () => {
    await gitOps.initialize(mockSettings);

    // Mock: File doesn't exist
    (fetch as jest.Mock)
      .mockResolvedValueOnce({
        status: 404,
        ok: false,
        statusText: 'Not Found',
      })
      // Mock: Successful creation
      .mockResolvedValueOnce({
        ok: true,
        status: 201,
        json: async () => ({
          content: {
            sha: 'new-file-sha',
            html_url: 'https://github.com/testuser/test-repo/blob/main/documents/test/new-file.md',
          },
          commit: {
            sha: 'creation-commit-sha',
            html_url: 'https://github.com/testuser/test-repo/commit/creation-commit-sha',
          },
        }),
      });

    const result = await gitOps.saveToGitHub(
      '# New File\n\nThis is a completely new file.',
      'new-file.md',
      mockMetadata
    );

    expect(result.success).toBe(true);
    expect(result.sha).toBe('creation-commit-sha');

    // Verify the creation request did NOT include SHA
    const createCall = (fetch as jest.Mock).mock.calls[1];
    const createBody = JSON.parse(createCall[1].body);
    expect(createBody.sha).toBeUndefined();
    expect(createBody.message).toContain('Add captured content');
  });

  test('FIXED: Should handle network errors gracefully', async () => {
    await gitOps.initialize(mockSettings);

    // Mock: Network error during file existence check
    (fetch as jest.Mock).mockRejectedValueOnce(new Error('Network timeout'));

    const result = await gitOps.saveToGitHub('content', 'test.md', mockMetadata);

    expect(result.success).toBe(false);
    expect(result.error).toContain('Network timeout');
  });

  test('INTEGRATION: Complete overwrite workflow', async () => {
    await gitOps.initialize(mockSettings);

    const originalSha = 'original-file-sha-123';
    const newCommitSha = 'updated-commit-sha-456';

    // Complete workflow: Check -> Update -> Success
    (fetch as jest.Mock)
      .mockResolvedValueOnce({
        ok: true,
        status: 200,
        json: async () => ({
          sha: originalSha,
          content: btoa('# Original Content\n\nThis is the original content.'),
          encoding: 'base64',
          name: 'integration-test.md',
          path: 'documents/tutorial/integration-test.md',
        }),
      })
      .mockResolvedValueOnce({
        ok: true,
        status: 200,
        json: async () => ({
          content: {
            sha: 'new-content-sha',
            html_url:
              'https://github.com/testuser/test-repo/blob/main/documents/tutorial/integration-test.md',
          },
          commit: {
            sha: newCommitSha,
            html_url: `https://github.com/testuser/test-repo/commit/${newCommitSha}`,
          },
        }),
      });

    const newContent = `# Updated Content

This is the completely new content that should replace the original file.

## Features
- Full file replacement
- Proper SHA handling  
- Commit message generation
- Metadata frontmatter

The old content should be completely overwritten.`;

    const result = await gitOps.saveToGitHub(newContent, 'integration-test.md', mockMetadata);

    // Verify success
    expect(result.success).toBe(true);
    expect(result.sha).toBe(newCommitSha);
    expect(result.url).toContain(newCommitSha);

    // Verify the complete workflow
    expect(fetch).toHaveBeenCalledTimes(2);

    // Check existence call
    const [existenceUrl, existenceOptions] = (fetch as jest.Mock).mock.calls[0];
    expect(existenceUrl).toContain('/contents/documents/tutorial/integration-test.md');
    expect(existenceOptions.method).toBe('GET');

    // Update call
    const [updateUrl, updateOptions] = (fetch as jest.Mock).mock.calls[1];
    const updateBody = JSON.parse(updateOptions.body);

    expect(updateUrl).toContain('/contents/documents/tutorial/integration-test.md');
    expect(updateOptions.method).toBe('PUT');
    expect(updateBody.sha).toBe(originalSha);
    expect(updateBody.message).toBe('Update captured content: Test Document (example.com)');

    // Verify content is properly encoded
    const decodedContent = decodeURIComponent(escape(atob(updateBody.content)));
    expect(decodedContent).toContain('Updated Content');
    expect(decodedContent).toContain('title: "Test Document"');
    expect(decodedContent).toContain('Full file replacement');
  });
});
