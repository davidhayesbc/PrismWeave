// Generated by Copilot
// Content Extractor Tests - Consolidated Test Suite
// Implements comprehensive test coverage with organized test suites

import { ContentExtractor } from '../../utils/content-extractor';
import { cleanupTest, createTestHTML, setupDOM } from '../test-helpers';

describe('VIII. ContentExtractor - Consolidated Test Suite', () => {
  let extractor: ContentExtractor;

  beforeEach(() => {
    extractor = new ContentExtractor();
    cleanupTest();
  });

  describe('VIII.1 Core Content Extraction', () => {
    test('VIII.1.1 - Extract main content from article pages', async () => {
      setupDOM(createTestHTML('article'));

      const result = await extractor.extractContent();

      expect(result).toBeDefined();
      expect(result.content).toContain('Understanding Modern Web Development');
      expect(result.content).toContain('Modern web development has evolved');
      expect(result.metadata).toBeDefined();
      expect(result.metadata.title).toBe('Understanding Modern Web Development - Complete Guide'); // Prefers og:title
      expect(result.metadata.author).toBe('Jane Developer');
      expect(result.wordCount).toBeGreaterThan(5);
    });

    test('C.1.2 - Extract content from blog posts', async () => {
      setupDOM(createTestHTML('blog'));

      const result = await extractor.extractContent();

      expect(result).toBeDefined();
      expect(result.content).toContain('10 Tips for Better Code Reviews');
      expect(result.content).toContain('Code reviews are an essential part');
      expect(result.wordCount).toBeGreaterThan(10);
      expect(result.readingTime).toBeGreaterThan(0);
    });

    test('C.1.3 - Handle pages with no clear main content', async () => {
      setupDOM(createTestHTML('generic'));

      const result = await extractor.extractContent();

      expect(result).toBeDefined();
      expect(result.content).toContain('scattered content');
      expect(result.content.length).toBeGreaterThan(0);
      expect(result.wordCount).toBeGreaterThan(0);
    });

    test('C.1.4 - Handle malformed HTML gracefully', async () => {
      setupDOM(createTestHTML('malformed'));

      const result = await extractor.extractContent();

      expect(result).toBeDefined();
      expect(result.content).toContain('Content with unclosed');
      expect(result.wordCount).toBeGreaterThan(0);
    });
  });

  describe('Content Cleaning and Filtering', () => {
    test('C.2.1 - Remove unwanted selectors (ads, navigation)', async () => {
      const htmlWithAds = `
        <head><title>Test Article</title></head>
        <body>
          <div class="main-content">
            <h1>Article Title</h1>
            <p>This is the main article content that should be preserved.</p>
            <div class="ad">Advertisement</div>
            <div class="advertisement">Sponsored Content</div>
            <p>More article content with valuable information.</p>
          </div>
        </body>
      `;

      setupDOM(htmlWithAds);

      const result = await extractor.extractContent();

      expect(result).toBeDefined();
      expect(result.content).toContain('Article Title');
      expect(result.content).toContain('main article content');
      expect(result.content).toContain('valuable information');
      // Ads should be removed by the content cleaning process
      expect(result.content).not.toContain('Advertisement');
      expect(result.content).not.toContain('Sponsored Content');
    });

    test('C.2.2 - Remove navigation elements while preserving content', async () => {
      const htmlWithNavigation = `
        <head><title>Test Article</title></head>
        <body>
          <nav>Navigation Menu</nav>
          <div class="navigation">Site Navigation</div>
          <header class="site-header">Header</header>
          <footer class="site-footer">Footer</footer>
          <aside class="sidebar">Sidebar</aside>
          
          <div class="main-content">
            <h1>Article Title</h1>
            <p>Main content paragraph with sufficient text for extraction.</p>
            <p>More valuable content that should be preserved.</p>
          </div>
        </body>
      `;

      setupDOM(htmlWithNavigation);

      const result = await extractor.extractContent();

      expect(result).toBeDefined();
      expect(result.content).toContain('Article Title');
      expect(result.content).toContain('Main content paragraph');
      expect(result.content).toContain('valuable content');
      // Navigation elements should be removed
      expect(result.content).not.toContain('Navigation Menu');
      expect(result.content).not.toContain('Site Navigation');
    });

    test('C.2.3 - Preserve formatting elements', async () => {
      const htmlWithFormatting = `
        <head><title>Technical Article</title></head>
        <body>
          <article class="main-content">
            <h1>Technical Article</h1>
            <h2>Introduction</h2>
            <p>This is a <strong>technical article</strong> with <em>important formatting</em>.</p>
            
            <pre><code>
              function example() {
                return "code block";
              }
            </code></pre>
            
            <ul>
              <li>First list item</li>
              <li>Second list item with <code>inline code</code></li>
            </ul>
            
            <blockquote>
              <p>This is an important quote that should be preserved.</p>
            </blockquote>
          </article>
        </body>
      `;

      setupDOM(htmlWithFormatting);

      const result = await extractor.extractContent();

      expect(result).toBeDefined();
      expect(result.content).toContain('Technical Article');
      expect(result.content).toContain('technical article');
      expect(result.content).toContain('function example');
      expect(result.content).toContain('First list item');
      expect(result.content).toContain('important quote');
      expect(result.wordCount).toBeGreaterThan(10);
    });

    test('C.2.4 - Handle custom selectors for removal', async () => {
      const htmlWithCustomElements = `
        <head><title>Article with Custom Elements</title></head>
        <body>
          <div class="main-content">
            <h1>Article with Custom Elements</h1>
            <p>Main content paragraph with enough text for meaningful extraction.</p>
            
            <div class="newsletter-signup">Subscribe to our newsletter!</div>
            <div class="social-share">Share this article</div>
            <div class="author-bio">About the author</div>
            <div class="related-posts">Related articles</div>
            <div data-tracking="analytics">Tracking element</div>
            <div class="custom-widget">Custom widget content</div>
            
            <p>More valuable content with additional text for testing purposes.</p>
          </div>
        </body>
      `;

      setupDOM(htmlWithCustomElements);

      const result = await extractor.extractContent();

      expect(result).toBeDefined();
      expect(result.content).toContain('Article with Custom Elements');
      expect(result.content).toContain('Main content paragraph');
      expect(result.content).toContain('valuable content');
      expect(result.wordCount).toBeGreaterThan(5);
    });

    test('C.2.5 - Clean malformed HTML and normalize whitespace', async () => {
      const malformedHtml = `
        <head><title>Malformed HTML Test</title></head>
        <body>
          <div class="main-content">
            <h1>Article Title</h1>
            
            <!-- Empty elements -->
            <p></p>
            <div></div>
            <span>   </span>
            <div>
              <p></p>
              <span></span>
            </div>
            
            <!-- Valid content -->
            <p>This paragraph has actual content with sufficient text for extraction.</p>
            
            <!-- Content with excessive whitespace -->
            <p>This    has     multiple    spaces    and
            
            
            line breaks for testing whitespace normalization.</p>
            
            <!-- Image should be preserved even in empty container -->
            <div>
              <img src="test.jpg" alt="Test image">
            </div>
          </div>
        </body>
      `;

      setupDOM(malformedHtml);

      const result = await extractor.extractContent();

      expect(result).toBeDefined();
      expect(result.content).toContain('Article Title');
      expect(result.content).toContain('actual content');
      expect(result.content).toContain('multiple');
      expect(result.content).toContain('spaces');
      expect(result.content).toContain('line breaks');
      expect(result.wordCount).toBeGreaterThan(5);
    });
  });

  describe('Content Quality Assessment', () => {
    test('C.4.1 - Calculate word count accurately', async () => {
      const contentHtml = `
        <head><title>Word Count Test</title></head>
        <body>
          <div class="content-text">
            <p>This is a test article with exactly twelve words in this sentence.</p>
          </div>
        </body>
      `;

      setupDOM(contentHtml);

      const result = await extractor.extractContent();

      expect(result.wordCount).toBe(12);
      expect(typeof result.wordCount).toBe('number');
    });

    test('C.4.2 - Estimate reading time based on word count', async () => {
      // Create content with approximately 300 words
      const longContent =
        'This is a comprehensive article with substantial content that demonstrates proper reading time estimation. '.repeat(
          30
        );
      const contentHtml = `
        <head><title>Reading Time Test</title></head>
        <body>
          <div class="content-text">
            <p>${longContent}</p>
          </div>
        </body>
      `;

      setupDOM(contentHtml);

      const result = await extractor.extractContent();

      expect(result.readingTime).toBeGreaterThan(0);
      expect(result.readingTime).toBeLessThan(10);
      expect(typeof result.readingTime).toBe('number');
    });

    test('C.4.3 - Calculate content quality score', () => {
      const qualityHtml = `
        <body>
          <article>
            <h1>High Quality Article</h1>
            <h2>Introduction</h2>
            <p>This is a comprehensive article with substantial content that demonstrates high quality standards.</p>
            <p>It contains multiple paragraphs with meaningful information and proper structural organization.</p>
            <p>The content is well-organized and provides significant value to readers through detailed explanations.</p>
            <img src="https://example.com/diagram.jpg" alt="Helpful diagram">
            <h2>Main Content</h2>
            <p>Additional detailed content continues here with more valuable information for readers and comprehensive coverage.</p>
            <a href="https://example.com/reference">Relevant reference link</a>
          </article>
        </body>
      `;

      setupDOM(qualityHtml);

      const score = extractor.getContentQualityScore();

      expect(score).toBeGreaterThan(50);
      expect(score).toBeLessThanOrEqual(100);
      expect(typeof score).toBe('number');
    });
  });

  describe('Metadata Extraction', () => {
    test('M.1.1 - Extract title from various sources with priority', async () => {
      const htmlWithMetadata = `
        <head>
          <title>Document Title</title>
          <meta property="og:title" content="OpenGraph Title">
          <meta name="twitter:title" content="Twitter Title">
        </head>
        <body>
          <h1>Header Title</h1>
          <div class="entry-content">
            <p>Some content here with enough text to be meaningful for extraction purposes.</p>
          </div>
        </body>
      `;

      setupDOM(htmlWithMetadata);

      const result = await extractor.extractContent();

      // Should prefer og:title over document.title
      expect(result.metadata.title).toBe('OpenGraph Title');
      expect(result.metadata.url).toBe('https://example.com/test-article');
      expect(result.metadata.captureDate).toBeDefined();
    });

    test('M.1.2 - Extract author information from multiple sources', async () => {
      const htmlWithAuthor = `
        <head>
          <meta name="author" content="Jane Smith">
        </head>
        <body>
          <article>
            <h1>Article with Author</h1>
            <p>Content written by an identified author with sufficient text for proper extraction.</p>
          </article>
        </body>
      `;

      setupDOM(htmlWithAuthor);

      const result = await extractor.extractContent();

      expect(result.metadata.author).toBe('Jane Smith');
    });

    test('M.1.3 - Extract and process tags from keywords and elements', async () => {
      const htmlWithTags = `
        <head>
          <meta name="keywords" content="javascript, typescript, testing">
        </head>
        <body>
          <div class="entry-content">
            <h1>Tagged Article</h1>
            <p>This article has tags and categories for organization purposes and content management.</p>
            <div class="tag">programming</div>
            <div class="category">web-development</div>
          </div>
        </body>
      `;

      setupDOM(htmlWithTags);

      const result = await extractor.extractContent();

      expect(result.metadata.tags).toContain('javascript');
      expect(result.metadata.tags).toContain('typescript');
      expect(result.metadata.tags).toContain('programming');
      expect(result.metadata.tags.length).toBeGreaterThan(0);
    });
  });

  describe('Utility Methods', () => {
    test('U.1.1 - Extract images with complete metadata', () => {
      const htmlWithImages = `
        <body>
          <img src="https://example.com/image1.jpg" alt="Test Image 1" title="Image Title">
          <img src="https://example.com/image2.png" alt="Test Image 2">
          <img src="data:image/gif;base64,..." alt="Base64 Image">
        </body>
      `;

      setupDOM(htmlWithImages);

      const images = extractor.extractImages();

      expect(images).toHaveLength(2); // Should exclude data: images
      expect(images[0]).toEqual({
        src: 'https://example.com/image1.jpg',
        alt: 'Test Image 1',
        title: 'Image Title',
      });
      expect(images[1]).toEqual({
        src: 'https://example.com/image2.png',
        alt: 'Test Image 2',
        title: '',
      });
    });

    test('U.1.2 - Extract links with proper filtering', () => {
      const htmlWithLinks = `
        <body>
          <a href="https://example.com/link1" title="Link Title">Link Text 1</a>
          <a href="https://example.com/link2">Link Text 2</a>
          <a href="javascript:void(0)">JavaScript Link</a>
        </body>
      `;

      setupDOM(htmlWithLinks);

      const links = extractor.extractLinks();

      expect(links).toHaveLength(2); // Should exclude javascript: links
      expect(links[0]).toEqual({
        href: 'https://example.com/link1',
        text: 'Link Text 1',
        title: 'Link Title',
      });
      expect(links[1]).toEqual({
        href: 'https://example.com/link2',
        text: 'Link Text 2',
        title: '',
      });
    });

    test('U.1.3 - Analyze page structure comprehensively', () => {
      const htmlWithStructure = `
        <body>
          <h1>Main Heading</h1>
          <h2>Sub Heading 1</h2>
          <h3>Sub Heading 2</h3>
          <section>Section 1</section>
          <article>Article 1</article>
          <p>Paragraph 1</p>
          <p>Paragraph 2</p>
          <p>Paragraph 3</p>
        </body>
      `;

      setupDOM(htmlWithStructure);

      const structure = extractor.getPageStructure();

      expect(structure.headings).toHaveLength(3);
      expect(structure.headings).toContain('Main Heading');
      expect(structure.headings).toContain('Sub Heading 1');
      expect(structure.sections).toBe(2); // section + article
      expect(structure.paragraphs).toBe(3);
    });
  });

  describe('Edge Cases and Error Handling', () => {
    test('E.1.1 - Handle empty document gracefully', async () => {
      setupDOM('<body></body>');

      const result = await extractor.extractContent();

      expect(result).toBeDefined();
      expect(result.content).toBeDefined();
      expect(result.wordCount).toBe(0);
      expect(result.readingTime).toBe(0);
    });

    test('E.1.2 - Handle content with only whitespace', async () => {
      const whitespaceHtml = `
        <body>
          <div class="content">
            <p>   </p>
            <div>
              
            </div>
            <span>	</span>
          </div>
        </body>
      `;

      setupDOM(whitespaceHtml);

      const result = await extractor.extractContent();

      expect(result).toBeDefined();
      expect(result.wordCount).toBe(0);
    });

    test('E.1.3 - Handle mixed wanted and unwanted elements', async () => {
      const htmlMixed = `
        <head><title>Mixed Content Article</title></head>
        <body>
          <article class="main-content">
            <h1>Mixed Content Article</h1>
            <div class="ad">Ad content</div>
            <p>Good paragraph content with sufficient text for meaningful extraction.</p>
            <nav>Navigation</nav>
            <p>Another good paragraph with additional content for testing purposes.</p>
            <div class="newsletter-signup">Newsletter</div>
            <blockquote>Important quote with valuable information</blockquote>
          </article>
        </body>
      `;

      setupDOM(htmlMixed);

      const result = await extractor.extractContent();

      expect(result).toBeDefined();
      expect(result.content).toContain('Mixed Content Article');
      expect(result.content).toContain('Good paragraph content');
      expect(result.content).toContain('Another good paragraph');
      expect(result.content).toContain('Important quote');
      expect(result.wordCount).toBeGreaterThan(10);
    });

    test('E.1.4 - Handle deeply nested empty elements', async () => {
      const htmlNested = `
        <head><title>Nested Structure</title></head>
        <body>
          <div class="main-content">
            <h1>Nested Structure</h1>
            <div>
              <section>
                <article>
                  <div>
                    <span></span>
                  </div>
                </article>
              </section>
            </div>
            <p>Valid content here with enough text for meaningful extraction.</p>
            <div>
              <div>
                <div>
                  <img src="preserved.jpg" alt="Should be kept">
                </div>
              </div>
            </div>
          </div>
        </body>
      `;

      setupDOM(htmlNested);

      const result = await extractor.extractContent();

      expect(result).toBeDefined();
      expect(result.content).toContain('Nested Structure');
      expect(result.content).toContain('Valid content here');
      expect(result.wordCount).toBeGreaterThan(5);
    });

    test('E.1.5 - Handle extraction options properly', async () => {
      const htmlWithAllElements = `
        <head><title>Article with All Elements</title></head>
        <body>
          <div class="main-content">
            <h1>Article with All Elements</h1>
            <div class="ad">Advertisement content</div>
            <nav>Navigation Menu</nav>
            <p>Main content with sufficient text for extraction and testing purposes.</p>
          </div>
        </body>
      `;

      setupDOM(htmlWithAllElements);

      // Test with removeAds: false
      const resultWithAds = await extractor.extractContent({ removeAds: false });
      expect(resultWithAds).toBeDefined();
      expect(resultWithAds.content).toContain('Article with All Elements');
      expect(resultWithAds.content).toContain('Main content');

      // Test with removeNavigation: false
      const resultWithNav = await extractor.extractContent({ removeNavigation: false });
      expect(resultWithNav).toBeDefined();
      expect(resultWithNav.content).toContain('Article with All Elements');
      expect(resultWithNav.content).toContain('Main content');
    });
  });

  describe('Integration and Performance', () => {
    test('I.1.1 - Process large content efficiently', async () => {
      const largeContent = 'Large content paragraph with many words. '.repeat(1000);
      const largeHtml = `
        <head><title>Large Article</title></head>
        <body>
          <article class="main-content">
            <h1>Large Article</h1>
            <p>${largeContent}</p>
          </article>
        </body>
      `;

      setupDOM(largeHtml);

      const startTime = Date.now();
      const result = await extractor.extractContent();
      const processingTime = Date.now() - startTime;

      expect(result).toBeDefined();
      expect(result.wordCount).toBeGreaterThan(5000);
      expect(processingTime).toBeLessThan(5000); // Should complete within 5 seconds
    });

    test('I.1.2 - Handle multiple extraction calls consistently', async () => {
      setupDOM(createTestHTML('article'));

      const result1 = await extractor.extractContent();
      const result2 = await extractor.extractContent();

      expect(result1.content).toBe(result2.content);
      expect(result1.wordCount).toBe(result2.wordCount);
      expect(result1.metadata.title).toBe(result2.metadata.title);
    });
  });
});
