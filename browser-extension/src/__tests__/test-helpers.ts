// Generated by Copilot
// Enhanced test utilities and setup for PrismWeave browser extension tests

// ============================================================================
// DOM Setup and Manipulation Utilities
// ============================================================================

// Common JSDOM setup function for content extraction tests
export const setupDOM = (
  html: string,
  options: {
    url?: string;
    hostname?: string;
    pathname?: string;
    title?: string;
    readyState?: DocumentReadyState;
  } = {}
) => {
  const {
    url = 'https://example.com/test-article',
    hostname = 'example.com',
    pathname = '/test-article',
    title = 'Test Article',
    readyState = 'complete',
  } = options;

  // Set up the document with the provided HTML
  document.documentElement.innerHTML = html;
  document.title = title;

  // Mock window.location for consistent URL handling
  Object.defineProperty(window, 'location', {
    value: {
      href: url,
      hostname,
      pathname,
      origin: `https://${hostname}`,
      protocol: 'https:',
      port: '',
      search: '',
      hash: '',
    },
    writable: true,
  });

  // Ensure document.readyState is set
  Object.defineProperty(document, 'readyState', {
    value: readyState,
    writable: true,
  });

  // Mock commonly used DOM APIs
  Object.defineProperty(window, 'getComputedStyle', {
    value: jest.fn(() => ({
      display: 'block',
      visibility: 'visible',
      opacity: '1',
    })),
    writable: true,
  });
};

// Create realistic DOM structures for testing
export const createRealisticDOMStructure = (
  contentType: 'article' | 'blog' | 'news' | 'documentation' = 'article'
) => {
  const structures = {
    article: `
      <html>
        <head>
          <title>Understanding Modern Web Development</title>
          <meta property="og:title" content="Understanding Modern Web Development - Complete Guide">
          <meta name="author" content="Jane Developer">
          <meta name="description" content="A comprehensive guide to modern web development practices and tools">
          <meta name="keywords" content="web development, javascript, react, nodejs, tutorial">
        </head>
        <body>
          <header class="site-header">
            <nav class="main-navigation">
              <ul><li><a href="/">Home</a></li><li><a href="/articles">Articles</a></li></ul>
            </nav>
          </header>
          <main class="main-content">
            <article class="article-content" id="main-article">
              <h1>Understanding Modern Web Development</h1>
              <div class="article-meta">
                <span class="author">By Jane Developer</span>
                <time datetime="2024-01-15">January 15, 2024</time>
              </div>
              <p>Modern web development has evolved significantly over the past decade. This comprehensive guide will walk you through the essential concepts, tools, and practices that every developer should know.</p>
              <h2>Core Technologies</h2>
              <p>The foundation of web development rests on three pillars: HTML for structure, CSS for styling, and JavaScript for interactivity. Understanding these technologies deeply is crucial for any web developer.</p>
              <h3>HTML5 Semantic Elements</h3>
              <p>HTML5 introduced semantic elements that provide meaning to the structure of web pages. These elements improve accessibility and SEO performance.</p>
              <ul>
                <li>Header and footer elements for page structure</li>
                <li>Section and article elements for content organization</li>
                <li>Nav elements for navigation sections</li>
              </ul>
              <h2>Modern JavaScript Frameworks</h2>
              <p>JavaScript frameworks have revolutionized how we build web applications. React, Vue, and Angular each offer unique approaches to component-based development.</p>
              <blockquote>
                <p>"The best framework is the one that solves your specific problem efficiently and maintainably."</p>
              </blockquote>
              <pre><code>// Example React component
function Welcome({ name }) {
  return &lt;h1&gt;Hello, {name}!&lt;/h1&gt;;
}</code></pre>
              <img src="https://example.com/web-dev-diagram.png" alt="Web Development Architecture Diagram" />
            </article>
          </main>
          <aside class="sidebar">
            <div class="advertisement">
              <p>Advertisement content that should be filtered out</p>
            </div>
            <div class="related-articles">
              <h3>Related Articles</h3>
              <ul>
                <li><a href="/css-grid">CSS Grid Layout</a></li>
                <li><a href="/js-async">Async JavaScript</a></li>
              </ul>
            </div>
          </aside>
          <footer class="site-footer">
            <p>&copy; 2024 Web Dev Blog. All rights reserved.</p>
          </footer>
        </body>
      </html>
    `,
    blog: `
      <html>
        <head>
          <title>10 Tips for Better Code Reviews</title>
          <meta name="author" content="Code Reviewer">
        </head>
        <body>
          <div class="blog-container">
            <header class="blog-header">
              <h1 class="blog-title">Developer Insights</h1>
            </header>
            <main class="blog-main">
              <div class="post-content">
                <h1>10 Tips for Better Code Reviews</h1>
                <div class="post-meta">
                  <span class="author">By Code Reviewer</span>
                  <span class="date">March 10, 2024</span>
                  <span class="reading-time">5 min read</span>
                </div>
                <p>Code reviews are an essential part of the software development process. They help maintain code quality, share knowledge, and catch bugs before they reach production.</p>
                <h2>Why Code Reviews Matter</h2>
                <p>Effective code reviews can significantly improve code quality and team collaboration. Here are the key benefits:</p>
                <ol>
                  <li>Bug detection and prevention</li>
                  <li>Knowledge sharing across the team</li>
                  <li>Code consistency and standards enforcement</li>
                  <li>Mentoring and learning opportunities</li>
                </ol>
                <h2>Best Practices</h2>
                <p>Following these practices will make your code reviews more effective and efficient.</p>
              </div>
            </main>
          </div>
        </body>
      </html>
    `,
    news: `
      <html>
        <head>
          <title>Breaking: New JavaScript Framework Released</title>
          <meta property="og:title" content="Breaking News: Revolutionary JavaScript Framework">
        </head>
        <body>
          <div class="news-layout">
            <header class="news-header">
              <div class="breaking-banner">BREAKING NEWS</div>
            </header>
            <article class="news-article">
              <h1>Revolutionary JavaScript Framework Promises 50% Faster Development</h1>
              <div class="news-meta">
                <span class="timestamp">2 hours ago</span>
                <span class="reporter">Tech Reporter</span>
              </div>
              <p class="lead">A new JavaScript framework has been released that claims to revolutionize web development with unprecedented speed and simplicity.</p>
              <p>The framework, developed by a team of industry veterans, introduces novel concepts that could change how developers approach modern web applications.</p>
              <h2>Key Features</h2>
              <ul>
                <li>Zero-configuration setup</li>
                <li>Built-in state management</li>
                <li>Automatic code splitting</li>
              </ul>
            </article>
            <div class="social-sharing">
              <button class="share-btn">Share on Twitter</button>
              <button class="share-btn">Share on LinkedIn</button>
            </div>
          </div>
        </body>
      </html>
    `,
    documentation: `
      <html>
        <head>
          <title>API Reference - Authentication Methods</title>
        </head>
        <body>
          <div class="docs-layout">
            <nav class="docs-nav">
              <ul>
                <li><a href="#getting-started">Getting Started</a></li>
                <li><a href="#authentication">Authentication</a></li>
                <li><a href="#endpoints">API Endpoints</a></li>
              </ul>
            </nav>
            <main class="docs-content">
              <h1>Authentication Methods</h1>
              <p>This API supports multiple authentication methods to secure your requests and protect user data.</p>
              <h2 id="api-keys">API Keys</h2>
              <p>API keys provide a simple way to authenticate requests. Include your API key in the Authorization header.</p>
              <pre><code>curl -H "Authorization: Bearer YOUR_API_KEY" https://api.example.com/data</code></pre>
              <h2 id="oauth">OAuth 2.0</h2>
              <p>OAuth 2.0 provides secure, token-based authentication for user accounts.</p>
              <h3>Authorization Flow</h3>
              <ol>
                <li>Redirect user to authorization endpoint</li>
                <li>User grants permission</li>
                <li>Exchange authorization code for access token</li>
              </ol>
            </main>
          </div>
        </body>
      </html>
    `,
  };

  return structures[contentType];
};

// ============================================================================
// Chrome API Mock Factories
// ============================================================================

// Comprehensive Chrome API mock factory with configurable behaviors
export const createChromeAPIMock = (
  options: {
    storage?: {
      syncEnabled?: boolean;
      localEnabled?: boolean;
      quota?: number;
      simulateErrors?: boolean;
    };
    runtime?: {
      enableMessaging?: boolean;
      simulateErrors?: boolean;
      messageResponses?: Record<string, any>;
    };
    tabs?: {
      enableTabOperations?: boolean;
      mockTabs?: chrome.tabs.Tab[];
    };
  } = {}
) => {
  const {
    storage = { syncEnabled: true, localEnabled: true, quota: 102400, simulateErrors: false },
    runtime = { enableMessaging: true, simulateErrors: false, messageResponses: {} },
    tabs = { enableTabOperations: true, mockTabs: [] },
  } = options;

  // Storage API mock with realistic behavior
  const createStorageMock = (type: 'sync' | 'local') => {
    const storageData: Record<string, any> = {};
    const enabled = type === 'sync' ? storage.syncEnabled : storage.localEnabled;

    return {
      get: jest.fn((keys: any, callback?: any) => {
        const performGet = (): any => {
          let result: Record<string, any> = {};

          if (!enabled || storage.simulateErrors) {
            (global as any).chrome.runtime.lastError = { message: `${type} storage unavailable` };
            if (callback) {
              callback({});
              return;
            } else {
              return Promise.reject(new Error(`${type} storage unavailable`));
            }
          }

          if (typeof keys === 'string') {
            if (storageData[keys]) result[keys] = storageData[keys];
          } else if (Array.isArray(keys)) {
            keys.forEach(key => {
              if (storageData[key]) result[key] = storageData[key];
            });
          } else if (keys === null || keys === undefined) {
            result = { ...storageData };
          } else if (typeof keys === 'object') {
            Object.keys(keys).forEach(key => {
              result[key] = storageData[key] || keys[key];
            });
          }

          (global as any).chrome.runtime.lastError = null;

          if (callback) {
            callback(result);
          } else {
            return Promise.resolve(result);
          }
        };

        return performGet();
      }),

      set: jest.fn((data: any, callback?: any) => {
        const performSet = (): any => {
          if (!enabled || storage.simulateErrors) {
            (global as any).chrome.runtime.lastError = { message: `${type} storage unavailable` };
            if (callback) {
              callback();
              return;
            } else {
              return Promise.reject(new Error(`${type} storage unavailable`));
            }
          }

          // Check quota
          const dataSize = JSON.stringify(data).length;
          if (dataSize > storage.quota!) {
            (global as any).chrome.runtime.lastError = { message: 'QUOTA_BYTES quota exceeded' };
            if (callback) {
              callback();
              return;
            } else {
              return Promise.reject(new Error('QUOTA_BYTES quota exceeded'));
            }
          }

          Object.assign(storageData, data);
          (global as any).chrome.runtime.lastError = null;

          if (callback) {
            callback();
          } else {
            return Promise.resolve();
          }
        };

        return performSet();
      }),

      remove: jest.fn((keys: string | string[], callback?: any) => {
        if (!enabled) {
          (global as any).chrome.runtime.lastError = { message: `${type} storage unavailable` };
          callback?.();
          return;
        }

        const keysArray = Array.isArray(keys) ? keys : [keys];
        keysArray.forEach(key => delete storageData[key]);
        (global as any).chrome.runtime.lastError = null;
        callback?.();
      }),

      clear: jest.fn((callback?: any) => {
        if (!enabled) {
          (global as any).chrome.runtime.lastError = { message: `${type} storage unavailable` };
          callback?.();
          return;
        }

        Object.keys(storageData).forEach(key => delete storageData[key]);
        (global as any).chrome.runtime.lastError = null;
        callback?.();
      }),

      // Test utility to get current storage state
      _getStorageData: () => ({ ...storageData }),
      _setStorageData: (data: Record<string, any>) => Object.assign(storageData, data),
      _clearStorageData: () => Object.keys(storageData).forEach(key => delete storageData[key]),
    };
  };

  // Runtime API mock with message handling
  const runtimeMock = {
    sendMessage: jest.fn((message: any, callback?: any) => {
      if (!runtime.enableMessaging || runtime.simulateErrors) {
        (global as any).chrome.runtime.lastError = { message: 'Message sending failed' };
        callback?.({ success: false, error: 'Runtime error' });
        return;
      }

      // Handle predefined responses
      const response = runtime.messageResponses?.[message.type] || { success: true, data: {} };
      (global as any).chrome.runtime.lastError = null;

      // Simulate async behavior
      setTimeout(() => callback?.(response), 0);
    }),

    onMessage: {
      addListener: jest.fn(),
      removeListener: jest.fn(),
      hasListener: jest.fn(() => false),
    },

    onInstalled: {
      addListener: jest.fn(),
      removeListener: jest.fn(),
      hasListener: jest.fn(() => false),
    },

    openOptionsPage: jest.fn(),
    getManifest: jest.fn(() => ({ version: '1.0.0', name: 'Test Extension' })),
    lastError: null as chrome.runtime.LastError | null,

    // Test utilities
    _simulateMessage: (message: any, response: any) => {
      runtime.messageResponses![message.type] = response;
    },
  };

  // Tabs API mock
  const tabsMock = {
    query: jest.fn((queryInfo: chrome.tabs.QueryInfo, callback: any) => {
      if (!tabs.enableTabOperations) {
        callback([]);
        return;
      }

      const defaultTab: chrome.tabs.Tab = {
        id: 1,
        url: 'https://example.com/test-page',
        title: 'Test Page',
        active: true,
        index: 0,
        pinned: false,
        highlighted: true,
        windowId: 1,
        incognito: false,
        selected: true,
        discarded: false,
        autoDiscardable: true,
        groupId: -1,
        frozen: false,
      };

      const mockTabs = tabs.mockTabs || [defaultTab];

      let filteredTabs = [...mockTabs];
      if (queryInfo.active !== undefined) {
        filteredTabs = filteredTabs.filter(tab => tab.active === queryInfo.active);
      }
      if (queryInfo.url) {
        filteredTabs = filteredTabs.filter(tab => tab.url?.includes(queryInfo.url as string));
      }

      callback(filteredTabs);
    }),

    sendMessage: jest.fn((tabId: number, message: any, callback?: any) => {
      if (!tabs.enableTabOperations) {
        (global as any).chrome.runtime.lastError = { message: 'Tab not found' };
        callback?.({ success: false });
        return;
      }

      const response = { success: true, data: message };
      (global as any).chrome.runtime.lastError = null;
      setTimeout(() => callback?.(response), 0);
    }),

    create: jest.fn((createProperties: chrome.tabs.CreateProperties, callback?: any) => {
      const newTab: chrome.tabs.Tab = {
        id: Math.floor(Math.random() * 1000) + 100,
        url: createProperties.url,
        title: 'New Tab',
        active: createProperties.active !== false,
        index: 0,
        pinned: false,
        highlighted: true,
        windowId: 1,
        incognito: false,
        selected: true,
        discarded: false,
        autoDiscardable: true,
        groupId: -1,
        frozen: false,
      };
      callback?.(newTab);
    }),
  };

  const chromeMock = {
    storage: {
      sync: createStorageMock('sync'),
      local: createStorageMock('local'),
    },
    runtime: runtimeMock,
    tabs: tabsMock,
    scripting: {
      executeScript: jest.fn((injection: any, callback?: any) => {
        const results = [{ result: 'Script executed successfully' }];
        callback?.(results);
      }),
    },
  };

  return chromeMock;
};

// Simplified Chrome API mock for basic tests
export const mockChromeAPIs = () => {
  const chromeMock = createChromeAPIMock();
  (global as any).chrome = chromeMock;
  return chromeMock;
};

// Chrome API mock with specific error scenarios
export const mockChromeAPIsWithErrors = (errorType: 'storage' | 'runtime' | 'tabs' = 'storage') => {
  const options: any = {};

  switch (errorType) {
    case 'storage':
      options.storage = { syncEnabled: false, localEnabled: false, simulateErrors: true };
      break;
    case 'runtime':
      options.runtime = { enableMessaging: false, simulateErrors: true };
      break;
    case 'tabs':
      options.tabs = { enableTabOperations: false };
      break;
  }

  const chromeMock = createChromeAPIMock(options);
  (global as any).chrome = chromeMock;
  return chromeMock;
};

// ============================================================================
// Test Data Generators and Factories
// ============================================================================

// Create mock DOM element with common properties
export const createMockElement = (
  properties: {
    innerHTML?: string;
    textContent?: string;
    className?: string;
    id?: string;
    tagName?: string;
    attributes?: Record<string, string>;
    children?: any[];
    style?: Partial<CSSStyleDeclaration>;
  } = {}
): any => {
  const {
    innerHTML = '',
    textContent = innerHTML.replace(/<[^>]*>/g, ''),
    className = '',
    id = '',
    tagName = 'DIV',
    attributes = {},
    children = [],
    style = {},
  } = properties;

  const element: any = {
    innerHTML,
    textContent,
    className,
    id,
    tagName,
    children:
      children.length > 0 ? Object.assign({ length: children.length }, children) : { length: 0 },
    parentElement: null,
    style: { display: 'block', visibility: 'visible', opacity: '1', ...style },

    // Mock DOM methods
    querySelectorAll: jest.fn((selector: string): any[] => {
      // Simple mock that returns children if selector matches
      if (selector === '*') return children;
      return children.filter(
        (child: any) =>
          child.className?.includes(selector.replace('.', '')) ||
          child.id === selector.replace('#', '') ||
          child.tagName === selector.toUpperCase()
      );
    }),

    querySelector: jest.fn((selector: string): any => {
      const results: any[] = element.querySelectorAll(selector);
      return results.length > 0 ? results[0] : null;
    }),

    cloneNode: jest.fn((deep: boolean = false): any => {
      return createMockElement({
        innerHTML: deep ? innerHTML : '',
        textContent: deep ? textContent : '',
        className,
        id,
        tagName,
        attributes: { ...attributes },
        children: deep ? [...children] : [],
      });
    }),

    remove: jest.fn(),
    getAttribute: jest.fn((name: string) => attributes[name] || null),
    setAttribute: jest.fn((name: string, value: string) => {
      attributes[name] = value;
    }),
    hasAttribute: jest.fn((name: string) => name in attributes),
    removeAttribute: jest.fn((name: string) => {
      delete attributes[name];
    }),
    addEventListener: jest.fn(),
    removeEventListener: jest.fn(),
  };

  return element;
};

// Factory for creating comprehensive test settings
export const createTestSettings = (overrides: Record<string, any> = {}) => ({
  // GitHub settings
  githubToken: '',
  githubRepo: '',
  githubBranch: 'main',

  // Folder and naming settings
  defaultFolder: 'unsorted',
  customFolder: '',
  fileNamingPattern: 'YYYY-MM-DD-domain-title',

  // Capture settings
  autoCommit: true,
  captureImages: true,
  captureLinks: true,
  removeAds: true,
  removeNavigation: true,
  removeComments: true,
  customSelectors: '',
  excludeSelectors: 'nav,footer,.advertisement,.sidebar',

  // Git settings
  commitMessageTemplate: 'Add: {domain} - {title}',
  autoSync: true,

  // UI settings
  debugMode: false,
  showNotifications: true,
  enableKeyboardShortcuts: true,
  theme: 'auto',

  // Performance settings
  maxFileSize: 10485760, // 10MB
  processingTimeout: 30000, // 30 seconds

  ...overrides,
});

// Factory for creating test HTML content with realistic structures
export const createTestHTML = (
  type: 'article' | 'blog' | 'generic' | 'malformed' | 'empty' | 'minimal' = 'article'
) => {
  const templates = {
    article: createRealisticDOMStructure('article'),
    blog: createRealisticDOMStructure('blog'),
    news: createRealisticDOMStructure('news'),
    documentation: createRealisticDOMStructure('documentation'),

    generic: `
      <html>
        <head><title>Generic Page</title></head>
        <body>
          <div class="content-wrapper">
            <p>Some scattered content here with enough text to make it meaningful and pass minimum requirements for testing content extraction algorithms.</p>
            <p>Additional paragraph with more substantial text content for comprehensive testing of content extraction and processing logic.</p>
          </div>
          <div class="secondary-content">
            <p>More scattered content there with additional meaningful text for testing purposes and validation of extraction quality.</p>
            <p>Another paragraph ensuring we have sufficient content volume for realistic testing scenarios and edge case validation.</p>
          </div>
        </body>
      </html>
    `,

    malformed: `
      <html>
        <head><title>Malformed HTML Test</title>
        <body>
          <div class="main-content">
            <p>Content with unclosed tags and sufficient text for meaningful content extraction and testing of error handling
            <span>Nested content without proper closing tags for malformed HTML testing and validation
            <p>More content without proper structural organization but enough text for comprehensive testing</p>
            <div>Another unclosed div with substantial content for testing malformed HTML parsing
            <p>Final paragraph with adequate text content to ensure meaningful extraction despite structural issues</p>
          </div>
        </body>
      </html>
    `,

    empty: `
      <html>
        <head><title>Empty Page</title></head>
        <body></body>
      </html>
    `,

    minimal: `
      <html>
        <head><title>Minimal Content</title></head>
        <body>
          <p>Short content that might not meet minimum extraction requirements.</p>
        </body>
      </html>
    `,
  };

  return templates[type] || templates.generic;
};

// Factory for creating realistic extracted document data
export const createTestDocument = (overrides: Record<string, any> = {}) => ({
  id: `doc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
  title: 'Test Document Title',
  url: 'https://example.com/test-article',
  domain: 'example.com',
  content: 'This is test content for a document with sufficient length for testing purposes.',
  markdown:
    '# Test Document Title\n\nThis is test content for a document with sufficient length for testing purposes.',
  images: ['https://example.com/image1.jpg', 'https://example.com/image2.png'],
  extractedAt: new Date().toISOString(),
  wordCount: 15,
  metadata: {
    author: 'Test Author',
    description: 'Test document description',
    keywords: ['test', 'document', 'content'],
    publishedDate: '2024-01-15',
    language: 'en',
  },
  tags: ['test', 'article'],
  folder: 'unsorted',
  ...overrides,
});

// Factory for creating test extraction results
export const createExtractionResult = (
  success: boolean = true,
  overrides: Record<string, any> = {}
) => {
  const baseResult = {
    success,
    timestamp: new Date().toISOString(),
    extractionTime: Math.floor(Math.random() * 1000) + 100,
    byteSize: Math.floor(Math.random() * 10000) + 1000,
    warnings: [] as string[],
  };

  if (success) {
    return {
      ...baseResult,
      document: createTestDocument(),
      metadata: {
        contentScore: 0.85,
        extractedElements: ['article', 'h1', 'p'],
        removedElements: ['nav', 'footer', '.advertisement'],
      },
      ...overrides,
    };
  } else {
    return {
      ...baseResult,
      error: {
        code: 'EXTRACTION_ERROR',
        message: 'Failed to extract content',
        details: { reason: 'Content not found' },
      },
      ...overrides,
    };
  }
};

// Validation result factory
export const createValidationResult = (isValid: boolean, errors: string[] = []) => ({
  isValid,
  errors,
  missingSettings: errors,
  warnings: [] as string[],
  details: errors.length > 0 ? { invalidFields: errors } : {},
  message: errors.length > 0 ? `Missing required settings: ${errors.join(', ')}` : 'Settings valid',
});

// Message factory for testing inter-component communication
export const createTestMessage = (
  type: string,
  data: Record<string, any> = {},
  overrides: Record<string, any> = {}
) => ({
  type,
  data,
  timestamp: Date.now(),
  id: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`,
  source: 'test',
  ...overrides,
});

// Response factory for message testing
export const createTestResponse = (
  success: boolean = true,
  data: any = {},
  overrides: Record<string, any> = {}
) => ({
  success,
  data: success ? data : undefined,
  error: !success ? { code: 'TEST_ERROR', message: 'Test error message' } : undefined,
  timestamp: Date.now(),
  ...overrides,
});

// ============================================================================
// Performance Testing Helpers
// ============================================================================

// Performance timing utilities for testing
class PerformanceTestHelper {
  private static timers: Map<string, number> = new Map();

  static startTimer(name: string): void {
    this.timers.set(name, Date.now());
  }

  static endTimer(name: string): number {
    const startTime = this.timers.get(name);
    if (!startTime) {
      throw new Error(`Timer '${name}' was not started`);
    }

    const duration = Date.now() - startTime;
    this.timers.delete(name);
    return duration;
  }

  static async measureAsync<T>(
    name: string,
    fn: () => Promise<T>
  ): Promise<{ result: T; duration: number }> {
    this.startTimer(name);
    const result = await fn();
    const duration = this.endTimer(name);
    return { result, duration };
  }

  static measure<T>(name: string, fn: () => T): { result: T; duration: number } {
    this.startTimer(name);
    const result = fn();
    const duration = this.endTimer(name);
    return { result, duration };
  }

  static expectPerformance(duration: number, maxExpected: number, operation: string): void {
    expect(duration).toBeLessThanOrEqual(maxExpected);
    if (duration > maxExpected) {
      console.warn(
        `Performance warning: ${operation} took ${duration}ms, expected <= ${maxExpected}ms`
      );
    }
  }

  static createPerformanceTest(
    operation: string,
    maxDuration: number,
    testFn: () => Promise<any> | any
  ): () => Promise<void> {
    return async () => {
      const isAsync = testFn.constructor.name === 'AsyncFunction';

      if (isAsync) {
        const { result, duration } = await this.measureAsync(operation, testFn);
        this.expectPerformance(duration, maxDuration, operation);
        return result;
      } else {
        const { result, duration } = this.measure(operation, testFn);
        this.expectPerformance(duration, maxDuration, operation);
        return result;
      }
    };
  }

  static clearTimers(): void {
    this.timers.clear();
  }
}

// Memory usage testing helpers
class MemoryTestHelper {
  static async simulateMemoryPressure(iterations: number = 1000): Promise<void> {
    const objects: any[] = [];

    for (let i = 0; i < iterations; i++) {
      objects.push({
        id: i,
        data: new Array(1000).fill(Math.random()),
        timestamp: new Date(),
        content: `Test content for iteration ${i} with some substantial text`,
      });
    }

    // Force garbage collection if available
    if ((global as any).gc) {
      (global as any).gc();
    }

    // Clear references
    objects.length = 0;
  }

  static createLargeTestData(sizeMB: number = 1): string {
    const targetSize = sizeMB * 1024 * 1024; // Convert to bytes
    const chunkSize = 1000;
    const chunks: string[] = [];

    while (chunks.join('').length < targetSize) {
      chunks.push('x'.repeat(chunkSize));
    }

    return chunks.join('');
  }

  static estimateObjectSize(obj: any): number {
    // Rough estimation of object size in bytes
    return JSON.stringify(obj).length * 2; // UTF-16 characters are 2 bytes each
  }
}

// Async operation testing helpers
class AsyncTestHelper {
  static async waitFor(
    condition: () => boolean,
    timeout: number = 5000,
    interval: number = 100,
    timeoutMessage: string = 'Condition not met within timeout'
  ): Promise<void> {
    const startTime = Date.now();

    return new Promise<void>((resolve, reject) => {
      const check = (): void => {
        if (condition()) {
          resolve();
        } else if (Date.now() - startTime > timeout) {
          reject(new Error(`${timeoutMessage} (${timeout}ms)`));
        } else {
          setTimeout(check, interval);
        }
      };

      check();
    });
  }

  static async waitForElementToExist(selector: string, timeout: number = 5000): Promise<Element> {
    let element: Element | null = null;

    await this.waitFor(
      () => {
        element = document.querySelector(selector);
        return element !== null;
      },
      timeout,
      100,
      `Element with selector '${selector}' not found`
    );

    return element!;
  }

  static createAsyncMock<T extends (...args: any[]) => Promise<any>>(
    delay: number = 0,
    resolveValue?: any,
    shouldReject: boolean = false
  ): jest.MockedFunction<T> {
    return jest.fn(async (...args: any[]) => {
      if (delay > 0) {
        await new Promise(resolve => setTimeout(resolve, delay));
      }

      if (shouldReject) {
        throw new Error(resolveValue || 'Mock async error');
      }

      return resolveValue;
    }) as unknown as jest.MockedFunction<T>;
  }

  static async flushPromises(): Promise<void> {
    return new Promise(resolve => setImmediate(resolve));
  }
}

// ============================================================================
// Test Environment Setup and Cleanup
// ============================================================================

// Comprehensive test environment setup
export const setupTestEnvironment = (
  options: {
    mockChrome?: boolean;
    setupDOM?: boolean;
    customHTML?: string;
    enablePerformanceTracking?: boolean;
    mockConsole?: boolean;
  } = {}
) => {
  const {
    mockChrome = true,
    setupDOM: setupDOMOption = true,
    customHTML,
    enablePerformanceTracking = false,
    mockConsole = true,
  } = options;

  const originalConsole = { ...console };
  let chromeMock: any;
  let consoleMocks: any = {};

  if (mockChrome) {
    chromeMock = mockChromeAPIs();
  }

  if (setupDOMOption) {
    if (customHTML) {
      setupDOM(customHTML);
    } else {
      setupDOM(createTestHTML('article'));
    }
  }

  if (enablePerformanceTracking) {
    PerformanceTestHelper.clearTimers();
  }

  if (mockConsole) {
    consoleMocks = {
      log: jest.spyOn(console, 'log').mockImplementation(() => {}),
      warn: jest.spyOn(console, 'warn').mockImplementation(() => {}),
      error: jest.spyOn(console, 'error').mockImplementation(() => {}),
      info: jest.spyOn(console, 'info').mockImplementation(() => {}),
      debug: jest.spyOn(console, 'debug').mockImplementation(() => {}),
    };
  }

  return {
    chromeMock,
    consoleMocks,
    cleanup: () => {
      cleanupTest();
      if (enablePerformanceTracking) {
        PerformanceTestHelper.clearTimers();
      }
      if (mockConsole) {
        Object.values(consoleMocks).forEach((mock: any) => mock.mockRestore());
      }
    },
  };
};

// Enhanced cleanup function for comprehensive test cleanup
export const cleanupTest = (): void => {
  // Clear DOM
  document.documentElement.innerHTML = '';
  document.title = '';

  // Clear all mocks
  jest.clearAllMocks();
  jest.restoreAllMocks();

  // Clear global Chrome mock
  (global as any).chrome = undefined;

  // Clear timers and intervals
  jest.clearAllTimers();

  // Clear performance timers
  PerformanceTestHelper.clearTimers();

  // Reset window location
  Object.defineProperty(window, 'location', {
    value: {
      href: 'http://localhost/',
      hostname: 'localhost',
      pathname: '/',
      origin: 'http://localhost',
      protocol: 'http:',
      port: '',
      search: '',
      hash: '',
    },
    writable: true,
  });

  // Reset document.readyState
  Object.defineProperty(document, 'readyState', {
    value: 'complete',
    writable: true,
  });
};

// Test suite wrapper for consistent setup/teardown
export const withTestSuite = (
  suiteName: string,
  tests: () => void,
  options: {
    mockChrome?: boolean;
    setupDOM?: boolean;
    enablePerformanceTracking?: boolean;
  } = {}
) => {
  describe(suiteName, () => {
    let testEnv: ReturnType<typeof setupTestEnvironment>;

    beforeEach(() => {
      testEnv = setupTestEnvironment(options);
    });

    afterEach(() => {
      testEnv.cleanup();
    });

    tests();
  });
};

// ============================================================================
// Test Data Validation Helpers
// ============================================================================

// Assertion helpers for common test patterns
export const TestAssertions = {
  // Validate document structure
  expectValidDocument: (doc: any) => {
    expect(doc).toBeDefined();
    expect(doc.id).toBeDefined();
    expect(doc.title).toBeDefined();
    expect(doc.url).toBeDefined();
    expect(doc.content).toBeDefined();
    expect(doc.extractedAt).toBeDefined();
  },

  // Validate settings object
  expectValidSettings: (settings: any) => {
    expect(settings).toBeDefined();
    expect(typeof settings.githubToken).toBe('string');
    expect(typeof settings.githubRepo).toBe('string');
    expect(typeof settings.autoCommit).toBe('boolean');
  },

  // Validate extraction result
  expectValidExtractionResult: (result: any) => {
    expect(result).toBeDefined();
    expect(typeof result.success).toBe('boolean');
    expect(result.timestamp).toBeDefined();
    expect(typeof result.extractionTime).toBe('number');
    expect(typeof result.byteSize).toBe('number');
    expect(Array.isArray(result.warnings)).toBe(true);
  },

  // Validate Chrome message
  expectValidMessage: (message: any) => {
    expect(message).toBeDefined();
    expect(message.type).toBeDefined();
    expect(typeof message.type).toBe('string');
    expect(message.timestamp).toBeDefined();
  },

  // Validate Chrome response
  expectValidResponse: (response: any) => {
    expect(response).toBeDefined();
    expect(typeof response.success).toBe('boolean');
    expect(response.timestamp).toBeDefined();
  },
};

// Export test helper classes
export { AsyncTestHelper, MemoryTestHelper, PerformanceTestHelper };

// Additional exports for service worker testing
export const setupChromeEnvironment = () => {
  const chromeMock = createChromeAPIMock();
  
  // Set up global fetch mock
  (global as any).mockFetch = mockFetch;
  (global as any).fetch = mockFetch;
  
  return chromeMock;
};

export const mockFetch = jest.fn().mockResolvedValue({
  ok: true,
  text: jest.fn().mockResolvedValue('mock library content'),
  json: jest.fn().mockResolvedValue({ success: true }),
});

export const mockGetURL = jest.fn((path: string) => `chrome-extension://test-id/${path}`);

// Execute service worker code and return API for testing
export const executeServiceWorkerCode = (chromeAPI?: any) => {
  try {
    // Read the compiled service worker JavaScript code (not TypeScript)
    const fs = require('fs');
    const path = require('path');

    // Get the compiled service worker JavaScript code
    const serviceWorkerPath = path.join(__dirname, '../../dist/background/service-worker.js');
    let serviceWorkerCode = fs.readFileSync(serviceWorkerPath, 'utf-8');

    // Remove the IIFE wrapper to expose functions globally
    serviceWorkerCode = serviceWorkerCode
      .replace(/^"use strict";\s*\(\(\) => \{\s*/, '') // Remove opening IIFE
      .replace(/\s*\}\)\(\);\s*$/m, '') // Remove closing IIFE
      .replace(/\/\/# sourceMappingURL=.*$/, ''); // Remove source map comment

    // Modify the service worker code to expose internal functions
    serviceWorkerCode = serviceWorkerCode
      .replace(
        /async function handleMessage\(message, sender\)/g,
        'global.handleMessage = async function handleMessage(message, sender)'
      )
      .replace(
        /async function testGitHubConnection\(\)/g,
        'global.testGitHubConnection = async function testGitHubConnection()'
      )
      .replace(
        /async function getTurndownLibrary\(\)/g,
        'global.getTurndownLibrary = async function getTurndownLibrary()'
      )
      .replace(/var settingsManager;/, 'var settingsManager; global.settingsManager = null;')
      .replace(
        /settingsManager = new ServiceWorkerSettingsManager\(\);/g,
        'settingsManager = new ServiceWorkerSettingsManager(); global.settingsManager = settingsManager;'
      );

    // Set up Chrome API and other globals before executing service worker code
    const setupGlobals = `
      // Set up Chrome API in global scope
      global.chrome = {
        storage: {
          sync: {
            get: function(keys) {
              const storageData = global.mockStorageData || {};
              return new Promise((resolve) => {
                let result = {};
                if (typeof keys === 'string') {
                  if (storageData[keys]) result[keys] = storageData[keys];
                } else if (Array.isArray(keys)) {
                  keys.forEach(key => {
                    if (storageData[key]) result[key] = storageData[key];
                  });
                } else if (keys === null || keys === undefined) {
                  result = { ...storageData };
                } else if (typeof keys === 'object') {
                  Object.keys(keys).forEach(key => {
                    result[key] = storageData[key] || keys[key];
                  });
                }
                global.chrome.runtime.lastError = null;
                resolve(result);
              });
            },
            set: function(data) {
              global.mockStorageData = global.mockStorageData || {};
              Object.assign(global.mockStorageData, data);
              return new Promise((resolve) => {
                global.chrome.runtime.lastError = null;
                resolve();
              });
            }
          }
        },
        runtime: {
          onInstalled: {
            addListener: function(callback) {}
          },
          onMessage: {
            addListener: function(callback) {}
          },
          getManifest: function() {
            return { version: '1.0.0' };
          },
          getURL: function(path) {
            return 'chrome-extension://test-extension-id/' + path;
          },
          lastError: null
        },
        scripting: {
          executeScript: function(injection) {
            return Promise.resolve([{ result: 'Script executed' }]);
          }
        },
        tabs: {
          query: function(queryInfo) {
            return Promise.resolve([{
              id: 1,
              url: 'https://example.com',
              title: 'Test Page',
              active: true
            }]);
          },
          sendMessage: function(tabId, message) {
            return Promise.resolve({ success: true });
          },
          get: function(tabId) {
            return Promise.resolve({
              id: tabId,
              url: 'https://example.com',
              title: 'Test Page'
            });
          }
        }
      };
      
      // Set up fetch for GitHub API calls
      global.fetch = global.mockFetch || function(url, options) {
        // Default mock response
        return Promise.resolve({ 
          ok: true, 
          status: 200,
          json: () => Promise.resolve({}),
          text: () => Promise.resolve('mock response')
        });
      };
      
      // Initialize mock storage data
      global.mockStorageData = {};
      
      // Set up console
      global.console = console;
    `;

    // Execute setup and service worker code
    const executeCode = new Function(setupGlobals + '\n' + serviceWorkerCode);
    executeCode();

    // Wait a bit for async initialization
    setTimeout(() => {}, 10);

    // Return access to the service worker's functions
    return {
      handleMessage: (global as any).handleMessage,
      settingsManager: (global as any).settingsManager,
      testGitHubConnection: (global as any).testGitHubConnection,
      getTurndownLibrary: (global as any).getTurndownLibrary,
    };
  } catch (error) {
    console.error('Failed to execute service worker code:', error);
    console.error('Error details:', (error as Error).message);
    console.error('Stack trace:', (error as Error).stack);

    // Return a mock API that throws meaningful errors
    return {
      handleMessage: jest.fn().mockRejectedValue(new Error('Service worker code execution failed')),
      settingsManager: null,
      testGitHubConnection: jest
        .fn()
        .mockRejectedValue(new Error('Service worker code execution failed')),
      getTurndownLibrary: jest
        .fn()
        .mockRejectedValue(new Error('Service worker code execution failed')),
    };
  }
};
