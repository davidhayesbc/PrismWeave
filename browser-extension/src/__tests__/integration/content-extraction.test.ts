// Generated by Copilot
// Integration tests for bookmarklet end-to-end functionality

import { BookmarkletRuntime } from '../../bookmarklet/runtime';
import { BookmarkletUI } from '../../bookmarklet/ui';
import { BookmarkletContentCapture } from '../../utils/bookmarklet-content-capture';

describe('Bookmarklet Integration Tests', () => {
  let runtime: BookmarkletRuntime;
  let mockDocument: any;
  let mockWindow: any;
  let mockFetch: jest.Mock;

  const testConfig = {
    githubToken: 'ghp_1234567890abcdef1234567890abcdef12345678',
    githubRepo: 'testuser/testrepo',
    defaultFolder: 'documents',
    customFolder: '',
    fileNamingPattern: '{date}-{title}',
    commitMessageTemplate: 'Add captured content: {title}',
    captureImages: true,
    removeAds: true,
    removeNavigation: true,
  };

  // Mock DOM environment for testing
  const createMockDocument = () => ({
    title: 'Test Article',
    body: {
      innerHTML: `
        <article>
          <h1>Test Article Title</h1>
          <p>This is test content for the article.</p>
          <p>Another paragraph with more content.</p>
          <img src="https://example.com/image.jpg" alt="Test Image" />
        </article>
      `,
    },
    querySelector: jest.fn(),
    querySelectorAll: jest.fn(),
    createElement: jest.fn(),
    head: { appendChild: jest.fn() },
  });

  const createMockWindow = () => ({
    location: {
      href: 'https://example.com/test-article',
      hostname: 'example.com',
    },
    document: mockDocument,
  });

  beforeEach(() => {
    // Create fresh mocks for each test
    mockDocument = createMockDocument();
    mockWindow = createMockWindow();
    mockFetch = jest.fn();

    // Mock global environment
    (global as any).document = mockDocument;
    (global as any).window = mockWindow;
    (global as any).fetch = mockFetch;

    // Create new runtime instance for each test
    runtime = new BookmarkletRuntime();
  });

  afterEach(() => {
    jest.clearAllMocks();
    // Clean up runtime if needed
    if (runtime && typeof runtime.shutdown === 'function') {
      runtime.shutdown().catch(() => {
        // Ignore cleanup errors in tests
      });
    }
  });

  describe('Runtime initialization', () => {
    test('should initialize with valid config', async () => {
      await expect(runtime.initialize(testConfig)).resolves.not.toThrow();

      const status = runtime.getStatus();
      expect(status.initialized).toBe(true);
    });

    test('should throw error with missing required config', async () => {
      const invalidConfig = { ...testConfig };
      (invalidConfig as any).githubToken = undefined;

      await expect(runtime.initialize(invalidConfig)).rejects.toThrow();
    });

    test('should merge stored config with provided config', async () => {
      // Mock localStorage with stored config
      const storedConfig = { customFolder: 'custom-docs' };
      jest.spyOn(Storage.prototype, 'getItem').mockReturnValue(JSON.stringify(storedConfig));

      await runtime.initialize(testConfig);

      const status = runtime.getStatus();
      expect(status.initialized).toBe(true);
    });
  });

  describe('Content extraction workflow', () => {
    beforeEach(async () => {
      await runtime.initialize(testConfig);
    });

    test('should execute content extraction workflow', async () => {
      const showSpy = jest.spyOn(BookmarkletUI.prototype, 'show');
      const executeSpy = jest.spyOn(runtime, 'execute');
      executeSpy.mockResolvedValue(undefined);

      await runtime.execute();

      expect(executeSpy).toHaveBeenCalled();
    });

    test('should handle content capture correctly', async () => {
      // Mock capture methods
      const captureSpy = jest.spyOn(BookmarkletContentCapture.prototype, 'captureCurrentPage');
      captureSpy.mockResolvedValue({
        success: true,
        data: {
          title: 'Test Article',
          url: 'https://example.com/test',
          markdown: '# Test Article\n\nTest content',
          frontmatter: '---\ntitle: Test Article\n---',
          content: 'Test content',
          wordCount: 2,
          readingTime: 1,
          extractedAt: new Date().toISOString(),
          images: [],
          metadata: {},
        },
        warnings: [],
        qualityScore: 0.8,
        extractionTime: 150,
      });

      const executeSpy = jest.spyOn(runtime, 'execute');
      executeSpy.mockResolvedValue(undefined);

      await runtime.execute();

      expect(executeSpy).toHaveBeenCalled();
    });

    test('should handle extraction failures gracefully', async () => {
      mockDocument.querySelector.mockImplementation(() => {
        throw new Error('DOM access failed');
      });

      const executeSpy = jest.spyOn(runtime, 'execute');
      executeSpy.mockResolvedValue(undefined);

      await runtime.initialize(testConfig);

      await expect(runtime.execute()).resolves.not.toThrow();
    });
  });

  describe('Error handling', () => {
    test('should handle network errors during save', async () => {
      await runtime.initialize(testConfig);

      const executeSpy = jest.spyOn(runtime, 'execute');
      executeSpy.mockResolvedValue(undefined);

      await runtime.execute();

      // Test should complete without throwing
      expect(executeSpy).toHaveBeenCalled();
    });

    test('should handle UI cleanup properly', async () => {
      await runtime.initialize(testConfig);

      const cleanupSpy = jest.spyOn(BookmarkletUI.prototype, 'cleanup');

      await runtime.shutdown();

      expect(cleanupSpy).toHaveBeenCalled();
    });

    test('should handle multiple shutdown calls', async () => {
      await runtime.initialize(testConfig);

      await runtime.shutdown();
      // Should not throw when called again
      await expect(runtime.shutdown()).resolves.not.toThrow();
    });
  });

  describe('Multi-instance handling', () => {
    test('should handle multiple runtime instances', async () => {
      const runtime1 = new BookmarkletRuntime();
      const runtime2 = new BookmarkletRuntime();

      await runtime1.initialize(testConfig);
      await runtime2.initialize(testConfig);

      const status1 = runtime1.getStatus();
      const status2 = runtime2.getStatus();

      expect(status1.initialized).toBe(true);
      expect(status2.initialized).toBe(true);
    });

    test('should track execution state correctly', async () => {
      await runtime.initialize(testConfig);

      const initialStatus = runtime.getStatus();

      const executeSpy = jest.spyOn(runtime, 'execute');
      executeSpy.mockResolvedValue(undefined);

      await runtime.execute();
      const afterExecution = runtime.getStatus();

      expect(initialStatus.initialized).toBe(true);
      expect(afterExecution.initialized).toBe(true);
    });
  });

  describe('status and compatibility', () => {
    test('should report status information', () => {
      const status = runtime.getStatus();

      expect(status.initialized).toBeDefined();
      expect(typeof status.initialized).toBe('boolean');
      expect(status.active).toBeDefined();
      expect(typeof status.active).toBe('boolean');
    });

    test('should be compatible across browser environments', async () => {
      // Test with minimal global environment
      const minimalGlobal = {
        document: mockDocument,
        window: createMockWindow(),
        fetch: mockFetch,
      };

      // Should initialize successfully even with minimal globals
      await expect(runtime.initialize(testConfig)).resolves.not.toThrow();
    });
  });
});
