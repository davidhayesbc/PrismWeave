// Generated by Copilot
// GitHub API Client Tests - Testing direct GitHub integration for bookmarklet

import { GitHubAPIClient } from '../../bookmarklet/github-api-client';

// Mock fetch for testing
global.fetch = jest.fn();

describe('GitHubAPIClient', () => {
  let client: GitHubAPIClient;
  const mockConfig = {
    token: 'test-token',
    repository: 'owner/repo',
    branch: 'main',
  };

  beforeEach(() => {
    client = new GitHubAPIClient(mockConfig);
    jest.clearAllMocks();
  });

  describe('constructor', () => {
    test('should initialize with provided config', () => {
      const config = client.getConfig();
      expect(config.repository).toBe('owner/repo');
      expect(config.branch).toBe('main');
      expect(config.baseUrl).toBe('https://api.github.com');
    });

    test('should use custom base URL when provided', () => {
      const customClient = new GitHubAPIClient({
        ...mockConfig,
        baseUrl: 'https://api.github.com/custom',
      });

      const config = customClient.getConfig();
      expect(config.baseUrl).toBe('https://api.github.com/custom');
    });
  });

  describe('parseRepository', () => {
    test('should parse valid repository format', async () => {
      const mockResponse = {
        ok: true,
        json: jest.fn().mockResolvedValue({
          login: 'testuser',
          name: 'Test User',
          email: 'test@example.com',
        }),
      };

      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);

      const result = await client.testConnection();

      // Verify the API was called with correct repository parsing
      expect(global.fetch).toHaveBeenCalledWith(
        'https://api.github.com/user',
        expect.objectContaining({
          headers: expect.objectContaining({
            Authorization: 'token test-token',
          }),
        })
      );
    });

    test('should throw error for invalid repository format', () => {
      expect(() => {
        new GitHubAPIClient({
          ...mockConfig,
          repository: 'invalid-format',
        });
      }).not.toThrow(); // Constructor doesn't validate, but methods do
    });
  });

  describe('testConnection', () => {
    test('should successfully test connection with valid credentials', async () => {
      const mockUserResponse = {
        ok: true,
        json: jest.fn().mockResolvedValue({
          login: 'testuser',
          name: 'Test User',
          email: 'test@example.com',
        }),
      };

      const mockRepoResponse = {
        ok: true,
        json: jest.fn().mockResolvedValue({
          name: 'repo',
          full_name: 'owner/repo',
          private: false,
          permissions: { admin: true, push: true, pull: true },
        }),
      };

      (global.fetch as jest.Mock)
        .mockResolvedValueOnce(mockUserResponse)
        .mockResolvedValueOnce(mockRepoResponse);

      const result = await client.testConnection();

      expect(result.success).toBe(true);
      expect(result.user?.login).toBe('testuser');
      expect(result.repository?.full_name).toBe('owner/repo');
    });

    test('should handle invalid GitHub token', async () => {
      const mockResponse = {
        ok: false,
        status: 401,
        json: jest.fn().mockResolvedValue({
          message: 'Bad credentials',
        }),
      };

      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);

      const result = await client.testConnection();

      expect(result.success).toBe(false);
      expect(result.error).toContain('Invalid GitHub token');
    });

    test('should handle repository not found', async () => {
      const mockUserResponse = {
        ok: true,
        json: jest.fn().mockResolvedValue({
          login: 'testuser',
          name: 'Test User',
          email: 'test@example.com',
        }),
      };

      const mockRepoResponse = {
        ok: false,
        status: 404,
      };

      (global.fetch as jest.Mock)
        .mockResolvedValueOnce(mockUserResponse)
        .mockResolvedValueOnce(mockRepoResponse);

      const result = await client.testConnection();

      expect(result.success).toBe(false);
      expect(result.error).toContain('Repository not found');
    });
  });

  describe('commitFile', () => {
    test('should successfully commit new file', async () => {
      const mockGetFileResponse = {
        ok: false,
        status: 404,
      };

      const mockCommitResponse = {
        ok: true,
        json: jest.fn().mockResolvedValue({
          commit: {
            sha: 'abc123',
            message: 'Test commit',
            author: {
              name: 'Test User',
              email: 'test@example.com',
              date: '2023-01-01T00:00:00Z',
            },
          },
          content: {
            html_url: 'https://github.com/owner/repo/blob/main/test.md',
          },
        }),
      };

      (global.fetch as jest.Mock)
        .mockResolvedValueOnce(mockGetFileResponse)
        .mockResolvedValueOnce(mockCommitResponse);

      const result = await client.commitFile('test.md', 'Test content', 'Test commit');

      expect(result.success).toBe(true);
      expect(result.data?.sha).toBe('abc123');
      expect(result.data?.html_url).toBe('https://github.com/owner/repo/blob/main/test.md');
    });

    test('should successfully update existing file', async () => {
      const mockGetFileResponse = {
        ok: true,
        json: jest.fn().mockResolvedValue({
          sha: 'existing-sha',
          content: 'existing-content',
        }),
      };

      const mockCommitResponse = {
        ok: true,
        json: jest.fn().mockResolvedValue({
          commit: {
            sha: 'new-sha',
            message: 'Update test',
            author: {
              name: 'Test User',
              email: 'test@example.com',
              date: '2023-01-01T00:00:00Z',
            },
          },
          content: {
            html_url: 'https://github.com/owner/repo/blob/main/test.md',
          },
        }),
      };

      (global.fetch as jest.Mock)
        .mockResolvedValueOnce(mockGetFileResponse)
        .mockResolvedValueOnce(mockCommitResponse);

      const result = await client.commitFile('test.md', 'Updated content', 'Update test');

      expect(result.success).toBe(true);
      expect(result.data?.sha).toBe('new-sha');

      // Verify the commit request included the existing SHA
      expect(global.fetch).toHaveBeenLastCalledWith(
        'https://api.github.com/repos/owner/repo/contents/test.md',
        expect.objectContaining({
          method: 'PUT',
          body: expect.stringContaining('"sha":"existing-sha"'),
        })
      );
    });

    test('should handle commit failure', async () => {
      const mockGetFileResponse = {
        ok: false,
        status: 404,
      };

      const mockCommitResponse = {
        ok: false,
        status: 422,
        json: jest.fn().mockResolvedValue({
          message: 'Validation failed',
        }),
      };

      (global.fetch as jest.Mock)
        .mockResolvedValueOnce(mockGetFileResponse)
        .mockResolvedValueOnce(mockCommitResponse);

      const result = await client.commitFile('test.md', 'Test content', 'Test commit');

      expect(result.success).toBe(false);
      expect(result.error).toContain('GitHub API error: 422');
    });
  });

  describe('getFile', () => {
    test('should successfully retrieve existing file', async () => {
      const mockResponse = {
        ok: true,
        json: jest.fn().mockResolvedValue({
          type: 'file',
          encoding: 'base64',
          size: 1024,
          name: 'test.md',
          path: 'test.md',
          content: 'dGVzdCBjb250ZW50',
          sha: 'file-sha',
          url: 'https://api.github.com/repos/owner/repo/contents/test.md',
          git_url: 'https://api.github.com/repos/owner/repo/git/blobs/file-sha',
          html_url: 'https://github.com/owner/repo/blob/main/test.md',
          download_url: 'https://raw.githubusercontent.com/owner/repo/main/test.md',
        }),
      };

      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);

      const result = await client.getFile('test.md');

      expect(result).not.toBeNull();
      expect(result?.name).toBe('test.md');
      expect(result?.sha).toBe('file-sha');
    });

    test('should return null for non-existent file', async () => {
      const mockResponse = {
        ok: false,
        status: 404,
      };

      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);

      const result = await client.getFile('nonexistent.md');

      expect(result).toBeNull();
    });
  });

  describe('listFiles', () => {
    test('should successfully list files in directory', async () => {
      const mockResponse = {
        ok: true,
        json: jest.fn().mockResolvedValue([
          {
            name: 'file1.md',
            path: 'docs/file1.md',
            type: 'file',
            size: 512,
            sha: 'file1-sha',
            html_url: 'https://github.com/owner/repo/blob/main/docs/file1.md',
          },
          {
            name: 'subdir',
            path: 'docs/subdir',
            type: 'dir',
            size: 0,
            sha: 'dir-sha',
            html_url: 'https://github.com/owner/repo/tree/main/docs/subdir',
          },
        ]),
      };

      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);

      const result = await client.listFiles('docs');

      expect(result.success).toBe(true);
      expect(result.files).toHaveLength(2);
      expect(result.files?.[0].name).toBe('file1.md');
      expect(result.files?.[0].type).toBe('file');
      expect(result.files?.[1].name).toBe('subdir');
      expect(result.files?.[1].type).toBe('dir');
    });

    test('should handle listing error', async () => {
      const mockResponse = {
        ok: false,
        status: 403,
        json: jest.fn().mockResolvedValue({
          message: 'Forbidden',
        }),
      };

      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);

      const result = await client.listFiles('docs');

      expect(result.success).toBe(false);
      expect(result.error).toContain('Failed to list files');
    });
  });

  describe('updateConfig', () => {
    test('should update configuration', () => {
      client.updateConfig({
        branch: 'develop',
        baseUrl: 'https://custom.github.com/api',
      });

      const config = client.getConfig();
      expect(config.branch).toBe('develop');
      expect(config.baseUrl).toBe('https://custom.github.com/api');
    });
  });

  describe('base64 encoding/decoding', () => {
    test('should properly encode content to base64', async () => {
      const mockGetFileResponse = {
        ok: false,
        status: 404,
      };

      const mockCommitResponse = {
        ok: true,
        json: jest.fn().mockResolvedValue({
          commit: {
            sha: 'test-sha',
            message: 'test',
            author: { name: 'test', email: 'test', date: '2023-01-01' },
          },
          content: { html_url: 'test-url' },
        }),
      };

      (global.fetch as jest.Mock)
        .mockResolvedValueOnce(mockGetFileResponse)
        .mockResolvedValueOnce(mockCommitResponse);

      const testContent = 'Hello, World! 🌍';
      await client.commitFile('test.md', testContent, 'Test commit');

      // Verify the content was base64 encoded
      const callBody = JSON.parse((global.fetch as jest.Mock).mock.calls[1][1].body);
      expect(callBody.content).toBe(btoa(unescape(encodeURIComponent(testContent))));
    });
  });
});
