// Generated by Copilot
// Core settings manager with environment-agnostic implementation

interface ISettingDefinition {
  type: 'string' | 'boolean' | 'number' | 'array';
  default: string | boolean | number | string[];
  required: boolean;
  sensitive: boolean;
  description: string;
  pattern?: RegExp;
  options?: string[];
  requires?: string[];
  min?: number;
  max?: number;
}

interface ISettingsSchema {
  [key: string]: ISettingDefinition;
}

interface IValidationResult {
  isValid: boolean;
  errors: string[];
}

interface ISettings {
  [key: string]: unknown;
}

// Core settings manager with dependency injection
export class SettingsManagerCore {
  private readonly STORAGE_KEY: string = 'prismWeaveSettings';
  private readonly schema: ISettingsSchema;

  constructor() {
    this.schema = this.getSettingsSchema();
  }

  private getSettingsSchema(): ISettingsSchema {
    return {
      // Repository Configuration
      githubToken: {
        type: 'string',
        default: '',
        required: false,
        sensitive: true,
        description: 'GitHub personal access token',
      },
      githubRepo: {
        type: 'string',
        default: '',
        required: false,
        sensitive: false,
        pattern: /^[a-zA-Z0-9._-]+\/[a-zA-Z0-9._-]+$/,
        description: 'GitHub repository in format owner/repo',
      },

      // File Organization
      defaultFolder: {
        type: 'string',
        default: 'unsorted',
        required: true,
        sensitive: false,
        options: [
          'tech',
          'business',
          'research',
          'news',
          'tutorial',
          'reference',
          'blog',
          'social',
          'unsorted',
          'custom',
        ],
        description: 'Default folder for captured documents',
      },
      customFolder: {
        type: 'string',
        default: '',
        required: false,
        sensitive: false,
        description: 'Custom folder name when defaultFolder is "custom"',
      },
      fileNamingPattern: {
        type: 'string',
        default: 'YYYY-MM-DD-domain-title',
        required: true,
        sensitive: false,
        options: [
          'YYYY-MM-DD-domain-title',
          'YYYY-MM-DD-title',
          'domain-YYYY-MM-DD-title',
          'title-YYYY-MM-DD',
        ],
        description: 'Template for generated filenames',
      },

      // Automation Settings
      autoCommit: {
        type: 'boolean',
        required: false,
        sensitive: false,
        default: true,
        description: 'Automatically commit captured files to Git',
      },

      // Content Processing
      captureImages: {
        type: 'boolean',
        required: false,
        sensitive: false,
        default: true,
        description: 'Download and save images from captured pages',
      },
      removeAds: {
        type: 'boolean',
        required: false,
        sensitive: false,
        default: true,
        description: 'Remove advertisements and promotional content',
      },
      removeNavigation: {
        type: 'boolean',
        required: false,
        sensitive: false,
        default: true,
        description: 'Remove navigation menus and site headers/footers',
      },
      customSelectors: {
        type: 'string',
        default: '',
        required: false,
        sensitive: false,
        description: 'Custom CSS selectors for elements to remove during capture',
      },

      // Git & Repository Settings
      commitMessageTemplate: {
        type: 'string',
        required: false,
        sensitive: false,
        default: 'Add: {domain} - {title}',
        description: 'Template for git commit messages',
      },

      // Debugging Settings
      debugMode: {
        type: 'boolean',
        required: false,
        sensitive: false,
        default: false,
        description: 'Enable detailed logging and debug information',
      },

      // UI Preferences
      showNotifications: {
        type: 'boolean',
        required: false,
        sensitive: false,
        default: true,
        description: 'Show completion notifications',
      },
      enableKeyboardShortcuts: {
        type: 'boolean',
        required: false,
        sensitive: false,
        default: true,
        description: 'Enable keyboard shortcuts for capture',
      },
    };
  }

  /**
   * Get defaults from schema
   */
  getDefaults(): ISettings {
    const defaults: ISettings = {};

    Object.entries(this.schema).forEach(([key, definition]) => {
      defaults[key] = definition.default;
    });

    return defaults;
  }

  /**
   * Merge current settings with defaults
   */
  mergeWithDefaults(currentSettings: Partial<ISettings>): ISettings {
    const defaults = this.getDefaults();
    return { ...defaults, ...currentSettings };
  }

  /**
   * Validate settings against schema
   */
  validateSettings(settings: Partial<ISettings>): IValidationResult {
    const errors: string[] = [];

    Object.entries(settings).forEach(([key, value]) => {
      const definition = this.schema[key];
      if (!definition) {
        errors.push(`Unknown setting: ${key}`);
        return;
      }

      // Type validation with proper array handling
      const isValidType = this.validateType(value, definition.type);
      if (!isValidType) {
        errors.push(
          `Invalid type for ${key}: expected ${definition.type}, got ${this.getActualType(value)}`
        );
        return;
      }

      // Pattern validation
      if (
        definition.pattern &&
        typeof value === 'string' &&
        value !== '' &&
        !definition.pattern.test(value)
      ) {
        errors.push(`Invalid format for ${key}: does not match required pattern`);
      }

      // Options validation
      if (definition.options && value !== '' && !definition.options.includes(value as string)) {
        errors.push(`Invalid value for ${key}: must be one of ${definition.options.join(', ')}`);
      }

      // Range validation for numbers
      if (definition.type === 'number' && typeof value === 'number') {
        if (definition.min !== undefined && value < definition.min) {
          errors.push(`Value for ${key} is below minimum: ${definition.min}`);
        }
        if (definition.max !== undefined && value > definition.max) {
          errors.push(`Value for ${key} is above maximum: ${definition.max}`);
        }
      }
    });

    return { isValid: errors.length === 0, errors };
  }

  /**
   * Check for missing dependencies
   */
  checkRequiredDependencies(settings: Partial<ISettings>): string[] {
    const missingDependencies: string[] = [];

    Object.entries(settings).forEach(([key, value]) => {
      const definition = this.schema[key];
      if (definition?.requires && value) {
        definition.requires.forEach(required => {
          if (!settings[required]) {
            missingDependencies.push(`${key} requires ${required} to be set`);
          }
        });
      }
    });

    return missingDependencies;
  }

  /**
   * Get setting definition by key
   */
  getSettingDefinition(key: string): ISettingDefinition | null {
    return this.schema[key] || null;
  }

  /**
   * Get all setting definitions
   */
  getAllSettingDefinitions(): ISettingsSchema {
    return { ...this.schema };
  }

  /**
   * Sanitize settings for export (remove sensitive data)
   */
  sanitizeForExport(settings: ISettings): ISettings {
    const sanitized = { ...settings };

    Object.entries(this.schema).forEach(([key, definition]) => {
      if (definition.sensitive && sanitized[key]) {
        sanitized[key] = '[REDACTED]';
      }
    });

    return sanitized;
  }

  /**
   * Parse and validate imported settings
   */
  parseImportedSettings(jsonString: string): { success: boolean; settings?: ISettings; error?: string } {
    try {
      const imported = JSON.parse(jsonString) as Partial<ISettings>;
      const validationResult = this.validateSettings(imported);
      
      if (!validationResult.isValid) {
        return {
          success: false,
          error: `Validation failed: ${validationResult.errors.join(', ')}`
        };
      }

      return {
        success: true,
        settings: imported
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown parsing error'
      };
    }
  }

  /**
   * Get storage key
   */
  getStorageKey(): string {
    return this.STORAGE_KEY;
  }

  private validateType(value: unknown, expectedType: string): boolean {
    switch (expectedType) {
      case 'array':
        return Array.isArray(value);
      case 'string':
        return typeof value === 'string';
      case 'boolean':
        return typeof value === 'boolean';
      case 'number':
        return typeof value === 'number';
      default:
        return false;
    }
  }

  private getActualType(value: unknown): string {
    if (Array.isArray(value)) return 'array';
    if (value === null) return 'null';
    return typeof value;
  }
}

// Export types for use by adapters
export type { ISettingDefinition, ISettings, ISettingsSchema, IValidationResult };

