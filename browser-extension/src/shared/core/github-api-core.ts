// Generated by Copilot
// Core GitHub API client with environment-agnostic implementation

/**
 * HTTP provider interface for dependency injection
 */
interface IHttpProvider {
  fetch(url: string, options?: RequestInit): Promise<Response>;
}

interface IRepositoryInfo {
  owner: string;
  repo: string;
}

interface IGitHubFileInfo {
  sha: string;
  html_url?: string;
  size?: number;
  [key: string]: unknown;
}

interface IGitHubCommitParams {
  token: string;
  repo: string;
  filePath: string;
  content: string;
  message: string;
  url?: string;
}

interface IGitHubCommitResult {
  success: boolean;
  data?: {
    html_url?: string;
    sha?: string;
    [key: string]: unknown;
  };
  error?: string;
}

interface IGitHubConnectionTest {
  success: boolean;
  status: string;
  message?: string;
  details?: Record<string, unknown>;
  error?: string;
}

/**
 * Core GitHub API client with dependency injection
 * Environment-agnostic implementation that works in both browser extensions and bookmarklets
 */
export class GitHubAPICore {
  private static readonly API_BASE = 'https://api.github.com';
  private static readonly USER_AGENT = 'PrismWeave-Extension/1.0';

  private logger?: {
    info: (msg: string, ...args: any[]) => void;
    debug: (msg: string, ...args: any[]) => void;
    warn: (msg: string, ...args: any[]) => void;
    error: (msg: string, ...args: any[]) => void;
  } | undefined;
  private httpProvider: IHttpProvider;

  constructor(
    logger?: {
      info: (msg: string, ...args: any[]) => void;
      debug: (msg: string, ...args: any[]) => void;
      warn: (msg: string, ...args: any[]) => void;
      error: (msg: string, ...args: any[]) => void;
    },
    httpProvider?: IHttpProvider
  ) {
    this.logger = logger;
    this.httpProvider = httpProvider || { fetch: (url, options) => fetch(url, options) };
  }

  /**
   * Commit content to GitHub repository with automatic file creation/update
   */
  async commitToGitHub(params: IGitHubCommitParams): Promise<IGitHubCommitResult> {
    try {
      const { token, repo, filePath, content, message } = params;

      this.logger?.info('üöÄ Starting GitHub commit process:', {
        repo,
        filePath,
        messageLength: message.length,
        contentLength: content.length,
      });

      // Validate and parse repository
      const repoInfo = this.parseRepositoryPath(repo);
      this.logger?.info('üìÅ Parsed repository:', repoInfo);

      // Check if file already exists
  const existingFile = await this.getFileInfo(token, repoInfo, filePath);
      this.logger?.info('üìã File existence check:', {
        exists: !!existingFile,
        sha: existingFile?.sha,
      });

      // Create or update the file
      const result = await this.createOrUpdateFile(
        token,
        repoInfo,
        filePath,
        content,
        message,
        existingFile?.sha
      );

      this.logger?.info('‚úÖ Successfully committed to GitHub:', result.content?.html_url);

      return {
        success: true,
        data: result.content,
      };
    } catch (error) {
      this.logger?.error('üí• GitHub commit failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  /**
   * Test GitHub connection and permissions
   */
  async testConnection(token: string, repo: string): Promise<IGitHubConnectionTest> {
    try {
      this.logger?.info('üîó Testing GitHub connection...');

      // Validate inputs
      if (!token || !repo) {
        return {
          success: false,
          status: 'failed',
          error: 'GitHub token and repository are required',
        };
      }

      // Parse repository
      const repoInfo = this.parseRepositoryPath(repo);

      // Test 1: Validate GitHub token
      this.logger?.info('üîë Testing GitHub token...');
      const userData = await this.validateToken(token);

      // Test 2: Check repository access
      this.logger?.info('üìÅ Testing repository access...');
      const repoData = await this.validateRepository(token, repoInfo);

      // Test 3: Check write permissions
      this.logger?.info('‚úèÔ∏è Testing write permissions...');
      const hasWriteAccess = await this.checkWritePermissions(token, repoInfo);

      return {
        success: true,
        status: 'connected',
        message: 'GitHub connection test successful',
        details: {
          user: userData.login,
          userType: userData.type,
          repository: repoData.full_name,
          repositoryPrivate: repoData.private,
          hasWriteAccess,
          permissions: repoData.permissions || { admin: false, push: false, pull: true },
        },
      };
    } catch (error) {
      this.logger?.error('GitHub connection test failed:', error);
      return {
        success: false,
        status: 'failed',
        error: error instanceof Error ? error.message : 'Unknown error occurred',
      };
    }
  }

  /**
   * Validate repository path and return owner/repo info
   */
  validateRepositoryPath(repoPath: string): IRepositoryInfo {
    return this.parseRepositoryPath(repoPath);
  }

  // =============================================================================
  // PRIVATE METHODS
  // =============================================================================

  /**
   * Parse repository path into owner and repo components
   */
  private parseRepositoryPath(repoPath: string): IRepositoryInfo {
    if (!repoPath) {
      throw new Error('Repository path is required');
    }

    // Handle different repository path formats
    let cleanPath = repoPath;

    // Remove GitHub URL prefixes if present
    cleanPath = cleanPath.replace(/^https?:\/\/github\.com\//, '');
    cleanPath = cleanPath.replace(/\.git$/, '');

    const parts = cleanPath.split('/');

    if (parts.length < 2) {
      throw new Error('Invalid repository path format. Expected: owner/repo');
    }

    return {
      owner: parts[0],
      repo: parts[1],
    };
  }

  /**
   * Get file information from GitHub if it exists
   */
  private async getFileInfo(
    token: string,
    repoInfo: IRepositoryInfo,
    path: string
  ): Promise<IGitHubFileInfo | null> {
    const url = `${GitHubAPICore.API_BASE}/repos/${repoInfo.owner}/${repoInfo.repo}/contents/${path}`;
    const requestOptions = {
      method: 'GET',
      headers: this.getAuthHeaders(token),
    };

    this.logger?.info('üåê GitHub API Request - Get File Info:', {
      url,
      method: requestOptions.method,
      headers: this.sanitizeHeaders(requestOptions.headers),
      repository: `${repoInfo.owner}/${repoInfo.repo}`,
      filePath: path,
    });

    try {
      const response = await this.httpProvider.fetch(url, requestOptions);

      this.logger?.info('üì• GitHub API Response - Get File Info:', {
        url,
        status: response.status,
        statusText: response.statusText,
        headers: this.headersToObject(response.headers),
      });

      if (response.status === 404) {
        this.logger?.info('üìÑ File not found (404), returning null');
        return null;
      }

      if (!response.ok) {
        const errorText = await response.text().catch(() => '');
        this.logger?.error('GitHub API Error Response:', {
          url,
          status: response.status,
          statusText: response.statusText,
          errorBody: errorText,
        });
        throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
      }

      const data = (await response.json()) as IGitHubFileInfo;

      this.logger?.info('üíæ GitHub API Success - File Info Retrieved:', {
        url,
        filePath: path,
        sha: data.sha,
        size: data.size || 'unknown',
        htmlUrl: data.html_url,
      });

      if (!data.sha) {
        throw new Error('Invalid file info from GitHub: missing SHA');
      }

      return data;
    } catch (error) {
      this.logger?.error('GitHub API Error - Get File Info:', {
        url,
        error: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined,
      });
      
      if ((error as Error).message.includes('404')) {
        return null;
      }
      throw error;
    }
  }

  /**
   * Create or update a file in the GitHub repository
   */
  private async createOrUpdateFile(
    token: string,
    repoInfo: IRepositoryInfo,
    path: string,
    content: string,
    message: string,
    existingSha?: string
  ): Promise<any> {
    const url = `${GitHubAPICore.API_BASE}/repos/${repoInfo.owner}/${repoInfo.repo}/contents/${path}`;
    
    const requestBody: any = {
      message,
      // For binary files (PDF), content is already base64 encoded
      // For text files, we need to encode to base64
      content: path.endsWith('.pdf') ? content : btoa(unescape(encodeURIComponent(content))),
      branch: 'main',
    };

    if (existingSha) {
      requestBody.sha = existingSha;
    }

    const requestOptions = {
      method: 'PUT',
      headers: {
        ...this.getAuthHeaders(token),
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody),
    };

    this.logger?.info('üöÄ GitHub API Request - Create/Update File:', {
      url,
      method: requestOptions.method,
      headers: this.sanitizeHeaders(requestOptions.headers),
      repository: `${repoInfo.owner}/${repoInfo.repo}`,
      filePath: path,
      payload: {
        message: requestBody.message,
        branch: requestBody.branch,
        operation: existingSha ? 'UPDATE' : 'CREATE',
        contentLength: requestBody.content.length,
        contentType: path.endsWith('.pdf') ? 'binary/pdf' : 'text',
        sha: existingSha || 'N/A (new file)',
      },
    });

    try {
      const response = await this.httpProvider.fetch(url, requestOptions);

      this.logger?.info('üì° GitHub API Response - Create/Update File:', {
        url,
        status: response.status,
        statusText: response.statusText,
        headers: this.headersToObject(response.headers),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        const errorMessage = `GitHub API error: ${response.status} - ${errorData.message || 'Unknown error'}`;
        
        this.logger?.error('‚ùå GitHub API Error Response - Create/Update File:', {
          url,
          status: response.status,
          statusText: response.statusText,
          errorData: this.sanitizePayload(errorData),
          operation: existingSha ? 'UPDATE' : 'CREATE',
          filePath: path,
        });

        throw new Error(errorMessage);
      }

      const responseData = await response.json();

      this.logger?.info('‚úÖ GitHub API Success - File Created/Updated:', {
        url,
        filePath: path,
        operation: existingSha ? 'UPDATE' : 'CREATE',
        commit: {
          sha: responseData.commit?.sha,
          message: responseData.commit?.message,
          author: responseData.commit?.author?.name,
        },
        content: {
          sha: responseData.content?.sha,
          htmlUrl: responseData.content?.html_url,
          downloadUrl: responseData.content?.download_url,
        },
      });

      return responseData;
    } catch (error) {
      this.logger?.error('GitHub API Error - Create/Update File:', {
        url,
        filePath: path,
        operation: existingSha ? 'UPDATE' : 'CREATE',
        error: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined,
      });
      throw error;
    }
  }

  /**
   * Validate GitHub token by fetching user info
   */
  private async validateToken(token: string): Promise<any> {
    const url = `${GitHubAPICore.API_BASE}/user`;
    const requestOptions = {
      headers: this.getAuthHeaders(token),
    };

    this.logger?.info('GitHub API Request - Validate Token:', {
      url,
      method: 'GET',
      headers: this.sanitizeHeaders(requestOptions.headers),
    });

    try {
      const response = await this.httpProvider.fetch(url, requestOptions);

      this.logger?.info('GitHub API Response - Validate Token:', {
        url,
        status: response.status,
        statusText: response.statusText,
        headers: this.headersToObject(response.headers),
      });

      if (!response.ok) {
        const errorText = await response.text().catch(() => '');
        this.logger?.error('GitHub API Error Response - Token Validation:', {
          url,
          status: response.status,
          statusText: response.statusText,
          errorBody: errorText,
        });
        throw new Error(`Invalid GitHub token (${response.status})`);
      }

      const userData = await response.json();
      
      this.logger?.info('GitHub API Success - Token Validated:', {
        url,
        user: {
          login: userData.login,
          id: userData.id,
          type: userData.type,
          company: userData.company,
          publicRepos: userData.public_repos,
          privateRepos: userData.total_private_repos,
          plan: userData.plan?.name,
        },
      });

      return userData;
    } catch (error) {
      this.logger?.error('GitHub API Error - Token Validation:', {
        url,
        error: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined,
      });
      throw error;
    }
  }

  /**
   * Validate repository access
   */
  private async validateRepository(token: string, repoInfo: IRepositoryInfo): Promise<any> {
    const url = `${GitHubAPICore.API_BASE}/repos/${repoInfo.owner}/${repoInfo.repo}`;
    const requestOptions = {
      headers: this.getAuthHeaders(token),
    };

    this.logger?.info('GitHub API Request - Validate Repository:', {
      url,
      method: 'GET',
      headers: this.sanitizeHeaders(requestOptions.headers),
      repository: `${repoInfo.owner}/${repoInfo.repo}`,
    });

    try {
      const response = await this.httpProvider.fetch(url, requestOptions);

      this.logger?.info('GitHub API Response - Validate Repository:', {
        url,
        status: response.status,
        statusText: response.statusText,
        headers: this.headersToObject(response.headers),
      });

      if (!response.ok) {
        const errorText = await response.text().catch(() => '');
        const errorMsg =
          response.status === 404
            ? 'Repository not found or no access'
            : `Repository access failed (${response.status})`;

        this.logger?.error('GitHub API Error Response - Repository Validation:', {
          url,
          repository: `${repoInfo.owner}/${repoInfo.repo}`,
          status: response.status,
          statusText: response.statusText,
          errorBody: errorText,
          errorMessage: errorMsg,
        });

        throw new Error(errorMsg);
      }

      const repoData = await response.json();
      
      this.logger?.info('GitHub API Success - Repository Validated:', {
        url,
        repository: {
          fullName: repoData.full_name,
          description: repoData.description,
          private: repoData.private,
          defaultBranch: repoData.default_branch,
          size: repoData.size,
          language: repoData.language,
          createdAt: repoData.created_at,
          updatedAt: repoData.updated_at,
          permissions: repoData.permissions,
          owner: {
            login: repoData.owner?.login,
            type: repoData.owner?.type,
          },
        },
      });

      return repoData;
    } catch (error) {
      this.logger?.error('GitHub API Error - Repository Validation:', {
        url,
        repository: `${repoInfo.owner}/${repoInfo.repo}`,
        error: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined,
      });
      throw error;
    }
  }

  /**
   * Check write permissions by testing contents API
   */
  private async checkWritePermissions(token: string, repoInfo: IRepositoryInfo): Promise<boolean> {
    const url = `${GitHubAPICore.API_BASE}/repos/${repoInfo.owner}/${repoInfo.repo}/contents`;
    const requestOptions = {
      headers: this.getAuthHeaders(token),
    };

    this.logger?.info('GitHub API Request - Check Write Permissions:', {
      url,
      method: 'GET',
      headers: this.sanitizeHeaders(requestOptions.headers),
      repository: `${repoInfo.owner}/${repoInfo.repo}`,
    });

    try {
      const response = await this.httpProvider.fetch(url, requestOptions);

      this.logger?.info('GitHub API Response - Check Write Permissions:', {
        url,
        status: response.status,
        statusText: response.statusText,
        headers: this.headersToObject(response.headers),
      });

      const hasAccess = response.ok;
      
      if (!hasAccess) {
        const errorText = await response.text().catch(() => '');
        this.logger?.warn('GitHub API Warning - Limited Repository Access:', {
          url,
          repository: `${repoInfo.owner}/${repoInfo.repo}`,
          status: response.status,
          statusText: response.statusText,
          errorBody: errorText,
          message: 'May not have write permissions',
        });
      } else {
        this.logger?.info('GitHub API Success - Write Permissions Confirmed:', {
          url,
          repository: `${repoInfo.owner}/${repoInfo.repo}`,
          hasWriteAccess: true,
        });
      }

      return hasAccess;
    } catch (error) {
      this.logger?.error('GitHub API Error - Check Write Permissions:', {
        url,
        repository: `${repoInfo.owner}/${repoInfo.repo}`,
        error: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined,
        result: 'Defaulting to no write access',
      });
      return false;
    }
  }

  /**
   * Get standard authentication headers for GitHub API
   */
  private getAuthHeaders(token: string): Record<string, string> {
    return {
      Authorization: `token ${token}`,
      Accept: 'application/vnd.github.v3+json',
      'User-Agent': GitHubAPICore.USER_AGENT,
    };
  }

  /**
   * Sanitize headers for logging by removing sensitive information
   */
  private sanitizeHeaders(headers: Record<string, string>): Record<string, string> {
    const sanitized = { ...headers };
    if (sanitized.Authorization) {
      sanitized.Authorization = 'token [REDACTED]';
    }
    return sanitized;
  }

  /**
   * Sanitize request payload for logging by removing sensitive information
   */
  private sanitizePayload(payload: any): any {
    if (!payload || typeof payload !== 'object') {
      return payload;
    }

    const sanitized = { ...payload };
    
    // Remove or redact sensitive fields
    if (sanitized.token) {
      sanitized.token = '[REDACTED]';
    }
    
    return sanitized;
  }

  /**
   * Convert Headers object to plain object for logging
   */
  private headersToObject(headers: Headers): Record<string, string> {
    const headerObj: Record<string, string> = {};
    try {
      // Use Headers.forEach method which is more compatible
      headers.forEach((value, key) => {
        headerObj[key] = value;
      });
    } catch (error) {
      // Fallback for environments where forEach might not exist
      return { 'headers-parse-error': 'Unable to parse headers' };
    }
    return headerObj;
  }
}

// Export types for use by adapters
export type {
  IGitHubCommitParams,
  IGitHubCommitResult,
  IGitHubConnectionTest, IGitHubFileInfo, IRepositoryInfo
};

