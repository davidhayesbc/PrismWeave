// Generated by Copilot
// Chrome API adapters for PrismWeave shared utilities (simplified for Phase 1)

import type { IHttpProvider } from '../core/github-client.js';
import type { IStorageProvider } from '../interfaces/storage-provider.js';

/**
 * Chrome storage adapter for sync storage
 */
export class ChromeStorageProvider implements IStorageProvider {
  async get<T>(key: string): Promise<T | null> {
    // Access chrome API - check multiple contexts for compatibility
    const chromeAPI = this.getChromeAPI();
    
    if (!chromeAPI || !chromeAPI.storage) {
      throw new Error('Chrome storage API not available');
    }

    return new Promise<T | null>((resolve, reject) => {
      chromeAPI.storage.sync.get([key], (result: Record<string, T>) => {
        if (chromeAPI.runtime.lastError) {
          reject(new Error(chromeAPI.runtime.lastError.message));
        } else {
          resolve(result[key] || null);
        }
      });
    });
  }

  async set<T>(key: string, value: T): Promise<void> {
    const chromeAPI = this.getChromeAPI();
    
    if (!chromeAPI || !chromeAPI.storage) {
      throw new Error('Chrome storage API not available');
    }

    return new Promise<void>((resolve, reject) => {
      chromeAPI.storage.sync.set({ [key]: value }, () => {
        if (chromeAPI.runtime.lastError) {
          reject(new Error(chromeAPI.runtime.lastError.message));
        } else {
          resolve();
        }
      });
    });
  }

  async remove(key: string): Promise<void> {
    const chromeAPI = this.getChromeAPI();
    
    if (!chromeAPI || !chromeAPI.storage) {
      throw new Error('Chrome storage API not available');
    }

    return new Promise<void>((resolve, reject) => {
      chromeAPI.storage.sync.remove([key], () => {
        if (chromeAPI.runtime.lastError) {
          reject(new Error(chromeAPI.runtime.lastError.message));
        } else {
          resolve();
        }
      });
    });
  }

  async getAll(): Promise<Record<string, unknown>> {
    const chromeAPI = this.getChromeAPI();
    
    if (!chromeAPI || !chromeAPI.storage) {
      throw new Error('Chrome storage API not available');
    }

    return new Promise<Record<string, unknown>>((resolve, reject) => {
      chromeAPI.storage.sync.get(null, (result: Record<string, unknown>) => {
        if (chromeAPI.runtime.lastError) {
          reject(new Error(chromeAPI.runtime.lastError.message));
        } else {
          resolve(result);
        }
      });
    });
  }

  async clear(): Promise<void> {
    const chromeAPI = this.getChromeAPI();
    
    if (!chromeAPI || !chromeAPI.storage) {
      throw new Error('Chrome storage API not available');
    }

    return new Promise<void>((resolve, reject) => {
      chromeAPI.storage.sync.clear(() => {
        if (chromeAPI.runtime.lastError) {
          reject(new Error(chromeAPI.runtime.lastError.message));
        } else {
          resolve();
        }
      });
    });
  }

  private getChromeAPI(): typeof chrome | undefined {
    return (
      (typeof chrome !== 'undefined' ? chrome : undefined) ||
      (typeof globalThis !== 'undefined' && (globalThis as any).chrome) ||
      (typeof self !== 'undefined' && (self as any).chrome) ||
      (typeof global !== 'undefined' && (global as any).chrome)
    );
  }
}

/**
 * Local storage adapter for bookmarklet use
 */
export class LocalStorageProvider implements IStorageProvider {
  private prefix = 'prismweave_';

  async get<T>(key: string): Promise<T | null> {
    try {
      const item = localStorage.getItem(this.prefix + key);
      return item ? JSON.parse(item) : null;
    } catch (error) {
      throw new Error(`LocalStorage get failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  async set<T>(key: string, value: T): Promise<void> {
    try {
      localStorage.setItem(this.prefix + key, JSON.stringify(value));
    } catch (error) {
      throw new Error(`LocalStorage set failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  async remove(key: string): Promise<void> {
    try {
      localStorage.removeItem(this.prefix + key);
    } catch (error) {
      throw new Error(`LocalStorage remove failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  async getAll(): Promise<Record<string, unknown>> {
    try {
      const result: Record<string, unknown> = {};
      const keys = Object.keys(localStorage).filter(key => key.startsWith(this.prefix));
      
      keys.forEach(key => {
        const shortKey = key.substring(this.prefix.length);
        const item = localStorage.getItem(key);
        if (item) {
          try {
            result[shortKey] = JSON.parse(item);
          } catch {
            result[shortKey] = item;
          }
        }
      });
      
      return result;
    } catch (error) {
      throw new Error(`LocalStorage getAll failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  async clear(): Promise<void> {
    try {
      const keys = Object.keys(localStorage).filter(key => key.startsWith(this.prefix));
      keys.forEach(key => localStorage.removeItem(key));
    } catch (error) {
      throw new Error(`LocalStorage clear failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
}

// =============================================================================
// HTTP PROVIDERS
// =============================================================================

/**
 * Standard fetch HTTP provider for modern browsers
 * Works in both extension and bookmarklet contexts
 */
export class FetchHttpProvider implements IHttpProvider {
  async fetch(url: string, options?: RequestInit): Promise<Response> {
    if (typeof globalThis.fetch !== 'function') {
      throw new Error('Fetch API not available in this environment');
    }
    
    return globalThis.fetch(url, options);
  }
}

/**
 * Chrome extension HTTP provider with CORS bypass
 * Uses Chrome extension permissions for cross-origin requests
 */
export class ChromeHttpProvider implements IHttpProvider {
  async fetch(url: string, options?: RequestInit): Promise<Response> {
    // Check if we're in a Chrome extension context
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.id) {
      // Use standard fetch - Chrome extensions have cross-origin permissions
      return globalThis.fetch(url, options);
    }
    
    // Fallback to standard fetch if not in extension context
    return globalThis.fetch(url, options);
  }
}

/**
 * CORS-compatible HTTP provider for bookmarklet context
 * Handles CORS limitations in bookmarklet environments
 */
export class CorsHttpProvider implements IHttpProvider {
  private corsProxy: string | undefined;

  constructor(corsProxy?: string) {
    this.corsProxy = corsProxy;
  }

  async fetch(url: string, options?: RequestInit): Promise<Response> {
    // If URL is GitHub API and we have a CORS proxy, use it
    if (this.corsProxy && url.includes('api.github.com')) {
      const proxiedUrl = `${this.corsProxy}/${url}`;
      return globalThis.fetch(proxiedUrl, {
        ...options,
        headers: {
          ...options?.headers,
          'X-Requested-With': 'PrismWeave',
        },
      });
    }
    
    // Try direct fetch first
    try {
      return await globalThis.fetch(url, options);
    } catch (error) {
      // If CORS error and no proxy available, provide helpful error
      if (error instanceof TypeError && error.message.includes('CORS')) {
        throw new Error('CORS error: GitHub API access blocked. Consider using CORS proxy or browser extension.');
      }
      throw error;
    }
  }
}
