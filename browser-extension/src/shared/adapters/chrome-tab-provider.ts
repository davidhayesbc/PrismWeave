// Generated by Copilot
// ChromeTabProvider for PrismWeave shared utilities

import type { IPageInfo, ITabProvider } from '../interfaces/tab-provider.js';

// ChromeTabProvider implements ITabProvider for Chrome extensions
export class ChromeTabProvider implements ITabProvider {
  async getCurrentTab(): Promise<IPageInfo> {
    return new Promise((resolve, reject) => {
      if (typeof chrome !== 'undefined' && chrome.tabs) {
        chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
          } else if (tabs.length === 0) {
            reject(new Error('No active tab found'));
          } else {
            const tab = tabs[0];
            resolve({
              id: tab.id!,
              url: tab.url || '',
              title: tab.title || '',
              favIconUrl: tab.favIconUrl || '',
              status: tab.status as 'loading' | 'complete',
              isActive: tab.active,
            });
          }
        });
      } else {
        reject(new Error('Chrome tabs API not available'));
      }
    });
  }

  async getTabById(tabId: number): Promise<IPageInfo> {
    return new Promise((resolve, reject) => {
      if (typeof chrome !== 'undefined' && chrome.tabs) {
        chrome.tabs.get(tabId, (tab) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
          } else {
            resolve({
              id: tab.id!,
              url: tab.url || '',
              title: tab.title || '',
              favIconUrl: tab.favIconUrl || '',
              status: tab.status as 'loading' | 'complete',
              isActive: tab.active,
            });
          }
        });
      } else {
        reject(new Error('Chrome tabs API not available'));
      }
    });
  }

  async getAllTabs(): Promise<IPageInfo[]> {
    return new Promise((resolve, reject) => {
      if (typeof chrome !== 'undefined' && chrome.tabs) {
        chrome.tabs.query({}, (tabs) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
          } else {
            resolve(tabs.map(tab => ({
              id: tab.id!,
              url: tab.url || '',
              title: tab.title || '',
              favIconUrl: tab.favIconUrl || '',
              status: tab.status as 'loading' | 'complete',
              isActive: tab.active,
            })));
          }
        });
      } else {
        reject(new Error('Chrome tabs API not available'));
      }
    });
  }

  async sendMessage<TRequest, TResponse>(tabId: number, message: TRequest): Promise<TResponse> {
    return new Promise((resolve, reject) => {
      if (typeof chrome !== 'undefined' && chrome.tabs) {
        chrome.tabs.sendMessage(tabId, message, (response) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
          } else {
            resolve(response as TResponse);
          }
        });
      } else {
        reject(new Error('Chrome tabs API not available'));
      }
    });
  }

  async executeScript<TResult>(tabId: number, script: string | (() => TResult)): Promise<TResult[]> {
    return new Promise((resolve, reject) => {
      if (typeof chrome !== 'undefined' && chrome.scripting) {
        const details = typeof script === 'string'
          ? { target: { tabId }, func: new Function(script) as () => TResult }
          : { target: { tabId }, func: script };
        chrome.scripting.executeScript(details, (results) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
          } else {
            resolve(results.map(r => r.result as TResult).filter(result => result !== undefined));
          }
        });
      } else {
        reject(new Error('Chrome scripting API not available'));
      }
    });
  }

  onUpdated(callback: (tabId: number, changeInfo: Record<string, unknown>, tab: IPageInfo) => void): void {
    if (typeof chrome !== 'undefined' && chrome.tabs) {
      chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
        callback(tabId, changeInfo as Record<string, unknown>, {
          id: tab.id!,
          url: tab.url || '',
          title: tab.title || '',
          favIconUrl: tab.favIconUrl || '',
          status: tab.status as 'loading' | 'complete',
          isActive: tab.active,
        });
      });
    }
  }
}
