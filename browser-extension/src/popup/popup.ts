// Generated by Copilot
// PrismWeave Popup Script - TypeScript version
// Handles the extension popup interface and user interactions

import { ISettings, IMessageData, IMessageResponse } from '../types/index.js';

// Declare logger for TypeScript
declare const PrismWeaveLogger: any;

// Initialize logger
const logger = (window as any).PrismWeaveLogger ? 
  (window as any).PrismWeaveLogger.createLogger('Popup') : 
  { 
    debug: console.log, 
    info: console.log, 
    warn: console.warn, 
    error: console.error, 
    trace: console.log,
    group: console.group, 
    groupEnd: console.groupEnd 
  };

export class PrismWeavePopup {
  private currentTab: chrome.tabs.Tab | null = null;
  private settings: Partial<ISettings> | null = null;
  private isCapturing: boolean = false;

  constructor() {
    logger.info('PrismWeavePopup constructor called');
    this.initializePopup();
  }

  private async initializePopup(): Promise<void> {
    logger.group('Initializing popup');
    try {
      // Get current tab information
      logger.debug('Getting current tab');
      await this.getCurrentTab();
      logger.debug('Current tab obtained:', this.currentTab);

      // Load settings
      logger.debug('Loading settings');
      await this.loadSettings();
      logger.debug('Settings loaded:', this.settings);

      // Update UI
      logger.debug('Updating page info');
      this.updatePageInfo();
      
      logger.debug('Setting up event listeners');
      this.setupEventListeners();

      // Check if page is capturable
      logger.debug('Checking page capturability');
      this.checkPageCapturability();
      
      logger.info('Initialization complete');
    } catch (error) {
      logger.error('Error initializing popup:', error);
      this.showError('Failed to initialize extension popup');
    } finally {
      logger.groupEnd();
    }
  }

  private async getCurrentTab(): Promise<void> {
    return new Promise<void>((resolve, reject) => {
      chrome.tabs.query({ active: true, currentWindow: true }, (tabs: chrome.tabs.Tab[]) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else if (tabs.length > 0) {
          this.currentTab = tabs[0];
          resolve();
        } else {
          reject(new Error('No active tab found'));
        }
      });
    });
  }

  private async loadSettings(): Promise<void> {
    try {
      const response = await this.sendMessageToBackground('GET_SETTINGS');
      this.settings = response.data as Partial<ISettings>;
    } catch (error) {
      logger.error('Error loading settings:', error);
      this.settings = {};
    }
  }

  private setupEventListeners(): void {
    // Capture page button
    const captureBtn = document.getElementById('capture-page');
    if (captureBtn) {
      captureBtn.addEventListener('click', () => this.capturePage());
    }

    // Capture selection button
    const captureSelectionBtn = document.getElementById('capture-selection');
    if (captureSelectionBtn) {
      captureSelectionBtn.addEventListener('click', () => this.captureSelection());
    }

    // Settings button
    const settingsBtn = document.getElementById('settings-btn');
    if (settingsBtn) {
      settingsBtn.addEventListener('click', () => this.openSettings());
    }

    // Quick capture toggle
    const quickCaptureToggle = document.getElementById('quick-capture') as HTMLInputElement;
    if (quickCaptureToggle) {
      quickCaptureToggle.addEventListener('change', (e) => {
        const target = e.target as HTMLInputElement;
        this.toggleQuickCapture(target.checked);
      });
    }

    // Folder selection
    const folderSelect = document.getElementById('folder-select') as HTMLSelectElement;
    if (folderSelect) {
      folderSelect.addEventListener('change', (e) => {
        const target = e.target as HTMLSelectElement;
        this.updateSelectedFolder(target.value);
      });
    }

    // Auto-commit toggle
    const autoCommitToggle = document.getElementById('auto-commit') as HTMLInputElement;
    if (autoCommitToggle) {
      autoCommitToggle.addEventListener('change', (e) => {
        const target = e.target as HTMLInputElement;
        this.toggleAutoCommit(target.checked);
      });
    }

    // View repository button
    const viewRepoBtn = document.getElementById('view-repo');
    if (viewRepoBtn) {
      viewRepoBtn.addEventListener('click', () => this.openRepository());
    }
  }

  private updatePageInfo(): void {
    if (!this.currentTab) return;

    // Update page title
    const titleElement = document.getElementById('page-title');
    if (titleElement) {
      titleElement.textContent = this.currentTab.title || 'Unknown page';
    }

    // Update page URL
    const urlElement = document.getElementById('page-url');
    if (urlElement) {
      const url = new URL(this.currentTab.url || '');
      urlElement.textContent = `${url.hostname}${url.pathname}`;
      urlElement.title = this.currentTab.url || '';
    }

    // Update favicon if available
    const faviconElement = document.getElementById('page-favicon') as HTMLImageElement;
    if (faviconElement && this.currentTab.favIconUrl) {
      faviconElement.src = this.currentTab.favIconUrl;
      faviconElement.style.display = 'block';
    }
  }

  private checkPageCapturability(): void {
    if (!this.currentTab?.url) return;

    const url = this.currentTab.url;
    const isCapturable = !url.startsWith('chrome://') && 
                        !url.startsWith('chrome-extension://') && 
                        !url.startsWith('about:') &&
                        !url.startsWith('moz-extension://');

    const captureBtn = document.getElementById('capture-page') as HTMLButtonElement;
    const captureSelectionBtn = document.getElementById('capture-selection') as HTMLButtonElement;
    const warningElement = document.getElementById('capture-warning');

    if (isCapturable) {
      if (captureBtn) captureBtn.disabled = false;
      if (captureSelectionBtn) captureSelectionBtn.disabled = false;
      if (warningElement) warningElement.style.display = 'none';
    } else {
      if (captureBtn) captureBtn.disabled = true;
      if (captureSelectionBtn) captureSelectionBtn.disabled = true;
      if (warningElement) {
        warningElement.textContent = 'Cannot capture browser internal pages';
        warningElement.style.display = 'block';
      }
    }
  }

  private async capturePage(): Promise<void> {
    if (this.isCapturing || !this.currentTab?.id) return;

    try {
      this.isCapturing = true;
      this.updateCaptureStatus('Capturing page...', 'progress');

      const message: IMessageData = {
        type: 'CAPTURE_PAGE',
        data: { 
          tabId: this.currentTab.id,
          settings: this.settings 
        }
      };

      const response = await this.sendMessageToBackground(message.type, message.data);
      
      if (response.success) {
        this.updateCaptureStatus('Page captured successfully!', 'success');
        setTimeout(() => this.resetCaptureStatus(), 3000);
      } else {
        throw new Error(response.error || 'Capture failed');
      }
    } catch (error) {
      logger.error('Error capturing page:', error);
      this.updateCaptureStatus('Capture failed', 'error');
      setTimeout(() => this.resetCaptureStatus(), 3000);
    } finally {
      this.isCapturing = false;
    }
  }

  private async captureSelection(): Promise<void> {
    if (this.isCapturing || !this.currentTab?.id) return;

    try {
      this.isCapturing = true;
      this.updateCaptureStatus('Capturing selection...', 'progress');

      // First, check if there's a selection
      const selectionCheck = await this.sendMessageToTab('GET_PAGE_INFO');
      if (!(selectionCheck.data as any)?.hasSelection) {
        throw new Error('No text selected on the page');
      }

      const message: IMessageData = {
        type: 'CAPTURE_SELECTION',
        data: { 
          tabId: this.currentTab.id,
          settings: this.settings 
        }
      };

      const response = await this.sendMessageToTab(message.type, message.data);
      
      if (response.success) {
        this.updateCaptureStatus('Selection captured successfully!', 'success');
        setTimeout(() => this.resetCaptureStatus(), 3000);
      } else {
        throw new Error(response.error || 'Selection capture failed');
      }
    } catch (error) {
      logger.error('Error capturing selection:', error);
      this.updateCaptureStatus((error as Error).message, 'error');
      setTimeout(() => this.resetCaptureStatus(), 3000);
    } finally {
      this.isCapturing = false;
    }
  }

  private updateCaptureStatus(message: string, type: 'progress' | 'success' | 'error'): void {
    const statusElement = document.getElementById('capture-status');
    if (!statusElement) return;

    statusElement.textContent = message;
    statusElement.className = `capture-status ${type}`;
    statusElement.style.display = 'block';
  }

  private resetCaptureStatus(): void {
    const statusElement = document.getElementById('capture-status');
    if (statusElement) {
      statusElement.style.display = 'none';
      statusElement.textContent = '';
      statusElement.className = 'capture-status';
    }
  }

  private async toggleQuickCapture(enabled: boolean): Promise<void> {
    try {
      await this.sendMessageToBackground('UPDATE_SETTINGS', { 
        quickCapture: enabled 
      });
      logger.info('Quick capture toggled:', enabled);
    } catch (error) {
      logger.error('Error toggling quick capture:', error);
    }
  }

  private async updateSelectedFolder(folder: string): Promise<void> {
    try {
      await this.sendMessageToBackground('UPDATE_SETTINGS', { 
        defaultFolder: folder 
      });
      logger.info('Default folder updated:', folder);
    } catch (error) {
      logger.error('Error updating folder:', error);
    }
  }

  private async toggleAutoCommit(enabled: boolean): Promise<void> {
    try {
      await this.sendMessageToBackground('UPDATE_SETTINGS', { 
        autoCommit: enabled 
      });
      logger.info('Auto-commit toggled:', enabled);
    } catch (error) {
      logger.error('Error toggling auto-commit:', error);
    }
  }

  private openSettings(): void {
    chrome.runtime.openOptionsPage();
  }

  private openRepository(): void {
    if (this.settings?.githubRepo) {
      const url = `https://github.com/${this.settings.githubRepo}`;
      chrome.tabs.create({ url });
    }
  }

  private showError(message: string): void {
    const errorElement = document.getElementById('error-message');
    if (errorElement) {
      errorElement.textContent = message;
      errorElement.style.display = 'block';
    }
  }

  private async sendMessageToBackground(type: string, data?: any): Promise<IMessageResponse> {
    return new Promise<IMessageResponse>((resolve, reject) => {
      const message: IMessageData = { type, data };
      
      chrome.runtime.sendMessage(message, (response: IMessageResponse) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve(response);
        }
      });
    });
  }

  private async sendMessageToTab(type: string, data?: any): Promise<IMessageResponse> {
    if (!this.currentTab?.id) {
      throw new Error('No active tab available');
    }

    return new Promise<IMessageResponse>((resolve, reject) => {
      const message: IMessageData = { type, data };
      
      chrome.tabs.sendMessage(this.currentTab!.id!, message, (response: IMessageResponse) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve(response);
        }
      });
    });
  }
}

// Initialize popup when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  new PrismWeavePopup();
});
