// Generated by Copilot
// PrismWeave Popup Script - TypeScript version
// Handles the extension popup interface and user interactions

import { ISettings, IMessageData, IMessageResponse } from '../types/index.js';

// Declare logger for TypeScript
declare const PrismWeaveLogger: any;

// Initialize logger
const logger = (window as any).PrismWeaveLogger ? 
  (window as any).PrismWeaveLogger.createLogger('Popup') : 
  { 
    debug: console.log, 
    info: console.log, 
    warn: console.warn, 
    error: console.error, 
    trace: console.log,
    group: console.group, 
    groupEnd: console.groupEnd 
  };

export class PrismWeavePopup {
  private currentTab: chrome.tabs.Tab | null = null;
  private settings: Partial<ISettings> | null = null;
  private isCapturing: boolean = false;

  constructor() {
    logger.info('PrismWeavePopup constructor called');
    this.initializePopup();
  }

  // ...existing code...

  private async initializePopup(): Promise<void> {
    logger.group('Initializing popup');
    try {
      // Get current tab information
      logger.debug('Getting current tab');
      await this.getCurrentTab();
      logger.debug('Current tab obtained:', this.currentTab);

      // Load settings
      logger.debug('Loading settings');
      await this.loadSettings();
      logger.debug('Settings loaded:', this.settings);

      // Update UI
      logger.debug('Updating page info');
      this.updatePageInfo();
      
      logger.debug('Setting up event listeners');
      this.setupEventListeners();

      // Check if page is capturable
      logger.debug('Checking page capturability');
      this.checkPageCapturability();
      
      logger.info('Initialization complete');
    } catch (error) {
      logger.error('Error initializing popup:', error);
      this.showError('Failed to initialize extension popup');
    } finally {
      logger.groupEnd();
    }
  }
  private async getCurrentTab(): Promise<void> {
    return new Promise<void>((resolve, reject) => {
      chrome.tabs.query({ active: true, currentWindow: true }, (tabs: chrome.tabs.Tab[]) => {
        if (chrome.runtime.lastError) {
          logger.error('Chrome tabs API error:', chrome.runtime.lastError.message);
          reject(new Error(chrome.runtime.lastError.message));
        } else if (tabs.length > 0 && tabs[0]) {
          this.currentTab = tabs[0];
          logger.debug('Current tab found:', {
            id: this.currentTab.id,
            url: this.currentTab.url,
            title: this.currentTab.title
          });
          resolve();
        } else {
          logger.warn('No active tab found in current window');
          reject(new Error('No active tab found'));
        }
      });
    });
  }

  private async loadSettings(): Promise<void> {
    try {
      const response = await this.sendMessageToBackground('GET_SETTINGS');
      this.settings = response.data as Partial<ISettings>;
    } catch (error) {
      logger.error('Error loading settings:', error);
      this.settings = {};
    }
  }

  private setupEventListeners(): void {
    // Capture page button
    const captureBtn = document.getElementById('capture-page');
    if (captureBtn) {
      captureBtn.addEventListener('click', () => this.capturePage());
    }

    // Capture selection button
    const captureSelectionBtn = document.getElementById('capture-selection');
    if (captureSelectionBtn) {
      captureSelectionBtn.addEventListener('click', () => this.captureSelection());
    }

    // Settings button
    const settingsBtn = document.getElementById('settings-btn');
    if (settingsBtn) {
      settingsBtn.addEventListener('click', () => this.openSettings());
    }

    // Quick capture toggle
    const quickCaptureToggle = document.getElementById('quick-capture') as HTMLInputElement;
    if (quickCaptureToggle) {
      quickCaptureToggle.addEventListener('change', (e) => {
        const target = e.target as HTMLInputElement;
        this.toggleQuickCapture(target.checked);
      });
    }

    // Folder selection
    const folderSelect = document.getElementById('folder-select') as HTMLSelectElement;
    if (folderSelect) {
      folderSelect.addEventListener('change', (e) => {
        const target = e.target as HTMLSelectElement;
        this.updateSelectedFolder(target.value);
      });
    }

    // Auto-commit toggle
    const autoCommitToggle = document.getElementById('auto-commit') as HTMLInputElement;
    if (autoCommitToggle) {
      autoCommitToggle.addEventListener('change', (e) => {
        const target = e.target as HTMLInputElement;
        this.toggleAutoCommit(target.checked);
      });
    }

    // View repository button
    const viewRepoBtn = document.getElementById('view-repo');
    if (viewRepoBtn) {
      viewRepoBtn.addEventListener('click', () => this.openRepository());
    }
  }

  private updatePageInfo(): void {
    if (!this.currentTab) return;

    // Update page title
    const titleElement = document.getElementById('page-title');
    if (titleElement) {
      titleElement.textContent = this.currentTab.title || 'Unknown page';
    }

    // Update page URL
    const urlElement = document.getElementById('page-url');
    if (urlElement) {
      const url = new URL(this.currentTab.url || '');
      urlElement.textContent = `${url.hostname}${url.pathname}`;
      urlElement.title = this.currentTab.url || '';
    }

    // Update favicon if available
    const faviconElement = document.getElementById('page-favicon') as HTMLImageElement;
    if (faviconElement && this.currentTab.favIconUrl) {
      faviconElement.src = this.currentTab.favIconUrl;
      faviconElement.style.display = 'block';
    }
  }
  /**
   * Validates that crucial settings are configured for capture operations
   * @returns Object with validation results and missing settings
   */
  private validateCaptureSettings(): { isValid: boolean; missingSettings: string[]; message?: string } {
    const missingSettings: string[] = [];
    
    if (!this.settings) {
      return {
        isValid: false,
        missingSettings: ['settings'],
        message: 'Settings not loaded. Please try refreshing the extension.'
      };
    }

    // Check crucial repository settings
    if (!this.settings.githubToken) {
      missingSettings.push('GitHub Token');
    }
    
    if (!this.settings.githubRepo) {
      missingSettings.push('GitHub Repository');
    }

    const isValid = missingSettings.length === 0;
    
    if (!isValid) {
      const settingsText = missingSettings.length === 1 ? 'setting' : 'settings';
      const message = `Missing required ${settingsText}: ${missingSettings.join(', ')}. Please configure these in the extension settings.`;
      return { isValid, missingSettings, message };
    }

    return { isValid, missingSettings };
  }
  private checkPageCapturability(): void {
    if (!this.currentTab?.url) return;

    const url = this.currentTab.url;
    const isCapturable = !url.startsWith('chrome://') && 
                        !url.startsWith('chrome-extension://') && 
                        !url.startsWith('about:') &&
                        !url.startsWith('moz-extension://') &&
                        !url.startsWith('edge://');

    const captureBtn = document.getElementById('capture-page') as HTMLButtonElement;
    const captureSelectionBtn = document.getElementById('capture-selection') as HTMLButtonElement;
    const warningContainer = document.getElementById('capture-warning');

    if (isCapturable) {
      if (captureBtn) captureBtn.disabled = false;
      if (captureSelectionBtn) captureSelectionBtn.disabled = false;
      if (warningContainer) warningContainer.style.display = 'none';
    } else {
      if (captureBtn) captureBtn.disabled = true;
      if (captureSelectionBtn) captureSelectionBtn.disabled = true;
      if (warningContainer) {
        warningContainer.style.display = 'block';
        // The warning content is already set in the HTML
      }
    }
  }private async capturePage(): Promise<void> {
    if (this.isCapturing) return;

    try {
      this.isCapturing = true;

      // Check if we have a current tab, and try to get it if not
      if (!this.currentTab?.id) {
        logger.warn('No current tab available, attempting to refresh tab info');
        try {
          await this.getCurrentTab();
        } catch (error) {
          logger.error('Failed to get current tab:', error);
          this.updateCaptureStatus('No active tab available for capture', 'error');
          setTimeout(() => this.resetCaptureStatus(), 3000);
          return;
        }
      }

      // Double-check we now have a valid tab ID
      if (!this.currentTab?.id) {
        this.updateCaptureStatus('Unable to identify current tab', 'error');
        setTimeout(() => this.resetCaptureStatus(), 3000);
        return;
      }      // Validate crucial settings before proceeding
      const settingsValidation = this.validateCaptureSettings();
      if (!settingsValidation.isValid) {
        this.showMissingSettingsMessage(settingsValidation.message!, settingsValidation.missingSettings);
        return;
      }

      // Check if page is capturable
      if (!this.isPageCapturable()) {
        this.updateCaptureStatus(
          'Page Cannot Be Captured',
          'This type of page (browser internal page) cannot be captured.',
          'error',
          { autoHide: 4000 }
        );
        return;
      }

      this.updateCaptureStatus(
        'Capturing Page...',
        'Extracting content and preparing markdown',
        'progress',
        { showProgress: true, progressValue: 20 }
      );

      const message: IMessageData = {
        type: 'CAPTURE_PAGE',
        data: { 
          tabId: this.currentTab.id,
          tabInfo: {
            url: this.currentTab.url,
            title: this.currentTab.title
          },
          settings: this.settings 
        }
      };

      // Update progress
      this.updateCaptureStatus(
        'Processing Content...',
        'Converting to markdown format',
        'progress',
        { showProgress: true, progressValue: 60 }
      );

      logger.debug('Sending capture message:', message);
      const response = await this.sendMessageToBackground(message.type, message.data);
      
      if (response.success) {
        const responseData = response.data as any;
        this.updateCaptureStatus(
          'Page Captured Successfully!',
          `Saved as: ${responseData?.filename || 'document.md'}`,
          'success',
          {
            autoHide: 5000,
            actions: [
              {
                label: 'View Repository',
                action: () => this.openRepository(),
                primary: true
              },
              {
                label: 'Capture Another',
                action: () => this.resetCaptureStatus()
              }
            ]
          }
        );
      } else {
        throw new Error(response.error || 'Capture failed');
      }    } catch (error) {
      logger.error('Error capturing page:', error);
      const errorMessage = (error as Error).message;
      
      this.updateCaptureStatus(
        'Capture Failed',
        errorMessage,
        'error',
        {
          autoHide: 6000,
          actions: [
            {
              label: 'Try Again',
              action: () => {
                this.resetCaptureStatus();
                setTimeout(() => this.capturePage(), 100);
              },
              primary: true
            },
            {
              label: 'Open Settings',
              action: () => this.openSettings()
            }
          ]
        }
      );
    } finally {
      this.isCapturing = false;
    }
  }

  private isPageCapturable(): boolean {
    if (!this.currentTab?.url) return false;
    
    const url = this.currentTab.url;
    return !url.startsWith('chrome://') && 
           !url.startsWith('chrome-extension://') && 
           !url.startsWith('edge://') &&
           !url.startsWith('about:') &&
           !url.startsWith('moz-extension://') &&
           (url.startsWith('http://') || url.startsWith('https://') || url.startsWith('file://'));
  }  private async captureSelection(): Promise<void> {
    if (this.isCapturing) return;

    try {
      this.isCapturing = true;

      // Check if we have a current tab, and try to get it if not
      if (!this.currentTab?.id) {
        logger.warn('No current tab available, attempting to refresh tab info');
        try {
          await this.getCurrentTab();
        } catch (error) {
          logger.error('Failed to get current tab:', error);
          this.updateCaptureStatus('No active tab available for capture', 'error');
          setTimeout(() => this.resetCaptureStatus(), 3000);
          return;
        }
      }

      // Double-check we now have a valid tab ID
      if (!this.currentTab?.id) {
        this.updateCaptureStatus('Unable to identify current tab', 'error');
        setTimeout(() => this.resetCaptureStatus(), 3000);
        return;
      }      // Validate crucial settings before proceeding
      const settingsValidation = this.validateCaptureSettings();
      if (!settingsValidation.isValid) {
        this.showMissingSettingsMessage(settingsValidation.message!, settingsValidation.missingSettings);
        return;
      }      

      // Check if page is capturable
      if (!this.isPageCapturable()) {
        this.updateCaptureStatus(
          'Page Cannot Be Captured',
          'This type of page (browser internal page) cannot be captured.',
          'error',
          { autoHide: 4000 }
        );
        return;
      }

      this.updateCaptureStatus(
        'Checking Selection...',
        'Looking for selected text on the page',
        'progress',
        { showProgress: true, progressValue: 30 }
      );

      // First, check if there's a selection
      const selectionCheck = await this.sendMessageToTab('GET_PAGE_INFO');
      if (!(selectionCheck.data as any)?.hasSelection) {
        this.updateCaptureStatus(
          'No Selection Found',
          'Please select some text on the page before capturing',
          'warning',
          {
            autoHide: 5000,
            actions: [
              {
                label: 'Capture Entire Page',
                action: () => {
                  this.resetCaptureStatus();
                  setTimeout(() => this.capturePage(), 100);
                },
                primary: true
              }
            ]
          }
        );
        return;
      }

      this.updateCaptureStatus(
        'Capturing Selection...',
        'Processing selected content',
        'progress',
        { showProgress: true, progressValue: 70 }
      );

      const message: IMessageData = {
        type: 'CAPTURE_SELECTION',
        data: { 
          tabId: this.currentTab.id,
          settings: this.settings 
        }
      };

      const response = await this.sendMessageToTab(message.type, message.data);
      
      if (response.success) {
        const responseData = response.data as any;
        this.updateCaptureStatus(
          'Selection Captured Successfully!',
          `Saved selected content as: ${responseData?.filename || 'selection.md'}`,
          'success',
          {
            autoHide: 5000,
            actions: [
              {
                label: 'View Repository',
                action: () => this.openRepository(),
                primary: true
              },
              {
                label: 'Capture More',
                action: () => this.resetCaptureStatus()
              }
            ]
          }
        );
      } else {
        throw new Error(response.error || 'Selection capture failed');
      }    } catch (error) {
      logger.error('Error capturing selection:', error);
      const errorMessage = (error as Error).message;
      
      this.updateCaptureStatus(
        'Selection Capture Failed',
        errorMessage,
        'error',
        {
          autoHide: 6000,
          actions: [
            {
              label: 'Try Again',
              action: () => {
                this.resetCaptureStatus();
                setTimeout(() => this.captureSelection(), 100);
              },
              primary: true
            },
            {
              label: 'Capture Full Page',
              action: () => {
                this.resetCaptureStatus();
                setTimeout(() => this.capturePage(), 100);
              }
            }
          ]
        }
      );
    } finally {
      this.isCapturing = false;
    }
  }
  /**
   * Enhanced status update method with rich UI feedback
   * @param title The main status title
   * @param message Optional detailed message
   * @param type Status type (success, error, progress, warning)
   * @param options Additional options for the status display
   */
  private updateCaptureStatus(
    title: string, 
    message?: string, 
    type: 'progress' | 'success' | 'error' | 'warning' = 'progress',
    options: {
      showProgress?: boolean;
      progressValue?: number;
      actions?: Array<{ label: string; action: () => void; primary?: boolean }>;
      autoHide?: number;
      details?: string[];
    } = {}
  ): void {
    const container = document.getElementById('capture-status');
    if (!container) return;

    // Update container class
    container.className = `capture-status-container ${type}`;
    
    // Update icon based on type
    const iconElement = document.getElementById('status-icon');
    if (iconElement) {
      const icons = {
        success: '✓',
        error: '⚠',
        progress: '⟳',
        warning: '⚠'
      };
      iconElement.textContent = icons[type];
    }

    // Update title
    const titleElement = document.getElementById('status-title');
    if (titleElement) {
      titleElement.textContent = title;
    }

    // Update message
    const messageElement = document.getElementById('status-message');
    if (messageElement) {
      messageElement.textContent = message || '';
      messageElement.style.display = message ? 'block' : 'none';
    }

    // Handle progress bar
    const progressBar = document.getElementById('progress-bar');
    const progressFill = progressBar?.querySelector('.progress-fill') as HTMLElement;
    if (options.showProgress && progressBar && progressFill) {
      progressBar.style.display = 'block';
      progressFill.style.width = `${options.progressValue || 0}%`;
    } else if (progressBar) {
      progressBar.style.display = 'none';
    }

    // Handle actions
    const actionsContainer = document.getElementById('status-actions');
    if (options.actions && actionsContainer) {
      actionsContainer.innerHTML = '';
      options.actions.forEach(action => {
        const button = document.createElement('button');
        button.className = `status-action-btn ${action.primary ? 'primary' : ''}`;
        button.textContent = action.label;
        button.addEventListener('click', action.action);
        actionsContainer.appendChild(button);
      });
      actionsContainer.style.display = 'flex';
    } else if (actionsContainer) {
      actionsContainer.style.display = 'none';
    }

    // Handle details
    const detailsContainer = document.getElementById('status-details');
    if ((options.showProgress || options.actions) && detailsContainer) {
      detailsContainer.style.display = 'block';
    } else if (detailsContainer) {
      detailsContainer.style.display = 'none';
    }

    // Setup close button
    const closeButton = document.getElementById('status-close');
    if (closeButton) {
      closeButton.onclick = () => this.resetCaptureStatus();
    }

    // Show container
    container.style.display = 'block';

    // Auto-hide if specified
    if (options.autoHide) {
      setTimeout(() => this.resetCaptureStatus(), options.autoHide);
    }
  }

  /**
   * Shows enhanced missing settings message with better UX
   * @param message The error message to display
   * @param missingSettings Array of missing setting names
   */
  private showMissingSettingsMessage(message: string, missingSettings: string[] = []): void {
    const container = document.getElementById('capture-status');
    if (!container) return;

    // Custom HTML for missing settings
    container.innerHTML = `
      <div class="status-card">
        <div class="status-header">
          <div class="status-icon-wrapper">
            <div class="status-icon">⚙️</div>
          </div>
          <div class="status-content">
            <div class="status-title">Configuration Required</div>
            <div class="status-message">${message}</div>
          </div>
          <button class="status-close" id="missing-settings-close" aria-label="Close">×</button>
        </div>
        <div class="status-details" style="display: block;">
          <div class="missing-settings-content">
            ${missingSettings.length > 0 ? `
              <div class="missing-settings-text">
                <strong>Missing settings:</strong> ${missingSettings.join(', ')}
              </div>
            ` : ''}
            <button id="open-settings-action" class="settings-action-btn">
              ⚙️ Configure Settings
            </button>
          </div>
        </div>
      </div>
    `;
    
    container.className = 'capture-status-container missing-settings';
    container.style.display = 'block';

    // Setup event handlers
    const openSettingsBtn = document.getElementById('open-settings-action');
    const closeBtn = document.getElementById('missing-settings-close');
    
    if (openSettingsBtn) {
      openSettingsBtn.addEventListener('click', () => {
        this.openSettings();
        setTimeout(() => this.resetCaptureStatus(), 500);
      });
    }

    if (closeBtn) {
      closeBtn.addEventListener('click', () => this.resetCaptureStatus());
    }

    // Auto-hide after 12 seconds (longer for settings issues)
    setTimeout(() => this.resetCaptureStatus(), 12000);
  }

  private resetCaptureStatus(): void {
    const statusElement = document.getElementById('capture-status');
    if (statusElement) {
      statusElement.style.display = 'none';
      statusElement.textContent = '';
      statusElement.className = 'capture-status';
    }
  }

  private async toggleQuickCapture(enabled: boolean): Promise<void> {
    try {
      await this.sendMessageToBackground('UPDATE_SETTINGS', { 
        quickCapture: enabled 
      });
      logger.info('Quick capture toggled:', enabled);
    } catch (error) {
      logger.error('Error toggling quick capture:', error);
    }
  }

  private async updateSelectedFolder(folder: string): Promise<void> {
    try {
      await this.sendMessageToBackground('UPDATE_SETTINGS', { 
        defaultFolder: folder 
      });
      logger.info('Default folder updated:', folder);
    } catch (error) {
      logger.error('Error updating folder:', error);
    }
  }

  private async toggleAutoCommit(enabled: boolean): Promise<void> {
    try {
      await this.sendMessageToBackground('UPDATE_SETTINGS', { 
        autoCommit: enabled 
      });
      logger.info('Auto-commit toggled:', enabled);
    } catch (error) {
      logger.error('Error toggling auto-commit:', error);
    }
  }

  private openSettings(): void {
    chrome.runtime.openOptionsPage();
  }

  private openRepository(): void {
    if (this.settings?.githubRepo) {
      const url = `https://github.com/${this.settings.githubRepo}`;
      chrome.tabs.create({ url });
    }
  }

  private showError(message: string): void {
    const errorElement = document.getElementById('error-message');
    if (errorElement) {
      errorElement.textContent = message;
      errorElement.style.display = 'block';
    }
  }

  private async sendMessageToBackground(type: string, data?: any): Promise<IMessageResponse> {
    return new Promise<IMessageResponse>((resolve, reject) => {
      const message: IMessageData = { type, data };
      
      chrome.runtime.sendMessage(message, (response: IMessageResponse) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve(response);
        }
      });
    });
  }

  private async sendMessageToTab(type: string, data?: any): Promise<IMessageResponse> {
    if (!this.currentTab?.id) {
      throw new Error('No active tab available');
    }

    return new Promise<IMessageResponse>((resolve, reject) => {
      const message: IMessageData = { type, data };
      
      chrome.tabs.sendMessage(this.currentTab!.id!, message, (response: IMessageResponse) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve(response);
        }
      });
    });
  }
  private async validateCurrentTab(): Promise<{ isValid: boolean; error?: string; tabInfo?: any }> {
    try {
      if (!this.currentTab?.id) {
        return { 
          isValid: false, 
          error: 'No current tab ID available' 
        };
      }

      const response = await this.sendMessageToBackground('VALIDATE_TAB', { 
        tabId: this.currentTab.id 
      });

      if (response.success) {
        const data = response.data as any;
        return {
          isValid: data.isValid,
          error: data.isValid ? undefined : data.message,
          tabInfo: data.tabInfo
        };
      } else {
        return {
          isValid: false,
          error: response.error || 'Unknown validation error'
        };
      }
    } catch (error) {
      logger.error('Error validating current tab:', error);
      return {
        isValid: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }
}

// Make available globally for service worker importScripts compatibility
if (typeof globalThis !== 'undefined') {
  (globalThis as any).PrismWeavePopup = PrismWeavePopup;
} else if (typeof self !== 'undefined') {
  (self as any).PrismWeavePopup = PrismWeavePopup;
}

// Initialize popup when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  new PrismWeavePopup();
});
