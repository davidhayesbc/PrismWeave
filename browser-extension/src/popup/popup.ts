// Generated by Copilot
// PrismWeave Popup Script - TypeScript version
// Handles the extension popup interface and user interactions

import { ISettings, IMessageData, IMessageResponse } from '../types/index.js';

// Declare logger for TypeScript
declare const PrismWeaveLogger: any;

// Initialize logger
const logger = (window as any).PrismWeaveLogger ? 
  (window as any).PrismWeaveLogger.createLogger('Popup') : 
  { 
    debug: console.log, 
    info: console.log, 
    warn: console.warn, 
    error: console.error, 
    trace: console.log,
    group: console.group, 
    groupEnd: console.groupEnd 
  };

export class PrismWeavePopup {
  private currentTab: chrome.tabs.Tab | null = null;
  private settings: Partial<ISettings> | null = null;
  private isCapturing: boolean = false;

  constructor() {
    logger.info('PrismWeavePopup constructor called');
    this.initializePopup();
  }

  // ...existing code...

  private async initializePopup(): Promise<void> {
    logger.group('Initializing popup');
    try {
      // Get current tab information
      logger.debug('Getting current tab');
      await this.getCurrentTab();
      logger.debug('Current tab obtained:', this.currentTab);

      // Load settings
      logger.debug('Loading settings');
      await this.loadSettings();
      logger.debug('Settings loaded:', this.settings);

      // Update UI
      logger.debug('Updating page info');
      this.updatePageInfo();
      
      logger.debug('Setting up event listeners');
      this.setupEventListeners();

      // Check if page is capturable
      logger.debug('Checking page capturability');
      this.checkPageCapturability();
      
      logger.info('Initialization complete');
    } catch (error) {
      logger.error('Error initializing popup:', error);
      this.showError('Failed to initialize extension popup');
    } finally {
      logger.groupEnd();
    }
  }

  private async getCurrentTab(): Promise<void> {
    return new Promise<void>((resolve, reject) => {
      chrome.tabs.query({ active: true, currentWindow: true }, (tabs: chrome.tabs.Tab[]) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else if (tabs.length > 0) {
          this.currentTab = tabs[0];
          resolve();
        } else {
          reject(new Error('No active tab found'));
        }
      });
    });
  }

  private async loadSettings(): Promise<void> {
    try {
      const response = await this.sendMessageToBackground('GET_SETTINGS');
      this.settings = response.data as Partial<ISettings>;
    } catch (error) {
      logger.error('Error loading settings:', error);
      this.settings = {};
    }
  }

  private setupEventListeners(): void {
    // Capture page button
    const captureBtn = document.getElementById('capture-page');
    if (captureBtn) {
      captureBtn.addEventListener('click', () => this.capturePage());
    }

    // Capture selection button
    const captureSelectionBtn = document.getElementById('capture-selection');
    if (captureSelectionBtn) {
      captureSelectionBtn.addEventListener('click', () => this.captureSelection());
    }

    // Settings button
    const settingsBtn = document.getElementById('settings-btn');
    if (settingsBtn) {
      settingsBtn.addEventListener('click', () => this.openSettings());
    }

    // Quick capture toggle
    const quickCaptureToggle = document.getElementById('quick-capture') as HTMLInputElement;
    if (quickCaptureToggle) {
      quickCaptureToggle.addEventListener('change', (e) => {
        const target = e.target as HTMLInputElement;
        this.toggleQuickCapture(target.checked);
      });
    }

    // Folder selection
    const folderSelect = document.getElementById('folder-select') as HTMLSelectElement;
    if (folderSelect) {
      folderSelect.addEventListener('change', (e) => {
        const target = e.target as HTMLSelectElement;
        this.updateSelectedFolder(target.value);
      });
    }

    // Auto-commit toggle
    const autoCommitToggle = document.getElementById('auto-commit') as HTMLInputElement;
    if (autoCommitToggle) {
      autoCommitToggle.addEventListener('change', (e) => {
        const target = e.target as HTMLInputElement;
        this.toggleAutoCommit(target.checked);
      });
    }

    // View repository button
    const viewRepoBtn = document.getElementById('view-repo');
    if (viewRepoBtn) {
      viewRepoBtn.addEventListener('click', () => this.openRepository());
    }
  }

  private updatePageInfo(): void {
    if (!this.currentTab) return;

    // Update page title
    const titleElement = document.getElementById('page-title');
    if (titleElement) {
      titleElement.textContent = this.currentTab.title || 'Unknown page';
    }

    // Update page URL
    const urlElement = document.getElementById('page-url');
    if (urlElement) {
      const url = new URL(this.currentTab.url || '');
      urlElement.textContent = `${url.hostname}${url.pathname}`;
      urlElement.title = this.currentTab.url || '';
    }

    // Update favicon if available
    const faviconElement = document.getElementById('page-favicon') as HTMLImageElement;
    if (faviconElement && this.currentTab.favIconUrl) {
      faviconElement.src = this.currentTab.favIconUrl;
      faviconElement.style.display = 'block';
    }
  }

  /**
   * Validates that crucial settings are configured for capture operations
   * @returns Object with validation results and missing settings
   */
  private validateCaptureSettings(): { isValid: boolean; missingSettings: string[]; message?: string } {
    const missingSettings: string[] = [];
    
    if (!this.settings) {
      return {
        isValid: false,
        missingSettings: ['settings'],
        message: 'Settings not loaded. Please try refreshing the extension.'
      };
    }

    // Check crucial repository settings
    if (!this.settings.githubToken) {
      missingSettings.push('GitHub Token');
    }
    
    if (!this.settings.githubRepo) {
      missingSettings.push('GitHub Repository');
    }
    
    if (!this.settings.repositoryPath && !this.settings.defaultFolder) {
      missingSettings.push('Repository Path or Default Folder');
    }

    const isValid = missingSettings.length === 0;
    
    if (!isValid) {
      const settingsText = missingSettings.length === 1 ? 'setting' : 'settings';
      const message = `Missing required ${settingsText}: ${missingSettings.join(', ')}. Please configure these in the extension settings.`;
      return { isValid, missingSettings, message };
    }

    return { isValid, missingSettings };
  }

  /**
   * Shows a helpful message with link to settings when crucial settings are missing
   * @param message The error message to display
   */
  private showMissingSettingsMessage(message: string): void {
    const statusElement = document.getElementById('capture-status');
    if (!statusElement) return;

    // Create a more detailed message with action button
    statusElement.innerHTML = `
      <div class="missing-settings-message">
        <div class="error-text">${message}</div>
        <button id="open-settings-btn" class="settings-link-btn">
          üìù Open Settings
        </button>
      </div>
    `;
    
    statusElement.className = 'capture-status error missing-settings';
    statusElement.style.display = 'block';

    // Add click handler for the settings button
    const openSettingsBtn = document.getElementById('open-settings-btn');
    if (openSettingsBtn) {
      openSettingsBtn.addEventListener('click', () => {
        this.openSettings();
        // Reset status after opening settings
        setTimeout(() => this.resetCaptureStatus(), 500);
      });
    }

    // Auto-hide after 10 seconds (longer than normal errors since this needs user action)
    setTimeout(() => this.resetCaptureStatus(), 10000);
  }

  private checkPageCapturability(): void {
    if (!this.currentTab?.url) return;

    const url = this.currentTab.url;
    const isCapturable = !url.startsWith('chrome://') && 
                        !url.startsWith('chrome-extension://') && 
                        !url.startsWith('about:') &&
                        !url.startsWith('moz-extension://');

    const captureBtn = document.getElementById('capture-page') as HTMLButtonElement;
    const captureSelectionBtn = document.getElementById('capture-selection') as HTMLButtonElement;
    const warningElement = document.getElementById('capture-warning');

    if (isCapturable) {
      if (captureBtn) captureBtn.disabled = false;
      if (captureSelectionBtn) captureSelectionBtn.disabled = false;
      if (warningElement) warningElement.style.display = 'none';
    } else {
      if (captureBtn) captureBtn.disabled = true;
      if (captureSelectionBtn) captureSelectionBtn.disabled = true;
      if (warningElement) {
        warningElement.textContent = 'Cannot capture browser internal pages';
        warningElement.style.display = 'block';
      }
    }
  }
  private async capturePage(): Promise<void> {
    if (this.isCapturing || !this.currentTab?.id) return;

    try {
      this.isCapturing = true;

      // Validate crucial settings before proceeding
      const settingsValidation = this.validateCaptureSettings();
      if (!settingsValidation.isValid) {
        this.showMissingSettingsMessage(settingsValidation.message!);
        return;
      }

      this.updateCaptureStatus('Capturing page...', 'progress');

      const message: IMessageData = {
        type: 'CAPTURE_PAGE',
        data: { 
          tabId: this.currentTab.id,
          settings: this.settings 
        }
      };

      const response = await this.sendMessageToBackground(message.type, message.data);
      
      if (response.success) {
        this.updateCaptureStatus('Page captured successfully!', 'success');
        setTimeout(() => this.resetCaptureStatus(), 3000);
      } else {
        throw new Error(response.error || 'Capture failed');
      }
    } catch (error) {
      logger.error('Error capturing page:', error);
      this.updateCaptureStatus('Capture failed', 'error');
      setTimeout(() => this.resetCaptureStatus(), 3000);
    } finally {
      this.isCapturing = false;
    }
  }
  private async captureSelection(): Promise<void> {
    if (this.isCapturing || !this.currentTab?.id) return;

    try {
      this.isCapturing = true;

      // Validate crucial settings before proceeding
      const settingsValidation = this.validateCaptureSettings();
      if (!settingsValidation.isValid) {
        this.showMissingSettingsMessage(settingsValidation.message!);
        return;
      }

      this.updateCaptureStatus('Capturing selection...', 'progress');

      // First, check if there's a selection
      const selectionCheck = await this.sendMessageToTab('GET_PAGE_INFO');
      if (!(selectionCheck.data as any)?.hasSelection) {
        throw new Error('No text selected on the page');
      }

      const message: IMessageData = {
        type: 'CAPTURE_SELECTION',
        data: { 
          tabId: this.currentTab.id,
          settings: this.settings 
        }
      };

      const response = await this.sendMessageToTab(message.type, message.data);
      
      if (response.success) {
        this.updateCaptureStatus('Selection captured successfully!', 'success');
        setTimeout(() => this.resetCaptureStatus(), 3000);
      } else {
        throw new Error(response.error || 'Selection capture failed');
      }
    } catch (error) {
      logger.error('Error capturing selection:', error);
      this.updateCaptureStatus((error as Error).message, 'error');
      setTimeout(() => this.resetCaptureStatus(), 3000);
    } finally {
      this.isCapturing = false;
    }
  }

  private updateCaptureStatus(message: string, type: 'progress' | 'success' | 'error'): void {
    const statusElement = document.getElementById('capture-status');
    if (!statusElement) return;

    statusElement.textContent = message;
    statusElement.className = `capture-status ${type}`;
    statusElement.style.display = 'block';
  }

  private resetCaptureStatus(): void {
    const statusElement = document.getElementById('capture-status');
    if (statusElement) {
      statusElement.style.display = 'none';
      statusElement.textContent = '';
      statusElement.className = 'capture-status';
    }
  }

  private async toggleQuickCapture(enabled: boolean): Promise<void> {
    try {
      await this.sendMessageToBackground('UPDATE_SETTINGS', { 
        quickCapture: enabled 
      });
      logger.info('Quick capture toggled:', enabled);
    } catch (error) {
      logger.error('Error toggling quick capture:', error);
    }
  }

  private async updateSelectedFolder(folder: string): Promise<void> {
    try {
      await this.sendMessageToBackground('UPDATE_SETTINGS', { 
        defaultFolder: folder 
      });
      logger.info('Default folder updated:', folder);
    } catch (error) {
      logger.error('Error updating folder:', error);
    }
  }

  private async toggleAutoCommit(enabled: boolean): Promise<void> {
    try {
      await this.sendMessageToBackground('UPDATE_SETTINGS', { 
        autoCommit: enabled 
      });
      logger.info('Auto-commit toggled:', enabled);
    } catch (error) {
      logger.error('Error toggling auto-commit:', error);
    }
  }

  private openSettings(): void {
    chrome.runtime.openOptionsPage();
  }

  private openRepository(): void {
    if (this.settings?.githubRepo) {
      const url = `https://github.com/${this.settings.githubRepo}`;
      chrome.tabs.create({ url });
    }
  }

  private showError(message: string): void {
    const errorElement = document.getElementById('error-message');
    if (errorElement) {
      errorElement.textContent = message;
      errorElement.style.display = 'block';
    }
  }

  private async sendMessageToBackground(type: string, data?: any): Promise<IMessageResponse> {
    return new Promise<IMessageResponse>((resolve, reject) => {
      const message: IMessageData = { type, data };
      
      chrome.runtime.sendMessage(message, (response: IMessageResponse) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve(response);
        }
      });
    });
  }

  private async sendMessageToTab(type: string, data?: any): Promise<IMessageResponse> {
    if (!this.currentTab?.id) {
      throw new Error('No active tab available');
    }

    return new Promise<IMessageResponse>((resolve, reject) => {
      const message: IMessageData = { type, data };
      
      chrome.tabs.sendMessage(this.currentTab!.id!, message, (response: IMessageResponse) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve(response);
        }
      });
    });
  }
}

// Make available globally for service worker importScripts compatibility
if (typeof globalThis !== 'undefined') {
  (globalThis as any).PrismWeavePopup = PrismWeavePopup;
} else if (typeof self !== 'undefined') {
  (self as any).PrismWeavePopup = PrismWeavePopup;
}

// Initialize popup when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  new PrismWeavePopup();
});
