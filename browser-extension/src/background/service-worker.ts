// Generated by Copilot
// Service worker for PrismWeave browser extension with ES module support
// Refactored to use consolidated ContentCaptureService for better architecture

import { IMessageData, IMessageResponse, MESSAGE_TYPES } from '../types/index';
import { ContentCaptureService } from '../utils/content-capture-service';
import { createLogger } from '../utils/logger';
import { PDFCaptureService } from '../utils/pdf-capture-service';
import { SettingsManager } from '../utils/settings-manager';
import { UnifiedCaptureService } from '../utils/unified-capture-service';

// Enhanced response interface with commit URL support
interface IEnhancedMessageResponse extends IMessageResponse {
  commitUrl?: string;
  saveResult?: {
    url?: string;
    commitUrl?: string;
    [key: string]: unknown;
  };
  timestamp?: number;
}

// Initialize logger
const logger = createLogger('ServiceWorker');

console.log('üü° SERVICE WORKER STARTING...');
logger.info('Service Worker starting...');

// Service worker state management
interface IServiceWorkerState {
  settingsManager: SettingsManager | null;
  captureService: ContentCaptureService | null;
  pdfCaptureService: PDFCaptureService | null;
  unifiedCaptureService: UnifiedCaptureService | null;
  isInitialized: boolean;
  initializationError: Error | null;
}

// Global state
let serviceWorkerState: IServiceWorkerState = {
  settingsManager: null,
  captureService: null,
  pdfCaptureService: null,
  unifiedCaptureService: null,
  isInitialized: false,
  initializationError: null,
};

// Initialize managers with dependency injection support for testing
export async function initializeServiceWorkers(
  customSettingsManager?: SettingsManager,
  customCaptureService?: ContentCaptureService,
  customPDFCaptureService?: PDFCaptureService
): Promise<IServiceWorkerState> {
  try {
    logger.info('Initializing service worker managers...');

    serviceWorkerState.settingsManager = customSettingsManager || new SettingsManager();
    serviceWorkerState.captureService =
      customCaptureService || new ContentCaptureService(serviceWorkerState.settingsManager);
    serviceWorkerState.pdfCaptureService =
      customPDFCaptureService || new PDFCaptureService(serviceWorkerState.settingsManager);
    serviceWorkerState.unifiedCaptureService = new UnifiedCaptureService(
      serviceWorkerState.settingsManager
    );

    serviceWorkerState.isInitialized = true;
    serviceWorkerState.initializationError = null;

    logger.info('Service managers initialized successfully');
    return serviceWorkerState;
  } catch (error) {
    serviceWorkerState.initializationError = error as Error;
    serviceWorkerState.isInitialized = false;
    logger.error('Failed to initialize service managers:', error);
    throw error;
  }
}

// Initialize on startup
initializeServiceWorkers()
  .then(() => {
    // Create context menus after initialization
    return createContextMenus();
  })
  .catch(error => {
    logger.error('Service worker startup failed:', error);
  });

// Chrome extension event handlers
export async function handleInstallation(details: chrome.runtime.InstalledDetails): Promise<void> {
  try {
    logger.info('Extension installed/updated:', details.reason);

    if (details.reason === 'install') {
      // Initialize default settings on first install
      if (serviceWorkerState.settingsManager) {
        await serviceWorkerState.settingsManager.resetSettings();
        logger.info('Default settings initialized');
      }
    }

    // Create context menus on install/startup
    await createContextMenus();
  } catch (error) {
    logger.error('Error handling installation:', error);
    throw error;
  }
}

// Context menu creation
async function createContextMenus(): Promise<void> {
  try {
    logger.info('Starting context menu creation process');

    // Remove existing context menus first
    try {
      logger.debug('Removing existing context menus');
      await chrome.contextMenus.removeAll();
      logger.debug('Existing context menus removed successfully');
    } catch (removeError) {
      logger.warn('Error removing existing context menus:', removeError);
    }

    // Create context menu for links
    try {
      logger.debug('Creating capture-link context menu item');
      chrome.contextMenus.create({
        id: 'capture-link',
        title: 'Capture this link with PrismWeave',
        contexts: ['link'],
        documentUrlPatterns: ['<all_urls>'],
      }, () => {
        if (chrome.runtime.lastError) {
          logger.error('Error creating capture-link menu:', chrome.runtime.lastError.message);
        } else {
          logger.info('capture-link context menu created successfully');
        }
      });
    } catch (linkMenuError) {
      logger.error('Exception creating capture-link menu:', linkMenuError);
    }

    // Create context menu for pages
    try {
      logger.debug('Creating capture-page context menu item');
      chrome.contextMenus.create({
        id: 'capture-page',
        title: 'Capture this page with PrismWeave',
        contexts: ['page'],
        documentUrlPatterns: ['<all_urls>'],
      }, () => {
        if (chrome.runtime.lastError) {
          logger.error('Error creating capture-page menu:', chrome.runtime.lastError.message);
        } else {
          logger.info('capture-page context menu created successfully');
        }
      });
    } catch (pageMenuError) {
      logger.error('Exception creating capture-page menu:', pageMenuError);
    }

    logger.info('Context menu creation process completed');
  } catch (error) {
    logger.error('Fatal error in createContextMenus:', error);
  }
}

// Message handler - implement actual functionality - exported for testing
export async function handleMessage(
  message: IMessageData,
  sender: chrome.runtime.MessageSender
): Promise<IEnhancedMessageResponse> {
  // Validate message structure
  if (!message || typeof message.type !== 'string') {
    throw new Error('Invalid message format');
  }

  // Check service worker initialization
  if (!serviceWorkerState.isInitialized) {
    throw new Error('Service worker not properly initialized');
  }

  // Validate manager initialization for data operations
  const requiresManager = [
    MESSAGE_TYPES.GET_SETTINGS,
    MESSAGE_TYPES.UPDATE_SETTINGS,
    MESSAGE_TYPES.RESET_SETTINGS,
    MESSAGE_TYPES.VALIDATE_SETTINGS,
  ];
  if (requiresManager.includes(message.type) && !serviceWorkerState.settingsManager) {
    throw new Error('Settings manager not initialized');
  }

  const requiresCaptureService = ['TEST_CONNECTION', 'CAPTURE_PAGE', 'CAPTURE_LINK'];
  if (requiresCaptureService.includes(message.type) && !serviceWorkerState.captureService) {
    throw new Error('Capture service not initialized');
  }

  const requiresPDFService = ['CAPTURE_PDF', 'CHECK_PDF'];
  if (requiresPDFService.includes(message.type) && !serviceWorkerState.pdfCaptureService) {
    throw new Error('PDF capture service not initialized');
  }

  const requiresUnifiedService = ['CAPTURE_CONTENT'];
  if (requiresUnifiedService.includes(message.type) && !serviceWorkerState.unifiedCaptureService) {
    throw new Error('Unified capture service not initialized');
  }

  switch (message.type) {
    case MESSAGE_TYPES.GET_SETTINGS:
      const settings = await serviceWorkerState.settingsManager!.getSettings();
      return { success: true, data: settings, timestamp: Date.now() };

    case MESSAGE_TYPES.UPDATE_SETTINGS:
      if (!message.data || typeof message.data !== 'object') {
        const error = new Error('Invalid settings data provided');
        logger.error(error);
        throw error;
      }
      await serviceWorkerState.settingsManager!.updateSettings(message.data);
      return { success: true, timestamp: Date.now() };

    case MESSAGE_TYPES.RESET_SETTINGS:
      await serviceWorkerState.settingsManager!.resetSettings();
      return { success: true, timestamp: Date.now() };

    case MESSAGE_TYPES.VALIDATE_SETTINGS:
      const currentSettings = await serviceWorkerState.settingsManager!.getSettings();
      const validationResult =
        serviceWorkerState.settingsManager!.validateSettings(currentSettings);
      return { success: true, data: validationResult, timestamp: Date.now() };

    case MESSAGE_TYPES.TEST:
      return {
        success: true,
        data: {
          message: 'Service worker is working',
          timestamp: new Date().toISOString(),
          version: chrome.runtime.getManifest().version,
        },
        timestamp: Date.now(),
      };

    case MESSAGE_TYPES.TEST_CONNECTION:
      const testResult = await serviceWorkerState.captureService!.testGitHubConnection();
      return { success: true, data: testResult, timestamp: Date.now() };

    case MESSAGE_TYPES.CAPTURE_PAGE:
      logger.info('üéØ Processing CAPTURE_PAGE message with data:', message.data);

      // Debug the extracted content structure
      if (message.data && message.data.extractedContent) {
        const extractedContent = message.data.extractedContent as any;
        logger.info('üìÑ Extracted content structure:', {
          hasExtractedContent: !!message.data.extractedContent,
          extractedContentKeys: Object.keys(message.data.extractedContent),
          hasMarkdown: !!extractedContent.markdown,
          markdownLength: extractedContent.markdown?.length || 0,
          hasHtml: !!extractedContent.html,
          htmlLength: extractedContent.html?.length || 0,
          hasTitle: !!extractedContent.title,
          title: extractedContent.title || 'no title',
        });
      } else {
        logger.info('‚ö†Ô∏è No extractedContent found in message data');
      }

      logger.info('üöÄ Calling captureService.capturePage...');
      const captureResult = await serviceWorkerState.captureService!.capturePage(message.data, {
        validateSettings: true,
        includeMarkdown: true,
      });
      logger.info('üìä CAPTURE_PAGE result:', {
        success: captureResult.success,
        message: captureResult.message,
        hasData: !!captureResult.data,
      });

      // Extract commit URL from capture result
      const pageCommitUrl = captureResult.data?.commitUrl || captureResult.data?.url;

      if (pageCommitUrl) {
        logger.info('Page capture commit URL found:', pageCommitUrl);
      } else {
        logger.warn('No commit URL found in page capture result');
      }

      // Return enhanced response with commit URL
      return {
        success: captureResult.success,
        data: {
          ...captureResult.data,
          commitUrl: pageCommitUrl || undefined,
        },
        ...(pageCommitUrl && { commitUrl: pageCommitUrl }),
        saveResult: {
          ...(pageCommitUrl && { url: pageCommitUrl, commitUrl: pageCommitUrl }),
        },
        timestamp: Date.now(),
      };

    case MESSAGE_TYPES.CAPTURE_LINK:
      logger.debug('Processing CAPTURE_LINK message with data:', message.data);

      if (!message.data || !message.data.linkUrl) {
        throw new Error('Link URL is required for link capture');
      }

      const linkUrl = message.data.linkUrl as string;
      logger.info('Capturing content from link:', linkUrl);

      const linkCaptureResult = await serviceWorkerState.captureService!.captureLink(
        linkUrl,
        message.data,
        {
          validateSettings: true,
          includeMarkdown: true,
        }
      );

      logger.debug('CAPTURE_LINK result:', {
        success: linkCaptureResult.success,
        message: linkCaptureResult.message,
        hasData: !!linkCaptureResult.data,
      });

      // Extract commit URL from link capture result
      const linkCommitUrl = linkCaptureResult.data?.commitUrl || linkCaptureResult.data?.url;

      if (linkCommitUrl) {
        logger.info('Link capture commit URL found:', linkCommitUrl);
      } else {
        logger.warn('No commit URL found in link capture result');
      }

      // Return enhanced response with commit URL
      return {
        success: linkCaptureResult.success,
        data: {
          ...linkCaptureResult.data,
          commitUrl: linkCommitUrl || undefined,
        },
        ...(linkCommitUrl && { commitUrl: linkCommitUrl }),
        saveResult: {
          ...(linkCommitUrl && { url: linkCommitUrl, commitUrl: linkCommitUrl }),
        },
        timestamp: Date.now(),
      };

    case MESSAGE_TYPES.CAPTURE_PDF:
      logger.debug('Processing CAPTURE_PDF message with data:', message.data);

      const pdfCaptureResult = await serviceWorkerState.pdfCaptureService!.capturePDF(
        message.data,
        {
          validateSettings: true,
          forceGitHubCommit: true,
        }
      );
      logger.debug('CAPTURE_PDF result:', {
        success: pdfCaptureResult.success,
        message: pdfCaptureResult.message,
        hasData: !!pdfCaptureResult.data,
      });

      // Extract commit URL from PDF capture result
      const pdfCommitUrl = pdfCaptureResult.data?.commitUrl || pdfCaptureResult.data?.url;

      if (pdfCommitUrl) {
        logger.info('PDF capture commit URL found:', pdfCommitUrl);
      } else {
        logger.warn('No commit URL found in PDF capture result');
      }

      // Return enhanced response with commit URL
      return {
        success: pdfCaptureResult.success,
        data: {
          ...pdfCaptureResult.data,
          commitUrl: pdfCommitUrl || undefined,
        },
        ...(pdfCommitUrl && { commitUrl: pdfCommitUrl }),
        saveResult: {
          ...(pdfCommitUrl && { url: pdfCommitUrl, commitUrl: pdfCommitUrl }),
        },
        timestamp: Date.now(),
      };

    case MESSAGE_TYPES.CHECK_PDF:
      logger.debug('Processing CHECK_PDF message');

      const pdfCheckResult = await serviceWorkerState.pdfCaptureService!.checkIfPDF();
      logger.debug('CHECK_PDF result:', pdfCheckResult);
      return { success: true, data: pdfCheckResult, timestamp: Date.now() };

    case MESSAGE_TYPES.CAPTURE_CONTENT:
      logger.debug('Processing CAPTURE_CONTENT message with unified service');

      const unifiedCaptureResult = await serviceWorkerState.unifiedCaptureService!.captureContent(
        message.data,
        {
          validateSettings: true,
          autoDetectionTimeout: 5000,
        }
      );

      logger.debug('CAPTURE_CONTENT result:', {
        success: unifiedCaptureResult.success,
        contentType: unifiedCaptureResult.contentType,
        captureMethod: unifiedCaptureResult.data?.captureMethod,
        hasData: !!unifiedCaptureResult.data,
        hasSaveResult: !!(unifiedCaptureResult as any).saveResult,
      });

      // Enhanced commit URL extraction from various possible locations in the response
      const extractCommitUrl = (result: any): string | undefined => {
        return (
          result.data?.commitUrl ||
          result.commitUrl ||
          result.data?.url ||
          result.data?.saveResult?.url ||
          result.data?.saveResult?.commitUrl ||
          result.data?.githubResult?.url ||
          result.data?.githubResult?.html_url ||
          result.data?.content?.html_url ||
          result.saveResult?.url ||
          result.saveResult?.commitUrl ||
          result.url
        );
      };

      const commitUrl = extractCommitUrl(unifiedCaptureResult);

      if (commitUrl) {
        logger.info('Commit URL found:', commitUrl);
      } else {
        logger.warn('No commit URL found in capture result');
      }

      // Extract saveResult from unified service response
      const unifiedSaveResult = (unifiedCaptureResult as any).saveResult;
      logger.debug('Unified service saveResult:', unifiedSaveResult);

      // Create enhanced saveResult merging unified service result with extracted commit URL
      const enhancedSaveResult = {
        ...(unifiedSaveResult || {}),
        ...(commitUrl && { url: commitUrl, commitUrl }),
      };

      // Return enhanced response with proper saveResult forwarding
      return {
        success: unifiedCaptureResult.success,
        data: {
          ...unifiedCaptureResult.data,
          commitUrl: commitUrl || undefined, // Add commit URL to data
          contentType: unifiedCaptureResult.contentType, // Ensure contentType is in data
          filename: (unifiedCaptureResult as any).filename || unifiedCaptureResult.data?.filename,
        },
        ...(commitUrl && { commitUrl }), // Add commit URL to top level only if it exists
        saveResult: enhancedSaveResult,
        timestamp: Date.now(),
      };

    case MESSAGE_TYPES.GET_STATUS:
      const statusData = getServiceWorkerStatus();
      return { success: true, data: statusData, timestamp: Date.now() };

    default:
      const error = new Error(`Unknown message type: ${message.type}`);
      logger.error('Service Worker Message Unknown', error);
      throw error;
  }
}

// Helper function to get service worker status - exported for testing
export function getServiceWorkerStatus(): Record<string, unknown> {
  return {
    initialized: serviceWorkerState.isInitialized,
    hasSettingsManager: !!serviceWorkerState.settingsManager,
    hasCaptureService: !!serviceWorkerState.captureService,
    hasPDFCaptureService: !!serviceWorkerState.pdfCaptureService,
    hasInitializationError: !!serviceWorkerState.initializationError,
    initializationError: serviceWorkerState.initializationError?.message,
    version: chrome.runtime.getManifest().version,
    timestamp: new Date().toISOString(),
  };
}

// Chrome extension event listeners
chrome.runtime.onInstalled.addListener(async (details: chrome.runtime.InstalledDetails) => {
  await handleInstallation(details);
});

chrome.runtime.onMessage.addListener(
  (
    message: IMessageData,
    sender: chrome.runtime.MessageSender,
    sendResponse: (response: IEnhancedMessageResponse) => void
  ) => {
    // Use both console.log and logger to ensure we see the message
    console.log('üî¥ SERVICE WORKER RECEIVED MESSAGE:', message.type, new Date().toISOString());
    logger.info('Received message:', message.type);

    // Handle message asynchronously
    handleMessage(message, sender)
      .then(result => {
        logger.debug('Message handled successfully:', message.type);
        sendResponse(result);
      })
      .catch(error => {
        logger.error('Error handling message:', message.type, error);
        sendResponse({
          success: false,
          error: error.message,
          timestamp: Date.now(),
        });
      });

    return true; // Keep message channel open for async response
  }
);

// Handle keyboard shortcut commands
chrome.commands.onCommand.addListener(async (command: string) => {
  logger.info('Keyboard command received:', command);

  try {
    if (command === 'capture-page') {
      // Get the active tab
      const tabs = await chrome.tabs.query({ active: true, currentWindow: true });

      if (tabs.length === 0) {
        logger.error('No active tab found for keyboard shortcut');
        return;
      }

      const activeTab = tabs[0];
      if (!activeTab.id) {
        logger.error('Active tab has no ID');
        return;
      }

      // Send message to content script to trigger capture
      try {
        await chrome.tabs.sendMessage(activeTab.id, {
          type: 'TRIGGER_CAPTURE_SHORTCUT',
          timestamp: Date.now(),
        });
        logger.info('Capture shortcut message sent to content script');
      } catch (error) {
        logger.error('Failed to send capture shortcut message:', error);
        // Optionally show browser notification if content script communication fails
        if (chrome.notifications) {
          chrome.notifications.create({
            type: 'basic',
            iconUrl: 'icons/icon48.png',
            title: 'PrismWeave',
            message: 'Please reload the page and try again',
          });
        }
      }
    }
  } catch (error) {
    logger.error('Error handling keyboard command:', error);
  }
});

// Handle context menu clicks
chrome.contextMenus.onClicked.addListener(async (info, tab) => {
  logger.info('Context menu clicked:', info.menuItemId, 'on tab:', tab?.id);

  try {
    if (!serviceWorkerState.isInitialized) {
      logger.error('Service worker not initialized for context menu action');
      return;
    }

    switch (info.menuItemId) {
      case 'capture-link':
        if (info.linkUrl) {
          logger.info('Capturing link:', info.linkUrl);

          // Show notification that capture is starting
          if (chrome.notifications) {
            chrome.notifications.create({
              type: 'basic',
              iconUrl: 'icons/icon48.png',
              title: 'PrismWeave',
              message: `Capturing content from: ${new URL(info.linkUrl).hostname}`,
            });
          }

          try {
            const result = await handleMessage(
              {
                type: MESSAGE_TYPES.CAPTURE_LINK,
                data: {
                  linkUrl: info.linkUrl,
                  sourceUrl: tab?.url,
                  sourceTitle: tab?.title,
                },
                timestamp: Date.now(),
              },
              { tab: tab }
            );

            // Show success/failure notification
            if (chrome.notifications) {
              if (result.success) {
                const domain = new URL(info.linkUrl).hostname;
                chrome.notifications.create({
                  type: 'basic',
                  iconUrl: 'icons/icon48.png',
                  title: 'PrismWeave - Link Captured',
                  message: `Successfully captured content from ${domain}`,
                });
              } else {
                chrome.notifications.create({
                  type: 'basic',
                  iconUrl: 'icons/icon48.png',
                  title: 'PrismWeave - Capture Failed',
                  message: `Failed to capture link: ${result.error || 'Unknown error'}`,
                });
              }
            }
          } catch (error) {
            logger.error('Failed to capture link:', error);
            if (chrome.notifications) {
              chrome.notifications.create({
                type: 'basic',
                iconUrl: 'icons/icon48.png',
                title: 'PrismWeave - Error',
                message: `Error capturing link: ${error instanceof Error ? error.message : 'Unknown error'}`,
              });
            }
          }
        } else {
          logger.error('No link URL provided for link capture');
        }
        break;

      case 'capture-page':
        if (tab?.id) {
          logger.info('Capturing current page via context menu');

          // Show notification that capture is starting
          if (chrome.notifications) {
            chrome.notifications.create({
              type: 'basic',
              iconUrl: 'icons/icon48.png',
              title: 'PrismWeave',
              message: `Capturing current page: ${tab.title || 'Untitled'}`,
            });
          }

          try {
            // Send message to content script to trigger capture
            await chrome.tabs.sendMessage(tab.id, {
              type: 'TRIGGER_CAPTURE_CONTEXT_MENU',
              timestamp: Date.now(),
            });
            logger.info('Context menu capture message sent to content script');
          } catch (error) {
            logger.error('Failed to send context menu capture message:', error);
            if (chrome.notifications) {
              chrome.notifications.create({
                type: 'basic',
                iconUrl: 'icons/icon48.png',
                title: 'PrismWeave',
                message: 'Please reload the page and try again',
              });
            }
          }
        } else {
          logger.error('No tab ID available for page capture');
        }
        break;

      default:
        logger.warn('Unknown context menu item:', info.menuItemId);
    }
  } catch (error) {
    logger.error('Error handling context menu click:', error);
  }
});

// Get current service worker state - exported for testing
export function getServiceWorkerState(): IServiceWorkerState {
  return { ...serviceWorkerState };
}

logger.info('Service Worker initialized successfully');

// Add heartbeat to verify service worker is running
setInterval(() => {
  console.log('üîµ Service Worker Heartbeat:', new Date().toISOString());
}, 30000); // Every 30 seconds

// Add immediate heartbeat
console.log('üü¢ Service Worker LOADED at:', new Date().toISOString());
