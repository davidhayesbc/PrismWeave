// Generated by Copilot
// Service worker for PrismWeave browser extension with ES module support
// Refactored to use consolidated ContentCaptureService for better architecture

import { IMessageData, IMessageResponse, MESSAGE_TYPES } from '../types/index';
import { ContentCaptureService } from '../utils/content-capture-service';
import { createLogger } from '../utils/logger';
import { PDFCaptureService } from '../utils/pdf-capture-service';
import { SettingsManager } from '../utils/settings-manager';

// Initialize logger
const logger = createLogger('ServiceWorker');

logger.info('Service Worker starting...');

// Service worker state management
interface IServiceWorkerState {
  settingsManager: SettingsManager | null;
  captureService: ContentCaptureService | null;
  pdfCaptureService: PDFCaptureService | null;
  isInitialized: boolean;
  initializationError: Error | null;
}

// Global state
let serviceWorkerState: IServiceWorkerState = {
  settingsManager: null,
  captureService: null,
  pdfCaptureService: null,
  isInitialized: false,
  initializationError: null,
};

// Initialize managers with dependency injection support for testing
export async function initializeServiceWorkers(
  customSettingsManager?: SettingsManager,
  customCaptureService?: ContentCaptureService,
  customPDFCaptureService?: PDFCaptureService
): Promise<IServiceWorkerState> {
  try {
    logger.info('Initializing service worker managers...');

    serviceWorkerState.settingsManager = customSettingsManager || new SettingsManager();
    serviceWorkerState.captureService =
      customCaptureService || new ContentCaptureService(serviceWorkerState.settingsManager);
    serviceWorkerState.pdfCaptureService =
      customPDFCaptureService || new PDFCaptureService(serviceWorkerState.settingsManager);

    serviceWorkerState.isInitialized = true;
    serviceWorkerState.initializationError = null;

    logger.info('Service managers initialized successfully');
    return serviceWorkerState;
  } catch (error) {
    serviceWorkerState.initializationError = error as Error;
    serviceWorkerState.isInitialized = false;
    logger.error('Failed to initialize service managers:', error);
    throw error;
  }
}

// Initialize on startup
initializeServiceWorkers().catch(error => {
  logger.error('Service worker startup failed:', error);
});

// Chrome extension event handlers
export async function handleInstallation(details: chrome.runtime.InstalledDetails): Promise<void> {
  try {
    logger.info('Extension installed/updated:', details.reason);

    if (details.reason === 'install') {
      // Initialize default settings on first install
      if (serviceWorkerState.settingsManager) {
        await serviceWorkerState.settingsManager.resetSettings();
        logger.info('Default settings initialized');
      }
    }
  } catch (error) {
    logger.error('Error handling installation:', error);
    throw error;
  }
}

// Message handler - implement actual functionality - exported for testing
export async function handleMessage(
  message: IMessageData,
  sender: chrome.runtime.MessageSender
): Promise<unknown> {
  // Validate message structure
  if (!message || typeof message.type !== 'string') {
    throw new Error('Invalid message format');
  }

  // Check service worker initialization
  if (!serviceWorkerState.isInitialized) {
    throw new Error('Service worker not properly initialized');
  }

  // Validate manager initialization for data operations
  const requiresManager = [
    MESSAGE_TYPES.GET_SETTINGS,
    MESSAGE_TYPES.UPDATE_SETTINGS,
    MESSAGE_TYPES.RESET_SETTINGS,
    MESSAGE_TYPES.VALIDATE_SETTINGS,
  ];
  if (requiresManager.includes(message.type) && !serviceWorkerState.settingsManager) {
    throw new Error('Settings manager not initialized');
  }

  const requiresCaptureService = ['TEST_CONNECTION', 'CAPTURE_PAGE'];
  if (requiresCaptureService.includes(message.type) && !serviceWorkerState.captureService) {
    throw new Error('Capture service not initialized');
  }

  const requiresPDFService = ['CAPTURE_PDF', 'CHECK_PDF'];
  if (requiresPDFService.includes(message.type) && !serviceWorkerState.pdfCaptureService) {
    throw new Error('PDF capture service not initialized');
  }

  switch (message.type) {
    case MESSAGE_TYPES.GET_SETTINGS:
      return await serviceWorkerState.settingsManager!.getSettings();

    case MESSAGE_TYPES.UPDATE_SETTINGS:
      if (!message.data || typeof message.data !== 'object') {
        const error = new Error('Invalid settings data provided');
        logger.error(error);
        throw error;
      }
      await serviceWorkerState.settingsManager!.updateSettings(message.data);
      return { success: true };

    case MESSAGE_TYPES.RESET_SETTINGS:
      await serviceWorkerState.settingsManager!.resetSettings();
      return { success: true };

    case MESSAGE_TYPES.VALIDATE_SETTINGS:
      const currentSettings = await serviceWorkerState.settingsManager!.getSettings();
      return serviceWorkerState.settingsManager!.validateSettings(currentSettings);

    case MESSAGE_TYPES.TEST:
      return {
        message: 'Service worker is working',
        timestamp: new Date().toISOString(),
        version: chrome.runtime.getManifest().version,
      };

    case MESSAGE_TYPES.TEST_CONNECTION:
      return await serviceWorkerState.captureService!.testGitHubConnection();

    case MESSAGE_TYPES.CAPTURE_PAGE:
      logger.debug('Processing CAPTURE_PAGE message with data:', message.data);

      // Debug the extracted content structure
      if (message.data && message.data.extractedContent) {
        const extractedContent = message.data.extractedContent as any;
        logger.debug('Extracted content structure:', {
          hasExtractedContent: !!message.data.extractedContent,
          extractedContentKeys: Object.keys(message.data.extractedContent),
          hasMarkdown: !!extractedContent.markdown,
          markdownLength: extractedContent.markdown?.length || 0,
          hasHtml: !!extractedContent.html,
          htmlLength: extractedContent.html?.length || 0,
          hasTitle: !!extractedContent.title,
          title: extractedContent.title || 'no title',
        });
      } else {
        logger.debug('No extractedContent found in message data');
      }

      const captureResult = await serviceWorkerState.captureService!.capturePage(message.data, {
        validateSettings: true,
        includeMarkdown: true,
      });
      logger.debug('CAPTURE_PAGE result:', {
        success: captureResult.success,
        message: captureResult.message,
        hasData: !!captureResult.data,
      });
      return captureResult;

    case MESSAGE_TYPES.CAPTURE_PDF:
      logger.debug('Processing CAPTURE_PDF message with data:', message.data);

      const pdfCaptureResult = await serviceWorkerState.pdfCaptureService!.capturePDF(
        message.data,
        {
          validateSettings: true,
          forceGitHubCommit: true,
        }
      );
      logger.debug('CAPTURE_PDF result:', {
        success: pdfCaptureResult.success,
        message: pdfCaptureResult.message,
        hasData: !!pdfCaptureResult.data,
      });
      return pdfCaptureResult;

    case MESSAGE_TYPES.CHECK_PDF:
      logger.debug('Processing CHECK_PDF message');

      const pdfCheckResult = await serviceWorkerState.pdfCaptureService!.checkIfPDF();
      logger.debug('CHECK_PDF result:', pdfCheckResult);
      return pdfCheckResult;

    case MESSAGE_TYPES.GET_STATUS:
      return getServiceWorkerStatus();

    default:
      const error = new Error(`Unknown message type: ${message.type}`);
      logger.error('Service Worker Message Unknown', error);
      throw error;
  }
}

// Helper function to get service worker status - exported for testing
export function getServiceWorkerStatus(): Record<string, unknown> {
  return {
    initialized: serviceWorkerState.isInitialized,
    hasSettingsManager: !!serviceWorkerState.settingsManager,
    hasCaptureService: !!serviceWorkerState.captureService,
    hasPDFCaptureService: !!serviceWorkerState.pdfCaptureService,
    hasInitializationError: !!serviceWorkerState.initializationError,
    initializationError: serviceWorkerState.initializationError?.message,
    version: chrome.runtime.getManifest().version,
    timestamp: new Date().toISOString(),
  };
}

// Chrome extension event listeners
chrome.runtime.onInstalled.addListener(async (details: chrome.runtime.InstalledDetails) => {
  await handleInstallation(details);
});

chrome.runtime.onMessage.addListener(
  (
    message: IMessageData,
    sender: chrome.runtime.MessageSender,
    sendResponse: (response: IMessageResponse) => void
  ) => {
    logger.info('Received message:', message.type);

    // Handle message asynchronously
    handleMessage(message, sender)
      .then(result => {
        logger.debug('Message handled successfully:', message.type);
        sendResponse({ success: true, data: result });
      })
      .catch(error => {
        logger.error('Error handling message:', message.type, error);
        sendResponse({ success: false, error: error.message });
      });

    return true; // Keep message channel open for async response
  }
);

// Get current service worker state - exported for testing
export function getServiceWorkerState(): IServiceWorkerState {
  return { ...serviceWorkerState };
}

logger.info('Service Worker initialized successfully');
