// Generated by Copilot
// PrismWeave Background Service Worker - TypeScript version
// Handles extension lifecycle, Git operations, and file management

// Standard ES6 imports - esbuild will bundle everything into IIFE format
import { SettingsManager } from '../utils/settings-manager';
import { GitOperations } from '../utils/git-operations';
import { FileManager } from '../utils/file-manager';
import { Logger, createLogger } from '../utils/logger';
import { ErrorHandler } from '../utils/error-handler';

// Type definitions for messages
interface IMessageData {
  type: string;
  data?: Record<string, unknown>;
  timestamp?: number;
}

interface IMessageResponse {
  success: boolean;
  data?: unknown;
  error?: string;
}

interface ISettings {
  [key: string]: unknown;
}

// Initialize logger for background
const logger = createLogger('Background');

class PrismWeaveBackground {
  private settingsManager: SettingsManager;
  private gitOperations: GitOperations;
  private fileManager: FileManager;
  private isInitialized: boolean = false;

  constructor() {
    logger.info('PrismWeaveBackground constructor called');
    logger.debug('Initializing core components');
    
    this.settingsManager = new SettingsManager();
    this.gitOperations = new GitOperations();
    this.fileManager = new FileManager();
    
    logger.debug('Core components initialized, starting extension initialization');
    this.initializeExtension();
  }

  async initializeExtension(): Promise<void> {
    logger.group('Initializing extension');
      // Load initial settings to ensure they exist
    try {
      const initialSettings = await this.settingsManager.getSettings();
      logger.info('Initial settings loaded on startup:', initialSettings);
      this.isInitialized = true;
    } catch (error) {
      logger.error('Failed to load initial settings:', error);
    }
    
    // Listen for extension installation/startup
    chrome.runtime.onInstalled.addListener((details: chrome.runtime.InstalledDetails) => {
      logger.info('Extension installed/updated:', details.reason);
      this.handleInstallation(details);
    });

    // Listen for extension startup
    chrome.runtime.onStartup.addListener(() => {
      logger.info('Extension startup event');
      this.handleStartup();
    });

    // Set up message listeners
    this.setupMessageListeners();
    
    logger.groupEnd();
  }

  private async handleInstallation(details: chrome.runtime.InstalledDetails): Promise<void> {
    try {
      logger.group('Handling installation/update');
      
      if (details.reason === 'install') {
        logger.info('First time installation - initializing default settings');
        await this.initializeDefaultSettings();
      } else if (details.reason === 'update') {
        logger.info('Extension updated - checking for setting migrations');
        await this.handleSettingsMigration(details.previousVersion);
      }
      
      logger.groupEnd();
    } catch (error) {
      logger.error('Error handling installation:', error);
    }
  }

  private async handleStartup(): Promise<void> {
    try {
      logger.info('Handling startup');
      await this.validateSettings();
    } catch (error) {
      logger.error('Error handling startup:', error);
    }
  }

  private setupMessageListeners(): void {
    chrome.runtime.onMessage.addListener((
      message: IMessageData,
      sender: chrome.runtime.MessageSender,
      sendResponse: (response: IMessageResponse) => void
    ) => {
      // Use async/await pattern for message handling
      this.handleMessage(message, sender)
        .then(result => sendResponse({ success: true, data: result }))
        .catch(error => {
          logger.error('Background: Message handling error:', error);
          sendResponse({ success: false, error: error.message });
        });
      return true; // Keep message channel open for async response
    });
  }

  private async handleMessage(message: IMessageData, sender: chrome.runtime.MessageSender): Promise<unknown> {
    logger.debug('Received message:', message.type, message.data);
    
    switch (message.type) {
      case 'CAPTURE_PAGE':
        return await this.capturePage(message.data, sender);
      case 'GET_SETTINGS':
        return await this.getSettings();
      case 'UPDATE_SETTINGS':
        return await this.updateSettings(message.data as Partial<ISettings>);
      case 'RESET_SETTINGS':
        return await this.resetSettings();
      case 'TEST_CONNECTION':
        return await this.testGitConnection();
      case 'GET_STATUS':
        return await this.getExtensionStatus();
      case 'SAVE_FILE':
        return await this.saveFile(message.data);
      case 'COMMIT_FILE':
        return await this.commitFile(message.data);
      case 'PUSH_CHANGES':
        return await this.pushChanges();
      case 'GET_TAB_INFO':
        return await this.getTabInfoForMessage(message.data);
      case 'VALIDATE_TAB':
        return await this.validateTabForMessage(message.data);
      default:
        throw new Error(`Unknown message type: ${message.type}`);
    }
  }

  private async initializeDefaultSettings(): Promise<void> {
    try {
      const defaults = await this.settingsManager.getDefaults();
      await this.settingsManager.updateSettings(defaults);
      logger.info('Default settings initialized');
    } catch (error) {
      logger.error('Error initializing default settings:', error);
      throw error;
    }
  }

  private async handleSettingsMigration(previousVersion?: string): Promise<void> {
    try {
      logger.info('Checking for settings migration from version:', previousVersion);
      
      const currentSettings = await this.settingsManager.getSettings();
      const defaults = await this.settingsManager.getDefaults();
      
      // Add any new default settings that don't exist
      const migrated = { ...defaults, ...currentSettings };
      await this.settingsManager.updateSettings(migrated);
      
      logger.info('Settings migration completed');
    } catch (error) {
      logger.error('Error during settings migration:', error);
    }
  }

  private async validateSettings(): Promise<void> {
    try {
      const settings = await this.settingsManager.getSettings();
      const validation = this.settingsManager.validateSettings(settings);
      
      if (!validation.isValid) {
        logger.warn('Invalid settings detected:', validation.errors);
        // Could trigger a notification or reset to defaults
      }
    } catch (error) {
      logger.error('Error validating settings:', error);
    }
  }
  private async capturePage(data: any, sender: chrome.runtime.MessageSender): Promise<any> {
    try {
      logger.info('Capturing page - sender tab ID:', sender.tab?.id, 'data tab ID:', data?.tabId);
      
      // Try to get tab ID from multiple sources
      let tabId: number | undefined;
      
      // First, try from sender (when called from content script)
      if (sender.tab?.id) {
        tabId = sender.tab.id;
        logger.debug('Using tab ID from sender:', tabId);
      }
      // Second, try from message data (when called from popup)
      else if (data?.tabId) {
        tabId = data.tabId;
        logger.debug('Using tab ID from message data:', tabId);
      }
      // Third, try to get current active tab
      else {
        logger.debug('No tab ID available, attempting to get current active tab');
        tabId = await this.getCurrentActiveTabId();
        logger.debug('Retrieved current active tab ID:', tabId);
      }

      if (!tabId) {
        throw new Error('No tab ID available for capture - unable to determine target tab');
      }

      // Validate that the tab still exists and is accessible
      const tabInfo = await this.getTabInfo(tabId);
      if (!tabInfo) {
        throw new Error(`Tab ${tabId} is no longer accessible or does not exist`);
      }

      // Validate that the tab can be captured (not a chrome:// or extension page)
      const isTabValid = await this.validateTabAccess(tabId);
      if (!isTabValid) {
        throw new Error(`Tab ${tabId} is not a valid target for capture`);
      }

      logger.info('Starting page capture for tab:', tabId, 'URL:', tabInfo.url);

      // Implementation would go here
      // This is a placeholder for the actual capture logic
      return { 
        success: true, 
        message: 'Page capture initiated',
        tabId: tabId,
        tabInfo: {
          id: tabInfo.id,
          url: tabInfo.url,
          title: tabInfo.title
        }
      };
    } catch (error) {
      logger.error('Error capturing page:', error);
      throw error;
    }
  }

  private async getCurrentActiveTabId(): Promise<number | undefined> {
    return new Promise<number | undefined>((resolve) => {
      chrome.tabs.query({ active: true, currentWindow: true }, (tabs: chrome.tabs.Tab[]) => {
        if (chrome.runtime.lastError) {
          logger.warn('Error querying current tab:', chrome.runtime.lastError.message);
          resolve(undefined);
        } else if (tabs.length > 0 && tabs[0].id) {
          resolve(tabs[0].id);
        } else {
          logger.warn('No active tab found or tab has no ID');
          resolve(undefined);
        }
      });
    });
  }

  private async getTabInfo(tabId: number): Promise<chrome.tabs.Tab | null> {
    return new Promise<chrome.tabs.Tab | null>((resolve) => {
      chrome.tabs.get(tabId, (tab: chrome.tabs.Tab) => {
        if (chrome.runtime.lastError) {
          logger.warn('Error getting tab info for tab', tabId, ':', chrome.runtime.lastError.message);
          resolve(null);
        } else {
          resolve(tab);
        }
      });
    });
  }

  private async validateTabAccess(tabId: number): Promise<boolean> {
    try {
      const tab = await this.getTabInfo(tabId);
      if (!tab) {
        return false;
      }

      // Check if tab URL is capturable (not chrome:// or extension pages)
      if (tab.url) {
        const url = new URL(tab.url);
        const isCapturableProtocol = ['http:', 'https:', 'file:'].includes(url.protocol);
        const isNotExtensionPage = !url.pathname.includes('chrome-extension://');
        const isNotSystemPage = !url.hostname.includes('chrome://') && !url.hostname.includes('edge://');
        
        return isCapturableProtocol && isNotExtensionPage && isNotSystemPage;
      }
      
      return false;
    } catch (error) {
      logger.warn('Error validating tab access for tab', tabId, ':', error);
      return false;
    }
  }

  private async getAllActiveTabs(): Promise<chrome.tabs.Tab[]> {
    return new Promise<chrome.tabs.Tab[]>((resolve) => {
      chrome.tabs.query({}, (tabs: chrome.tabs.Tab[]) => {
        if (chrome.runtime.lastError) {
          logger.warn('Error querying all tabs:', chrome.runtime.lastError.message);
          resolve([]);
        } else {
          resolve(tabs);
        }
      });
    });
  }

  private async getSettings(): Promise<Partial<ISettings>> {
    try {
      return await this.settingsManager.getSettingsWithDefaults();
    } catch (error) {
      logger.error('Error getting settings:', error);
      throw error;
    }
  }

  private async updateSettings(updates: Partial<ISettings>): Promise<boolean> {
    try {
      const success = await this.settingsManager.updateSettings(updates);
      if (success) {
        logger.info('Settings updated successfully');
      }
      return success;
    } catch (error) {
      logger.error('Error updating settings:', error);
      throw error;
    }
  }

  private async resetSettings(): Promise<boolean> {
    try {
      const success = await this.settingsManager.resetSettings();
      if (success) {
        logger.info('Settings reset to defaults');
      }
      return success;
    } catch (error) {
      logger.error('Error resetting settings:', error);
      throw error;
    }
  }

  private async testGitConnection(): Promise<any> {
    try {
      // Implementation would test Git connectivity
      return { connected: true, message: 'Git connection successful' };
    } catch (error) {
      logger.error('Error testing Git connection:', error);
      throw error;
    }
  }

  private async getExtensionStatus(): Promise<any> {
    return {
      initialized: this.isInitialized,
      version: chrome.runtime.getManifest().version,
      timestamp: new Date().toISOString()
    };
  }

  private async saveFile(data: any): Promise<any> {
    try {
      // Implementation would save file using FileManager
      return { success: true, message: 'File saved' };
    } catch (error) {
      logger.error('Error saving file:', error);
      throw error;
    }
  }

  private async commitFile(data: any): Promise<any> {
    try {
      // Implementation would commit file using GitOperations
      return { success: true, message: 'File committed' };
    } catch (error) {
      logger.error('Error committing file:', error);
      throw error;
    }
  }

  private async pushChanges(): Promise<any> {
    try {
      // Implementation would push changes using GitOperations
      return { success: true, message: 'Changes pushed' };
    } catch (error) {
      logger.error('Error pushing changes:', error);
      throw error;
    }
  }

  private async getTabInfoForMessage(data: any): Promise<any> {
    try {
      const tabId = data?.tabId;
      if (!tabId) {
        // Try to get current active tab if no tab ID provided
        const currentTabId = await this.getCurrentActiveTabId();
        if (currentTabId) {
          const tabInfo = await this.getTabInfo(currentTabId);
          return { 
            success: true, 
            tabId: currentTabId, 
            tabInfo: tabInfo 
          };
        } else {
          return { 
            success: false, 
            error: 'No tab ID provided and no active tab found' 
          };
        }
      }

      const tabInfo = await this.getTabInfo(tabId);
      if (tabInfo) {
        return { 
          success: true, 
          tabId: tabId, 
          tabInfo: tabInfo 
        };
      } else {
        return { 
          success: false, 
          error: `Tab ${tabId} not found or not accessible` 
        };
      }
    } catch (error) {
      logger.error('Error getting tab info:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error' 
      };
    }
  }

  private async validateTabForMessage(data: any): Promise<any> {
    try {
      const tabId = data?.tabId;
      if (!tabId) {
        return { 
          success: false, 
          isValid: false, 
          error: 'No tab ID provided' 
        };
      }

      const isAccessible = await this.validateTabAccess(tabId);
      const tabInfo = isAccessible ? await this.getTabInfo(tabId) : null;

      return {
        success: true,
        isValid: isAccessible,
        tabId: tabId,
        tabInfo: tabInfo,
        message: isAccessible ? 'Tab is valid and accessible' : 'Tab is not accessible or not capturable'
      };
    } catch (error) {
      logger.error('Error validating tab:', error);
      return { 
        success: false, 
        isValid: false, 
        error: error instanceof Error ? error.message : 'Unknown error' 
      };
    }
  }
}

// Initialize the background service worker
const backgroundService = new PrismWeaveBackground();
