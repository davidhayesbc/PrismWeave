// Generated by Copilot
// Self-contained service worker for PrismWeave browser extension - NO external dependencies

console.log('Service Worker starting...');

// Type definitions - define inline, no imports
interface IMessageData {
  type: string;
  data?: Record<string, unknown>;
  timestamp?: number;
}

interface IMessageResponse {
  success: boolean;
  data?: unknown;
  error?: string;
}

interface ISettingsData {
  githubToken?: string;
  githubRepo?: string;
  githubUsername?: string;
  autoCommit?: boolean;
  outputFormat?: string;
  customPrompt?: string;
  [key: string]: unknown;
}

// Simple logger - define inline
const swLogger = {
  info: (...args: any[]) => console.log('[SW-INFO]', ...args),
  debug: (...args: any[]) => console.log('[SW-DEBUG]', ...args),
  warn: (...args: any[]) => console.warn('[SW-WARN]', ...args),
  error: (...args: any[]) => console.error('[SW-ERROR]', ...args),
};

// Self-contained settings manager
class ServiceWorkerSettingsManager {
  private static readonly SETTINGS_KEY = 'prismweave_settings';

  async getSettings(): Promise<ISettingsData> {
    try {
      const result = await chrome.storage.sync.get(ServiceWorkerSettingsManager.SETTINGS_KEY);
      const settings =
        result[ServiceWorkerSettingsManager.SETTINGS_KEY] || this.getDefaultSettings();
      swLogger.debug('Retrieved settings:', settings);
      return settings;
    } catch (error) {
      swLogger.error('Error getting settings:', error);
      return this.getDefaultSettings();
    }
  }

  async updateSettings(updates: Record<string, unknown>): Promise<void> {
    try {
      const currentSettings = await this.getSettings();
      const newSettings = { ...currentSettings, ...updates };

      await chrome.storage.sync.set({
        [ServiceWorkerSettingsManager.SETTINGS_KEY]: newSettings,
      });

      swLogger.debug('Settings updated:', newSettings);
    } catch (error) {
      swLogger.error('Error updating settings:', error);
      throw error;
    }
  }

  async resetSettings(): Promise<void> {
    try {
      const defaultSettings = this.getDefaultSettings();
      await chrome.storage.sync.set({
        [ServiceWorkerSettingsManager.SETTINGS_KEY]: defaultSettings,
      });
      swLogger.info('Settings reset to defaults');
    } catch (error) {
      swLogger.error('Error resetting settings:', error);
      throw error;
    }
  }

  async validateSettings(): Promise<{ valid: boolean; errors: string[] }> {
    try {
      const settings = await this.getSettings();
      const errors: string[] = [];

      // Validate GitHub token
      if (
        !settings.githubToken ||
        typeof settings.githubToken !== 'string' ||
        settings.githubToken.trim() === ''
      ) {
        errors.push('GitHub token is required');
      }

      // Validate GitHub repo format (owner/repo)
      if (!settings.githubRepo || typeof settings.githubRepo !== 'string') {
        errors.push('GitHub repository is required');
      } else {
        const repoPattern = /^[a-zA-Z0-9._-]+\/[a-zA-Z0-9._-]+$/;
        if (!repoPattern.test(settings.githubRepo)) {
          errors.push('GitHub repository must be in format "owner/repo"');
        }
      }

      return {
        valid: errors.length === 0,
        errors,
      };
    } catch (error) {
      swLogger.error('Error validating settings:', error);
      return {
        valid: false,
        errors: ['Failed to validate settings'],
      };
    }
  }

  private getDefaultSettings(): ISettingsData {
    return {
      githubToken: '',
      githubRepo: '',
      githubUsername: '',
      autoCommit: true,
      outputFormat: 'markdown',
      customPrompt: '',
    };
  }
}

// Initialize manager
let settingsManager: ServiceWorkerSettingsManager;
try {
  settingsManager = new ServiceWorkerSettingsManager();
  swLogger.info('Settings manager initialized successfully');
} catch (error) {
  swLogger.error('Failed to initialize settings manager:', error);
}

// Chrome extension event listeners
chrome.runtime.onInstalled.addListener(async (details: chrome.runtime.InstalledDetails) => {
  try {
    swLogger.info('Extension installed/updated:', details.reason);

    if (details.reason === 'install') {
      // Initialize default settings on first install
      if (settingsManager) {
        await settingsManager.resetSettings();
        swLogger.info('Default settings initialized');
      }
    }
  } catch (error) {
    swLogger.error('Error handling installation:', error);
  }
});

chrome.runtime.onMessage.addListener(
  (
    message: IMessageData,
    sender: chrome.runtime.MessageSender,
    sendResponse: (response: IMessageResponse) => void
  ) => {
    swLogger.info('Received message:', message.type);

    // Handle message asynchronously
    handleMessage(message, sender)
      .then(result => {
        swLogger.debug('Message handled successfully:', message.type);
        sendResponse({ success: true, data: result });
      })
      .catch(error => {
        swLogger.error('Error handling message:', message.type, error);
        sendResponse({ success: false, error: error.message });
      });

    return true; // Keep message channel open for async response
  }
);

// Message handler - implement actual functionality
async function handleMessage(
  message: IMessageData,
  sender: chrome.runtime.MessageSender
): Promise<unknown> {
  // Validate message structure
  if (!message || typeof message.type !== 'string') {
    throw new Error('Invalid message format');
  }

  // Validate manager initialization for data operations
  const requiresManager = [
    'GET_SETTINGS',
    'UPDATE_SETTINGS',
    'RESET_SETTINGS',
    'VALIDATE_SETTINGS',
  ];
  if (requiresManager.includes(message.type) && !settingsManager) {
    throw new Error('Service manager not initialized');
  }

  switch (message.type) {
    case 'GET_SETTINGS':
      return await settingsManager!.getSettings();

    case 'UPDATE_SETTINGS':
      if (!message.data || typeof message.data !== 'object') {
        throw new Error('Invalid settings data provided');
      }
      await settingsManager!.updateSettings(message.data);
      return { success: true };

    case 'RESET_SETTINGS':
      await settingsManager!.resetSettings();
      return { success: true };

    case 'VALIDATE_SETTINGS':
      return await settingsManager!.validateSettings();
    case 'TEST':
      return {
        message: 'Service worker is working',
        timestamp: new Date().toISOString(),
        version: chrome.runtime.getManifest().version,
      };
    case 'TEST_CONNECTION':
      return await testGitHubConnection();

    case 'CAPTURE_PAGE':
      return await handleCapturePage(message.data);

    case 'GET_STATUS':
      return {
        initialized: !!settingsManager,
        version: chrome.runtime.getManifest().version,
        timestamp: new Date().toISOString(),
      };

    default:
      throw new Error(`Unknown message type: ${message.type}`);
  }
}

// Test GitHub connection with real API calls
async function testGitHubConnection(): Promise<unknown> {
  try {
    swLogger.info('Testing GitHub connection...');

    if (!settingsManager) {
      throw new Error('Settings manager not available');
    }

    const settings = await settingsManager.getSettings();

    // Validate required settings
    if (!settings.githubToken || !settings.githubRepo) {
      return {
        success: false,
        status: 'failed',
        error: 'GitHub token and repository are required',
        timestamp: new Date().toISOString(),
      };
    }

    // Parse repository
    const repoMatch = settings.githubRepo.match(/^([^\/]+)\/([^\/]+)$/);
    if (!repoMatch) {
      return {
        success: false,
        status: 'failed',
        error: 'Invalid repository format. Use "owner/repo"',
        timestamp: new Date().toISOString(),
      };
    }

    const [, owner, repo] = repoMatch;

    // Test 1: Validate GitHub token by getting user info
    swLogger.debug('Testing GitHub token...');
    const userResponse = await fetch('https://api.github.com/user', {
      headers: {
        Authorization: `token ${settings.githubToken}`,
        Accept: 'application/vnd.github.v3+json',
        'User-Agent': 'PrismWeave-Extension/1.0',
      },
    });

    if (!userResponse.ok) {
      swLogger.error('GitHub token validation failed:', userResponse.status);
      return {
        success: false,
        status: 'failed',
        error: `Invalid GitHub token (${userResponse.status})`,
        timestamp: new Date().toISOString(),
      };
    }

    const userData = await userResponse.json();
    swLogger.debug('GitHub user validated:', userData.login);

    // Test 2: Check repository access
    swLogger.debug('Testing repository access...');
    const repoResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}`, {
      headers: {
        Authorization: `token ${settings.githubToken}`,
        Accept: 'application/vnd.github.v3+json',
        'User-Agent': 'PrismWeave-Extension/1.0',
      },
    });

    if (!repoResponse.ok) {
      swLogger.error('Repository access failed:', repoResponse.status);
      const errorMsg =
        repoResponse.status === 404
          ? 'Repository not found or no access'
          : `Repository access failed (${repoResponse.status})`;
      return {
        success: false,
        status: 'failed',
        error: errorMsg,
        timestamp: new Date().toISOString(),
      };
    }

    const repoData = await repoResponse.json();
    swLogger.debug('Repository access confirmed:', repoData.full_name);

    // Test 3: Check write permissions by testing contents API
    swLogger.debug('Testing write permissions...');
    const contentsResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents`, {
      headers: {
        Authorization: `token ${settings.githubToken}`,
        Accept: 'application/vnd.github.v3+json',
        'User-Agent': 'PrismWeave-Extension/1.0',
      },
    });

    const hasWriteAccess = contentsResponse.ok;
    if (!hasWriteAccess) {
      swLogger.warn('Limited repository access - may not have write permissions');
    }

    // Success response with detailed information
    return {
      success: true,
      status: 'connected',
      message: 'GitHub connection test successful',
      details: {
        user: userData.login,
        userType: userData.type,
        repository: repoData.full_name,
        repositoryPrivate: repoData.private,
        hasWriteAccess: hasWriteAccess,
        permissions: repoData.permissions || { admin: false, push: false, pull: true },
      },
      timestamp: new Date().toISOString(),
    };
  } catch (error) {
    swLogger.error('GitHub connection test failed:', error);
    return {
      success: false,
      status: 'failed',
      error: error instanceof Error ? error.message : 'Unknown error occurred',
      timestamp: new Date().toISOString(),
    };
  }
}

// Handle page capture requests
async function handleCapturePage(data?: Record<string, unknown>): Promise<unknown> {
  try {
    swLogger.info('Handling capture page request');

    // Validate settings first
    if (!settingsManager) {
      throw new Error('Settings manager not available');
    }

    const validation = await settingsManager.validateSettings();
    if (!validation.valid) {
      throw new Error(`Invalid settings: ${validation.errors.join(', ')}`);
    }

    // Return success - actual capture logic would go here
    return {
      success: true,
      message: 'Page capture initiated',
      timestamp: new Date().toISOString(),
    };
  } catch (error) {
    swLogger.error('Error in capture page:', error);
    throw error;
  }
}

swLogger.info('Service Worker initialized successfully');
