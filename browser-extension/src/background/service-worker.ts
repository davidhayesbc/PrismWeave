// Generated by Copilot
// Service worker for PrismWeave browser extension with ES module support
// Refactored to use consolidated ContentCaptureService for better architecture

import { IMessageData, IMessageResponse } from '../types/index';
import { ContentCaptureService } from '../utils/content-capture-service';
import { createLogger } from '../utils/logger';
import { SettingsManager } from '../utils/settings-manager';

// Initialize logger
const logger = createLogger('ServiceWorker');

logger.info('Service Worker starting...');

// Initialize managers
let settingsManager: SettingsManager;
let captureService: ContentCaptureService;

try {
  settingsManager = new SettingsManager();
  captureService = new ContentCaptureService(settingsManager);
  logger.info('Service managers initialized successfully');
} catch (error) {
  logger.error('Failed to initialize service managers:', error);
}

// Chrome extension event listeners
chrome.runtime.onInstalled.addListener(async (details: chrome.runtime.InstalledDetails) => {
  try {
    logger.info('Extension installed/updated:', details.reason);

    if (details.reason === 'install') {
      // Initialize default settings on first install
      if (settingsManager) {
        await settingsManager.resetSettings();
        logger.info('Default settings initialized');
      }
    }
  } catch (error) {
    logger.error('Error handling installation:', error);
  }
});

chrome.runtime.onMessage.addListener(
  (
    message: IMessageData,
    sender: chrome.runtime.MessageSender,
    sendResponse: (response: IMessageResponse) => void
  ) => {
    logger.info('Received message:', message.type);

    // Handle message asynchronously
    handleMessage(message, sender)
      .then(result => {
        logger.debug('Message handled successfully:', message.type);
        sendResponse({ success: true, data: result });
      })
      .catch(error => {
        logger.error('Error handling message:', message.type, error);
        sendResponse({ success: false, error: error.message });
      });

    return true; // Keep message channel open for async response
  }
);

// Message handler - implement actual functionality
async function handleMessage(
  message: IMessageData,
  sender: chrome.runtime.MessageSender
): Promise<unknown> {
  // Validate message structure
  if (!message || typeof message.type !== 'string') {
    throw new Error('Invalid message format');
  }

  // Validate manager initialization for data operations
  const requiresManager = [
    'GET_SETTINGS',
    'UPDATE_SETTINGS',
    'RESET_SETTINGS',
    'VALIDATE_SETTINGS',
  ];
  if (requiresManager.includes(message.type) && !settingsManager) {
    throw new Error('Service manager not initialized');
  }

  switch (message.type) {
    case 'GET_SETTINGS':
      return await settingsManager!.getSettings();

    case 'UPDATE_SETTINGS':
      if (!message.data || typeof message.data !== 'object') {
        throw new Error('Invalid settings data provided');
      }
      await settingsManager!.updateSettings(message.data);
      return { success: true };

    case 'RESET_SETTINGS':
      await settingsManager!.resetSettings();
      return { success: true };

    case 'VALIDATE_SETTINGS':
      const currentSettings = await settingsManager!.getSettings();
      return settingsManager!.validateSettings(currentSettings);
    case 'TEST':
      return {
        message: 'Service worker is working',
        timestamp: new Date().toISOString(),
        version: chrome.runtime.getManifest().version,
      };
    case 'TEST_CONNECTION':
      return await captureService.testGitHubConnection();

    case 'CAPTURE_PAGE':
      return await captureService.capturePage(message.data, {
        validateSettings: true,
        includeMarkdown: true,
      });

    case 'GET_STATUS':
      return {
        initialized: !!settingsManager,
        version: chrome.runtime.getManifest().version,
        timestamp: new Date().toISOString(),
      };

    case 'GET_TURNDOWN_LIBRARY':
      return await getTurndownLibrary();

    // TEST_MARKDOWN_CONVERSION removed - use content script conversion only

    default:
      throw new Error(`Unknown message type: ${message.type}`);
  }
}

// Get TurndownService library content for alternative loading
async function getTurndownLibrary(): Promise<unknown> {
  try {
    logger.info('Fetching TurndownService library for content script...');

    const response = await fetch(chrome.runtime.getURL('libs/turndown.min.js'));
    if (!response.ok) {
      throw new Error(`Failed to fetch library: ${response.status}`);
    }

    const content = await response.text();

    return {
      success: true,
      content: content,
      timestamp: new Date().toISOString(),
    };
  } catch (error) {
    logger.error('Failed to fetch TurndownService library:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      timestamp: new Date().toISOString(),
    };
  }
}

logger.info('Service Worker initialized successfully');
