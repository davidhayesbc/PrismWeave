// Generated by Copilot
// Self-contained service worker for PrismWeave browser extension
// HTML to Markdown conversion now handled by content scripts

console.log('Service Worker starting...');

// Type definitions - define inline, no imports
interface IMessageData {
  type: string;
  data?: Record<string, unknown>;
  timestamp?: number;
}

interface IMessageResponse {
  success: boolean;
  data?: unknown;
  error?: string;
}

interface ISettingsData {
  githubToken?: string;
  githubRepo?: string;
  autoCommit?: boolean;
  defaultFolder?: string;
  customFolder?: string;
  fileNamingPattern?: string;
  captureImages?: boolean;
  removeAds?: boolean;
  removeNavigation?: boolean;
  customSelectors?: string;
  commitMessageTemplate?: string;
  debugMode?: boolean;
  showNotifications?: boolean;
  enableKeyboardShortcuts?: boolean;
  [key: string]: unknown;
}

interface IContentExtractionData {
  html: string;
  title?: string;
  url?: string;
  metadata?: Record<string, unknown>;
  markdown?: string;
  frontmatter?: string;
  images?: string[];
}

interface IContentExtractionResult {
  success: boolean;
  data?: IContentExtractionData;
  error?: string;
  extractionMethod?: 'content-script' | 'direct';
  timestamp?: string;
}

interface ICaptureResult {
  success: boolean;
  message: string;
  data?: {
    filename: string;
    filePath: string;
    title?: string;
    url?: string;
    markdownLength: number;
    commitUrl?: string;
    status?: string;
    timestamp: string;
  };
}

// Simple logger - define inline
const swLogger = {
  info: (...args: any[]) => console.log('[SW-INFO]', ...args),
  debug: (...args: any[]) => console.log('[SW-DEBUG]', ...args),
  warn: (...args: any[]) => console.warn('[SW-WARN]', ...args),
  error: (...args: any[]) => console.error('[SW-ERROR]', ...args),
};

// Self-contained settings manager
class ServiceWorkerSettingsManager {
  private static readonly SETTINGS_KEY = 'prismweave_settings';

  async getSettings(): Promise<ISettingsData> {
    try {
      const result = await chrome.storage.sync.get(ServiceWorkerSettingsManager.SETTINGS_KEY);
      const settings =
        result[ServiceWorkerSettingsManager.SETTINGS_KEY] || this.getDefaultSettings();
      swLogger.debug('Retrieved settings:', settings);
      return settings;
    } catch (error) {
      swLogger.error('Error getting settings:', error);
      return this.getDefaultSettings();
    }
  }

  async updateSettings(updates: Record<string, unknown>): Promise<void> {
    try {
      const currentSettings = await this.getSettings();
      const newSettings = { ...currentSettings, ...updates };

      await chrome.storage.sync.set({
        [ServiceWorkerSettingsManager.SETTINGS_KEY]: newSettings,
      });

      swLogger.debug('Settings updated:', newSettings);
    } catch (error) {
      swLogger.error('Error updating settings:', error);
      throw error;
    }
  }

  async resetSettings(): Promise<void> {
    try {
      const defaultSettings = this.getDefaultSettings();
      await chrome.storage.sync.set({
        [ServiceWorkerSettingsManager.SETTINGS_KEY]: defaultSettings,
      });
      swLogger.info('Settings reset to defaults');
    } catch (error) {
      swLogger.error('Error resetting settings:', error);
      throw error;
    }
  }

  async validateSettings(): Promise<{ valid: boolean; errors: string[] }> {
    try {
      const settings = await this.getSettings();
      const errors: string[] = [];

      // Validate GitHub token
      if (
        !settings.githubToken ||
        typeof settings.githubToken !== 'string' ||
        settings.githubToken.trim() === ''
      ) {
        errors.push('GitHub token is required');
      }

      // Validate GitHub repo format (owner/repo)
      if (!settings.githubRepo || typeof settings.githubRepo !== 'string') {
        errors.push('GitHub repository is required');
      } else {
        const repoPattern = /^[a-zA-Z0-9._-]+\/[a-zA-Z0-9._-]+$/;
        if (!repoPattern.test(settings.githubRepo)) {
          errors.push('GitHub repository must be in format "owner/repo"');
        }
      }

      return {
        valid: errors.length === 0,
        errors,
      };
    } catch (error) {
      swLogger.error('Error validating settings:', error);
      return {
        valid: false,
        errors: ['Failed to validate settings'],
      };
    }
  }

  private getDefaultSettings(): ISettingsData {
    return {
      githubToken: '',
      githubRepo: '',
      autoCommit: true,
      defaultFolder: 'auto',
      customFolder: '',
      fileNamingPattern: 'YYYY-MM-DD-domain-title',
      captureImages: true,
      removeAds: true,
      removeNavigation: true,
      customSelectors: '',
      commitMessageTemplate: 'Add: {domain} - {title}',
      debugMode: false,
      showNotifications: true,
      enableKeyboardShortcuts: true,
    };
  }
}

// Initialize manager
let settingsManager: ServiceWorkerSettingsManager;
try {
  settingsManager = new ServiceWorkerSettingsManager();
  swLogger.info('Settings manager initialized successfully');
} catch (error) {
  swLogger.error('Failed to initialize settings manager:', error);
}

// Chrome extension event listeners
chrome.runtime.onInstalled.addListener(async (details: chrome.runtime.InstalledDetails) => {
  try {
    swLogger.info('Extension installed/updated:', details.reason);

    if (details.reason === 'install') {
      // Initialize default settings on first install
      if (settingsManager) {
        await settingsManager.resetSettings();
        swLogger.info('Default settings initialized');
      }
    }
  } catch (error) {
    swLogger.error('Error handling installation:', error);
  }
});

chrome.runtime.onMessage.addListener(
  (
    message: IMessageData,
    sender: chrome.runtime.MessageSender,
    sendResponse: (response: IMessageResponse) => void
  ) => {
    swLogger.info('Received message:', message.type);

    // Handle message asynchronously
    handleMessage(message, sender)
      .then(result => {
        swLogger.debug('Message handled successfully:', message.type);
        sendResponse({ success: true, data: result });
      })
      .catch(error => {
        swLogger.error('Error handling message:', message.type, error);
        sendResponse({ success: false, error: error.message });
      });

    return true; // Keep message channel open for async response
  }
);

// Message handler - implement actual functionality
async function handleMessage(
  message: IMessageData,
  sender: chrome.runtime.MessageSender
): Promise<unknown> {
  // Validate message structure
  if (!message || typeof message.type !== 'string') {
    throw new Error('Invalid message format');
  }

  // Validate manager initialization for data operations
  const requiresManager = [
    'GET_SETTINGS',
    'UPDATE_SETTINGS',
    'RESET_SETTINGS',
    'VALIDATE_SETTINGS',
  ];
  if (requiresManager.includes(message.type) && !settingsManager) {
    throw new Error('Service manager not initialized');
  }

  switch (message.type) {
    case 'GET_SETTINGS':
      return await settingsManager!.getSettings();

    case 'UPDATE_SETTINGS':
      if (!message.data || typeof message.data !== 'object') {
        throw new Error('Invalid settings data provided');
      }
      await settingsManager!.updateSettings(message.data);
      return { success: true };

    case 'RESET_SETTINGS':
      await settingsManager!.resetSettings();
      return { success: true };

    case 'VALIDATE_SETTINGS':
      return await settingsManager!.validateSettings();
    case 'TEST':
      return {
        message: 'Service worker is working',
        timestamp: new Date().toISOString(),
        version: chrome.runtime.getManifest().version,
      };
    case 'TEST_CONNECTION':
      return await testGitHubConnection();

    case 'CAPTURE_PAGE':
      return await handleCapturePage(message.data);

    case 'GET_STATUS':
      return {
        initialized: !!settingsManager,
        version: chrome.runtime.getManifest().version,
        timestamp: new Date().toISOString(),
      };

    case 'GET_TURNDOWN_LIBRARY':
      return await getTurndownLibrary();

    case 'TEST_MARKDOWN_CONVERSION':
      return await testMarkdownConversion(message.data);

    default:
      throw new Error(`Unknown message type: ${message.type}`);
  }
}

// Get TurndownService library content for alternative loading
async function getTurndownLibrary(): Promise<unknown> {
  try {
    swLogger.info('Fetching TurndownService library for content script...');

    const response = await fetch(chrome.runtime.getURL('libs/turndown.min.js'));
    if (!response.ok) {
      throw new Error(`Failed to fetch library: ${response.status}`);
    }

    const content = await response.text();

    return {
      success: true,
      content: content,
      timestamp: new Date().toISOString(),
    };
  } catch (error) {
    swLogger.error('Failed to fetch TurndownService library:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      timestamp: new Date().toISOString(),
    };
  }
}

// Test GitHub connection with real API calls
async function testGitHubConnection(): Promise<unknown> {
  try {
    swLogger.info('Testing GitHub connection...');

    if (!settingsManager) {
      throw new Error('Settings manager not available');
    }

    const settings = await settingsManager.getSettings();

    // Validate required settings
    if (!settings.githubToken || !settings.githubRepo) {
      return {
        success: false,
        status: 'failed',
        error: 'GitHub token and repository are required',
        timestamp: new Date().toISOString(),
      };
    }

    // Parse repository
    const repoMatch = settings.githubRepo.match(/^([^\/]+)\/([^\/]+)$/);
    if (!repoMatch) {
      return {
        success: false,
        status: 'failed',
        error: 'Invalid repository format. Use "owner/repo"',
        timestamp: new Date().toISOString(),
      };
    }

    const [, owner, repo] = repoMatch;

    // Test 1: Validate GitHub token by getting user info
    swLogger.debug('Testing GitHub token...');
    const userResponse = await fetch('https://api.github.com/user', {
      headers: {
        Authorization: `token ${settings.githubToken}`,
        Accept: 'application/vnd.github.v3+json',
        'User-Agent': 'PrismWeave-Extension/1.0',
      },
    });

    if (!userResponse.ok) {
      swLogger.error('GitHub token validation failed:', userResponse.status);
      return {
        success: false,
        status: 'failed',
        error: `Invalid GitHub token (${userResponse.status})`,
        timestamp: new Date().toISOString(),
      };
    }

    const userData = await userResponse.json();
    swLogger.debug('GitHub user validated:', userData.login);

    // Test 2: Check repository access
    swLogger.debug('Testing repository access...');
    const repoResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}`, {
      headers: {
        Authorization: `token ${settings.githubToken}`,
        Accept: 'application/vnd.github.v3+json',
        'User-Agent': 'PrismWeave-Extension/1.0',
      },
    });

    if (!repoResponse.ok) {
      swLogger.error('Repository access failed:', repoResponse.status);
      const errorMsg =
        repoResponse.status === 404
          ? 'Repository not found or no access'
          : `Repository access failed (${repoResponse.status})`;
      return {
        success: false,
        status: 'failed',
        error: errorMsg,
        timestamp: new Date().toISOString(),
      };
    }

    const repoData = await repoResponse.json();
    swLogger.debug('Repository access confirmed:', repoData.full_name);

    // Test 3: Check write permissions by testing contents API
    swLogger.debug('Testing write permissions...');
    const contentsResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents`, {
      headers: {
        Authorization: `token ${settings.githubToken}`,
        Accept: 'application/vnd.github.v3+json',
        'User-Agent': 'PrismWeave-Extension/1.0',
      },
    });

    const hasWriteAccess = contentsResponse.ok;
    if (!hasWriteAccess) {
      swLogger.warn('Limited repository access - may not have write permissions');
    }

    // Success response with detailed information
    return {
      success: true,
      status: 'connected',
      message: 'GitHub connection test successful',
      details: {
        user: userData.login,
        userType: userData.type,
        repository: repoData.full_name,
        repositoryPrivate: repoData.private,
        hasWriteAccess: hasWriteAccess,
        permissions: repoData.permissions || { admin: false, push: false, pull: true },
      },
      timestamp: new Date().toISOString(),
    };
  } catch (error) {
    swLogger.error('GitHub connection test failed:', error);
    return {
      success: false,
      status: 'failed',
      error: error instanceof Error ? error.message : 'Unknown error occurred',
      timestamp: new Date().toISOString(),
    };
  }
}

// Content script injection and extraction helpers
async function ensureContentScriptInjected(tabId: number): Promise<void> {
  try {
    swLogger.debug('Ensuring content script is injected in tab:', tabId);

    // Get tab info to validate it's a valid web page
    const tab = await chrome.tabs.get(tabId);
    if (
      !tab.url ||
      tab.url.startsWith('chrome://') ||
      tab.url.startsWith('chrome-extension://') ||
      tab.url.startsWith('moz-extension://')
    ) {
      throw new Error('Cannot inject content script into special pages');
    }

    // Check if content script is already available by sending a ping
    const pingResult = await new Promise<boolean>(resolve => {
      const timeout = setTimeout(() => resolve(false), 1000); // 1 second timeout for ping

      chrome.tabs.sendMessage(tabId, { type: 'PING' }, response => {
        clearTimeout(timeout);
        if (chrome.runtime.lastError) {
          swLogger.debug(
            'Ping failed (expected if script not injected):',
            chrome.runtime.lastError.message
          );
          resolve(false);
        } else {
          resolve(!!response);
        }
      });
    });

    if (pingResult) {
      swLogger.debug('Content script already active');
      return;
    }

    // Inject TurndownService library first
    swLogger.debug('Injecting TurndownService library...');
    try {
      await chrome.scripting.executeScript({
        target: { tabId },
        files: ['libs/turndown.min.js'],
      });
      swLogger.debug('TurndownService library injected successfully');
    } catch (libraryError) {
      swLogger.warn('Failed to inject TurndownService library:', libraryError);
      // This is not fatal - content script has fallback conversion
    }

    // Inject content script if not available
    swLogger.debug('Injecting content script...');
    try {
      await chrome.scripting.executeScript({
        target: { tabId },
        files: ['content/content-script.js'],
      });

      swLogger.debug('Content script injected successfully');

      // Wait a bit for the script to initialize
      await new Promise(resolve => setTimeout(resolve, 500));
    } catch (scriptError) {
      swLogger.warn(
        'Failed to inject content script file, script may not be built yet:',
        scriptError
      );
      // This is not a fatal error - we'll use direct extraction instead
      throw new Error('Content script injection failed');
    }
  } catch (error) {
    swLogger.error('Failed to ensure content script injection:', error);
    throw error;
  }
}

async function extractContentFromTab(tabId: number): Promise<IContentExtractionResult> {
  return new Promise<IContentExtractionResult>((resolve, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error('Content extraction timeout after 10 seconds'));
    }, 10000); // 10 second timeout

    swLogger.debug('Sending EXTRACT_AND_CONVERT message to tab:', tabId);

    chrome.tabs.sendMessage(
      tabId,
      {
        type: 'EXTRACT_AND_CONVERT_TO_MARKDOWN',
        data: {
          extractionRules: ['article', 'main', '.content', '#content', 'body'],
          includeImages: true,
          cleanHtml: true,
          convertToMarkdown: true, // Request markdown conversion in content script
        },
      },
      (response: IContentExtractionResult) => {
        clearTimeout(timeout);

        if (chrome.runtime.lastError) {
          swLogger.error('Content script message error:', chrome.runtime.lastError.message);
          reject(new Error(chrome.runtime.lastError.message));
        } else if (!response) {
          swLogger.error('No response received from content script');
          reject(new Error('No response received from content script'));
        } else if (!response.success) {
          swLogger.error('Content script reported failure:', response.error);
          reject(new Error(response.error || 'Content extraction failed'));
        } else {
          swLogger.debug('Content extraction and conversion successful via content script');
          resolve(response);
        }
      }
    );
  });
}

async function extractContentDirectly(tabId: number): Promise<IContentExtractionResult> {
  try {
    swLogger.debug('Extracting content directly from tab:', tabId);

    // Execute extraction script directly in the page
    const results = await chrome.scripting.executeScript({
      target: { tabId },
      func: () => {
        // Direct extraction function that runs in page context
        const getPageTitle = (): string => {
          return document.title || 'Untitled';
        };

        const getPageUrl = (): string => {
          return window.location.href;
        };

        const extractMainContent = (): string => {
          // Try to find main content using semantic selectors
          const contentSelectors = [
            'article',
            '[role="article"]',
            'main',
            '[role="main"]',
            '.content',
            '#content',
            '.post-content',
            '.entry-content',
            '.article-content',
            '.page-content',
          ];

          let contentElement: Element | null = null;
          for (const selector of contentSelectors) {
            contentElement = document.querySelector(selector);
            if (
              contentElement &&
              contentElement.textContent &&
              contentElement.textContent.trim().length > 100
            ) {
              break;
            }
          }

          if (!contentElement) {
            contentElement = document.body;
          }

          return contentElement?.innerHTML || document.body.innerHTML;
        };

        const extractMetadata = (): Record<string, string> => {
          const metadata: Record<string, string> = {};

          // Extract meta tags
          const metaTags = document.querySelectorAll('meta');
          metaTags.forEach(meta => {
            const name = meta.getAttribute('name') || meta.getAttribute('property');
            const content = meta.getAttribute('content');
            if (name && content) {
              metadata[name] = content;
            }
          });

          return metadata;
        };

        return {
          title: getPageTitle(),
          url: getPageUrl(),
          html: extractMainContent(),
          metadata: extractMetadata(),
        };
      },
    });

    if (!results || results.length === 0 || !results[0].result) {
      throw new Error('Failed to execute extraction script');
    }

    const extractedData = results[0].result;
    swLogger.debug('Direct extraction completed successfully');

    return {
      success: true,
      data: {
        html: extractedData.html,
        title: extractedData.title,
        url: extractedData.url,
        metadata: extractedData.metadata,
      },
      extractionMethod: 'direct',
      timestamp: new Date().toISOString(),
    };
  } catch (error) {
    swLogger.error('Direct content extraction failed:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown extraction error',
      extractionMethod: 'direct',
      timestamp: new Date().toISOString(),
    };
  }
}

// Handle page capture requests
async function handleCapturePage(data?: Record<string, unknown>): Promise<ICaptureResult> {
  try {
    swLogger.info('Handling capture page request');

    // Validate settings first
    if (!settingsManager) {
      throw new Error('Settings manager not available');
    }

    const validation = await settingsManager.validateSettings();
    if (!validation.valid) {
      throw new Error(`Invalid settings: ${validation.errors.join(', ')}`);
    }

    const settings = await settingsManager.getSettings();

    // Get active tab for content extraction
    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });
    if (!tabs.length || !tabs[0].id) {
      throw new Error('No active tab found');
    }

    const activeTab = tabs[0];
    const tabId = activeTab.id!; // Assert non-null since we checked above
    swLogger.debug('Capturing content from tab:', activeTab.url);

    // Extract page content and convert to markdown using content script with automatic injection
    let conversionResult: IContentExtractionResult;
    try {
      // First, try to ensure content script is injected
      await ensureContentScriptInjected(tabId);

      // Add a small delay to let content script initialize
      await new Promise(resolve => setTimeout(resolve, 100));

      conversionResult = await extractContentFromTab(tabId);
    } catch (error) {
      swLogger.warn(
        'Content script extraction and conversion failed, falling back to direct content extraction:',
        error
      );

      // Fallback: Extract content directly using chrome.scripting API
      try {
        const extractionResult = await extractContentDirectly(tabId);
        if (!extractionResult?.success || !extractionResult.data?.html) {
          throw new Error('Direct extraction failed to get HTML content');
        }

        // Since we can't use TurndownService in service worker, create a simple fallback
        const { html, title, url, metadata } = extractionResult.data;
        const simpleMarkdown = createSimpleMarkdown(
          html,
          title || 'Untitled',
          url || activeTab.url || ''
        );

        conversionResult = {
          success: true,
          data: {
            markdown: simpleMarkdown,
            frontmatter: `---\ntitle: "${(title || 'Untitled').replace(/"/g, '\\"')}"\nurl: "${url || activeTab.url || ''}"\ncapture_date: "${new Date().toISOString()}"\nsource: "PrismWeave Browser Extension"\ntags: ["web-capture", "article"]\n---\n\n`,
            html,
            title: title || 'Untitled',
            url: url || activeTab.url || '',
            metadata: {
              ...metadata,
              extractedAt: new Date().toISOString(),
              extractionMethod: 'direct-fallback',
            },
            images: [],
          },
        };
      } catch (fallbackError) {
        swLogger.warn('Direct extraction also failed, using basic tab content:', fallbackError);

        // Final fallback: Get basic page information
        try {
          const tab = await chrome.tabs.get(tabId);
          const basicContent = `# ${tab.title || 'Untitled'}\n\nContent extraction failed. Only basic page information is available.\n\n**URL:** ${tab.url || 'Unknown'}\n**Captured:** ${new Date().toISOString()}`;

          conversionResult = {
            success: true,
            data: {
              markdown: basicContent,
              frontmatter: `---\ntitle: "${(tab.title || 'Untitled').replace(/"/g, '\\"')}"\nurl: "${tab.url || ''}"\ncapture_date: "${new Date().toISOString()}"\nsource: "PrismWeave Browser Extension"\ntags: ["web-capture", "fallback"]\n---\n\n`,
              html: `<h1>${tab.title || 'Untitled'}</h1><p>Content extraction failed. Only basic page information is available.</p><p>URL: ${tab.url || 'Unknown'}</p>`,
              title: tab.title || 'Untitled',
              url: tab.url || '',
              metadata: {
                extractedAt: new Date().toISOString(),
                method: 'basic-fallback',
                error: 'Content extraction failed',
              },
              images: [],
            },
          };
        } catch (basicError) {
          throw new Error(
            `All extraction methods failed: ${fallbackError instanceof Error ? fallbackError.message : 'Unknown error'}`
          );
        }
      }
    }

    if (!conversionResult?.success) {
      throw new Error(conversionResult?.error || 'Content extraction and conversion failed');
    }

    const { markdown, frontmatter, title, url, metadata } = conversionResult.data || {};

    swLogger.debug('Extraction result data:', {
      hasMarkdown: !!markdown,
      markdownLength: markdown?.length || 0,
      hasFrontmatter: !!frontmatter,
      hasTitle: !!title,
      hasUrl: !!url,
      hasMetadata: !!metadata,
    });

    // Validate that we have content
    if (!markdown) {
      swLogger.error('No markdown content in response. Full data:', conversionResult.data);
      throw new Error('No markdown content generated from page');
    }

    // Combine frontmatter and markdown
    const markdownContent = (frontmatter || '') + (markdown || '');

    // Generate filename and determine appropriate folder
    const filename = generateFileName(title, url || activeTab.url);
    const documentMetadata = {
      title: title || 'Untitled',
      url: url || activeTab.url || '',
      captureDate: new Date().toISOString(),
      tags: extractTagsFromMetadata(metadata || {}),
    };
    const folder = determineFolder(documentMetadata, settings);
    const filePath = `documents/${folder}/${filename}`;

    // Commit to GitHub repository if auto-commit is enabled
    swLogger.info('Checking GitHub commit conditions:', {
      autoCommit: settings.autoCommit,
      hasGithubToken: !!settings.githubToken,
      hasGithubRepo: !!settings.githubRepo,
      githubTokenLength: settings.githubToken?.length || 0,
      githubRepo: settings.githubRepo,
    });

    if (settings.autoCommit && settings.githubToken && settings.githubRepo) {
      swLogger.info('All conditions met, starting GitHub commit process');

      const commitParams = {
        token: settings.githubToken,
        repo: settings.githubRepo,
        filePath,
        content: markdownContent,
        message: `Add captured page: ${title || 'Untitled'}`,
        ...(url && { url }),
      };

      swLogger.debug('Commit parameters prepared:', {
        repo: commitParams.repo,
        filePath: commitParams.filePath,
        messageLength: commitParams.message.length,
        contentLength: commitParams.content.length,
      });

      const commitResult = await commitToGitHub(commitParams);

      if (!commitResult.success) {
        swLogger.error('GitHub commit failed:', commitResult.error);
        // Continue with local storage fallback
      } else {
        swLogger.info('Successfully committed to GitHub:', commitResult.data?.html_url);

        return {
          success: true,
          message: 'Page captured and committed to repository',
          data: {
            filename,
            filePath,
            ...(title && { title }),
            ...(url && { url }),
            markdownLength: markdownContent.length,
            ...(commitResult.data?.html_url && { commitUrl: commitResult.data.html_url }),
            timestamp: new Date().toISOString(),
          },
        };
      }
    } else {
      swLogger.warn('GitHub commit conditions not met, storing locally:', {
        autoCommit: settings.autoCommit,
        hasToken: !!settings.githubToken,
        hasRepo: !!settings.githubRepo,
      });
    }

    // Fallback: Store locally for manual sync
    await chrome.storage.local.set({
      [`pending_capture_${Date.now()}`]: {
        filePath,
        content: markdownContent,
        ...(title && { title }),
        ...(url && { url }),
        timestamp: new Date().toISOString(),
      },
    });

    return {
      success: true,
      message: 'Page captured and stored locally (pending sync)',
      data: {
        filename,
        filePath,
        ...(title && { title }),
        ...(url && { url }),
        markdownLength: markdownContent.length,
        status: 'pending_sync',
        timestamp: new Date().toISOString(),
      },
    };
  } catch (error) {
    swLogger.error('Error in capture page:', error);
    throw error;
  }
}

// Generate a safe filename from title and URL
function generateFileName(title?: string, url?: string): string {
  try {
    let filename = title || 'untitled';

    // Clean title for filename
    filename = filename
      .toLowerCase()
      .replace(/[^\w\s-]/g, '') // Remove special characters
      .replace(/\s+/g, '-') // Replace spaces with hyphens
      .replace(/-+/g, '-') // Remove duplicate hyphens
      .substring(0, 50); // Limit length

    // Add timestamp to ensure uniqueness
    const timestamp = new Date().toISOString().split('T')[0]; // YYYY-MM-DD

    return `${timestamp}-${filename}.md`;
  } catch (error) {
    // Fallback to timestamp-based filename
    return `capture-${Date.now()}.md`;
  }
}

// Folder classification logic - self-contained implementation
interface IFolderMapping {
  [key: string]: string[];
}

interface IDocumentMetadata {
  title: string;
  url: string;
  captureDate: string;
  tags: string[];
}

const FOLDER_MAPPING: IFolderMapping = {
  tech: [
    'programming',
    'software',
    'coding',
    'development',
    'technology',
    'tech',
    'javascript',
    'python',
    'react',
    'node',
    'github',
    'stackoverflow',
    'dev.to',
    'css',
    'html',
    'typescript',
    'api',
    'framework',
    'library',
  ],
  business: [
    'business',
    'marketing',
    'finance',
    'startup',
    'entrepreneur',
    'sales',
    'management',
    'strategy',
    'linkedin',
    'enterprise',
    'corporate',
    'economics',
    'market',
    'revenue',
    'profit',
  ],
  tutorial: [
    'tutorial',
    'guide',
    'how-to',
    'learn',
    'course',
    'lesson',
    'walkthrough',
    'step-by-step',
    'instructions',
    'tips',
    'howto',
    'example',
  ],
  news: [
    'news',
    'article',
    'blog',
    'opinion',
    'analysis',
    'update',
    'announcement',
    'breaking',
    'report',
    'current',
    'events',
  ],
  research: [
    'research',
    'study',
    'paper',
    'academic',
    'journal',
    'thesis',
    'analysis',
    'data',
    'science',
    'experiment',
    'findings',
    'methodology',
  ],
  design: [
    'design',
    'ui',
    'ux',
    'css',
    'figma',
    'adobe',
    'creative',
    'visual',
    'art',
    'layout',
    'typography',
    'color',
    'interface',
  ],
  tools: [
    'tool',
    'utility',
    'software',
    'app',
    'service',
    'platform',
    'extension',
    'plugin',
    'resource',
    'toolkit',
  ],
  personal: [
    'personal',
    'diary',
    'journal',
    'thoughts',
    'reflection',
    'life',
    'experience',
    'blog',
    'opinion',
  ],
  reference: [
    'reference',
    'documentation',
    'manual',
    'spec',
    'api',
    'docs',
    'wiki',
    'handbook',
    'guide',
  ],
};

function extractTagsFromMetadata(metadata: Record<string, any>): string[] {
  const tags: string[] = [];

  // Extract keywords from common metadata fields
  const keywordFields = ['keywords', 'description', 'author', 'category', 'tags'];

  keywordFields.forEach(field => {
    const value = metadata[field];
    if (typeof value === 'string') {
      // Split by common delimiters and clean up
      const extractedTags = value
        .split(/[,;|]/)
        .map(tag => tag.trim().toLowerCase())
        .filter(tag => tag.length > 2 && tag.length < 30);
      tags.push(...extractedTags);
    }
  });

  return [...new Set(tags)]; // Remove duplicates
}

function determineFolder(metadata: IDocumentMetadata, settings: ISettingsData): string {
  // Use explicit folder setting if provided
  if (
    settings.defaultFolder &&
    settings.defaultFolder !== 'auto' &&
    settings.defaultFolder !== 'custom'
  ) {
    return settings.defaultFolder;
  }

  if (settings.defaultFolder === 'custom' && settings.customFolder) {
    return sanitizeFolderName(settings.customFolder);
  }

  // Auto-detect folder based on content
  const detectedFolder = autoDetectFolder(metadata);
  return detectedFolder || 'unsorted';
}

function autoDetectFolder(metadata: IDocumentMetadata): string | null {
  const searchText = [
    metadata.title.toLowerCase(),
    metadata.url.toLowerCase(),
    ...metadata.tags.map(tag => tag.toLowerCase()),
  ].join(' ');

  // Score each folder based on keyword matches
  const folderScores: Record<string, number> = {};

  Object.entries(FOLDER_MAPPING).forEach(([folder, keywords]) => {
    let score = 0;
    keywords.forEach(keyword => {
      const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
      const matches = searchText.match(regex);
      if (matches) {
        score += matches.length;
      }
    });

    if (score > 0) {
      folderScores[folder] = score;
    }
  });

  // Return folder with highest score
  const bestFolder = Object.entries(folderScores).sort(([, a], [, b]) => b - a)[0];

  return bestFolder ? bestFolder[0] : null;
}

function sanitizeFolderName(folderName: string): string {
  return folderName
    .toLowerCase()
    .replace(/[^\w\s-]/g, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '');
}

// Commit content to GitHub repository
async function commitToGitHub(params: {
  token: string;
  repo: string;
  filePath: string;
  content: string;
  message: string;
  url?: string;
}): Promise<{ success: boolean; data?: any; error?: string }> {
  try {
    const { token, repo, filePath, content, message } = params;

    swLogger.info('Starting GitHub commit process:', {
      repo,
      filePath,
      messageLength: message.length,
      contentLength: content.length,
    });

    // Parse repository owner and name
    const repoMatch = repo.match(/^([^\/]+)\/([^\/]+)$/);
    if (!repoMatch) {
      throw new Error('Invalid repository format');
    }

    const [, owner, repoName] = repoMatch;
    swLogger.debug('Parsed repository:', { owner, repoName });

    // Check if file already exists
    let existingFile = null;
    try {
      swLogger.debug('Checking if file already exists...');
      const existingResponse = await fetch(
        `https://api.github.com/repos/${owner}/${repoName}/contents/${filePath}`,
        {
          headers: {
            Authorization: `token ${token}`,
            Accept: 'application/vnd.github.v3+json',
            'User-Agent': 'PrismWeave-Extension/1.0',
          },
        }
      );

      if (existingResponse.ok) {
        existingFile = await existingResponse.json();
        swLogger.debug('File exists, will update with SHA:', existingFile.sha);
      } else {
        swLogger.debug(
          'File does not exist, will create new file. Status:',
          existingResponse.status
        );
      }
    } catch (error) {
      // File doesn't exist, which is fine
      swLogger.debug('File existence check failed (normal for new files):', error);
    }

    // Prepare commit data
    const commitData: any = {
      message,
      content: btoa(unescape(encodeURIComponent(content))), // Base64 encode
      branch: 'main', // Default to main branch
    };

    // Include SHA if file exists (for updates)
    if (existingFile && existingFile.sha) {
      commitData.sha = existingFile.sha;
    }

    swLogger.debug('Commit data prepared:', {
      hasMessage: !!commitData.message,
      hasContent: !!commitData.content,
      branch: commitData.branch,
      hasSha: !!commitData.sha,
    });

    // Create or update file
    const apiUrl = `https://api.github.com/repos/${owner}/${repoName}/contents/${filePath}`;
    swLogger.debug('Making GitHub API request to:', apiUrl);

    const response = await fetch(apiUrl, {
      method: 'PUT',
      headers: {
        Authorization: `token ${token}`,
        Accept: 'application/vnd.github.v3+json',
        'User-Agent': 'PrismWeave-Extension/1.0',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(commitData),
    });

    swLogger.debug('GitHub API response status:', response.status);

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      const errorMessage = `GitHub API error: ${response.status} - ${errorData.message || 'Unknown error'}`;
      swLogger.error('GitHub API error details:', { status: response.status, errorData });
      throw new Error(errorMessage);
    }

    const result = await response.json();
    swLogger.info('Successfully committed to GitHub:', result.content?.html_url);

    return {
      success: true,
      data: result.content,
    };
  } catch (error) {
    swLogger.error('GitHub commit failed:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

// Test markdown conversion functionality
async function testMarkdownConversion(data: any): Promise<unknown> {
  try {
    swLogger.info('Testing markdown conversion with TurndownService...');

    if (!data || !data.html) {
      throw new Error('No HTML content provided for testing');
    }

    const html = data.html;
    const metadata = data.metadata || {
      title: 'Test Document',
      url: 'test://example',
      captureDate: new Date().toISOString(),
    };

    swLogger.info('Converting test HTML to markdown, length:', html.length);

    const markdown = createSimpleMarkdown(
      html,
      metadata.title || 'Test Document',
      metadata.url || 'test://example'
    );

    swLogger.info('Test conversion completed, markdown length:', markdown.length);

    return {
      success: true,
      data: {
        markdown: markdown,
        originalLength: html.length,
        markdownLength: markdown.length,
        metadata: metadata,
        timestamp: new Date().toISOString(),
        turndownAvailable: false, // No longer using TurndownService in service worker
      },
    };
  } catch (error) {
    swLogger.error('Error in test markdown conversion:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : String(error),
      turndownAvailable: false, // No longer using TurndownService in service worker
    };
  }
}

// Simple HTML to Markdown conversion without DOM (fallback for service worker)
function createSimpleMarkdown(html: string, title: string, url: string): string {
  try {
    // Basic HTML to Markdown conversion using regex (no DOM required)
    let markdown = html
      .replace(/<h1[^>]*>(.*?)<\/h1>/gi, '# $1\n\n')
      .replace(/<h2[^>]*>(.*?)<\/h2>/gi, '## $1\n\n')
      .replace(/<h3[^>]*>(.*?)<\/h3>/gi, '### $1\n\n')
      .replace(/<h4[^>]*>(.*?)<\/h4>/gi, '#### $1\n\n')
      .replace(/<h5[^>]*>(.*?)<\/h5>/gi, '##### $1\n\n')
      .replace(/<h6[^>]*>(.*?)<\/h6>/gi, '###### $1\n\n')
      .replace(/<p[^>]*>(.*?)<\/p>/gi, '$1\n\n')
      .replace(/<a[^>]*href="([^"]*)"[^>]*>(.*?)<\/a>/gi, '[$2]($1)')
      .replace(/<strong[^>]*>(.*?)<\/strong>/gi, '**$1**')
      .replace(/<b[^>]*>(.*?)<\/b>/gi, '**$1**')
      .replace(/<em[^>]*>(.*?)<\/em>/gi, '*$1*')
      .replace(/<i[^>]*>(.*?)<\/i>/gi, '*$1*')
      .replace(/<br[^>]*\/?>/gi, '\n')
      .replace(/<ul[^>]*>(.*?)<\/ul>/gis, (match, content) => {
        return content.replace(/<li[^>]*>(.*?)<\/li>/gi, '- $1\n') + '\n';
      })
      .replace(/<ol[^>]*>(.*?)<\/ol>/gis, (match, content) => {
        let counter = 1;
        return content.replace(/<li[^>]*>(.*?)<\/li>/gi, () => `${counter++}. $1\n`) + '\n';
      })
      .replace(/<blockquote[^>]*>(.*?)<\/blockquote>/gis, '> $1\n\n')
      .replace(/<pre[^>]*><code[^>]*>(.*?)<\/code><\/pre>/gis, '```\n$1\n```\n\n')
      .replace(/<code[^>]*>(.*?)<\/code>/gi, '`$1`')
      .replace(/<img[^>]*src="([^"]*)"[^>]*alt="([^"]*)"[^>]*>/gi, '![$2]($1)')
      .replace(/<img[^>]*src="([^"]*)"[^>]*>/gi, '![]($1)')
      .replace(/<[^>]*>/g, '')
      .replace(/\n\s*\n\s*\n/g, '\n\n')
      .replace(/^\s+|\s+$/g, '');

    // Clean up the markdown
    markdown = markdown
      .replace(/\n{3,}/g, '\n\n') // Remove excessive line breaks
      .replace(/^\s+|\s+$/g, '') // Trim whitespace
      .replace(/\\\n/g, '\n') // Remove escaped newlines
      .replace(/&nbsp;/g, ' ') // Replace non-breaking spaces
      .replace(/&amp;/g, '&') // Decode common HTML entities
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g, "'");

    return markdown;
  } catch (error) {
    swLogger.error('Error in simple markdown conversion:', error);
    return `# ${title}\n\n[Original URL](${url})\n\nContent extraction failed.`;
  }
}

swLogger.info('Service Worker initialized successfully');
