// Generated by Copilot
// PrismWeave Background Service Worker - TypeScript version
// Handles extension lifecycle, Git operations, and file management

/// <reference path="../types/service-worker.d.ts" />

import { IMessageData, IMessageResponse, ISettings } from '../types/index.js';

// Import all required utilities at startup (more reliable than lazy loading in Manifest V3)
importScripts('../utils/logger.js');
importScripts('../utils/log-config.js');
importScripts('../utils/utils-registry.js');
importScripts('../utils/error-handler.js');
importScripts('../utils/performance-monitor.js');
importScripts('../utils/settings-manager.js');
importScripts('../utils/shared-utils.js');
importScripts('../utils/git-operations.js');
importScripts('../utils/file-manager.js');

// Declare global utilities for TypeScript
declare const SettingsManager: any;
declare const GitOperations: any;
declare const FileManager: any;
declare const PrismWeaveLogger: any;

// Initialize logger for background
const logger = (self as any).PrismWeaveLogger ? 
  (self as any).PrismWeaveLogger.createLogger('Background') : 
  { debug: console.log, info: console.log, warn: console.warn, error: console.error, group: console.group, groupEnd: console.groupEnd };

class PrismWeaveBackground {
  private settingsManager: any;
  private gitOperations: any;
  private fileManager: any;
  private isInitialized: boolean = false;

  constructor() {
    logger.info('PrismWeaveBackground constructor called');
    logger.debug('Initializing core components');
    
    this.settingsManager = new SettingsManager();
    this.gitOperations = new GitOperations();
    this.fileManager = new FileManager();
    
    logger.debug('Core components initialized, starting extension initialization');
    this.initializeExtension();
  }

  async initializeExtension(): Promise<void> {
    logger.group('Initializing extension');
    
    // Load initial settings to ensure they exist
    try {
      const initialSettings = await this.settingsManager.loadSettings();
      logger.info('Initial settings loaded on startup:', initialSettings);
      this.isInitialized = true;
    } catch (error) {
      logger.error('Failed to load initial settings:', error);
    }
    
    // Listen for extension installation/startup
    chrome.runtime.onInstalled.addListener((details: chrome.runtime.InstalledDetails) => {
      logger.info('Extension installed/updated:', details.reason);
      this.handleInstallation(details);
    });

    // Listen for extension startup
    chrome.runtime.onStartup.addListener(() => {
      logger.info('Extension startup event');
      this.handleStartup();
    });

    // Set up message listeners
    this.setupMessageListeners();
    
    logger.groupEnd();
  }

  private async handleInstallation(details: chrome.runtime.InstalledDetails): Promise<void> {
    try {
      logger.group('Handling installation/update');
      
      if (details.reason === 'install') {
        logger.info('First time installation - initializing default settings');
        await this.initializeDefaultSettings();
      } else if (details.reason === 'update') {
        logger.info('Extension updated - checking for setting migrations');
        await this.handleSettingsMigration(details.previousVersion);
      }
      
      logger.groupEnd();
    } catch (error) {
      logger.error('Error handling installation:', error);
    }
  }

  private async handleStartup(): Promise<void> {
    try {
      logger.info('Handling startup');
      await this.validateSettings();
    } catch (error) {
      logger.error('Error handling startup:', error);
    }
  }

  private setupMessageListeners(): void {
    chrome.runtime.onMessage.addListener((
      message: IMessageData,
      sender: chrome.runtime.MessageSender,
      sendResponse: (response: IMessageResponse) => void
    ) => {
      // Use async/await pattern for message handling
      this.handleMessage(message, sender)
        .then(result => sendResponse({ success: true, data: result }))
        .catch(error => {
          logger.error('Background: Message handling error:', error);
          sendResponse({ success: false, error: error.message });
        });
      return true; // Keep message channel open for async response
    });
  }

  private async handleMessage(message: IMessageData, sender: chrome.runtime.MessageSender): Promise<unknown> {
    logger.debug('Received message:', message.type, message.data);
    
    switch (message.type) {
      case 'CAPTURE_PAGE':
        return await this.capturePage(message.data, sender);
      case 'GET_SETTINGS':
        return await this.getSettings();
      case 'UPDATE_SETTINGS':
        return await this.updateSettings(message.data as Partial<ISettings>);
      case 'RESET_SETTINGS':
        return await this.resetSettings();
      case 'TEST_CONNECTION':
        return await this.testGitConnection();
      case 'GET_STATUS':
        return await this.getExtensionStatus();
      case 'SAVE_FILE':
        return await this.saveFile(message.data);
      case 'COMMIT_FILE':
        return await this.commitFile(message.data);
      case 'PUSH_CHANGES':
        return await this.pushChanges();
      default:
        throw new Error(`Unknown message type: ${message.type}`);
    }
  }

  private async initializeDefaultSettings(): Promise<void> {
    try {
      const defaults = await this.settingsManager.getDefaults();
      await this.settingsManager.updateSettings(defaults);
      logger.info('Default settings initialized');
    } catch (error) {
      logger.error('Error initializing default settings:', error);
      throw error;
    }
  }

  private async handleSettingsMigration(previousVersion?: string): Promise<void> {
    try {
      logger.info('Checking for settings migration from version:', previousVersion);
      
      const currentSettings = await this.settingsManager.getSettings();
      const defaults = await this.settingsManager.getDefaults();
      
      // Add any new default settings that don't exist
      const migrated = { ...defaults, ...currentSettings };
      await this.settingsManager.updateSettings(migrated);
      
      logger.info('Settings migration completed');
    } catch (error) {
      logger.error('Error during settings migration:', error);
    }
  }

  private async validateSettings(): Promise<void> {
    try {
      const settings = await this.settingsManager.getSettings();
      const validation = this.settingsManager.validateSettings(settings);
      
      if (!validation.isValid) {
        logger.warn('Invalid settings detected:', validation.errors);
        // Could trigger a notification or reset to defaults
      }
    } catch (error) {
      logger.error('Error validating settings:', error);
    }
  }

  private async capturePage(data: any, sender: chrome.runtime.MessageSender): Promise<any> {
    try {
      logger.info('Capturing page for tab:', sender.tab?.id);
      
      if (!sender.tab?.id) {
        throw new Error('No tab ID available for capture');
      }

      // Implementation would go here
      // This is a placeholder for the actual capture logic
      return { 
        success: true, 
        message: 'Page capture initiated',
        tabId: sender.tab.id 
      };
    } catch (error) {
      logger.error('Error capturing page:', error);
      throw error;
    }
  }

  private async getSettings(): Promise<Partial<ISettings>> {
    try {
      return await this.settingsManager.getSettingsWithDefaults();
    } catch (error) {
      logger.error('Error getting settings:', error);
      throw error;
    }
  }

  private async updateSettings(updates: Partial<ISettings>): Promise<boolean> {
    try {
      const success = await this.settingsManager.updateSettings(updates);
      if (success) {
        logger.info('Settings updated successfully');
      }
      return success;
    } catch (error) {
      logger.error('Error updating settings:', error);
      throw error;
    }
  }

  private async resetSettings(): Promise<boolean> {
    try {
      const success = await this.settingsManager.resetSettings();
      if (success) {
        logger.info('Settings reset to defaults');
      }
      return success;
    } catch (error) {
      logger.error('Error resetting settings:', error);
      throw error;
    }
  }

  private async testGitConnection(): Promise<any> {
    try {
      // Implementation would test Git connectivity
      return { connected: true, message: 'Git connection successful' };
    } catch (error) {
      logger.error('Error testing Git connection:', error);
      throw error;
    }
  }

  private async getExtensionStatus(): Promise<any> {
    return {
      initialized: this.isInitialized,
      version: chrome.runtime.getManifest().version,
      timestamp: new Date().toISOString()
    };
  }

  private async saveFile(data: any): Promise<any> {
    try {
      // Implementation would save file using FileManager
      return { success: true, message: 'File saved' };
    } catch (error) {
      logger.error('Error saving file:', error);
      throw error;
    }
  }

  private async commitFile(data: any): Promise<any> {
    try {
      // Implementation would commit file using GitOperations
      return { success: true, message: 'File committed' };
    } catch (error) {
      logger.error('Error committing file:', error);
      throw error;
    }
  }

  private async pushChanges(): Promise<any> {
    try {
      // Implementation would push changes using GitOperations
      return { success: true, message: 'Changes pushed' };
    } catch (error) {
      logger.error('Error pushing changes:', error);
      throw error;
    }
  }
}

// Initialize the background service worker
const backgroundService = new PrismWeaveBackground();
