// Generated by Copilot
// PrismWeave Injectable Bundle for Bookmarklet
// This bundle provides all the sophisticated browser extension utilities
// in an injectable format that can be loaded dynamically into web pages

import { createLogger } from '../utils/logger.js';
import { showToast, type ToastType } from '../utils/notifications/toast-internal.js';
import {
  IInjectableContentResult,
  IInjectableExtractionOptions,
  InjectableContentExtractor,
} from './content-extractor-injectable.js';
import {
  IInjectableMarkdownOptions,
  IInjectableMarkdownResult,
  InjectableMarkdownConverter,
} from './markdown-converter-injectable.js';

// Combined interfaces for the bundle
export interface IPrismWeaveInjectableOptions {
  extraction?: IInjectableExtractionOptions;
  markdown?: IInjectableMarkdownOptions;
}

export interface IPrismWeaveProcessedContent {
  title: string;
  url: string;
  domain: string;
  html: string;
  markdown: string;
  frontmatter: string;
  fullDocument: string; // frontmatter + markdown
  metadata: Record<string, unknown>;
  images: string[];
  wordCount: number;
  readingTime: number;
  qualityScore: number;
  extractedAt: string;
  processingMethod: 'injectable-advanced-bundle';
}

/**
 * PrismWeave Injectable Bundle
 * Combines sophisticated content extraction and markdown conversion
 * for use in bookmarklets via script injection
 */
export class PrismWeaveInjectableBundle {
  private _extractor: InjectableContentExtractor;
  private _converter: InjectableMarkdownConverter;
  private _logger: any;
  private _isInitialized: boolean = false;

  constructor() {
    this._extractor = new InjectableContentExtractor();
    this._converter = new InjectableMarkdownConverter();
    this._logger = createLogger('PrismWeaveBundle');
  }

  async initialize(): Promise<void> {
    if (this._isInitialized) return;

    try {
      this._logger.info('Initializing PrismWeave injectable bundle');

      // Initialize both components
      await Promise.all([this._extractor.initialize(), this._converter.initialize()]);

      this._isInitialized = true;
      this._logger.info('PrismWeave injectable bundle initialized successfully');
    } catch (error) {
      this._logger.error('Failed to initialize PrismWeave bundle:', error);
      throw error;
    }
  }

  async processPage(
    options: IPrismWeaveInjectableOptions = {}
  ): Promise<IPrismWeaveProcessedContent> {
    if (!this._isInitialized) {
      await this.initialize();
    }

    try {
      this._logger.info('Starting advanced page processing');

      // Step 1: Extract content using sophisticated content extractor
      const extractionResult = await this._extractor.extractAdvancedContent(options.extraction);

      // Step 2: Convert to markdown using sophisticated converter
      const markdownOptions: IInjectableMarkdownOptions = {
        generateFrontmatter: true,
        includeMetadata: true,
        includeImages: options.markdown?.includeImages ?? true,
        includeLinks: options.markdown?.includeLinks ?? true,
        ...options.markdown,
      };

      const conversionResult = await this._converter.convertToAdvancedMarkdown(
        extractionResult.content,
        markdownOptions
      );

      // Step 3: Combine results
      const fullDocument = conversionResult.frontmatter
        ? `${conversionResult.frontmatter}\n\n${conversionResult.markdown}`
        : conversionResult.markdown;

      return {
        title: extractionResult.title,
        url: extractionResult.url,
        domain: extractionResult.domain,
        html: extractionResult.html,
        markdown: conversionResult.markdown,
        frontmatter: conversionResult.frontmatter,
        fullDocument,
        metadata: {
          ...extractionResult.metadata,
          ...conversionResult.metadata,
          processingMethod: 'injectable-advanced-bundle',
          processedAt: new Date().toISOString(),
        },
        images: extractionResult.images,
        wordCount: extractionResult.wordCount,
        readingTime: extractionResult.readingTime,
        qualityScore: extractionResult.qualityScore,
        extractedAt: extractionResult.extractedAt,
        processingMethod: 'injectable-advanced-bundle',
      };
    } catch (error) {
      this._logger.error('Page processing failed:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      throw new Error(`Advanced page processing failed: ${errorMessage}`);
    }
  }

  // Convenience methods for direct access
  async extractContent(
    options: IInjectableExtractionOptions = {}
  ): Promise<IInjectableContentResult> {
    if (!this._isInitialized) {
      await this.initialize();
    }
    return await this._extractor.extractAdvancedContent(options);
  }

  async convertToMarkdown(
    html: string,
    options: IInjectableMarkdownOptions = {}
  ): Promise<IInjectableMarkdownResult> {
    if (!this._isInitialized) {
      await this.initialize();
    }
    return await this._converter.convertToAdvancedMarkdown(html, options);
  }

  // Static method for easy access
  static async processCurrentPage(
    options: IPrismWeaveInjectableOptions = {}
  ): Promise<IPrismWeaveProcessedContent> {
    const bundle = new PrismWeaveInjectableBundle();
    return await bundle.processPage(options);
  }

  // Static method for simple content extraction
  static async extractPageContent(
    options: IInjectableExtractionOptions = {}
  ): Promise<IInjectableContentResult> {
    const bundle = new PrismWeaveInjectableBundle();
    return await bundle.extractContent(options);
  }

  // Static method for simple markdown conversion
  static async convertHtmlToMarkdown(
    html: string,
    options: IInjectableMarkdownOptions = {}
  ): Promise<IInjectableMarkdownResult> {
    const bundle = new PrismWeaveInjectableBundle();
    return await bundle.convertToMarkdown(html, options);
  }
}

// Global registration for bookmarklet access
declare global {
  interface Window {
    PrismWeaveInjectableBundle?: typeof PrismWeaveInjectableBundle;
    prismweaveProcessPage?: (
      options?: IPrismWeaveInjectableOptions
    ) => Promise<IPrismWeaveProcessedContent>;
    prismweaveExtractPageContent?: (
      options?: IInjectableExtractionOptions
    ) => Promise<IInjectableContentResult>;
    prismweaveConvertHtmlToMarkdown?: (
      html: string,
      options?: IInjectableMarkdownOptions
    ) => Promise<IInjectableMarkdownResult>;
    prismweaveShowToast?: (message: string, type?: ToastType, clickUrl?: string) => void;
  }
}

// Register globally for bookmarklet access
if (typeof window !== 'undefined') {
  window.PrismWeaveInjectableBundle = PrismWeaveInjectableBundle;
  window.prismweaveProcessPage = PrismWeaveInjectableBundle.processCurrentPage;
  window.prismweaveExtractPageContent = PrismWeaveInjectableBundle.extractPageContent;
  window.prismweaveConvertHtmlToMarkdown = PrismWeaveInjectableBundle.convertHtmlToMarkdown;

  // Register the shared toast utility
  window.prismweaveShowToast = (message: string, type?: ToastType, clickUrl?: string) => {
    const options: { type?: ToastType; clickUrl?: string } = {};
    if (type) options.type = type;
    if (clickUrl) options.clickUrl = clickUrl;
    showToast(message, options);
  };

  // Log successful injection
  console.log('ðŸš€ PrismWeave Injectable Bundle loaded successfully');
  console.log(
    'Available methods: prismweaveProcessPage, prismweaveExtractPageContent, prismweaveConvertHtmlToMarkdown, prismweaveShowToast'
  );
}

// Export for module use
export default PrismWeaveInjectableBundle;
