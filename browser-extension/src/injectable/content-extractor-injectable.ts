// Generated by Copilot
// Injectable Content Extractor for PrismWeave Bookmarklet
// This module creates an injectable version of the sophisticated browser extension ContentExtractor
// that can be loaded dynamically into web pages via script injection

import { ContentExtractor, IExtractorOptions } from '../utils/content-extractor.js';
import { createLogger } from '../utils/logger.js';
import { MarkdownConverter } from '../utils/markdown-converter.js';

// Re-export types for standalone use
export interface IInjectableExtractionOptions {
  customSelectors?: string[];
  cleanHtml?: boolean;
  preserveFormatting?: boolean;
  waitForDynamicContent?: boolean;
  removeAds?: boolean;
  removeNavigation?: boolean;
  excludeSelectors?: string[];
  includeImages?: boolean;
  includeLinks?: boolean;
}

export interface IInjectableContentResult {
  content: string;
  title: string;
  url: string;
  domain: string;
  html: string;
  markdown: string;
  frontmatter: string;
  metadata: Record<string, unknown>;
  images: string[];
  wordCount: number;
  readingTime: number;
  qualityScore: number;
  extractedAt: string;
  extractionMethod: 'injectable-advanced';
}

export interface IGitHubConfig {
  token: string;
  repository: string;
  folder?: string;
  commitMessage?: string;
}

export interface IGitHubCommitResult {
  success: boolean;
  data?: {
    sha: string;
    url: string;
    html_url: string;
  };
  error?: string;
}

/**
 * Injectable Content Extractor
 * Uses the sophisticated browser extension ContentExtractor in an injectable context
 */
export class InjectableContentExtractor {
  private _extractor: ContentExtractor | null = null;
  private _markdownConverter: MarkdownConverter | null = null;
  private _logger: any;
  private _isInitialized: boolean = false;

  constructor() {
    // Create a simple logger for injectable context
    this._logger = createLogger('InjectableExtractor');
  }

  async initialize(): Promise<void> {
    if (this._isInitialized) return;

    try {
      // Initialize the sophisticated ContentExtractor
      this._extractor = new ContentExtractor();
      this._markdownConverter = new MarkdownConverter();
      this._isInitialized = true;
      this._logger.info('Injectable content extractor initialized');
    } catch (error) {
      this._logger.error('Failed to initialize injectable extractor:', error);
      throw error;
    }
  }

  async extractAdvancedContent(
    options: IInjectableExtractionOptions = {}
  ): Promise<IInjectableContentResult> {
    if (!this._isInitialized || !this._extractor || !this._markdownConverter) {
      await this.initialize();
    }

    try {
      this._logger.info('Starting advanced content extraction');

      // Convert injectable options to ContentExtractor options
      const extractorOptions: IExtractorOptions = {};

      if (options.customSelectors !== undefined) {
        extractorOptions.customSelectors = options.customSelectors;
      }
      if (options.cleanHtml !== undefined) {
        extractorOptions.cleanHtml = options.cleanHtml;
      }
      if (options.preserveFormatting !== undefined) {
        extractorOptions.preserveFormatting = options.preserveFormatting;
      }
      if (options.waitForDynamicContent !== undefined) {
        extractorOptions.waitForDynamicContent = options.waitForDynamicContent;
      }
      if (options.removeAds !== undefined) {
        extractorOptions.removeAds = options.removeAds;
      }
      if (options.removeNavigation !== undefined) {
        extractorOptions.removeNavigation = options.removeNavigation;
      }
      if (options.excludeSelectors !== undefined) {
        extractorOptions.excludeSelectors = options.excludeSelectors;
      }

      // Use the sophisticated browser extension content extractor
      const contentResult = await this._extractor!.extractContent(extractorOptions);

      // Convert HTML to markdown using the sophisticated converter
      const markdownResult = this._markdownConverter!.convertToMarkdown(contentResult.content);
      const markdown = markdownResult.markdown;

      // Extract additional metadata using sophisticated methods
      const advancedMetadata = this._extractAdvancedMetadata();

      // Extract images with proper URL resolution
      const images = this._extractImages(document.body);

      // Calculate quality score
      const qualityScore = this._calculateQualityScore(document.body, contentResult.wordCount);

      // Generate frontmatter
      const frontmatter = this._generateFrontmatter({
        title: contentResult.metadata.title,
        url: contentResult.metadata.url,
        domain: window.location.hostname,
        wordCount: contentResult.wordCount,
        extractedAt: new Date().toISOString(),
        metadata: advancedMetadata,
      });

      return {
        content: contentResult.content,
        title: contentResult.metadata.title,
        url: contentResult.metadata.url,
        domain: window.location.hostname,
        html: contentResult.content,
        markdown,
        frontmatter,
        metadata: {
          ...contentResult.metadata,
          ...advancedMetadata,
          extractedAt: new Date().toISOString(),
          qualityScore,
          extractionMethod: 'injectable-advanced',
        },
        images,
        wordCount: contentResult.wordCount,
        readingTime: contentResult.readingTime,
        qualityScore,
        extractedAt: new Date().toISOString(),
        extractionMethod: 'injectable-advanced',
      };
    } catch (error) {
      this._logger.error('Advanced content extraction failed:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      throw new Error(`Advanced extraction failed: ${errorMessage}`);
    }
  }

  private async _waitForContent(): Promise<void> {
    // Enhanced content waiting strategy
    await new Promise(resolve => setTimeout(resolve, 500));

    // Wait for images to load
    const images = Array.from(document.images).filter(img => !img.complete);
    if (images.length > 0) {
      await Promise.allSettled(
        images.map(
          img =>
            new Promise(resolve => {
              const timeout = setTimeout(() => resolve(null), 3000);
              img.onload = img.onerror = () => {
                clearTimeout(timeout);
                resolve(null);
              };
            })
        )
      );
    }

    // Wait for any lazy-loaded content
    if ('IntersectionObserver' in window) {
      await new Promise<void>(resolve => {
        const observer = new IntersectionObserver((entries, obs) => {
          obs.disconnect();
          resolve();
        });

        const elements = document.querySelectorAll('[data-src], [loading="lazy"]');
        if (elements.length === 0) {
          resolve();
        } else {
          elements.forEach(el => observer.observe(el));
          setTimeout(() => {
            observer.disconnect();
            resolve();
          }, 2000);
        }
      });
    }
  }

  private _extractAdvancedMetadata(): Record<string, unknown> {
    const metadata: Record<string, unknown> = {};

    // Open Graph metadata
    document.querySelectorAll('[property^="og:"]').forEach(meta => {
      const property = meta.getAttribute('property');
      const content = meta.getAttribute('content');
      if (property && content) {
        metadata[property] = content;
      }
    });

    // Twitter Card metadata
    document.querySelectorAll('[name^="twitter:"]').forEach(meta => {
      const name = meta.getAttribute('name');
      const content = meta.getAttribute('content');
      if (name && content) {
        metadata[name] = content;
      }
    });

    // Standard meta tags
    const metaTags = ['description', 'keywords', 'author', 'generator', 'theme-color'];
    metaTags.forEach(name => {
      const meta = document.querySelector(`[name="${name}"]`);
      if (meta) {
        const content = meta.getAttribute('content');
        if (content) metadata[name] = content;
      }
    });

    // Structured data (JSON-LD)
    try {
      const jsonLdScripts = document.querySelectorAll('script[type="application/ld+json"]');
      const structuredData: any[] = [];
      jsonLdScripts.forEach(script => {
        try {
          const data = JSON.parse(script.textContent || '');
          structuredData.push(data);
        } catch (e) {
          // Invalid JSON-LD, skip
        }
      });
      if (structuredData.length > 0) {
        metadata.structuredData = structuredData;
      }
    } catch (error) {
      // JSON-LD parsing failed, continue without it
    }

    // Page information
    metadata.url = window.location.href;
    metadata.domain = window.location.hostname;
    metadata.pathname = window.location.pathname;
    metadata.language = document.documentElement.lang || 'en';
    metadata.extractedAt = new Date().toISOString();

    return metadata;
  }

  private _extractImages(element: Element): string[] {
    const images: string[] = [];
    const imgElements = element.querySelectorAll('img');

    imgElements.forEach(img => {
      const src = img.src || img.dataset.src; // Handle lazy-loaded images
      if (src && !src.startsWith('data:') && src.length > 0) {
        try {
          // Convert relative URLs to absolute
          const absoluteUrl = new URL(src, window.location.href).href;
          if (!images.includes(absoluteUrl)) {
            images.push(absoluteUrl);
          }
        } catch (error) {
          // Invalid URL, skip
        }
      }
    });

    return images;
  }

  private _extractTitle(): string {
    // Enhanced title extraction with multiple fallbacks
    const titleSources = [
      () => document.querySelector('[property="og:title"]')?.getAttribute('content'),
      () => document.querySelector('[name="twitter:title"]')?.getAttribute('content'),
      () => document.querySelector('h1')?.textContent,
      () => document.querySelector('.entry-title, .post-title, .article-title')?.textContent,
      () => document.title,
      () => document.querySelector('title')?.textContent,
    ];

    for (const source of titleSources) {
      try {
        const title = source();
        if (title && title.trim().length > 0) {
          return title.trim();
        }
      } catch (error) {
        // Source failed, try next
      }
    }

    return 'Untitled Page';
  }

  private _countWords(text: string): number {
    if (!text) return 0;
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }

  private _calculateQualityScore(element: Element, wordCount: number): number {
    let score = 0;

    // Word count scoring (base score)
    score += Math.min(wordCount / 10, 50);

    // Content structure scoring
    const paragraphs = element.querySelectorAll('p').length;
    const headers = element.querySelectorAll('h1, h2, h3, h4, h5, h6').length;
    const lists = element.querySelectorAll('ul, ol').length;

    score += paragraphs * 2;
    score += headers * 3;
    score += lists * 1.5;

    // Content density (text to HTML ratio)
    const textLength = element.textContent?.length || 0;
    const htmlLength = element.innerHTML?.length || 1;
    const density = textLength / htmlLength;
    score += density * 20;

    // Link density penalty
    const links = element.querySelectorAll('a').length;
    const linkDensity = wordCount > 0 ? links / wordCount : 0;
    if (linkDensity > 0.1) {
      score -= linkDensity * 30;
    }

    // Semantic structure bonus
    const semanticElements = element.querySelectorAll('article, section, main, aside').length;
    score += semanticElements * 5;

    return Math.max(Math.min(score, 100), 0); // Clamp between 0-100
  }

  private _generateFrontmatter(params: {
    title: string;
    url: string;
    domain: string;
    wordCount: number;
    extractedAt: string;
    metadata: Record<string, unknown>;
  }): string {
    const frontmatterLines = [
      '---',
      `title: "${params.title.replace(/"/g, '\\"')}"`,
      `url: "${params.url}"`,
      `domain: "${params.domain}"`,
      `extracted_at: "${params.extractedAt}"`,
      `word_count: ${params.wordCount}`,
      `extraction_method: "injectable-advanced"`,
    ];

    // Add author if available
    if (params.metadata.author && typeof params.metadata.author === 'string') {
      frontmatterLines.push(`author: "${params.metadata.author.replace(/"/g, '\\"')}"`);
    }

    // Add description if available
    if (params.metadata.description && typeof params.metadata.description === 'string') {
      frontmatterLines.push(`description: "${params.metadata.description.replace(/"/g, '\\"')}"`);
    }

    // Add keywords/tags if available
    if (params.metadata.keywords && Array.isArray(params.metadata.keywords)) {
      const tags = params.metadata.keywords
        .map(k => `"${String(k).replace(/"/g, '\\"')}"`)
        .join(', ');
      frontmatterLines.push(`tags: [${tags}]`);
    }

    frontmatterLines.push('---', '');
    return frontmatterLines.join('\n');
  }

  /**
   * Commit content directly to GitHub repository
   */
  async commitToGitHub(
    content: string,
    config: IGitHubConfig,
    filename?: string
  ): Promise<IGitHubCommitResult> {
    try {
      const extractionResult = await this.extractAdvancedContent();

      // Generate filename if not provided
      const finalFilename = filename || this._generateFilename(extractionResult.title);
      const folder = config.folder || 'documents';
      const filePath = `${folder}/${finalFilename}`;

      // Combine frontmatter and markdown
      const fullContent = extractionResult.frontmatter + extractionResult.markdown;

      const commitMessage = (config.commitMessage || 'PrismWeave: Add {title}').replace(
        '{title}',
        extractionResult.title
      );

      // Check if file exists first
      let existingFileSha: string | undefined;
      try {
        const existingResponse = await fetch(
          `https://api.github.com/repos/${config.repository}/contents/${filePath}`,
          {
            headers: {
              Authorization: `token ${config.token}`,
              Accept: 'application/vnd.github.v3+json',
              'User-Agent': 'PrismWeave-Injectable/1.0',
            },
          }
        );

        if (existingResponse.ok) {
          const existingData = await existingResponse.json();
          existingFileSha = existingData.sha;
        }
      } catch (error) {
        // File doesn't exist, which is fine
      }

      // Create or update file
      const requestBody: any = {
        message: commitMessage,
        content: btoa(unescape(encodeURIComponent(fullContent))),
        branch: 'main',
      };

      if (existingFileSha) {
        requestBody.sha = existingFileSha;
      }

      const response = await fetch(
        `https://api.github.com/repos/${config.repository}/contents/${filePath}`,
        {
          method: 'PUT',
          headers: {
            Authorization: `token ${config.token}`,
            'Content-Type': 'application/json',
            Accept: 'application/vnd.github.v3+json',
            'User-Agent': 'PrismWeave-Injectable/1.0',
          },
          body: JSON.stringify(requestBody),
        }
      );

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(
          `GitHub API error: ${response.status} - ${errorData.message || 'Unknown error'}`
        );
      }

      const result = await response.json();
      return {
        success: true,
        data: {
          sha: result.content.sha,
          url: result.content.url,
          html_url: result.content.html_url,
        },
      };
    } catch (error) {
      this._logger.error('GitHub commit failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  private _generateFilename(title: string): string {
    const safeName = title
      .replace(/[^\w\s-]/g, '')
      .replace(/\s+/g, '-')
      .toLowerCase()
      .slice(0, 40);

    const date = new Date().toISOString().slice(0, 10);
    return `${date}-${safeName}.md`;
  }

  // Static methods for easy access
  static async extractContent(
    options: IInjectableExtractionOptions = {}
  ): Promise<IInjectableContentResult> {
    const extractor = new InjectableContentExtractor();
    return await extractor.extractAdvancedContent(options);
  }

  static async extractAndCommit(
    config: IGitHubConfig,
    options: IInjectableExtractionOptions = {},
    filename?: string
  ): Promise<IGitHubCommitResult> {
    const extractor = new InjectableContentExtractor();
    await extractor.initialize();
    const extractionResult = await extractor.extractAdvancedContent(options);

    // Generate filename if not provided
    const finalFilename = filename || extractor._generateFilename(extractionResult.title);
    const folder = config.folder || 'documents';
    const filePath = `${folder}/${finalFilename}`;

    // Combine frontmatter and markdown
    const fullContent = extractionResult.frontmatter + extractionResult.markdown;

    return await extractor.commitToGitHub(fullContent, config, finalFilename);
  }
}

// Global registration for bookmarklet access
declare global {
  interface Window {
    PrismWeaveInjectableExtractor?: typeof InjectableContentExtractor;
    prismweaveExtractContent?: (
      options?: IInjectableExtractionOptions
    ) => Promise<IInjectableContentResult>;
    prismweaveExtractAndCommit?: (
      config: IGitHubConfig,
      options?: IInjectableExtractionOptions,
      filename?: string
    ) => Promise<IGitHubCommitResult>;
  }
}

// Register globally for bookmarklet access
if (typeof window !== 'undefined') {
  window.PrismWeaveInjectableExtractor = InjectableContentExtractor;
  window.prismweaveExtractContent = InjectableContentExtractor.extractContent;
  window.prismweaveExtractAndCommit = InjectableContentExtractor.extractAndCommit;

  // Log successful injection
  console.log('ðŸ”— PrismWeave Injectable Content Extractor loaded successfully');
}
