// Generated by Copilot
// Injectable Content Extractor for PrismWeave Bookmarklet
// This module creates an injectable version of the sophisticated browser extension ContentExtractor
// that can be loaded dynamically into web pages via script injection

import { ContentExtractor, IExtractorOptions } from '../utils/content-extractor.js';
import { createLogger } from '../utils/logger.js';

// Re-export types for standalone use
export interface IInjectableExtractionOptions {
  customSelectors?: string[];
  cleanHtml?: boolean;
  preserveFormatting?: boolean;
  waitForDynamicContent?: boolean;
  removeAds?: boolean;
  removeNavigation?: boolean;
  excludeSelectors?: string[];
  includeImages?: boolean;
  includeLinks?: boolean;
}

export interface IInjectableContentResult {
  content: string;
  title: string;
  url: string;
  domain: string;
  html: string;
  metadata: Record<string, unknown>;
  images: string[];
  wordCount: number;
  readingTime: number;
  qualityScore: number;
  extractedAt: string;
  extractionMethod: 'injectable-advanced';
}

/**
 * Injectable Content Extractor
 * Uses the sophisticated browser extension ContentExtractor in an injectable context
 */
export class InjectableContentExtractor {
  private _extractor: ContentExtractor | null = null;
  private _logger: any;
  private _isInitialized: boolean = false;

  constructor() {
    // Create a simple logger for injectable context
    this._logger = createLogger('InjectableExtractor');
  }

  async initialize(): Promise<void> {
    if (this._isInitialized) return;

    try {
      // Initialize the sophisticated ContentExtractor
      this._extractor = new ContentExtractor();
      this._isInitialized = true;
      this._logger.info('Injectable content extractor initialized');
    } catch (error) {
      this._logger.error('Failed to initialize injectable extractor:', error);
      throw error;
    }
  }

  async extractAdvancedContent(
    options: IInjectableExtractionOptions = {}
  ): Promise<IInjectableContentResult> {
    if (!this._isInitialized || !this._extractor) {
      await this.initialize();
    }

    try {
      this._logger.info('Starting advanced content extraction');

      // Convert injectable options to ContentExtractor options
      const extractorOptions: IExtractorOptions = {};

      if (options.customSelectors !== undefined) {
        extractorOptions.customSelectors = options.customSelectors;
      }
      if (options.cleanHtml !== undefined) {
        extractorOptions.cleanHtml = options.cleanHtml;
      }
      if (options.preserveFormatting !== undefined) {
        extractorOptions.preserveFormatting = options.preserveFormatting;
      }
      if (options.waitForDynamicContent !== undefined) {
        extractorOptions.waitForDynamicContent = options.waitForDynamicContent;
      }
      if (options.removeAds !== undefined) {
        extractorOptions.removeAds = options.removeAds;
      }
      if (options.removeNavigation !== undefined) {
        extractorOptions.removeNavigation = options.removeNavigation;
      }
      if (options.excludeSelectors !== undefined) {
        extractorOptions.excludeSelectors = options.excludeSelectors;
      }

      // Use the sophisticated browser extension content extractor
      const contentResult = await this._extractor!.extractContent(extractorOptions);

      // Extract additional metadata using sophisticated methods
      const advancedMetadata = this._extractAdvancedMetadata();

      // Extract images with proper URL resolution
      const images = this._extractImages(document.body);

      // Calculate quality score
      const qualityScore = this._calculateQualityScore(document.body, contentResult.wordCount);

      return {
        content: contentResult.content,
        title: contentResult.metadata.title,
        url: contentResult.metadata.url,
        domain: window.location.hostname,
        html: contentResult.content,
        metadata: {
          ...contentResult.metadata,
          ...advancedMetadata,
          extractedAt: new Date().toISOString(),
          qualityScore,
          extractionMethod: 'injectable-advanced',
        },
        images,
        wordCount: contentResult.wordCount,
        readingTime: contentResult.readingTime,
        qualityScore,
        extractedAt: new Date().toISOString(),
        extractionMethod: 'injectable-advanced',
      };
    } catch (error) {
      this._logger.error('Advanced content extraction failed:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      throw new Error(`Advanced extraction failed: ${errorMessage}`);
    }
  }

  private async _waitForContent(): Promise<void> {
    // Enhanced content waiting strategy
    await new Promise(resolve => setTimeout(resolve, 500));

    // Wait for images to load
    const images = Array.from(document.images).filter(img => !img.complete);
    if (images.length > 0) {
      await Promise.allSettled(
        images.map(
          img =>
            new Promise(resolve => {
              const timeout = setTimeout(() => resolve(null), 3000);
              img.onload = img.onerror = () => {
                clearTimeout(timeout);
                resolve(null);
              };
            })
        )
      );
    }

    // Wait for any lazy-loaded content
    if ('IntersectionObserver' in window) {
      await new Promise<void>(resolve => {
        const observer = new IntersectionObserver((entries, obs) => {
          obs.disconnect();
          resolve();
        });

        const elements = document.querySelectorAll('[data-src], [loading="lazy"]');
        if (elements.length === 0) {
          resolve();
        } else {
          elements.forEach(el => observer.observe(el));
          setTimeout(() => {
            observer.disconnect();
            resolve();
          }, 2000);
        }
      });
    }
  }

  private _extractAdvancedMetadata(): Record<string, unknown> {
    const metadata: Record<string, unknown> = {};

    // Open Graph metadata
    document.querySelectorAll('[property^="og:"]').forEach(meta => {
      const property = meta.getAttribute('property');
      const content = meta.getAttribute('content');
      if (property && content) {
        metadata[property] = content;
      }
    });

    // Twitter Card metadata
    document.querySelectorAll('[name^="twitter:"]').forEach(meta => {
      const name = meta.getAttribute('name');
      const content = meta.getAttribute('content');
      if (name && content) {
        metadata[name] = content;
      }
    });

    // Standard meta tags
    const metaTags = ['description', 'keywords', 'author', 'generator', 'theme-color'];
    metaTags.forEach(name => {
      const meta = document.querySelector(`[name="${name}"]`);
      if (meta) {
        const content = meta.getAttribute('content');
        if (content) metadata[name] = content;
      }
    });

    // Structured data (JSON-LD)
    try {
      const jsonLdScripts = document.querySelectorAll('script[type="application/ld+json"]');
      const structuredData: any[] = [];
      jsonLdScripts.forEach(script => {
        try {
          const data = JSON.parse(script.textContent || '');
          structuredData.push(data);
        } catch (e) {
          // Invalid JSON-LD, skip
        }
      });
      if (structuredData.length > 0) {
        metadata.structuredData = structuredData;
      }
    } catch (error) {
      // JSON-LD parsing failed, continue without it
    }

    // Page information
    metadata.url = window.location.href;
    metadata.domain = window.location.hostname;
    metadata.pathname = window.location.pathname;
    metadata.language = document.documentElement.lang || 'en';
    metadata.extractedAt = new Date().toISOString();

    return metadata;
  }

  private _extractImages(element: Element): string[] {
    const images: string[] = [];
    const imgElements = element.querySelectorAll('img');

    imgElements.forEach(img => {
      const src = img.src || img.dataset.src; // Handle lazy-loaded images
      if (src && !src.startsWith('data:') && src.length > 0) {
        try {
          // Convert relative URLs to absolute
          const absoluteUrl = new URL(src, window.location.href).href;
          if (!images.includes(absoluteUrl)) {
            images.push(absoluteUrl);
          }
        } catch (error) {
          // Invalid URL, skip
        }
      }
    });

    return images;
  }

  private _extractTitle(): string {
    // Enhanced title extraction with multiple fallbacks
    const titleSources = [
      () => document.querySelector('[property="og:title"]')?.getAttribute('content'),
      () => document.querySelector('[name="twitter:title"]')?.getAttribute('content'),
      () => document.querySelector('h1')?.textContent,
      () => document.querySelector('.entry-title, .post-title, .article-title')?.textContent,
      () => document.title,
      () => document.querySelector('title')?.textContent,
    ];

    for (const source of titleSources) {
      try {
        const title = source();
        if (title && title.trim().length > 0) {
          return title.trim();
        }
      } catch (error) {
        // Source failed, try next
      }
    }

    return 'Untitled Page';
  }

  private _countWords(text: string): number {
    if (!text) return 0;
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }

  private _calculateQualityScore(element: Element, wordCount: number): number {
    let score = 0;

    // Word count scoring (base score)
    score += Math.min(wordCount / 10, 50);

    // Content structure scoring
    const paragraphs = element.querySelectorAll('p').length;
    const headers = element.querySelectorAll('h1, h2, h3, h4, h5, h6').length;
    const lists = element.querySelectorAll('ul, ol').length;

    score += paragraphs * 2;
    score += headers * 3;
    score += lists * 1.5;

    // Content density (text to HTML ratio)
    const textLength = element.textContent?.length || 0;
    const htmlLength = element.innerHTML?.length || 1;
    const density = textLength / htmlLength;
    score += density * 20;

    // Link density penalty
    const links = element.querySelectorAll('a').length;
    const linkDensity = wordCount > 0 ? links / wordCount : 0;
    if (linkDensity > 0.1) {
      score -= linkDensity * 30;
    }

    // Semantic structure bonus
    const semanticElements = element.querySelectorAll('article, section, main, aside').length;
    score += semanticElements * 5;

    return Math.max(Math.min(score, 100), 0); // Clamp between 0-100
  }

  // Static method for easy access
  static async extractContent(
    options: IInjectableExtractionOptions = {}
  ): Promise<IInjectableContentResult> {
    const extractor = new InjectableContentExtractor();
    return await extractor.extractAdvancedContent(options);
  }
}

// Global registration for bookmarklet access
declare global {
  interface Window {
    PrismWeaveInjectableExtractor?: typeof InjectableContentExtractor;
    prismweaveExtractContent?: (
      options?: IInjectableExtractionOptions
    ) => Promise<IInjectableContentResult>;
  }
}

// Register globally for bookmarklet access
if (typeof window !== 'undefined') {
  window.PrismWeaveInjectableExtractor = InjectableContentExtractor;
  window.prismweaveExtractContent = InjectableContentExtractor.extractContent;

  // Log successful injection
  console.log('🔗 PrismWeave Injectable Content Extractor loaded successfully');
}
