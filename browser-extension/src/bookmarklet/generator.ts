// Generated by Copilot
// Bookmarklet generator frontend JavaScript for PrismWeave browser extension

interface IFormData {
  githubToken: string;
  githubRepo: string;
  defaultFolder: string;
  commitMessage: string;
  fileNaming: string;
}

interface IBookmarkletConfig {
  githubToken: string;
  githubRepo: string;
  defaultFolder?: string;
  commitMessageTemplate?: string;
  fileNamingPattern?: string;
  captureImages?: boolean;
  removeAds?: boolean;
  removeNavigation?: boolean;
}

class BookmarkletGeneratorUI {
  private form: HTMLFormElement;
  private statusMessage: HTMLElement;
  private resultSection: HTMLElement;
  private bookmarkletLink: HTMLAnchorElement;
  private bookmarkletCodeDisplay: HTMLElement;
  private currentBookmarkletCode: string = '';

  constructor() {
    this.form = document.getElementById('generator-form') as HTMLFormElement;
    this.statusMessage = document.getElementById('status-message') as HTMLElement;
    this.resultSection = document.getElementById('result-section') as HTMLElement;
    this.bookmarkletLink = document.getElementById('bookmarklet-link') as HTMLAnchorElement;
    this.bookmarkletCodeDisplay = document.getElementById(
      'bookmarklet-code-display'
    ) as HTMLElement;

    this.init();
  }

  init(): void {
    this.bindEvents();
    this.loadSavedSettings();
  }

  bindEvents(): void {
    this.form.addEventListener('submit', e => this.handleSubmit(e));

    // Real-time validation
    const tokenInput = document.getElementById('github-token') as HTMLInputElement;
    const repoInput = document.getElementById('github-repo') as HTMLInputElement;

    tokenInput.addEventListener('blur', () => this.validateToken());
    repoInput.addEventListener('blur', () => this.validateRepo());

    // Result section buttons
    document.getElementById('copy-btn')?.addEventListener('click', () => this.copyBookmarklet());
    document
      .getElementById('download-btn')
      ?.addEventListener('click', () => this.downloadBookmarklet());
  }

  loadSavedSettings(): void {
    try {
      const saved = localStorage.getItem('prismweave_generator_settings');
      if (saved) {
        const settings = JSON.parse(saved);

        // Don't restore the token for security
        if (settings.githubRepo) {
          (document.getElementById('github-repo') as HTMLInputElement).value = settings.githubRepo;
        }
        if (settings.defaultFolder) {
          (document.getElementById('default-folder') as HTMLSelectElement).value =
            settings.defaultFolder;
        }
        if (settings.commitMessage) {
          (document.getElementById('commit-message') as HTMLInputElement).value =
            settings.commitMessage;
        }
        if (settings.fileNaming) {
          (document.getElementById('file-naming') as HTMLSelectElement).value = settings.fileNaming;
        }
      }
    } catch (error) {
      console.warn('Failed to load saved settings:', error);
    }
  }

  saveSettings(formData: IFormData): void {
    try {
      const settingsToSave = {
        githubRepo: formData.githubRepo,
        defaultFolder: formData.defaultFolder,
        commitMessage: formData.commitMessage,
        fileNaming: formData.fileNaming,
        // Intentionally not saving the token
      };

      localStorage.setItem('prismweave_generator_settings', JSON.stringify(settingsToSave));
    } catch (error) {
      console.warn('Failed to save settings:', error);
    }
  }

  handleSubmit(e: Event): void {
    e.preventDefault();

    const formData = this.getFormData();

    if (!this.validateForm(formData)) {
      this.showStatus('Please fix the validation errors above.', 'error');
      return;
    }

    this.showStatus('Generating your personalized bookmarklet...', 'info');

    try {
      // Generate a compact, self-contained bookmarklet instead of the loader version
      const bookmarkletCode = this.generateCompactBookmarklet(formData);

      this.currentBookmarkletCode = bookmarkletCode;
      this.displayResult(bookmarkletCode, formData);
      this.saveSettings(formData);

      this.showStatus('✅ Bookmarklet generated successfully!', 'success');
    } catch (error) {
      this.showStatus(`❌ Generation failed: ${(error as Error).message}`, 'error');
      console.error('Bookmarklet generation failed:', error);
    }
  }

  getFormData(): IFormData {
    return {
      githubToken: (document.getElementById('github-token') as HTMLInputElement).value.trim(),
      githubRepo: (document.getElementById('github-repo') as HTMLInputElement).value.trim(),
      defaultFolder: (document.getElementById('default-folder') as HTMLSelectElement).value,
      commitMessage: (document.getElementById('commit-message') as HTMLInputElement).value.trim(),
      fileNaming: (document.getElementById('file-naming') as HTMLSelectElement).value,
    };
  }

  convertToBookmarkletConfig(formData: IFormData): IBookmarkletConfig {
    return {
      githubToken: formData.githubToken,
      githubRepo: formData.githubRepo,
      defaultFolder: formData.defaultFolder,
      commitMessageTemplate: formData.commitMessage,
      fileNamingPattern: formData.fileNaming,
      captureImages: true,
      removeAds: true,
      removeNavigation: true,
    };
  }

  generateCompactBookmarklet(formData: IFormData): string {
    const token = formData.githubToken;
    const repo = formData.githubRepo;
    const folder = formData.defaultFolder;
    const msgTemplate = formData.commitMessage || 'PrismWeave: Add {title}';

    // Build the bookmarklet JavaScript as a simple string without template literals
    const jsCode = [
      '(function(){',
      'function extractTitle(){',
      '  var title = document.querySelector(\'[property="og:title"]\');',
      '  if(title) return title.getAttribute(\'content\').trim();',
      '  title = document.querySelector(\'h1\');',
      '  if(title) return title.textContent.trim();',
      '  return document.title || \'Untitled\';',
      '}',
      
      'function findMainContent(){',
      '  var selectors = [\'article\',\'main\',\'.content\',\'#content\'];',
      '  for(var i=0; i<selectors.length; i++){',
      '    var el = document.querySelector(selectors[i]);',
      '    if(el && el.textContent && el.textContent.trim().length > 100) return el;',
      '  }',
      '  return document.body;',
      '}',
      
      'function cleanContent(el){',
      '  var clone = el.cloneNode(true);',
      '  var removeSelectors = [\'script\',\'style\',\'nav\',\'header\',\'footer\',\'.ad\',\'.advertisement\'];',
      '  removeSelectors.forEach(function(sel){',
      '    var elements = clone.querySelectorAll(sel);',
      '    for(var i=0; i<elements.length; i++) elements[i].remove();',
      '  });',
      '  return clone;',
      '}',
      
      'function htmlToMarkdown(html){',
      '  var md = html;',
      '  md = md.replace(/<h([1-6])[^>]*>(.*?)<\\/h[1-6]>/gi, function(m,l,c){',
      '    return \'\\n\' + \'#\'.repeat(parseInt(l)) + \' \' + c.replace(/<[^>]*>/g,\'\').trim() + \'\\n\';',
      '  });',
      '  md = md.replace(/<p[^>]*>(.*?)<\\/p>/gi, \'\\n$1\\n\');',
      '  md = md.replace(/<(strong|b)[^>]*>(.*?)<\\/(strong|b)>/gi, \'**$2**\');',
      '  md = md.replace(/<(em|i)[^>]*>(.*?)<\\/(em|i)>/gi, \'*$2*\');',
      '  md = md.replace(/<a[^>]*href=["\\\']([^"\\\']*)["\\\'][^>]*>(.*?)<\\/a>/gi, \'[$2]($1)\');',
      '  md = md.replace(/<[^>]*>/g, \'\');',
      '  md = md.replace(/\\n\\s*\\n\\s*\\n/g, \'\\n\\n\').trim();',
      '  return md;',
      '}',
      
      'var title = extractTitle();',
      'var contentEl = findMainContent();',
      'var cleanedEl = cleanContent(contentEl);',
      'var markdown = htmlToMarkdown(cleanedEl.innerHTML);',
      'var wordCount = cleanedEl.textContent.split(/\\s+/).filter(function(w){return w.length>0;}).length;',
      
      'var frontmatter = \'---\\n\';',
      'frontmatter += \'title: "\' + title.replace(/"/g, \'\\\\\"\') + \'"\\n\';',
      'frontmatter += \'url: "\' + location.href + \'"\\n\';',
      'frontmatter += \'domain: "\' + location.hostname + \'"\\n\';',
      'frontmatter += \'extracted_at: "\' + new Date().toISOString() + \'"\\n\';',
      'frontmatter += \'word_count: \' + wordCount + \'\\n\';',
      'frontmatter += \'extraction_method: "bookmarklet"\\n\';',
      'frontmatter += \'---\\n\\n\';',
      
      'var fullContent = frontmatter + markdown;',
      'var filename = title.replace(/[^\\w\\s-]/g, \'\').replace(/\\s+/g, \'-\').toLowerCase().slice(0, 40) + \'-\' + new Date().toISOString().slice(0, 10) + \'.md\';',
      
      'fetch(\'https://api.github.com/repos/' + repo + '/contents/' + folder + '/\' + filename, {',
      '  method: \'PUT\',',
      '  headers: {',
      '    \'Authorization\': \'token ' + token + '\',',
      '    \'Content-Type\': \'application/json\'',
      '  },',
      '  body: JSON.stringify({',
      '    message: \'' + msgTemplate + '\'.replace(\'{title}\', title),',
      '    content: btoa(unescape(encodeURIComponent(fullContent)))',
      '  })',
      '}).then(function(r){',
      '  if(r.ok){',
      '    r.json().then(function(data){',
      '      alert(\'✅ Page captured successfully!\');',
      '    });',
      '  } else {',
      '    alert(\'❌ Capture failed (\' + r.status + \')\');',
      '  }',
      '}).catch(function(e){',
      '  alert(\'❌ Network error: \' + e.message);',
      '});',
      '})();'
    ].join('');

    return 'javascript:' + encodeURIComponent(jsCode);
  }

  validateForm(formData: IFormData): boolean {
    let isValid = true;

    // Clear previous errors
    document.querySelectorAll('.validation-error').forEach(el => {
      el.textContent = '';
    });

    // Validate token
    if (!formData.githubToken) {
      this.showFieldError('token-error', 'GitHub token is required');
      isValid = false;
    } else if (formData.githubToken.length < 20) {
      this.showFieldError('token-error', 'GitHub token appears to be invalid (too short)');
      isValid = false;
    } else if (
      !formData.githubToken.startsWith('ghp_') &&
      !formData.githubToken.startsWith('github_pat_')
    ) {
      this.showFieldError(
        'token-error',
        'Token should start with "ghp_" (classic) or "github_pat_" (fine-grained)'
      );
      isValid = false;
    }

    // Validate repository
    if (!formData.githubRepo) {
      this.showFieldError('repo-error', 'GitHub repository is required');
      isValid = false;
    } else if (!/^[\w\-\.]+\/[\w\-\.]+$/.test(formData.githubRepo)) {
      this.showFieldError('repo-error', 'Repository must be in format: owner/repo');
      isValid = false;
    }

    return isValid;
  }

  validateToken(): void {
    const token = (document.getElementById('github-token') as HTMLInputElement).value.trim();
    const errorEl = document.getElementById('token-error') as HTMLElement;

    if (!token) {
      errorEl.textContent = 'GitHub token is required';
    } else if (token.length < 20) {
      errorEl.textContent = 'GitHub token appears to be invalid (too short)';
    } else if (!token.startsWith('ghp_') && !token.startsWith('github_pat_')) {
      errorEl.textContent = 'Token should start with "ghp_" or "github_pat_"';
    } else {
      errorEl.textContent = '';
    }
  }

  validateRepo(): void {
    const repo = (document.getElementById('github-repo') as HTMLInputElement).value.trim();
    const errorEl = document.getElementById('repo-error') as HTMLElement;

    if (!repo) {
      errorEl.textContent = 'GitHub repository is required';
    } else if (!/^[\w\-\.]+\/[\w\-\.]+$/.test(repo)) {
      errorEl.textContent = 'Repository must be in format: owner/repo';
    } else {
      errorEl.textContent = '';
    }
  }

  showFieldError(fieldId: string, message: string): void {
    const errorEl = document.getElementById(fieldId);
    if (errorEl) {
      errorEl.textContent = message;
    }
  }

  showStatus(message: string, type: 'info' | 'success' | 'error'): void {
    this.statusMessage.innerHTML = `<div class="status-message status-${type}">${message}</div>`;

    // Auto-hide success messages
    if (type === 'success') {
      setTimeout(() => {
        this.statusMessage.innerHTML = '';
      }, 5000);
    }
  }

  displayResult(bookmarkletCode: string, formData: IFormData): void {
    // Update bookmarklet link
    this.bookmarkletLink.href = bookmarkletCode;
    this.bookmarkletLink.title = `PrismWeave → ${formData.githubRepo}`;

    // Update code display (truncated for security/readability)
    const truncatedCode =
      bookmarkletCode.length > 200
        ? bookmarkletCode.substring(0, 200) + '...[truncated]'
        : bookmarkletCode;
    this.bookmarkletCodeDisplay.textContent = truncatedCode;

    // Show result section with animation
    this.resultSection.classList.add('show');
    this.resultSection.scrollIntoView({ behavior: 'smooth' });
  }

  async copyBookmarklet(): Promise<void> {
    try {
      await navigator.clipboard.writeText(this.currentBookmarkletCode);
      this.showStatus('📋 Bookmarklet copied to clipboard!', 'success');
    } catch (error) {
      // Fallback for older browsers
      const textArea = document.createElement('textarea');
      textArea.value = this.currentBookmarkletCode;
      document.body.appendChild(textArea);
      textArea.select();
      document.execCommand('copy');
      document.body.removeChild(textArea);

      this.showStatus('📋 Bookmarklet copied to clipboard! (fallback method)', 'success');
    }
  }

  downloadBookmarklet(): void {
    const formData = this.getFormData();
    const repoName = formData.githubRepo.split('/')[1] || 'repository';

    const html = this.generateBookmarkletPage(formData);
    const blob = new Blob([html], { type: 'text/html' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = `prismweave-bookmarklet-${repoName}.html`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    this.showStatus('💾 Bookmarklet HTML page downloaded!', 'success');
  }

  generateBookmarkletPage(formData: IFormData): string {
    const repoName = formData.githubRepo.split('/')[1] || 'repository';
    const currentDate = new Date().toLocaleDateString();

    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PrismWeave Bookmarklet - ${repoName}</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; max-width: 800px; margin: 2rem auto; padding: 2rem; }
        .header { text-align: center; margin-bottom: 3rem; }
        .bookmarklet-box { background: #f8f9fa; border: 2px dashed #6c757d; border-radius: 8px; padding: 2rem; text-align: center; margin: 2rem 0; }
        .bookmarklet-link { display: inline-block; padding: 1rem 2rem; background: #007bff; color: white; text-decoration: none; border-radius: 8px; font-weight: bold; margin: 1rem; }
        .instructions { background: #fff; border: 1px solid #e9ecef; border-radius: 8px; padding: 1.5rem; margin: 2rem 0; }
        .info { background: #d4edda; border: 1px solid #c3e6cb; border-radius: 6px; padding: 1rem; margin: 1rem 0; }
    </style>
</head>
<body>
    <div class="header">
        <h1>🌟 PrismWeave Bookmarklet</h1>
        <p>Personal bookmarklet for <strong>${formData.githubRepo}</strong></p>
        <p><em>Generated on ${currentDate}</em></p>
    </div>

    <div class="bookmarklet-box">
        <h3>Drag this to your bookmarks bar:</h3>
        <a href="${this.currentBookmarkletCode}" class="bookmarklet-link">📄 PrismWeave → ${repoName}</a>
        <p><small>Your GitHub settings are embedded - no setup required!</small></p>
    </div>

    <div class="instructions">
        <h3>📋 Installation Instructions:</h3>
        <ol>
            <li><strong>Drag & Drop:</strong> Drag the bookmarklet button above to your browser's bookmarks bar</li>
            <li><strong>Manual Method:</strong>
                <ul>
                    <li>Right-click the bookmarklet button and copy the link</li>
                    <li>Add a new bookmark in your browser</li>
                    <li>Set the name to "PrismWeave → ${repoName}" and paste the copied link as the URL</li>
                </ul>
            </li>
            <li><strong>Usage:</strong> Visit any webpage and click your bookmarklet to capture content</li>
        </ol>
    </div>

    <div class="info">
        <h4>⚙️ Configuration Summary:</h4>
        <ul>
            <li><strong>Repository:</strong> ${formData.githubRepo}</li>
            <li><strong>Default Folder:</strong> ${formData.defaultFolder}</li>
            <li><strong>Commit Message:</strong> ${formData.commitMessage}</li>
            <li><strong>File Naming:</strong> ${formData.fileNaming}</li>
        </ul>
    </div>

    <div class="info">
        <h4>🔒 Security Note:</h4>
        <p>This bookmarklet contains your GitHub Personal Access Token. Keep this file private and only share the bookmarklet with trusted parties.</p>
    </div>
</body>
</html>`;
  }
}

// Initialize the generator when the DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    new BookmarkletGeneratorUI();
  });
} else {
  new BookmarkletGeneratorUI();
}
