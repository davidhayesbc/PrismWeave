// Generated by Copilot
// Bookmarklet Runtime - Main execution environment for PrismWeave bookmarklet
// Self-contained with no Chrome extension API dependencies

import {
  BookmarkletContentCapture,
  IBookmarkletCaptureOptions,
} from '../utils/bookmarklet-content-capture.js';
import { GitHubAPIClient } from './github-api-client.js';
import { BookmarkletUI } from './ui.js';

interface IBookmarkletConfig {
  githubToken: string;
  githubRepo: string;
  githubBranch: string;
  folderPath: string;
  commitMessageTemplate: string;
  captureOptions: Partial<IBookmarkletCaptureOptions>;
  uiTheme: 'light' | 'dark' | 'auto';
  autoSave: boolean;
  showPreview: boolean;
}

interface IBookmarkletContext {
  config: IBookmarkletConfig;
  ui: BookmarkletUI;
  capture: BookmarkletContentCapture;
  github: GitHubAPIClient;
  isActive: boolean;
  sessionId: string;
}

/**
 * Main bookmarklet runtime class
 * Coordinates content capture, user interface, and GitHub integration
 */
export class BookmarkletRuntime {
  private _context: IBookmarkletContext | null = null;
  private _initialized: boolean = false;

  /**
   * Initialize the bookmarklet runtime
   */
  async initialize(config: Partial<IBookmarkletConfig> = {}): Promise<void> {
    if (this._initialized) {
      console.warn('Bookmarklet already initialized');
      return;
    }

    try {
      // Load configuration from localStorage and merge with provided config
      const storedConfig = this.loadStoredConfig();
      const finalConfig = this.mergeConfig(storedConfig, config);

      // Validate required configuration
      if (!finalConfig.githubToken || !finalConfig.githubRepo) {
        throw new Error('GitHub token and repository are required');
      }

      // Initialize components
      const ui = new BookmarkletUI({
        theme: finalConfig.uiTheme,
        showPreview: finalConfig.showPreview,
      });

      const capture = new BookmarkletContentCapture(finalConfig.captureOptions);

      const github = new GitHubAPIClient({
        token: finalConfig.githubToken,
        repository: finalConfig.githubRepo,
        branch: finalConfig.githubBranch,
      });

      // Create context
      this._context = {
        config: finalConfig,
        ui,
        capture,
        github,
        isActive: false,
        sessionId: this.generateSessionId(),
      };

      // Initialize UI
      await this._context.ui.initialize();

      this._initialized = true;
      console.log('PrismWeave bookmarklet initialized successfully');
    } catch (error) {
      console.error('Failed to initialize bookmarklet:', error);
      throw error;
    }
  }

  /**
   * Execute the bookmarklet - capture and process current page
   */
  async execute(): Promise<void> {
    if (!this._initialized || !this._context) {
      throw new Error('Bookmarklet not initialized');
    }

    if (this._context.isActive) {
      console.warn('Bookmarklet already active');
      return;
    }

    try {
      this._context.isActive = true;
      await this.runCaptureWorkflow();
    } catch (error) {
      console.error('Bookmarklet execution failed:', error);
      await this._context.ui.showError(
        error instanceof Error ? error.message : 'Unknown error occurred'
      );
    } finally {
      this._context.isActive = false;
    }
  }

  /**
   * Cleanup and shutdown the bookmarklet
   */
  async shutdown(): Promise<void> {
    if (!this._context) {
      return;
    }

    try {
      await this._context.ui.cleanup();
      this._context.isActive = false;
      this._context = null;
      this._initialized = false;
      console.log('PrismWeave bookmarklet shutdown completed');
    } catch (error) {
      console.error('Error during bookmarklet shutdown:', error);
    }
  }

  /**
   * Update bookmarklet configuration
   */
  async updateConfig(updates: Partial<IBookmarkletConfig>): Promise<void> {
    if (!this._context) {
      throw new Error('Bookmarklet not initialized');
    }

    // Merge with existing config
    this._context.config = this.mergeConfig(this._context.config, updates);

    // Save to localStorage
    this.saveConfig(this._context.config);

    // Update components if needed
    if (updates.captureOptions) {
      this._context.capture = new BookmarkletContentCapture(this._context.config.captureOptions);
    }

    if (updates.githubToken || updates.githubRepo || updates.githubBranch) {
      this._context.github = new GitHubAPIClient({
        token: this._context.config.githubToken,
        repository: this._context.config.githubRepo,
        branch: this._context.config.githubBranch,
      });
    }

    if (updates.uiTheme) {
      await this._context.ui.updateTheme(updates.uiTheme);
    }

    console.log('Bookmarklet configuration updated');
  }

  /**
   * Get current bookmarklet status
   */
  getStatus(): {
    initialized: boolean;
    active: boolean;
    sessionId?: string;
    config?: Partial<IBookmarkletConfig>;
  } {
    return {
      initialized: this._initialized,
      active: this._context?.isActive || false,
      ...(this._context?.sessionId && { sessionId: this._context.sessionId }),
      ...(this._context && {
        config: {
          githubRepo: this._context.config.githubRepo,
          githubBranch: this._context.config.githubBranch,
          folderPath: this._context.config.folderPath,
          uiTheme: this._context.config.uiTheme,
          autoSave: this._context.config.autoSave,
          showPreview: this._context.config.showPreview,
        },
      }),
    };
  }

  // Private methods

  private async runCaptureWorkflow(): Promise<void> {
    const { ui, capture, github, config } = this._context!;

    // Show initial UI
    await ui.show();
    await ui.showProgress('Analyzing page...', 0);

    try {
      // Step 1: Test page quality
      const quality = capture.getPageQuality();
      await ui.showProgress('Analyzing page...', 20);

      if (quality.score < 30) {
        const proceed = await ui.showConfirm(
          'Low Quality Content',
          `This page has a low quality score (${quality.score}/100). It may not capture well. Continue anyway?`
        );
        if (!proceed) {
          await ui.hide();
          return;
        }
      }

      if (quality.hasPaywall) {
        await ui.showWarning('Paywall detected. Content may be incomplete.');
      }

      // Step 2: Capture content
      await ui.showProgress('Capturing content...', 40);
      const captureResult = await capture.captureCurrentPage();

      if (!captureResult.success) {
        throw new Error(captureResult.error || 'Content capture failed');
      }

      await ui.showProgress('Processing content...', 60);

      // Step 3: Show preview if enabled
      if (config.showPreview) {
        const shouldSave = await ui.showPreview(captureResult.data!);
        if (!shouldSave) {
          await ui.hide();
          return;
        }
      }

      // Step 4: Generate file path and name
      const fileName = this.generateFileName(captureResult.data!);
      const filePath = `${config.folderPath}/${fileName}`;

      await ui.showProgress('Saving to GitHub...', 80);

      // Step 5: Commit to GitHub
      const commitMessage = this.generateCommitMessage(
        captureResult.data!,
        config.commitMessageTemplate
      );
      const commitResult = await github.commitFile(
        filePath,
        captureResult.data!.content,
        commitMessage
      );

      if (!commitResult.success) {
        throw new Error(commitResult.error || 'Failed to save to GitHub');
      }

      // Step 6: Show success
      await ui.showProgress('Complete!', 100);
      await ui.showSuccess(
        'Content Saved',
        `Successfully saved to ${config.githubRepo}/${filePath}`,
        commitResult.data?.html_url || ''
      );

      // Auto-hide after success
      setTimeout(async () => {
        await ui.hide();
      }, 3000);
    } catch (error) {
      console.error('Capture workflow failed:', error);
      throw error;
    }
  }

  private loadStoredConfig(): Partial<IBookmarkletConfig> {
    try {
      const stored = localStorage.getItem('prismweave-bookmarklet-config');
      return stored ? JSON.parse(stored) : {};
    } catch (error) {
      console.warn('Failed to load stored config:', error);
      return {};
    }
  }

  private saveConfig(config: IBookmarkletConfig): void {
    try {
      // Don't store the GitHub token for security
      const { githubToken, ...configToStore } = config;
      localStorage.setItem('prismweave-bookmarklet-config', JSON.stringify(configToStore));
    } catch (error) {
      console.warn('Failed to save config:', error);
    }
  }

  private mergeConfig(
    base: Partial<IBookmarkletConfig>,
    updates: Partial<IBookmarkletConfig>
  ): IBookmarkletConfig {
    const defaults: IBookmarkletConfig = {
      githubToken: '',
      githubRepo: '',
      githubBranch: 'main',
      folderPath: 'documents',
      commitMessageTemplate: 'Add captured content: {title}',
      captureOptions: {
        includeImages: true,
        includeLinks: true,
        cleanHtml: true,
        generateFrontmatter: true,
        includeMetadata: true,
      },
      uiTheme: 'auto',
      autoSave: false,
      showPreview: true,
    };

    return {
      ...defaults,
      ...base,
      ...updates,
      captureOptions: {
        ...defaults.captureOptions,
        ...base.captureOptions,
        ...updates.captureOptions,
      },
    };
  }

  private generateFileName(content: { title: string; url: string; extractedAt: string }): string {
    // Extract date from extractedAt
    const date = new Date(content.extractedAt);
    const dateStr = date.toISOString().split('T')[0]; // YYYY-MM-DD format

    // Clean title for filename
    const cleanTitle = content.title
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '')
      .substring(0, 50); // Limit length

    // Extract domain for context
    const domain = new URL(content.url).hostname.replace('www.', '');

    return `${dateStr}-${domain}-${cleanTitle}.md`;
  }

  private generateCommitMessage(content: { title: string; url: string }, template: string): string {
    return template
      .replace('{title}', content.title)
      .replace('{url}', content.url)
      .replace('{domain}', new URL(content.url).hostname)
      .replace('{date}', new Date().toISOString().split('T')[0]);
  }

  private generateSessionId(): string {
    return `bookmarklet-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}

// Global instance for bookmarklet use
let globalBookmarkletRuntime: BookmarkletRuntime | null = null;

/**
 * Initialize global bookmarklet instance
 */
export async function initializeBookmarklet(
  config?: Partial<IBookmarkletConfig>
): Promise<BookmarkletRuntime> {
  if (!globalBookmarkletRuntime) {
    globalBookmarkletRuntime = new BookmarkletRuntime();
  }

  await globalBookmarkletRuntime.initialize(config);
  return globalBookmarkletRuntime;
}

/**
 * Execute global bookmarklet instance
 */
export async function executeBookmarklet(): Promise<void> {
  if (!globalBookmarkletRuntime) {
    throw new Error('Bookmarklet not initialized. Call initializeBookmarklet() first.');
  }

  await globalBookmarkletRuntime.execute();
}

/**
 * Cleanup global bookmarklet instance
 */
export async function shutdownBookmarklet(): Promise<void> {
  if (globalBookmarkletRuntime) {
    await globalBookmarkletRuntime.shutdown();
    globalBookmarkletRuntime = null;
  }
}

/**
 * Quick bookmarklet execution with minimal setup
 * For use in generated bookmarklet code
 */
export async function quickExecute(config: {
  githubToken: string;
  githubRepo: string;
  folderPath?: string;
}): Promise<void> {
  try {
    const runtime = await initializeBookmarklet({
      githubToken: config.githubToken,
      githubRepo: config.githubRepo,
      folderPath: config.folderPath || 'documents',
      autoSave: true,
      showPreview: false, // Skip preview for quick execution
    });

    await runtime.execute();
  } catch (error) {
    console.error('Quick bookmarklet execution failed:', error);

    // Show simple error if UI is not available
    alert(
      `PrismWeave Bookmarklet Error: ${error instanceof Error ? error.message : 'Unknown error'}`
    );
  }
}

// Expose to global scope for bookmarklet access
if (typeof window !== 'undefined') {
  (window as any).PrismWeaveBookmarklet = {
    initializeBookmarklet,
    executeBookmarklet,
    shutdownBookmarklet,
    quickExecute,
    BookmarkletRuntime,
  };
}
