// Enhanced Bookmarklet Runtime with Improved User Experience
// Generated by Copilot for PrismWeave project
// Compatible with existing BookmarkletUI and interfaces

import {
  BookmarkletContentCapture,
  IBookmarkletCaptureResult,
} from '../utils/bookmarklet-content-capture';
import { GitHubAPIClient, IGitHubAPIConfig } from './github-api-client';
import { BookmarkletUI } from './ui';

interface IEnhancedBookmarkletConfig {
  githubToken: string;
  githubRepo: string;
  githubBranch: string;
  folderPath: string;
  autoCommit: boolean;
  includeImages: boolean;
  includeLinks: boolean;
  cleanHtml: boolean;
  showPreview: boolean;
  quickMode: boolean; // New: Skip configuration dialog if already configured
  smartFilenames: boolean; // New: Generate smarter filenames
  notifications: boolean; // New: Show browser notifications
  analytics: boolean; // New: Track usage analytics
}

interface IEnhancedBookmarkletState {
  isProcessing: boolean;
  lastCapture?: IBookmarkletCaptureResult;
  captureCount: number;
  errorCount: number;
  startTime: number;
}

interface IPageQuality {
  score: number;
  confidence: 'high' | 'medium' | 'low';
  issues: string[];
  recommendations: string[];
}

export class EnhancedBookmarkletRuntime {
  private _config: IEnhancedBookmarkletConfig;
  private _state: IEnhancedBookmarkletState;
  private _ui: BookmarkletUI;
  private _contentCapture: BookmarkletContentCapture;
  private _githubClient!: GitHubAPIClient; // Use definite assignment assertion

  private static readonly CONFIG_KEY = 'prismweave-enhanced-config';
  private static readonly STATE_KEY = 'prismweave-enhanced-state';
  private static readonly ANALYTICS_KEY = 'prismweave-analytics';

  private static readonly DEFAULT_CONFIG: IEnhancedBookmarkletConfig = {
    githubToken: '',
    githubRepo: '',
    githubBranch: 'main',
    folderPath: 'documents',
    autoCommit: true,
    includeImages: true,
    includeLinks: true,
    cleanHtml: true,
    showPreview: false,
    quickMode: true,
    smartFilenames: true,
    notifications: true,
    analytics: true,
  };

  constructor() {
    this._config = this.loadConfig();
    this._state = this.loadState();
    this._ui = new BookmarkletUI({
      theme: this.detectPreferredTheme(),
      position: 'top-right',
      showPreview: this._config.showPreview,
    });
    this._contentCapture = new BookmarkletContentCapture();

    // Initialize GitHub client with current config
    this.updateGitHubClient();

    // Bind methods to preserve context
    this.execute = this.execute.bind(this);
    this.quickExecute = this.quickExecute.bind(this);
  }

  private updateGitHubClient(): void {
    const config: IGitHubAPIConfig = {
      token: this._config.githubToken,
      repository: this._config.githubRepo,
      branch: this._config.githubBranch,
    };
    this._githubClient = new GitHubAPIClient(config);
  }

  // Main execution method with enhanced user experience
  async execute(): Promise<void> {
    try {
      // Prevent multiple executions
      if (this._state.isProcessing) {
        this.showSimpleNotification('PrismWeave is already processing...', 'warning');
        return;
      }

      this._state.isProcessing = true;
      this._state.startTime = Date.now();
      this.saveState();

      // Check if page is suitable for capture - disabled to match browser extension behavior
      const pageQuality = await this.assessPageQuality();
      // Quality warnings disabled - browser extension doesn't show these warnings
      // This keeps behavior consistent between bookmarklet and extension
      // if (pageQuality.confidence === 'low') {
      //   const proceed = await this.showSimpleConfirm(
      //     'Content Quality Warning',
      //     `This page may not capture well. Quality score: ${pageQuality.score}/100\\n\\nIssues:\\n${pageQuality.issues.join('\\n')}\\n\\nDo you want to proceed anyway?`
      //   );
      //   if (!proceed) {
      //     this.cleanup();
      //     return;
      //   }
      // }

      // Configuration check with smart defaults
      if (!this.isConfigured()) {
        if (this._config.quickMode) {
          // Try to use saved credentials from the installation page
          const webConfig = this.loadWebPageConfig();
          if (webConfig && this.validateConfig(webConfig)) {
            this._config = { ...this._config, ...webConfig };
            this.saveConfig();
            this.updateGitHubClient();
          } else {
            await this.showConfigDialog();
            if (!this.isConfigured()) {
              this.cleanup();
              return;
            }
          }
        } else {
          await this.showConfigDialog();
          if (!this.isConfigured()) {
            this.cleanup();
            return;
          }
        }
      }

      // Show enhanced progress UI
      await this._ui.show();
      this._ui.showProgress('Initializing capture...', 0);

      // Execute capture workflow
      await this.runEnhancedCaptureWorkflow();
    } catch (error) {
      console.error('PrismWeave execution failed:', error);
      this._state.errorCount++;
      this.saveState();

      // Enhanced error handling with actionable messages
      const errorMessage = this.getActionableErrorMessage(error as Error);
      this._ui.showError(errorMessage);

      // Track error for analytics
      if (this._config.analytics) {
        this.trackError(error as Error);
      }
    } finally {
      this.cleanup();
    }
  }

  // Quick execution mode for power users
  async quickExecute(): Promise<void> {
    if (!this.isConfigured()) {
      await this.execute(); // Fall back to full execution
      return;
    }

    try {
      this._state.isProcessing = true;

      // Minimal UI for quick mode
      await this._ui.show();
      this._ui.showProgress('Quick capture...', 50);

      const result = await this._contentCapture.captureCurrentPage();
      if (!result.success || !result.data) {
        throw new Error('Content capture failed');
      }

      await this.saveToGitHub(result.data);

      this._state.captureCount++;
      this._state.lastCapture = result;
      this.saveState();

      this._ui.showSuccess('Content Captured', `Saved: ${result.data.title}`);

      // Show browser notification if enabled
      if (this._config.notifications && 'Notification' in window) {
        this.showBrowserNotification('Content Captured', result.data.title);
      }
    } catch (error) {
      console.error('Quick capture failed:', error);
      this._ui.showError(this.getActionableErrorMessage(error as Error));
    } finally {
      this.cleanup();
    }
  }

  // Enhanced capture workflow with better progress tracking
  private async runEnhancedCaptureWorkflow(): Promise<void> {
    // Step 1: Analyze page (10%)
    this._ui.showProgress('Analyzing page structure...', 10);
    const pageQuality = await this.assessPageQuality();

    // Step 2: Extract content (30%)
    this._ui.showProgress('Extracting main content...', 30);
    console.log('[EnhancedBookmarkletRuntime] Starting content capture...');
    const result = await this._contentCapture.captureCurrentPage();
    console.log('[EnhancedBookmarkletRuntime] Content capture completed:', {
      success: result.success,
      hasData: !!result.data,
      error: result.error,
      warnings: result.warnings?.length || 0,
    });

    if (!result.success || !result.data) {
      const errorMsg = result.error || 'Unknown capture error';
      console.error('[EnhancedBookmarkletRuntime] Content capture failed:', errorMsg);
      throw new Error(`Content extraction failed: ${errorMsg}`);
    }

    // Step 3: Enhance document (50%)
    this._ui.showProgress('Processing content...', 50);
    const enhancedData = await this.enhanceDocument(result.data, pageQuality);

    // Step 4: Generate filename (60%)
    this._ui.showProgress('Generating filename...', 60);
    const filename = this.generateSmartFilename(enhancedData);

    // Step 5: Preview (if enabled) (70%)
    if (this._config.showPreview) {
      this._ui.showProgress('Preparing preview...', 70);
      const previewData = this.convertToPreview(enhancedData);
      const proceed = await this._ui.showPreview(previewData);
      if (!proceed) {
        this.cleanup();
        return;
      }
    }

    // Step 6: Save to GitHub (90%)
    this._ui.showProgress('Saving to GitHub...', 90);
    // Update the data with enhanced content
    const updatedResult = { ...result, data: enhancedData };
    await this.saveToGitHub(enhancedData, filename);

    // Step 7: Complete (100%)
    this._ui.showProgress('Complete!', 100);

    // Update state
    this._state.captureCount++;
    this._state.lastCapture = updatedResult;
    this.saveState();

    // Show success with enhanced information
    const repoUrl = `https://github.com/${this._config.githubRepo}/blob/${this._config.githubBranch}/${this._config.folderPath}/${filename}`;
    this._ui.showSuccess(
      'Content Captured Successfully',
      `${enhancedData.title}\n\nWords: ${enhancedData.wordCount} | Reading time: ${enhancedData.readingTime}min | Quality: ${pageQuality.confidence}`,
      repoUrl
    );

    // Show browser notification
    if (this._config.notifications && 'Notification' in window) {
      this.showBrowserNotification('Content Captured', enhancedData.title, repoUrl);
    }

    // Track successful capture
    if (this._config.analytics) {
      this.trackCapture(enhancedData, pageQuality);
    }
  }

  // Convert capture data to preview format
  private convertToPreview(data: any) {
    return {
      title: data.title,
      url: data.url,
      markdown: data.markdown,
      frontmatter: data.frontmatter,
      content: data.content,
      wordCount: data.wordCount,
      readingTime: data.readingTime,
      extractedAt: data.extractedAt,
      images: data.images || [],
      metadata: data.metadata || {},
    };
  }

  // Assess page quality before capture
  private async assessPageQuality(): Promise<IPageQuality> {
    const issues: string[] = [];
    const recommendations: string[] = [];
    let score = 100;

    // Check content length
    const textContent = document.body.textContent || '';
    const wordCount = textContent.trim().split(/\\s+/).length;

    if (wordCount < 50) {
      score -= 40;
      issues.push('Very short content (less than 50 words)');
      recommendations.push('Consider capturing multiple pages or waiting for content to load');
    } else if (wordCount < 200) {
      score -= 20;
      issues.push('Short content (less than 200 words)');
    }

    // Check for main content elements - more lenient detection
    const mainElements = document.querySelectorAll(
      'article, main, [role="main"], .content, .post, .entry, .blog-post, .article-content'
    );
    if (mainElements.length === 0) {
      // Additional check for common blog patterns
      const blogElements = document.querySelectorAll('h1, h2, .title, .headline, [class*="post"]');
      if (blogElements.length === 0) {
        score -= 15;
        issues.push('No clear main content structure detected');
        recommendations.push('This page may not have well-structured content');
      }
    }

    // More reasonable content ratio check - only flag severely markup-heavy pages
    const contentRatio = textContent.length / document.body.innerHTML.length;
    if (contentRatio < 0.05) {
      // Changed from 0.1 to 0.05 - much more lenient
      score -= 20;
      issues.push('Very high markup-to-content ratio');
      recommendations.push('Try capturing from the main article or content section');
    }

    // Less aggressive dynamic content detection
    const dynamicElements = document.querySelectorAll('[data-react-class], [data-vue], .ng-scope');
    if (dynamicElements.length > 5) {
      // Only penalize if many dynamic elements
      score -= 5; // Reduced penalty from 10 to 5
      issues.push('Heavy dynamic content detected - may need time to load');
      recommendations.push('Wait for content to fully load before capturing');
    }

    // More specific paywall detection - avoid false positives
    const paywallIndicators = [
      '.paywall',
      '.login-required',
      '.subscription-required',
      '.premium-content',
      '[class*="paywall"]',
    ];
    const hasPaywallElements = paywallIndicators.some(
      selector => document.querySelector(selector) !== null
    );

    // Only check for paywall text if we don't have substantial content
    const hasPaywallText =
      wordCount < 300 &&
      (document.body.textContent?.toLowerCase().includes('subscribe to continue reading') ||
        document.body.textContent?.toLowerCase().includes('sign in to read more') ||
        document.body.textContent?.toLowerCase().includes('premium subscription required'));

    if (hasPaywallElements || hasPaywallText) {
      score -= 15;
      issues.push('Possible paywall or login requirement detected');
      recommendations.push('Ensure you have access to the full content');
    }

    // More reasonable confidence thresholds
    let confidence: 'high' | 'medium' | 'low';
    if (score >= 70) {
      // Lowered from 80
      confidence = 'high';
    } else if (score >= 50) {
      // Lowered from 60
      confidence = 'medium';
    } else {
      confidence = 'low';
    }

    return { score, confidence, issues, recommendations };
  }

  // Enhanced document processing
  private async enhanceDocument(data: any, pageQuality: IPageQuality): Promise<any> {
    // Add quality assessment to metadata
    const enhancedMetadata = {
      ...data.metadata,
      captureQuality: pageQuality.confidence,
      qualityScore: pageQuality.score,
      captureMethod: 'hybrid-bookmarklet',
      captureVersion: '2.0.0',
      userAgent: navigator.userAgent,
      captureTime: Date.now(),
      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    };

    // Smart content cleaning based on quality assessment
    let cleanedContent = data.content;
    if (pageQuality.confidence === 'low') {
      // Apply more aggressive cleaning for low-quality pages
      cleanedContent = this.aggressiveContentClean(cleanedContent);
    }

    // Enhanced markdown with better formatting
    const enhancedMarkdown = this.enhanceMarkdown(data.markdown, pageQuality);

    return {
      ...data,
      content: cleanedContent,
      markdown: enhancedMarkdown,
      metadata: enhancedMetadata,
    };
  }

  // Generate smart filenames with better collision handling
  private generateSmartFilename(data: any): string {
    if (!this._config.smartFilenames) {
      return this.generateBasicFilename(data.title);
    }

    const date = new Date().toISOString().split('T')[0];
    const domain = new URL(data.url).hostname.replace(/^www\\./, '');

    // Smart title processing
    let title = data.title
      .toLowerCase()
      .replace(/[^\\w\\s-]/g, '') // Remove special characters
      .replace(/\\s+/g, '-') // Replace spaces with hyphens
      .replace(/-+/g, '-') // Collapse multiple hyphens
      .replace(/^-+|-+$/g, '') // Remove leading/trailing hyphens
      .substring(0, 50); // Limit length

    // Add document type hint if detectable
    const typeHint = this.detectContentType(data);
    if (typeHint) {
      title = `${typeHint}-${title}`;
    }

    // Handle potential collisions with timestamp
    const timestamp = new Date().toTimeString().slice(0, 5).replace(':', '');

    return `${date}-${domain}-${title}-${timestamp}.md`;
  }

  // Detect content type for better organization
  private detectContentType(data: any): string | null {
    const title = data.title.toLowerCase();
    const content = data.content.toLowerCase();
    const url = data.url.toLowerCase();

    if (
      url.includes('/blog/') ||
      url.includes('/post/') ||
      content.includes('published') ||
      content.includes('author')
    ) {
      return 'blog';
    }
    if (
      url.includes('/docs/') ||
      url.includes('/documentation/') ||
      title.includes('documentation')
    ) {
      return 'docs';
    }
    if (url.includes('/news/') || url.includes('/article/') || content.includes('news')) {
      return 'news';
    }
    if (url.includes('/tutorial/') || title.includes('tutorial') || title.includes('how to')) {
      return 'tutorial';
    }
    if (url.includes('/reference/') || title.includes('reference') || title.includes('api')) {
      return 'reference';
    }
    if (
      url.includes('/research/') ||
      content.includes('abstract') ||
      content.includes('methodology')
    ) {
      return 'research';
    }

    return null;
  }

  // Enhanced error handling with actionable messages
  private getActionableErrorMessage(error: Error): string {
    const message = error.message.toLowerCase();

    if (message.includes('network') || message.includes('fetch')) {
      return 'Network error: Please check your internet connection and try again.';
    }
    if (
      message.includes('token') ||
      message.includes('authentication') ||
      message.includes('401')
    ) {
      return 'GitHub authentication failed: Please check your Personal Access Token in the configuration.';
    }
    if (message.includes('repository') || message.includes('404')) {
      return 'Repository not found: Please verify the repository name (owner/repo format) and your access permissions.';
    }
    if (message.includes('rate limit') || message.includes('403')) {
      return 'GitHub API rate limit exceeded: Please wait a few minutes before trying again.';
    }
    if (message.includes('content') || message.includes('extraction')) {
      return 'Content extraction failed: This page may not be suitable for capture. Try a different page or wait for content to load.';
    }
    if (message.includes('file size') || message.includes('too large')) {
      return 'Content too large: The captured content exceeds GitHub file size limits. Try capturing a shorter article.';
    }

    return `Capture failed: ${error.message}. Please try again or check the troubleshooting guide.`;
  }

  // Simple notification fallback
  private showSimpleNotification(
    message: string,
    type: 'info' | 'warning' | 'error' = 'info'
  ): void {
    console.log(`[PrismWeave ${type.toUpperCase()}] ${message}`);
    // Could show a simple alert or console message
    if (type === 'warning' || type === 'error') {
      alert(`PrismWeave: ${message}`);
    }
  }

  // Simple confirmation dialog
  private async showSimpleConfirm(title: string, message: string): Promise<boolean> {
    return confirm(`${title}\\n\\n${message}`);
  }

  // Browser notification support
  private async showBrowserNotification(title: string, body: string, url?: string): Promise<void> {
    if (!('Notification' in window)) return;

    // Request permission if needed
    if (Notification.permission === 'default') {
      await Notification.requestPermission();
    }

    if (Notification.permission === 'granted') {
      const notification = new Notification(title, {
        body,
        icon: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iOCIgZmlsbD0iIzI1NjNlYiIvPgo8cGF0aCBkPSJNOCAxMmg0djhIOHptNiAwaDR2OGgtNHptNiAwaDR2OGgtNHoiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPgo=',
        tag: 'prismweave-capture',
        requireInteraction: false,
      });

      // Auto-close after 5 seconds
      setTimeout(() => notification.close(), 5000);

      // Handle click to open GitHub
      if (url) {
        notification.onclick = () => window.open(url, '_blank');
      }
    }
  }

  // Analytics tracking (privacy-conscious)
  private trackCapture(data: any, quality: IPageQuality): void {
    try {
      const analytics = this.loadAnalytics();
      analytics.totalCaptures++;
      analytics.lastCapture = Date.now();
      analytics.domains = analytics.domains || {};

      const domain = new URL(data.url).hostname;
      analytics.domains[domain] = (analytics.domains[domain] || 0) + 1;

      analytics.qualityStats = analytics.qualityStats || { high: 0, medium: 0, low: 0 };
      analytics.qualityStats[quality.confidence]++;

      // Store only aggregated data, no personal content
      localStorage.setItem(EnhancedBookmarkletRuntime.ANALYTICS_KEY, JSON.stringify(analytics));
    } catch (error) {
      console.warn('Analytics tracking failed:', error);
    }
  }

  private trackError(error: Error): void {
    try {
      const analytics = this.loadAnalytics();
      analytics.errorCount = (analytics.errorCount || 0) + 1;
      analytics.lastError = {
        message: error.message,
        timestamp: Date.now(),
        url: window.location.href,
      };
      localStorage.setItem(EnhancedBookmarkletRuntime.ANALYTICS_KEY, JSON.stringify(analytics));
    } catch (trackingError) {
      console.warn('Error tracking failed:', trackingError);
    }
  }

  // Configuration management
  private loadConfig(): IEnhancedBookmarkletConfig {
    try {
      const stored = localStorage.getItem(EnhancedBookmarkletRuntime.CONFIG_KEY);
      if (stored) {
        const parsed = JSON.parse(stored);
        return { ...EnhancedBookmarkletRuntime.DEFAULT_CONFIG, ...parsed };
      }
    } catch (error) {
      console.warn('Failed to load stored config:', error);
    }
    return { ...EnhancedBookmarkletRuntime.DEFAULT_CONFIG };
  }

  private saveConfig(config: IEnhancedBookmarkletConfig = this._config): void {
    try {
      localStorage.setItem(EnhancedBookmarkletRuntime.CONFIG_KEY, JSON.stringify(config));
      this._config = config;
    } catch (error) {
      console.error('Failed to save config:', error);
    }
  }

  // Load configuration from web installation page
  private loadWebPageConfig(): Partial<IEnhancedBookmarkletConfig> | null {
    try {
      const webConfig = localStorage.getItem('prismweave-config');
      return webConfig ? JSON.parse(webConfig) : null;
    } catch (error) {
      return null;
    }
  }

  // State management
  private loadState(): IEnhancedBookmarkletState {
    try {
      const stored = localStorage.getItem(EnhancedBookmarkletRuntime.STATE_KEY);
      if (stored) {
        const parsed = JSON.parse(stored);
        return {
          isProcessing: false, // Always reset processing state on load
          captureCount: parsed.captureCount || 0,
          errorCount: parsed.errorCount || 0,
          lastCapture: parsed.lastCapture,
          startTime: 0,
        };
      }
    } catch (error) {
      console.warn('Failed to load state:', error);
    }
    return {
      isProcessing: false,
      captureCount: 0,
      errorCount: 0,
      startTime: 0,
    };
  }

  private saveState(): void {
    try {
      localStorage.setItem(EnhancedBookmarkletRuntime.STATE_KEY, JSON.stringify(this._state));
    } catch (error) {
      console.error('Failed to save state:', error);
    }
  }

  private loadAnalytics() {
    try {
      const stored = localStorage.getItem(EnhancedBookmarkletRuntime.ANALYTICS_KEY);
      return stored ? JSON.parse(stored) : { totalCaptures: 0, errorCount: 0 };
    } catch (error) {
      return { totalCaptures: 0, errorCount: 0 };
    }
  }

  // Utility methods
  private isConfigured(): boolean {
    return !!(this._config.githubToken && this._config.githubRepo);
  }

  private validateConfig(config: any): boolean {
    return !!(
      config.githubToken &&
      config.githubRepo &&
      typeof config.githubToken === 'string' &&
      typeof config.githubRepo === 'string' &&
      config.githubRepo.includes('/')
    );
  }

  private detectPreferredTheme(): 'light' | 'dark' | 'auto' {
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      return 'dark';
    }
    return 'light';
  }

  private generateBasicFilename(title: string): string {
    const date = new Date().toISOString().split('T')[0];
    const domain = window.location.hostname.replace(/^www\\./, '');
    const cleanTitle = title
      .toLowerCase()
      .replace(/[^a-z0-9\\s]/g, '')
      .replace(/\\s+/g, '-')
      .substring(0, 50);

    return `${date}-${domain}-${cleanTitle}.md`;
  }

  private aggressiveContentClean(content: string): string {
    // More aggressive cleaning for low-quality pages
    return content
      .replace(/\\s+/g, ' ') // Normalize whitespace
      .replace(/\\n{3,}/g, '\\n\\n') // Limit consecutive newlines
      .trim();
  }

  private enhanceMarkdown(markdown: string, quality: IPageQuality): string {
    // Add quality metadata comment
    const qualityComment = `<!-- Captured with PrismWeave Enhanced - Quality: ${quality.confidence} (${quality.score}/100) -->\\n\\n`;

    // Improve markdown formatting
    let enhanced = markdown
      .replace(/\\n{3,}/g, '\\n\\n') // Normalize paragraph spacing
      .replace(/^\\s+/gm, '') // Remove leading whitespace
      .trim();

    return qualityComment + enhanced;
  }

  private async saveToGitHub(data: any, filename?: string): Promise<void> {
    const filePath = `${this._config.folderPath}/${filename || this.generateBasicFilename(data.title)}`;
    const commitMessage = `Add: ${data.title}`;

    const result = await this._githubClient.commitFile(filePath, data.markdown, commitMessage);

    if (!result.success) {
      throw new Error(result.error || 'Failed to save to GitHub');
    }
  }

  private async showConfigDialog(): Promise<void> {
    // Simple configuration dialog using prompts
    const token = prompt('Enter your GitHub Personal Access Token:');
    if (!token) {
      throw new Error('GitHub token is required');
    }

    const repo = prompt('Enter your GitHub repository (owner/repo format):');
    if (!repo || !repo.includes('/')) {
      throw new Error('Valid GitHub repository is required');
    }

    this._config.githubToken = token;
    this._config.githubRepo = repo;
    this.saveConfig();
    this.updateGitHubClient();
  }

  private cleanup(): void {
    this._state.isProcessing = false;
    this.saveState();

    // Hide UI after a delay
    setTimeout(() => {
      this._ui.hide();
    }, 3000);
  }
}

// Global execution function for the bookmarklet
function executeEnhancedBookmarklet(): void {
  // Prevent multiple instances
  if ((window as any).PrismWeaveActive) {
    console.log('PrismWeave already active');
    return;
  }
  (window as any).PrismWeaveActive = true;

  try {
    const runtime = new EnhancedBookmarkletRuntime();

    // Check for quick mode (Shift+Click or double-click)
    const isQuickMode =
      (window as any).event?.shiftKey ||
      Date.now() - ((window as any).lastPrismWeaveClick || 0) < 500;

    if (isQuickMode) {
      runtime.quickExecute().finally(() => {
        (window as any).PrismWeaveActive = false;
      });
    } else {
      runtime.execute().finally(() => {
        (window as any).PrismWeaveActive = false;
      });
    }

    (window as any).lastPrismWeaveClick = Date.now();
  } catch (error) {
    console.error('Failed to initialize PrismWeave:', error);
    alert('PrismWeave failed to initialize. Please check the console for details.');
    (window as any).PrismWeaveActive = false;
  }
}

// Make available globally for the bookmarklet
(window as any).executeEnhancedBookmarklet = executeEnhancedBookmarklet;

// Also expose as PrismWeaveEnhanced for the hybrid loader compatibility
(window as any).PrismWeaveEnhanced = {
  execute: executeEnhancedBookmarklet,
};

// Debug logging to verify API is properly set
console.log('PrismWeave Runtime APIs initialized:', {
  executeEnhancedBookmarklet: typeof (window as any).executeEnhancedBookmarklet,
  PrismWeaveEnhanced: typeof (window as any).PrismWeaveEnhanced,
  PrismWeaveEnhanced_execute: typeof (window as any).PrismWeaveEnhanced?.execute,
  timestamp: new Date().toISOString(),
});

// Default export for esbuild IIFE format compatibility
export default {
  execute: executeEnhancedBookmarklet,
  EnhancedBookmarkletRuntime,
};
