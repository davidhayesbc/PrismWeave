// Generated by Copilot
// Build script for PrismWeave injectable bundles
// Compiles TypeScript and creates self-contained bundles for bookmarklet injection

const esbuild = require('esbuild');
const fs = require('fs');
const path = require('path');

async function buildInjectables() {
  const srcDir = path.join(__dirname, '..', 'src');
  const distDir = path.join(__dirname, '..', 'dist', 'injectable');

  // Ensure dist directory exists
  if (!fs.existsSync(distDir)) {
    fs.mkdirSync(distDir, { recursive: true });
  }

  console.log('üî® Building PrismWeave injectable bundles...');

  try {
    // Build individual injectable utilities
    const builds = [
      {
        name: 'content-extractor-injectable',
        entry: path.join(srcDir, 'injectable', 'content-extractor-injectable.ts'),
        output: path.join(distDir, 'content-extractor-injectable.js'),
      },
      {
        name: 'markdown-converter-injectable',
        entry: path.join(srcDir, 'injectable', 'markdown-converter-injectable.ts'),
        output: path.join(distDir, 'markdown-converter-injectable.js'),
      },
      {
        name: 'prismweave-bundle',
        entry: path.join(srcDir, 'injectable', 'prismweave-bundle.ts'),
        output: path.join(distDir, 'prismweave-bundle.js'),
      },
    ];

    for (const build of builds) {
      console.log(`  Building ${build.name}...`);

      await esbuild.build({
        entryPoints: [build.entry],
        bundle: true,
        outfile: build.output,
        format: 'iife', // Immediately Invoked Function Expression for browser injection
        platform: 'browser',
        target: 'es2020',
        minify: false, // Keep readable for debugging
        sourcemap: false,
        globalName: build.name.replace(/-/g, ''), // Remove hyphens for valid JS variable names
        define: {
          'process.env.NODE_ENV': '"production"',
        },
        external: [], // Bundle everything for self-contained injection
        loader: {
          '.ts': 'ts',
        },
        tsconfig: path.join(__dirname, '..', 'tsconfig.json'),
        logLevel: 'warning',
      });

      console.log(`  ‚úÖ ${build.name} built successfully`);
    }

    // Create a combined all-in-one bundle
    console.log('  Building combined bundle...');

    const combinedBundle = `
// PrismWeave Combined Injectable Bundle
// Auto-generated from individual components

${fs.readFileSync(path.join(distDir, 'content-extractor-injectable.js'), 'utf8')}

${fs.readFileSync(path.join(distDir, 'markdown-converter-injectable.js'), 'utf8')}

${fs.readFileSync(path.join(distDir, 'prismweave-bundle.js'), 'utf8')}

// Bundle initialization
if (typeof window !== 'undefined') {
  console.log('üöÄ PrismWeave Combined Injectable Bundle loaded');
  console.log('Available: window.prismweaveProcessPage, window.prismweaveExtractPageContent, window.prismweaveConvertHtmlToMarkdown');
}
`;

    fs.writeFileSync(path.join(distDir, 'prismweave-combined.js'), combinedBundle);
    console.log('  ‚úÖ Combined bundle created');

    // Create minified versions
    console.log('  Creating minified versions...');

    for (const build of builds) {
      const minifiedOutput = build.output.replace('.js', '.min.js');

      await esbuild.build({
        entryPoints: [build.entry],
        bundle: true,
        outfile: minifiedOutput,
        format: 'iife',
        platform: 'browser',
        target: 'es2020',
        minify: true,
        sourcemap: false,
        globalName: build.name.replace(/-/g, ''),
        define: {
          'process.env.NODE_ENV': '"production"',
        },
        external: [],
        loader: {
          '.ts': 'ts',
        },
        tsconfig: path.join(__dirname, '..', 'tsconfig.json'),
        logLevel: 'error',
      });
    }

    // Create minified combined bundle
    await esbuild.build({
      entryPoints: [path.join(srcDir, 'injectable', 'prismweave-bundle.ts')],
      bundle: true,
      outfile: path.join(distDir, 'prismweave-combined.min.js'),
      format: 'iife',
      platform: 'browser',
      target: 'es2020',
      minify: true,
      sourcemap: false,
      globalName: 'PrismWeaveCombined',
      define: {
        'process.env.NODE_ENV': '"production"',
      },
      external: [],
      loader: {
        '.ts': 'ts',
      },
      tsconfig: path.join(__dirname, '..', 'tsconfig.json'),
      logLevel: 'error',
    });

    console.log('  ‚úÖ Minified versions created');

    // Generate file size report
    console.log('\nüìä Injectable Bundle Sizes:');
    const files = fs.readdirSync(distDir);
    for (const file of files.sort()) {
      const filePath = path.join(distDir, file);
      const stats = fs.statSync(filePath);
      const sizeKB = (stats.size / 1024).toFixed(1);
      console.log(`  ${file}: ${sizeKB} KB`);
    }

    // Create usage examples
    const exampleUsage = `
// PrismWeave Injectable Bundle Usage Examples

// 1. Load the bundle via script injection
function loadPrismWeaveBundle() {
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = 'https://your-cdn.com/prismweave-combined.min.js';
    script.onload = () => resolve();
    script.onerror = () => reject(new Error('Failed to load PrismWeave bundle'));
    document.head.appendChild(script);
  });
}

// 2. Use in bookmarklet
javascript:(async function() {
  try {
    // Load the bundle
    await loadPrismWeaveBundle();
    
    // Process current page
    const result = await window.prismweaveProcessPage({
      extraction: {
        includeImages: true,
        includeLinks: true,
        cleanHtml: true
      },
      markdown: {
        generateFrontmatter: true,
        includeMetadata: true
      }
    });
    
    console.log('Extracted content:', result);
    console.log('Full markdown document:');
    console.log(result.fullDocument);
    
    // Copy to clipboard if available
    if (navigator.clipboard) {
      await navigator.clipboard.writeText(result.fullDocument);
      alert('Content copied to clipboard!');
    }
  } catch (error) {
    console.error('PrismWeave processing failed:', error);
    alert('Error: ' + error.message);
  }
})();

// 3. Direct content extraction
javascript:(async function() {
  await loadPrismWeaveBundle();
  const content = await window.prismweaveExtractPageContent();
  console.log('Title:', content.title);
  console.log('Content:', content.content);
})();

// 4. HTML to Markdown conversion
javascript:(async function() {
  await loadPrismWeaveBundle();
  const html = document.querySelector('article, main, .content')?.innerHTML || document.body.innerHTML;
  const result = await window.prismweaveConvertHtmlToMarkdown(html, {
    generateFrontmatter: true
  });
  console.log('Markdown:', result.markdown);
})();
`;

    fs.writeFileSync(path.join(distDir, 'usage-examples.js'), exampleUsage);
    console.log('  ‚úÖ Usage examples created');

    console.log('\nüéâ All injectable bundles built successfully!');
    console.log(`üìÅ Output directory: ${distDir}`);
  } catch (error) {
    console.error('‚ùå Build failed:', error);
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  buildInjectables().catch(console.error);
}

module.exports = { buildInjectables };
