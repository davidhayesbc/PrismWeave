// Generated by Copilot
// Simplified build script for PrismWeave browser extension
// Uses esbuild with IIFE format to eliminate module compatibility issues

const esbuild = require('esbuild');
const fs = require('fs');
const path = require('path');

async function buildExtension() {
  console.log('🚀 Building PrismWeave Browser Extension...');

  const isProduction = process.env.NODE_ENV === 'production';
  console.log(`📦 Build mode: ${isProduction ? 'Production' : 'Development'}`);

  // Clean dist directory
  if (fs.existsSync('./dist')) {
    fs.rmSync('./dist', { recursive: true });
  }
  fs.mkdirSync('./dist', { recursive: true });

  const baseOptions = {
    target: 'es2020',
    platform: 'browser',
    sourcemap: !isProduction, // No sourcemaps in production
    minify: isProduction, // Minify in production
    bundle: true, // Bundle all dependencies
    define: {
      'process.env.NODE_ENV': isProduction ? '"production"' : '"development"',
    },
  };

  try {
    // Build components with appropriate formats for Chrome extension compatibility
    const builds = [
      {
        name: 'Service Worker',
        entryPoints: ['src/background/service-worker.ts'],
        outfile: 'dist/background/service-worker.js',
        format: 'esm', // ES modules for service worker (manifest has "type": "module")
        ...baseOptions,
      },
      {
        name: 'Content Script',
        entryPoints: ['src/content/content-script.ts'],
        outfile: 'dist/content/content-script.js',
        format: 'iife', // IIFE format for content script
        ...baseOptions,
      },
      {
        name: 'Popup',
        entryPoints: ['src/popup/popup.ts'],
        outfile: 'dist/popup/popup.js',
        format: 'iife', // IIFE format for popup scripts
        ...baseOptions,
      },
      {
        name: 'Options',
        entryPoints: ['src/options/options.ts'],
        outfile: 'dist/options/options.js',
        format: 'iife', // IIFE format for options scripts
        ...baseOptions,
      },
    ];

    // Build all components in parallel
    await Promise.all(
      builds.map(async build => {
        console.log(`  📦 Building ${build.name}...`);
        const { name, ...options } = build;
        await esbuild.build(options);
        console.log(`  ✅ ${build.name} completed`);
      })
    );

    // Copy static assets
    await copyStaticAssets();

    console.log('🎉 Build completed successfully!');
  } catch (error) {
    console.error('❌ Build failed:', error);
    process.exit(1);
  }
}

async function copyStaticAssets() {
  console.log('  📁 Copying static assets...');
  const assets = [
    // Manifest
    { src: 'manifest.json', dest: 'dist/manifest.json' },

    // HTML and CSS files
    { src: 'src/popup/popup.html', dest: 'dist/popup/popup.html' },
    { src: 'src/popup/popup.css', dest: 'dist/popup/popup.css' },
    { src: 'src/options/options.html', dest: 'dist/options/options.html' },
    { src: 'src/options/options.css', dest: 'dist/options/options.css' },

    // Icons directory
    { src: 'icons', dest: 'dist/icons', isDirectory: true },

    // Libraries directory (TurndownService, etc.)
    { src: 'src/libs', dest: 'dist/libs', isDirectory: true },
  ];

  for (const asset of assets) {
    const srcPath = asset.src;
    const destPath = asset.dest;

    // Ensure destination directory exists
    const destDir = path.dirname(destPath);
    if (!fs.existsSync(destDir)) {
      fs.mkdirSync(destDir, { recursive: true });
    }

    if (asset.isDirectory) {
      // Copy entire directory
      if (fs.existsSync(srcPath)) {
        fs.cpSync(srcPath, destPath, { recursive: true });
      }
    } else {
      // Copy single file
      if (fs.existsSync(srcPath)) {
        fs.copyFileSync(srcPath, destPath);
      }
    }
  }

  console.log('  ✅ Static assets copied');
}

// Development mode with watch
async function buildDev() {
  console.log('🔄 Starting development build with watch mode...');

  const baseOptions = {
    target: 'es2020',
    platform: 'browser',
    sourcemap: true,
    minify: false,
    bundle: true,
  };

  const contexts = await Promise.all([
    esbuild.context({
      entryPoints: ['src/background/service-worker.ts'],
      outfile: 'dist/background/service-worker.js',
      format: 'esm', // ES modules for service worker
      ...baseOptions,
    }),
    esbuild.context({
      entryPoints: ['src/content/content-script.ts'],
      outfile: 'dist/content/content-script.js',
      format: 'iife', // IIFE for content script
      ...baseOptions,
    }),
    esbuild.context({
      entryPoints: ['src/popup/popup.ts'],
      outfile: 'dist/popup/popup.js',
      format: 'iife', // IIFE for popup
      ...baseOptions,
    }),
    esbuild.context({
      entryPoints: ['src/options/options.ts'],
      outfile: 'dist/options/options.js',
      format: 'iife', // IIFE for options
      ...baseOptions,
    }),
  ]);

  // Watch for changes
  await Promise.all(contexts.map(ctx => ctx.watch()));

  // Copy static assets initially
  await copyStaticAssets();

  console.log('👀 Watching for changes... Press Ctrl+C to stop');

  // Keep the process alive
  process.on('SIGINT', async () => {
    console.log('\n🛑 Shutting down...');
    await Promise.all(contexts.map(ctx => ctx.dispose()));
    process.exit(0);
  });
}

// Check command line arguments
const args = process.argv.slice(2);
if (args.includes('--watch') || args.includes('-w')) {
  buildDev().catch(console.error);
} else {
  buildExtension().catch(console.error);
}
