#!/usr/bin/env node

// Cleanup script for PrismWeave bookmarklet builds
// Generated by Copilot for PrismWeave project
// Removes old build artifacts and organizes the directory

const fs = require('fs');
const path = require('path');

class BookmarkletCleaner {
  constructor() {
    this.distDir = path.join(__dirname, '../dist/bookmarklet');
    this.filesToRemove = [
      // Old bookmarklet files
      'bookmarklet.js',
      'bookmarklet-enhanced.js',
      'bookmarklet-encoded.txt',
      'bookmarklet-enhanced-encoded.txt',
      'bookmarklet-enhanced-url.txt',
      'bookmarklet-url.txt',
      'runtime.js',
      'runtime.js.map',
      'install.html',
      'install-simple.html',
      'size-report.json',

      // Old directories (will be removed if empty)
      'bookmarklet',
      'templates',
      'types',
      'utils',
    ];
    this.filesToKeep = [
      // Keep the new hybrid system files
      'hybrid-loader.js',
      'enhanced-runtime.js',
      'enhanced-v2.0.0.js',
      'install-hybrid.html',
      'README-hybrid.md',
      'build-analytics.json',
    ];
  }

  async clean() {
    console.log('üßπ Cleaning up old bookmarklet files...');

    if (!fs.existsSync(this.distDir)) {
      console.log('üìÅ Dist directory does not exist, nothing to clean');
      return;
    }

    let removedCount = 0;
    let keptCount = 0;

    // Remove old files
    for (const fileName of this.filesToRemove) {
      const filePath = path.join(this.distDir, fileName);

      if (fs.existsSync(filePath)) {
        try {
          const stats = fs.statSync(filePath);

          if (stats.isDirectory()) {
            // Check if directory is empty before removing
            const dirContents = fs.readdirSync(filePath);
            if (dirContents.length === 0) {
              fs.rmdirSync(filePath);
              console.log(`üóÇÔ∏è  Removed empty directory: ${fileName}`);
              removedCount++;
            } else {
              console.log(`üìÅ Kept non-empty directory: ${fileName} (${dirContents.length} items)`);
            }
          } else {
            fs.unlinkSync(filePath);
            console.log(`üóëÔ∏è  Removed file: ${fileName}`);
            removedCount++;
          }
        } catch (error) {
          console.warn(`‚ö†Ô∏è  Could not remove ${fileName}: ${error.message}`);
        }
      }
    }

    // List files that are kept
    console.log('\nüìã Current hybrid bookmarklet files:');
    for (const fileName of this.filesToKeep) {
      const filePath = path.join(this.distDir, fileName);
      if (fs.existsSync(filePath)) {
        const stats = fs.statSync(filePath);
        const size = stats.isFile() ? this.formatFileSize(stats.size) : '';
        console.log(`‚úÖ ${fileName} ${size}`);
        keptCount++;
      } else {
        console.log(`‚ùå Missing: ${fileName}`);
      }
    }

    // Summary
    console.log(`\nüìä Cleanup Summary:`);
    console.log(`   üóëÔ∏è  Removed: ${removedCount} items`);
    console.log(`   üìÑ Current files: ${keptCount} items`);

    if (keptCount < this.filesToKeep.length) {
      console.log('\nüí° Some files are missing. Run the build to generate them:');
      console.log('   npm run build:bookmarklet:hybrid');
    }

    console.log('\n‚úÖ Cleanup completed!');
  }

  formatFileSize(bytes) {
    if (bytes === 0) return '(0 bytes)';
    const k = 1024;
    const sizes = ['bytes', 'KB', 'MB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return `(${parseFloat((bytes / Math.pow(k, i)).toFixed(1))} ${sizes[i]})`;
  }

  async checkBuildIntegrity() {
    console.log('\nüîç Checking build integrity...');

    const checks = [
      {
        name: 'Hybrid Loader',
        file: 'hybrid-loader.js',
        checks: [
          { name: 'Size under 2KB', test: content => content.length < 2000 },
          { name: 'Is JavaScript URL', test: content => content.startsWith('javascript:') },
          { name: 'Contains loader logic', test: content => content.includes('createElement') },
        ],
      },
      {
        name: 'Enhanced Runtime',
        file: 'enhanced-runtime.js',
        checks: [
          { name: 'Has PrismWeave class', test: content => content.includes('PrismWeave') },
          { name: 'Has execute method', test: content => content.includes('execute') },
          {
            name: 'Size reasonable',
            test: content => content.length > 10000 && content.length < 200000,
          },
        ],
      },
      {
        name: 'Installation Page',
        file: 'install-hybrid.html',
        checks: [
          { name: 'Is HTML', test: content => content.includes('<!DOCTYPE html>') },
          {
            name: 'Has bookmarklet button',
            test: content => content.includes('bookmarklet-button'),
          },
          {
            name: 'Contains instructions',
            test: content => content.includes('Installation Steps'),
          },
        ],
      },
    ];

    let allChecksPass = true;

    for (const check of checks) {
      const filePath = path.join(this.distDir, check.file);
      console.log(`\nüîß ${check.name} (${check.file}):`);

      if (!fs.existsSync(filePath)) {
        console.log(`   ‚ùå File not found`);
        allChecksPass = false;
        continue;
      }

      const content = fs.readFileSync(filePath, 'utf8');

      for (const test of check.checks) {
        const passed = test.test(content);
        console.log(`   ${passed ? '‚úÖ' : '‚ùå'} ${test.name}`);
        if (!passed) allChecksPass = false;
      }
    }

    if (allChecksPass) {
      console.log('\nüéâ All integrity checks passed!');
    } else {
      console.log('\n‚ö†Ô∏è  Some integrity checks failed. Consider rebuilding:');
      console.log('   npm run build:bookmarklet:hybrid');
    }

    return allChecksPass;
  }
}

// Command line interface
async function main() {
  const args = process.argv.slice(2);
  const cleaner = new BookmarkletCleaner();

  if (args.includes('--help')) {
    console.log(`
PrismWeave Bookmarklet Cleanup Tool

Usage: node cleanup-bookmarklet.js [options]

Options:
  --check-only     Only check integrity, don't clean files
  --help           Show this help message

Examples:
  node cleanup-bookmarklet.js           # Clean and check
  node cleanup-bookmarklet.js --check-only  # Only check integrity
    `);
    process.exit(0);
  }

  try {
    if (!args.includes('--check-only')) {
      await cleaner.clean();
    }

    await cleaner.checkBuildIntegrity();

    console.log('\nüöÄ Ready for testing! Start the local server:');
    console.log('   node scripts/serve-local.js');
  } catch (error) {
    console.error('‚ùå Cleanup failed:', error);
    process.exit(1);
  }
}

// Execute if called directly
if (require.main === module) {
  main();
}

module.exports = { BookmarkletCleaner };
