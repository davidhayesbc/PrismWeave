// Generated by Copilot
// ULTRA-SIMPLIFIED Markdown Converter - Maximum TurndownService Reliance
//
// This version demonstrates the absolute minimum custom code needed,
// relying almost entirely on TurndownService's built-in capabilities.

import { IDocumentMetadata, IImageAsset } from '../types/index';
import { createLogger } from './logger';

const logger = createLogger('MarkdownConverter');

export interface IConversionOptions {
  preserveFormatting?: boolean;
  includeMetadata?: boolean;
  generateFrontmatter?: boolean;
  customRules?: Record<string, unknown>;
  headingStyle?: 'atx' | 'setext';
  bulletListMarker?: '-' | '*' | '+';
  codeBlockStyle?: 'fenced' | 'indented';
  linkStyle?: 'inlined' | 'referenced';
}

export interface IConversionResult {
  markdown: string;
  frontmatter: string;
  metadata: IDocumentMetadata;
  images: IImageAsset[];
  wordCount: number;
}

/**
 * Ultra-Simplified Markdown Conversion Engine
 *
 * This version demonstrates maximum reliance on TurndownService with minimal custom code.
 * Key principles:
 * - Use TurndownService built-in .remove() for unwanted elements
 * - Use TurndownService built-in options instead of custom rules where possible
 * - Only add custom rules for truly unique cases that TurndownService can't handle
 * - Eliminate complex preprocessing/postprocessing in favor of TurndownService defaults
 */
export class UltraSimpleMarkdownConverter {
  protected turndownService: any = null;
  protected _isInitialized: boolean = false;

  constructor() {
    // No complex initialization needed
  }

  protected setupTurndownService(): void {
    if (!this.turndownService) {
      throw new Error('TurndownService not initialized');
    }

    // Use TurndownService's built-in removal instead of custom filtering
    this.turndownService.remove([
      // Core unwanted elements
      'script',
      'style',
      'head',
      'noscript',
      'meta',
      'link',

      // Navigation and UI elements
      'nav',
      'header',
      'footer',
      'aside',

      // Common unwanted content (let TurndownService handle the rest)
      '.advertisement',
      '.ads',
      '.popup',
      '.modal',
      '.overlay',
      '.social-share',
      '.share-buttons',
      '.comment-form',
      '.subscription',
      '.newsletter',
      '.paywall',
      '.navigation',
      '.menu',
      '.sidebar',
      '.widget',
    ]);

    // ONLY add custom rules for cases TurndownService truly can't handle
    this.addMinimalCustomRules();
  }

  protected getTurndownOptions() {
    return {
      headingStyle: 'atx' as const,
      bulletListMarker: '-' as const,
      codeBlockStyle: 'fenced' as const,
      emDelimiter: '*' as const,
      strongDelimiter: '**' as const,
      linkStyle: 'inlined' as const,
      linkReferenceStyle: 'full' as const,
      preformattedCode: true,

      // Let TurndownService handle these natively
      blankReplacement: (content: string, node: any) => {
        // Only for truly blank elements
        return node.isBlock ? '\n\n' : '';
      },

      // Use TurndownService's built-in keep functionality
      keepReplacement: (content: string, node: any) => {
        return node.isBlock ? '\n\n' + content + '\n\n' : content;
      },
    };
  }

  private addMinimalCustomRules(): void {
    if (!this.turndownService) return;

    // ONLY rule needed: Handle pseudo-numbered lists that aren't semantic HTML
    // Everything else should be handled by TurndownService's built-in capabilities
    this.turndownService.addRule('pseudoNumberedParagraphs', {
      filter: (node: any) => {
        if (node.nodeType !== 1 || node.tagName !== 'P') return false;

        // Skip if already in a list - let TurndownService handle it
        if (node.closest('ol, ul, li')) return false;

        const text = (node.textContent || '').trim();

        // Only handle clear pseudo-numbered content
        return /^\d+\.\s+\w/.test(text) && text.length > 20;
      },
      replacement: (content: string) => {
        // Keep the numbered format as-is
        return content.trim() ? `\n${content.trim()}\n` : '';
      },
    });
  }

  public convertToMarkdown(html: string, options: IConversionOptions = {}): IConversionResult {
    if (!this._isInitialized || !this.turndownService) {
      throw new Error('MarkdownConverter not properly initialized');
    }

    try {
      // Minimal preprocessing - let TurndownService handle most of it
      const cleanedHtml = html
        .replace(/<!--[\s\S]*?-->/g, '') // Remove comments only
        .trim();

      // Convert to markdown - TurndownService does the heavy lifting
      const markdown = this.turndownService.turndown(cleanedHtml);

      // Minimal postprocessing - trust TurndownService output
      const cleanedMarkdown = markdown
        .replace(/\n{4,}/g, '\n\n\n') // Limit excessive line breaks
        .trim();

      const wordCount = cleanedMarkdown.split(/\s+/).filter(Boolean).length;

      const result: IConversionResult = {
        markdown: cleanedMarkdown,
        frontmatter: '',
        metadata: {
          title: '',
          url: typeof window !== 'undefined' ? window.location.href : '',
          captureDate: new Date().toISOString(),
          tags: [],
          author: '',
          wordCount,
          estimatedReadingTime: Math.ceil(wordCount / 200),
        },
        images: [],
        wordCount,
      };

      return result;
    } catch (error) {
      logger.error('Ultra-simple conversion failed:', error);
      throw error;
    }
  }
}
