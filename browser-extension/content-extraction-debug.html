<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>PrismWeave Content Extraction Debug</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        padding: 20px;
        max-width: 1200px;
        margin: 0 auto;
      }
      .debug-panel {
        background: #f5f5f5;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 20px;
        margin: 20px 0;
      }
      .debug-section {
        margin: 15px 0;
      }
      .debug-section h3 {
        margin: 0 0 10px 0;
        color: #333;
      }
      .debug-logs {
        background: #1e1e1e;
        color: #f0f0f0;
        padding: 15px;
        border-radius: 5px;
        font-family: 'Courier New', monospace;
        font-size: 12px;
        max-height: 300px;
        overflow-y: auto;
        white-space: pre-wrap;
      }
      .extraction-result {
        background: white;
        border: 1px solid #ccc;
        padding: 15px;
        border-radius: 5px;
        max-height: 400px;
        overflow-y: auto;
      }
      .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin: 15px 0;
      }
      .stat-item {
        background: white;
        padding: 15px;
        border-radius: 5px;
        border: 1px solid #ddd;
        text-align: center;
      }
      .stat-value {
        font-size: 24px;
        font-weight: bold;
        color: #2563eb;
      }
      .stat-label {
        color: #666;
        font-size: 14px;
      }
      button {
        background: #2563eb;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 16px;
        margin: 5px;
      }
      button:hover {
        background: #1d4ed8;
      }
      button:disabled {
        background: #9ca3af;
        cursor: not-allowed;
      }
      .error {
        color: #dc2626;
        background: #fef2f2;
        padding: 10px;
        border-radius: 5px;
        border: 1px solid #fecaca;
      }
      .success {
        color: #059669;
        background: #f0fdf4;
        padding: 10px;
        border-radius: 5px;
        border: 1px solid #bbf7d0;
      }
      .url-input {
        width: 100%;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 5px;
        font-size: 16px;
        margin: 10px 0;
      }
      .markdown-preview {
        background: #f9fafb;
        border: 1px solid #e5e7eb;
        padding: 20px;
        border-radius: 8px;
        white-space: pre-wrap;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        max-height: 500px;
        overflow-y: auto;
      }
    </style>
  </head>
  <body>
    <h1>üîç PrismWeave Content Extraction Debug Tool</h1>
    <p>Use this tool to debug and test content extraction from any webpage, including the Docker blog post.</p>

    <div class="debug-panel">
      <h2>üöÄ Quick Test</h2>
      <div class="debug-section">
        <h3>Test URL</h3>
        <input
          type="text"
          id="testUrl"
          class="url-input"
          value="https://www.docker.com/blog/how-to-make-ai-chatbot-from-scratch/?utm_source=tldrdevops"
          placeholder="Enter URL to test"
        />
        <button onclick="testCurrentPage()">Test Current Page</button>
        <button onclick="extractWithLogging()">Extract with Debug Logging</button>
        <button onclick="testSelectors()">Test All Selectors</button>
        <button onclick="clearLogs()">Clear Logs</button>
      </div>
    </div>

    <div class="debug-panel">
      <h2>üìä Extraction Statistics</h2>
      <div
        class="stats"
        id="stats"
      >
        <div class="stat-item">
          <div
            class="stat-value"
            id="originalLength"
          >
            -
          </div>
          <div class="stat-label">Original HTML Length</div>
        </div>
        <div class="stat-item">
          <div
            class="stat-value"
            id="extractedLength"
          >
            -
          </div>
          <div class="stat-label">Extracted Content Length</div>
        </div>
        <div class="stat-item">
          <div
            class="stat-value"
            id="textLength"
          >
            -
          </div>
          <div class="stat-label">Text Content Length</div>
        </div>
        <div class="stat-item">
          <div
            class="stat-value"
            id="wordCount"
          >
            -
          </div>
          <div class="stat-label">Word Count</div>
        </div>
        <div class="stat-item">
          <div
            class="stat-value"
            id="markdownLength"
          >
            -
          </div>
          <div class="stat-label">Markdown Length</div>
        </div>
        <div class="stat-item">
          <div
            class="stat-value"
            id="compressionRatio"
          >
            -
          </div>
          <div class="stat-label">Compression Ratio</div>
        </div>
      </div>
    </div>

    <div class="debug-panel">
      <h2>üêõ Debug Console</h2>
      <div class="debug-section">
        <div
          id="debugLogs"
          class="debug-logs"
        >
          Debug logs will appear here...
        </div>
      </div>
    </div>

    <div class="debug-panel">
      <h2>üìÑ Extracted Content</h2>
      <div class="debug-section">
        <h3>Raw HTML</h3>
        <div
          id="extractedHtml"
          class="extraction-result"
        >
          No content extracted yet
        </div>
      </div>
    </div>

    <div class="debug-panel">
      <h2>üìù Markdown Output</h2>
      <div class="debug-section">
        <div
          id="markdownOutput"
          class="markdown-preview"
        >
          No markdown generated yet
        </div>
      </div>
    </div>

    <script>
      let debugLogs = [];
      let originalConsoleLog = console.log;
      let originalConsoleWarn = console.warn;
      let originalConsoleError = console.error;

      // Intercept console logs for debugging
      function setupLogging() {
        console.log = function (...args) {
          debugLogs.push(`[LOG] ${args.join(' ')}`);
          updateDebugDisplay();
          originalConsoleLog.apply(console, args);
        };

        console.warn = function (...args) {
          debugLogs.push(`[WARN] ${args.join(' ')}`);
          updateDebugDisplay();
          originalConsoleWarn.apply(console, args);
        };

        console.error = function (...args) {
          debugLogs.push(`[ERROR] ${args.join(' ')}`);
          updateDebugDisplay();
          originalConsoleError.apply(console, args);
        };
      }

      function updateDebugDisplay() {
        const debugElement = document.getElementById('debugLogs');
        debugElement.textContent = debugLogs.slice(-50).join('\n'); // Show last 50 logs
        debugElement.scrollTop = debugElement.scrollHeight;
      }

      function clearLogs() {
        debugLogs = [];
        updateDebugDisplay();
      }

      function updateStats(originalHtml, extractedHtml, textContent, markdown) {
        document.getElementById('originalLength').textContent = originalHtml
          ? originalHtml.length.toLocaleString()
          : '-';
        document.getElementById('extractedLength').textContent = extractedHtml
          ? extractedHtml.length.toLocaleString()
          : '-';
        document.getElementById('textLength').textContent = textContent ? textContent.length.toLocaleString() : '-';

        const wordCount = textContent ? textContent.split(/\s+/).filter(word => word.length > 0).length : 0;
        document.getElementById('wordCount').textContent = wordCount.toLocaleString();

        document.getElementById('markdownLength').textContent = markdown ? markdown.length.toLocaleString() : '-';

        const compressionRatio =
          originalHtml && extractedHtml
            ? ((1 - extractedHtml.length / originalHtml.length) * 100).toFixed(1) + '%'
            : '-';
        document.getElementById('compressionRatio').textContent = compressionRatio;
      }

      async function testCurrentPage() {
        try {
          console.log('üß™ Testing content extraction on current page...');

          // Send message to content script
          const response = await chrome.runtime.sendMessage({
            type: 'EXTRACT_CONTENT',
            data: { includeMetadata: true },
          });

          if (response && response.success) {
            console.log('‚úÖ Content extraction successful');
            const data = response.data;

            document.getElementById('extractedHtml').innerHTML =
              '<pre>' + escapeHtml(data.content || 'No content') + '</pre>';

            if (data.markdown) {
              document.getElementById('markdownOutput').textContent = data.markdown;
            }

            updateStats(document.documentElement.outerHTML, data.content, data.metadata?.textContent, data.markdown);
          } else {
            console.error('‚ùå Content extraction failed:', response?.error || 'Unknown error');
            document.getElementById('extractedHtml').innerHTML =
              '<div class="error">Content extraction failed: ' + (response?.error || 'Unknown error') + '</div>';
          }
        } catch (error) {
          console.error('‚ùå Error testing extraction:', error);
          document.getElementById('extractedHtml').innerHTML = '<div class="error">Error: ' + error.message + '</div>';
        }
      }

      async function extractWithLogging() {
        console.log('üîç Starting extraction with detailed logging...');
        clearLogs();

        // Enable verbose logging
        localStorage.setItem('prismweave_debug', 'true');

        await testCurrentPage();

        console.log('üìã Extraction complete. Check the debug logs above for details.');
      }

      async function testSelectors() {
        console.log('üéØ Testing individual selectors...');

        const selectors = [
          'article',
          'main',
          '[role="main"]',
          '.content',
          '.post-content',
          '.entry-content',
          '.article-content',
          '.article-body',
          '.post-body',
          '.blog-content',
          '.article__content',
          '.prose',
          '.rich-text',
        ];

        selectors.forEach(selector => {
          const elements = document.querySelectorAll(selector);
          console.log(`Selector "${selector}": ${elements.length} elements found`);

          elements.forEach((element, index) => {
            const textLength = element.textContent?.length || 0;
            const hasContent = textLength > 100;
            console.log(`  Element ${index + 1}: ${textLength} characters, content: ${hasContent}`);
          });
        });
      }

      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      // Initialize logging when page loads
      document.addEventListener('DOMContentLoaded', function () {
        setupLogging();
        console.log('üöÄ PrismWeave Debug Tool loaded');
        console.log('üìç Current URL:', window.location.href);
        console.log('üìÑ Page title:', document.title);

        // Check if we're on the Docker blog page
        if (window.location.href.includes('docker.com/blog')) {
          console.log('üê≥ Docker blog page detected - this is the target page for testing!');
        }
      });
    </script>
  </body>
</html>
