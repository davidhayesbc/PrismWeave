#!/usr/bin/env node

// Generated by Copilot
// Working URL test script for PrismWeave markdown conversion

import chalk from 'chalk';
import fs from 'fs-extra';
import fetch from 'node-fetch';
import path from 'path';
import { NodeMarkdownConverter } from './node-markdown-converter.ts';

async function testUrlConversion(url: string) {
  console.log(chalk.yellow('ğŸš€ PrismWeave URL Conversion Test'));
  console.log(chalk.blue(`ğŸ¯ Testing URL: ${url}\n`));
  
  const outputDir = path.resolve('./test-outputs');
  const startTime = Date.now();
  
  try {
    // Step 1: Create converter
    console.log(chalk.gray('ğŸ”§ Creating converter...'));
    const converter = new NodeMarkdownConverter();
    console.log(chalk.green('âœ… Converter ready'));
    
    // Step 2: Fetch HTML
    console.log(chalk.gray('ğŸŒ Fetching HTML...'));
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    const html = await response.text();
    console.log(chalk.green(`âœ… Fetched ${html.length.toLocaleString()} characters`));
    
    // Step 3: Convert to markdown
    console.log(chalk.gray('ğŸ”„ Converting to markdown...'));
    const result = await converter.convertHtmlWithDOM(html, {
      generateFrontmatter: true,
      includeMetadata: true,
      preserveFormatting: true,
    });
    console.log(chalk.green('âœ… Conversion complete'));
    
    // Step 4: Save results
    console.log(chalk.gray('ğŸ’¾ Saving results...'));
    await fs.ensureDir(outputDir);
    
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const baseFilename = `conversion-${timestamp}`;
    
    // Save markdown
    const mdPath = path.join(outputDir, `${baseFilename}.md`);
    await fs.writeFile(mdPath, result.markdown, 'utf8');
    
    // Save HTML
    const htmlPath = path.join(outputDir, `${baseFilename}.html`);
    await fs.writeFile(htmlPath, html, 'utf8');
    
    // Save metadata
    const metadata = {
      url,
      timestamp: new Date().toISOString(),
      conversionTimeMs: Date.now() - startTime,
      stats: {
        htmlLength: html.length,
        markdownLength: result.markdown.length,
        wordCount: result.wordCount,
        imageCount: result.images.length,
      },
      files: {
        markdown: mdPath,
        html: htmlPath,
      }
    };
    
    const jsonPath = path.join(outputDir, `${baseFilename}.json`);
    await fs.writeFile(jsonPath, JSON.stringify(metadata, null, 2), 'utf8');
    
    console.log(chalk.green('âœ… Results saved!'));
    
    // Step 5: Display summary
    const conversionTime = Date.now() - startTime;
    console.log(chalk.cyan(`\nğŸ“Š Conversion Summary:`));
    console.log(chalk.cyan(`â±ï¸  Time: ${conversionTime}ms`));
    console.log(chalk.cyan(`ğŸ“ Word count: ${result.wordCount.toLocaleString()}`));
    console.log(chalk.cyan(`ğŸ“„ Markdown: ${result.markdown.length.toLocaleString()} chars`));
    console.log(chalk.cyan(`ğŸ–¼ï¸  Images: ${result.images.length}`));
    console.log(chalk.cyan(`ğŸ“ Output: ${outputDir}`));
    
    console.log(chalk.green('\nğŸ‰ Test completed successfully!'));
    
  } catch (error: any) {
    console.error(chalk.red('\nâŒ Test failed:'), error.message);
    if (error.stack) {
      console.error(chalk.red('Stack trace:'), error.stack);
    }
    process.exit(1);
  }
}

// Get URL from command line or use default
const testUrl = process.argv[2] || 'https://docs.docker.com/get-started/';

// Run the test
testUrlConversion(testUrl);
