#!/usr/bin/env node

// Generated by Copilot
// Simple URL testing tool for PrismWeave markdown conversion
// JavaScript version that runs directly without TypeScript compilation

import chalk from 'chalk';
import fs from 'fs-extra';
import { JSDOM } from 'jsdom';
import fetch from 'node-fetch';
import path from 'path';
import TurndownService from 'turndown';

class SimpleUrlTester {
  constructor(outputDir = './test-outputs') {
    this.outputDir = path.resolve(outputDir);
    this.converter = this.initializeConverter();
  }

  initializeConverter() {
    const turndownService = new TurndownService({
      headingStyle: 'atx',
      bulletListMarker: '-',
      codeBlockStyle: 'fenced',
      emDelimiter: '*',
      strongDelimiter: '**',
      linkStyle: 'inlined',
      linkReferenceStyle: 'full',
      preformattedCode: true,
    });

    // Add line number removal rule
    turndownService.addRule('removeLineNumbers', {
      filter: node => {
        if (node.nodeType === 1) {
          const className = (node.className || '').toLowerCase();
          const id = (node.id || '').toLowerCase();
          const lineNumberPatterns = [
            'line-number',
            'linenumber',
            'line-num',
            'linenum',
            'gutter',
            'line-gutter',
            'hljs-ln-numbers',
            'hljs-ln-line',
            'code-line-number',
          ];
          return lineNumberPatterns.some(
            pattern => className.includes(pattern) || id.includes(pattern)
          );
        }
        return false;
      },
      replacement: () => '',
    });

    return turndownService;
  }

  async testUrl(url, options = {}) {
    const startTime = Date.now();

    console.log(chalk.blue(`üåê Fetching URL: ${url}`));

    try {
      // Fetch the URL
      const response = await fetch(url, {
        headers: {
          'User-Agent':
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        },
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const html = await response.text();
      console.log(chalk.green(`‚úì Fetched ${html.length} characters`));

      // Extract metadata
      const metadata = this.extractMetadata(html, url);

      if (options.verbose) {
        console.log(chalk.cyan('üìä Extracted metadata:'), metadata);
      }

      // Convert to markdown
      console.log(chalk.blue('üîÑ Converting to markdown...'));
      const markdown = this.converter.turndown(html);

      const conversionTime = Date.now() - startTime;
      console.log(chalk.green(`‚úì Conversion completed in ${conversionTime}ms`));

      // Generate frontmatter
      const frontmatter =
        options.generateFrontmatter !== false ? this.generateFrontmatter(metadata) : '';

      // Calculate stats
      const stats = this.getMarkdownStats(markdown);

      const result = {
        url,
        timestamp: new Date().toISOString(),
        originalHtml: html,
        markdown,
        frontmatter,
        metadata,
        stats,
        conversionTime,
      };

      // Save results
      await this.saveResults(result, options);

      // Display stats
      this.displayStats(result);

      return result;
    } catch (error) {
      console.error(chalk.red('‚ùå Error during conversion:'), error);
      throw error;
    }
  }

  extractMetadata(html, url) {
    const dom = new JSDOM(html);
    const document = dom.window.document;

    const metadata = {
      url,
      title: '',
      description: '',
      author: '',
      publishedDate: '',
      canonical: url,
      language: 'en',
    };

    // Extract title
    const titleElement =
      document.querySelector('title') ||
      document.querySelector('h1') ||
      document.querySelector('meta[property="og:title"]');
    if (titleElement) {
      metadata.title =
        titleElement.textContent?.trim() || titleElement.getAttribute('content')?.trim() || '';
    }

    // Extract description
    const descriptionElement =
      document.querySelector('meta[name="description"]') ||
      document.querySelector('meta[property="og:description"]');
    if (descriptionElement) {
      metadata.description = descriptionElement.getAttribute('content')?.trim() || '';
    }

    // Extract author
    const authorElement =
      document.querySelector('meta[name="author"]') ||
      document.querySelector('meta[property="article:author"]') ||
      document.querySelector('.author, .byline');
    if (authorElement) {
      metadata.author =
        authorElement.getAttribute('content')?.trim() || authorElement.textContent?.trim() || '';
    }

    return metadata;
  }

  generateFrontmatter(metadata) {
    const yaml = Object.entries(metadata)
      .filter(([_, value]) => value !== undefined && value !== null && value !== '')
      .map(([key, value]) => `${key}: ${JSON.stringify(value)}`)
      .join('\n');

    return yaml ? `---\n${yaml}\n---\n\n` : '';
  }

  getMarkdownStats(markdown) {
    return {
      words: markdown
        .replace(/[^\w\s]/g, '')
        .split(/\s+/)
        .filter(word => word.length > 0).length,
      characters: markdown.length,
      headings: (markdown.match(/^#+\s/gm) || []).length,
      links: (markdown.match(/\[([^\]]*)\]\([^)]*\)/g) || []).length,
      images: (markdown.match(/!\[([^\]]*)\]\([^)]*\)/g) || []).length,
      codeBlocks: Math.floor((markdown.match(/```/g) || []).length / 2),
    };
  }

  async saveResults(result, options) {
    // Create output directory
    await fs.ensureDir(this.outputDir);

    // Generate filename from URL
    const urlObj = new URL(result.url);
    const hostname = urlObj.hostname.replace(/[^a-zA-Z0-9]/g, '-');
    const pathname = urlObj.pathname.replace(/[^a-zA-Z0-9]/g, '-').substring(0, 50);
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const baseFilename = `${hostname}${pathname}-${timestamp}`;

    if (options.format !== 'markdown') {
      // Save original HTML
      const htmlPath = path.join(this.outputDir, `${baseFilename}.html`);
      await fs.writeFile(htmlPath, result.originalHtml, 'utf8');
      console.log(chalk.gray(`üíæ Saved HTML: ${htmlPath}`));
    }

    if (options.format !== 'html') {
      // Save markdown
      const markdownContent = result.frontmatter + result.markdown;
      const markdownPath = path.join(this.outputDir, `${baseFilename}.md`);
      await fs.writeFile(markdownPath, markdownContent, 'utf8');
      console.log(chalk.gray(`üíæ Saved Markdown: ${markdownPath}`));
    }

    // Save test result metadata
    const metadataPath = path.join(this.outputDir, `${baseFilename}.json`);
    await fs.writeFile(metadataPath, JSON.stringify(result, null, 2), 'utf8');
    console.log(chalk.gray(`üíæ Saved metadata: ${metadataPath}`));
  }

  displayStats(result) {
    console.log(chalk.yellow('\nüìä Conversion Statistics:'));
    console.log(`   Words: ${result.stats.words}`);
    console.log(`   Characters: ${result.stats.characters}`);
    console.log(`   Headings: ${result.stats.headings}`);
    console.log(`   Links: ${result.stats.links}`);
    console.log(`   Images: ${result.stats.images}`);
    console.log(`   Code blocks: ${result.stats.codeBlocks}`);
    console.log(`   Conversion time: ${result.conversionTime}ms`);
  }
}

// Simple argument parsing
const args = process.argv.slice(2);
const url = args[0];

if (!url) {
  console.error(chalk.red('Error: Please provide a URL'));
  console.log('Usage: npm run test-url <url>');
  process.exit(1);
}

// Parse simple options
const options = {
  verbose: args.includes('--verbose') || args.includes('-v'),
  format: 'all',
  generateFrontmatter: !args.includes('--no-frontmatter'),
};

// Main execution
async function main() {
  try {
    console.log(chalk.green('üöÄ PrismWeave URL Tester\n'));

    const tester = new SimpleUrlTester('./test-outputs');
    await tester.testUrl(url, options);

    console.log(chalk.green('\n‚úÖ Test completed successfully!'));
  } catch (error) {
    console.error(chalk.red('\n‚ùå Test failed:'), error);
    process.exit(1);
  }
}

main();
