// Generated by Copilot
// Comparison utility for analyzing markdown conversion results
// Helps identify differences between conversion attempts and quality metrics

import chalk from 'chalk';
import { diffLines } from 'diff';
import fs from 'fs-extra';
import path from 'path';

interface IComparisonResult {
  filesCompared: string[];
  htmlDifferences: any[];
  markdownDifferences: any[];
  metadataComparison: any;
  qualityMetrics: IQualityMetrics;
  recommendations: string[];
}

interface IQualityMetrics {
  markdownValidity: boolean;
  codeBlockIntegrity: number; // Percentage of properly formatted code blocks
  linkIntegrity: number; // Percentage of valid links
  headingStructure: number; // Hierarchy score
  contentPreservation: number; // Estimated content preservation score
  readabilityScore: number; // Basic readability assessment
}

interface ITestOutput {
  markdown: string;
  frontmatter: string;
  metadata: any;
  stats: any;
  originalHtml: string;
  url: string;
  timestamp: string;
}

export class ConversionComparator {
  private outputDir: string;

  constructor(outputDir: string = './test-outputs') {
    this.outputDir = path.resolve(outputDir);
  }

  async compareResults(file1: string, file2: string): Promise<IComparisonResult> {
    console.log(chalk.blue('üìä Comparing conversion results...'));

    const result1 = await this.loadTestResult(file1);
    const result2 = await this.loadTestResult(file2);

    const comparison: IComparisonResult = {
      filesCompared: [file1, file2],
      htmlDifferences: this.compareHtml(result1.originalHtml, result2.originalHtml),
      markdownDifferences: this.compareMarkdown(result1.markdown, result2.markdown),
      metadataComparison: this.compareMetadata(result1.metadata, result2.metadata),
      qualityMetrics: this.assessQuality(result1, result2),
      recommendations: this.generateRecommendations(result1, result2),
    };

    this.displayComparison(comparison);
    return comparison;
  }

  async analyzeConversionQuality(filePath: string): Promise<IQualityMetrics> {
    console.log(chalk.blue(`üîç Analyzing conversion quality: ${filePath}`));

    const result = await this.loadTestResult(filePath);
    const metrics = this.calculateQualityMetrics(result);

    this.displayQualityMetrics(metrics);
    return metrics;
  }

  async batchAnalyze(pattern: string = '*.json'): Promise<IQualityMetrics[]> {
    console.log(chalk.blue(`üìÅ Batch analyzing files matching: ${pattern}`));

    const files = await this.findTestFiles(pattern);
    const results: IQualityMetrics[] = [];

    for (const file of files) {
      try {
        const metrics = await this.analyzeConversionQuality(file);
        results.push(metrics);
      } catch (error) {
        console.warn(chalk.yellow(`‚ö†Ô∏è  Skipped ${file}: ${error}`));
      }
    }

    this.displayBatchSummary(results, files);
    return results;
  }

  private async loadTestResult(filePath: string): Promise<ITestOutput> {
    const fullPath = path.resolve(this.outputDir, filePath);

    if (!(await fs.pathExists(fullPath))) {
      throw new Error(`Test result file not found: ${fullPath}`);
    }

    const content = await fs.readFile(fullPath, 'utf8');
    return JSON.parse(content);
  }

  private async findTestFiles(pattern: string): Promise<string[]> {
    const files = await fs.readdir(this.outputDir);

    // Simple pattern matching - convert glob to regex
    const regexPattern = pattern.replace(/\./g, '\\.').replace(/\*/g, '.*');
    const regex = new RegExp(`^${regexPattern}$`);

    return files.filter(file => regex.test(file));
  }

  private compareHtml(html1: string, html2: string): any[] {
    return diffLines(html1, html2)
      .filter(change => change.added || change.removed)
      .slice(0, 10); // Limit to first 10 differences
  }

  private compareMarkdown(md1: string, md2: string): any[] {
    return diffLines(md1, md2).filter(change => change.added || change.removed);
  }

  private compareMetadata(meta1: any, meta2: any): any {
    const keys = new Set([...Object.keys(meta1), ...Object.keys(meta2)]);
    const differences: any = {};

    for (const key of keys) {
      if (meta1[key] !== meta2[key]) {
        differences[key] = {
          file1: meta1[key],
          file2: meta2[key],
        };
      }
    }

    return differences;
  }

  private assessQuality(result1: ITestOutput, result2: ITestOutput): IQualityMetrics {
    // Compare against both results and return better quality metrics
    const metrics1 = this.calculateQualityMetrics(result1);
    const metrics2 = this.calculateQualityMetrics(result2);

    // Return the better performing metrics for comparison
    return {
      markdownValidity: metrics1.markdownValidity && metrics2.markdownValidity,
      codeBlockIntegrity: Math.max(metrics1.codeBlockIntegrity, metrics2.codeBlockIntegrity),
      linkIntegrity: Math.max(metrics1.linkIntegrity, metrics2.linkIntegrity),
      headingStructure: Math.max(metrics1.headingStructure, metrics2.headingStructure),
      contentPreservation: Math.max(metrics1.contentPreservation, metrics2.contentPreservation),
      readabilityScore: Math.max(metrics1.readabilityScore, metrics2.readabilityScore),
    };
  }

  private calculateQualityMetrics(result: ITestOutput): IQualityMetrics {
    const markdown = result.markdown;

    // Markdown validity check
    const markdownValidity = this.checkMarkdownValidity(markdown);

    // Code block integrity
    const codeBlockIntegrity = this.assessCodeBlockIntegrity(markdown);

    // Link integrity
    const linkIntegrity = this.assessLinkIntegrity(markdown);

    // Heading structure
    const headingStructure = this.assessHeadingStructure(markdown);

    // Content preservation (estimated)
    const contentPreservation = this.estimateContentPreservation(result.originalHtml, markdown);

    // Readability score
    const readabilityScore = this.calculateReadabilityScore(markdown);

    return {
      markdownValidity,
      codeBlockIntegrity,
      linkIntegrity,
      headingStructure,
      contentPreservation,
      readabilityScore,
    };
  }

  private checkMarkdownValidity(markdown: string): boolean {
    // Check for unclosed code blocks
    const codeBlockCount = (markdown.match(/```/g) || []).length;
    if (codeBlockCount % 2 !== 0) return false;

    // Check for malformed links
    const malformedLinks = markdown.match(/\[([^\]]*)\]\([^)]*$/gm);
    if (malformedLinks && malformedLinks.length > 0) return false;

    return true;
  }

  private assessCodeBlockIntegrity(markdown: string): number {
    const codeBlocks = markdown.match(/```[\s\S]*?```/g) || [];
    if (codeBlocks.length === 0) return 100; // No code blocks = perfect score

    let wellFormatted = 0;

    codeBlocks.forEach(block => {
      // Check if code block has language specification
      const hasLanguage = /^```\w+/.test(block);

      // Check if code block has proper newlines
      const hasProperFormat = block.includes('\n') && !block.includes('````');

      if (hasProperFormat) wellFormatted++;
    });

    return Math.round((wellFormatted / codeBlocks.length) * 100);
  }

  private assessLinkIntegrity(markdown: string): number {
    const links = markdown.match(/\[([^\]]*)\]\(([^)]*)\)/g) || [];
    if (links.length === 0) return 100; // No links = perfect score

    let validLinks = 0;

    links.forEach(link => {
      const urlMatch = link.match(/\[([^\]]*)\]\(([^)]*)\)/);
      if (urlMatch) {
        const url = urlMatch[2];
        // Basic URL validation
        if (url && (url.startsWith('http') || url.startsWith('/') || url.startsWith('#'))) {
          validLinks++;
        }
      }
    });

    return Math.round((validLinks / links.length) * 100);
  }

  private assessHeadingStructure(markdown: string): number {
    const headings = markdown.match(/^#+\s.*/gm) || [];
    if (headings.length === 0) return 100; // No headings = neutral score

    let structureScore = 100;
    let lastLevel = 0;

    headings.forEach(heading => {
      const level = (heading.match(/#/g) || []).length;

      // Penalize jumping more than one level
      if (lastLevel > 0 && level > lastLevel + 1) {
        structureScore -= 10;
      }

      lastLevel = level;
    });

    return Math.max(0, structureScore);
  }

  private estimateContentPreservation(html: string, markdown: string): number {
    // Simple heuristic: compare character counts after normalization
    const htmlText = html
      .replace(/<[^>]*>/g, '')
      .replace(/\s+/g, ' ')
      .trim();
    const markdownText = markdown
      .replace(/[*_`#\[\]()]/g, '')
      .replace(/\s+/g, ' ')
      .trim();

    const htmlLength = htmlText.length;
    const markdownLength = markdownText.length;

    if (htmlLength === 0) return 0;

    // Calculate preservation ratio
    const ratio = markdownLength / htmlLength;

    // Optimal ratio is around 0.8-1.2 (some markup overhead is expected)
    if (ratio >= 0.8 && ratio <= 1.2) {
      return 100;
    } else if (ratio < 0.5) {
      return Math.round(ratio * 100); // Significant content loss
    } else {
      return Math.round(Math.max(0, 100 - Math.abs(ratio - 1) * 50));
    }
  }

  private calculateReadabilityScore(markdown: string): number {
    const lines = markdown.split('\n');
    let score = 100;

    // Penalize very long lines
    const longLines = lines.filter(line => line.length > 120).length;
    score -= longLines * 2;

    // Reward proper paragraph breaks
    let consecutiveEmptyLines = 0;
    lines.forEach(line => {
      if (line.trim() === '') {
        consecutiveEmptyLines++;
        if (consecutiveEmptyLines > 2) score -= 1; // Penalize excessive empty lines
      } else {
        consecutiveEmptyLines = 0;
      }
    });

    return Math.max(0, Math.min(100, score));
  }

  private generateRecommendations(result1: ITestOutput, result2: ITestOutput): string[] {
    const recommendations: string[] = [];
    const metrics1 = this.calculateQualityMetrics(result1);
    const metrics2 = this.calculateQualityMetrics(result2);

    if (!metrics1.markdownValidity || !metrics2.markdownValidity) {
      recommendations.push('Fix markdown syntax errors (unclosed code blocks, malformed links)');
    }

    if (metrics1.codeBlockIntegrity < 80 || metrics2.codeBlockIntegrity < 80) {
      recommendations.push('Improve code block formatting and language detection');
    }

    if (metrics1.linkIntegrity < 90 || metrics2.linkIntegrity < 90) {
      recommendations.push('Fix broken or malformed links');
    }

    if (metrics1.headingStructure < 80 || metrics2.headingStructure < 80) {
      recommendations.push('Improve heading hierarchy structure');
    }

    if (metrics1.contentPreservation < 70 || metrics2.contentPreservation < 70) {
      recommendations.push('Review content extraction - possible content loss detected');
    }

    return recommendations;
  }

  private displayComparison(comparison: IComparisonResult): void {
    console.log(chalk.yellow('\nüìä Comparison Results:'));
    console.log(`Files: ${comparison.filesCompared.join(' vs ')}`);

    console.log(chalk.cyan('\nüîç Markdown Differences:'));
    if (comparison.markdownDifferences.length === 0) {
      console.log(chalk.green('   ‚úì No differences found'));
    } else {
      comparison.markdownDifferences.slice(0, 5).forEach((diff, index) => {
        const prefix = diff.added ? chalk.green('+ ') : chalk.red('- ');
        console.log(`   ${prefix}${diff.value.trim().substring(0, 100)}...`);
      });
      if (comparison.markdownDifferences.length > 5) {
        console.log(
          chalk.gray(`   ... and ${comparison.markdownDifferences.length - 5} more differences`)
        );
      }
    }

    console.log(chalk.cyan('\nüìã Metadata Differences:'));
    const metaDiffKeys = Object.keys(comparison.metadataComparison);
    if (metaDiffKeys.length === 0) {
      console.log(chalk.green('   ‚úì No metadata differences'));
    } else {
      metaDiffKeys.forEach(key => {
        console.log(
          `   ${key}: ${comparison.metadataComparison[key].file1} ‚Üí ${comparison.metadataComparison[key].file2}`
        );
      });
    }

    this.displayQualityMetrics(comparison.qualityMetrics);

    if (comparison.recommendations.length > 0) {
      console.log(chalk.yellow('\nüí° Recommendations:'));
      comparison.recommendations.forEach(rec => {
        console.log(`   ‚Ä¢ ${rec}`);
      });
    }
  }

  private displayQualityMetrics(metrics: IQualityMetrics): void {
    console.log(chalk.cyan('\n‚≠ê Quality Metrics:'));
    console.log(
      `   Markdown Validity: ${metrics.markdownValidity ? chalk.green('‚úì') : chalk.red('‚úó')}`
    );
    console.log(`   Code Block Integrity: ${this.formatScore(metrics.codeBlockIntegrity)}%`);
    console.log(`   Link Integrity: ${this.formatScore(metrics.linkIntegrity)}%`);
    console.log(`   Heading Structure: ${this.formatScore(metrics.headingStructure)}%`);
    console.log(`   Content Preservation: ${this.formatScore(metrics.contentPreservation)}%`);
    console.log(`   Readability Score: ${this.formatScore(metrics.readabilityScore)}%`);
  }

  private displayBatchSummary(results: IQualityMetrics[], files: string[]): void {
    console.log(chalk.green(`\nüìà Batch Analysis Summary (${results.length} files):`));

    if (results.length === 0) {
      console.log(chalk.yellow('   No valid results to analyze'));
      return;
    }

    const averages = {
      codeBlockIntegrity:
        results.reduce((sum, r) => sum + r.codeBlockIntegrity, 0) / results.length,
      linkIntegrity: results.reduce((sum, r) => sum + r.linkIntegrity, 0) / results.length,
      headingStructure: results.reduce((sum, r) => sum + r.headingStructure, 0) / results.length,
      contentPreservation:
        results.reduce((sum, r) => sum + r.contentPreservation, 0) / results.length,
      readabilityScore: results.reduce((sum, r) => sum + r.readabilityScore, 0) / results.length,
    };

    console.log(
      `   Average Code Block Integrity: ${this.formatScore(averages.codeBlockIntegrity)}%`
    );
    console.log(`   Average Link Integrity: ${this.formatScore(averages.linkIntegrity)}%`);
    console.log(`   Average Heading Structure: ${this.formatScore(averages.headingStructure)}%`);
    console.log(
      `   Average Content Preservation: ${this.formatScore(averages.contentPreservation)}%`
    );
    console.log(`   Average Readability: ${this.formatScore(averages.readabilityScore)}%`);

    const validFiles = results.filter(r => r.markdownValidity).length;
    console.log(`   Valid Markdown Files: ${validFiles}/${results.length}`);
  }

  private formatScore(score: number): string {
    const rounded = Math.round(score);
    if (rounded >= 90) return chalk.green(rounded.toString());
    if (rounded >= 70) return chalk.yellow(rounded.toString());
    return chalk.red(rounded.toString());
  }
}

// Export for use
export default ConversionComparator;
