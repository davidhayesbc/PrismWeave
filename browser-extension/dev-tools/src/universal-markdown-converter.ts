// Generated by Copilot
// Universal Markdown Converter - Works in both Node.js and Browser environments
// Refactored from the original browser-extension version

// Universal interface definitions (copied from browser extension)
interface IConversionOptions {
  preserveFormatting?: boolean;
  includeMetadata?: boolean;
  generateFrontmatter?: boolean;
  customRules?: Record<string, unknown>;
  headingStyle?: 'atx' | 'setext';
  bulletListMarker?: '-' | '*' | '+';
  codeBlockStyle?: 'fenced' | 'indented';
  linkStyle?: 'inlined' | 'referenced';
}

interface IConversionResult {
  markdown: string;
  frontmatter: string;
  metadata: IDocumentMetadata;
  images: IImageAsset[];
  wordCount: number;
}

interface IDocumentMetadata {
  title: string;
  url?: string;
  author?: string;
  publishedDate?: string;
  modifiedDate?: string;
  description?: string;
  tags?: string[];
  category?: string;
  language?: string;
  canonical?: string;
  [key: string]: unknown;
}

interface IImageAsset {
  url: string;
  filename: string;
  alt?: string;
  title?: string;
  mimeType: string;
  size?: { width: number; height: number };
}

interface ITurndownService {
  turndown(html: string): string;
  addRule(key: string, rule: any): void;
  remove(filter: string | string[]): void;
  use(plugin: any): void;
}

interface ISemanticSelectors {
  callouts: string[];
  quotes: string[];
  highlights: string[];
  captions: string[];
  metadata: string[];
  codeElements: string[];
}

interface IEnvironmentContext {
  isNode: boolean;
  isBrowser: boolean;
  isServiceWorker: boolean;
  turndownService: any;
  DOMParser?: typeof window.DOMParser;
  document?: Document;
}

export class UniversalMarkdownConverter {
  private turndownService: ITurndownService | null = null;
  private readonly semanticSelectors: ISemanticSelectors;
  private _isInitialized: boolean = false;
  private context: IEnvironmentContext;

  constructor() {
    this.semanticSelectors = {
      callouts: ['.callout', '.note', '.warning', '.info', '.alert', '.notice', '[role="note"]'],
      quotes: ['blockquote', '.quote', '.pullquote', '[role="blockquote"]'],
      highlights: ['.highlight', '.featured', '.important', 'mark', '.marker'],
      captions: ['figcaption', '.caption', '.image-caption', '.photo-caption'],
      metadata: ['.byline', '.author', '.date', '.timestamp', '.published', '.updated'],
      codeElements: ['code', 'pre', '.code', '.highlight', '.syntax'],
    };

    this.context = this.detectEnvironment();
    this.initializeTurndown();
  }

  private detectEnvironment(): IEnvironmentContext {
    const isNode = typeof process !== 'undefined' && process.versions?.node;
    const isBrowser = typeof window !== 'undefined';
    const isServiceWorker = typeof importScripts === 'function' && typeof window === 'undefined';

    let turndownService = null;
    let DOMParser = null;
    let document = null;

    if (isNode) {
      // Node.js environment - import turndown and jsdom
      try {
        const TurndownService = require('turndown');
        turndownService = TurndownService;

        const { JSDOM } = require('jsdom');
        const dom = new JSDOM('<!DOCTYPE html><html><body></body></html>');
        DOMParser = dom.window.DOMParser;
        document = dom.window.document;
      } catch (error) {
        console.warn('UniversalMarkdownConverter: Failed to load Node.js dependencies:', error);
      }
    } else if (isBrowser) {
      // Browser environment
      turndownService = (window as any).TurndownService;
      DOMParser = window.DOMParser;
      document = window.document;
    } else if (isServiceWorker) {
      // Service worker - should not initialize here
      console.warn(
        'UniversalMarkdownConverter: Service worker context detected - conversion not supported'
      );
    }

    return {
      isNode: !!isNode,
      isBrowser: !!isBrowser,
      isServiceWorker: !!isServiceWorker,
      turndownService,
      DOMParser,
      document,
    };
  }

  private initializeTurndown(): void {
    if (this.context.isServiceWorker) {
      console.warn('UniversalMarkdownConverter: Cannot initialize in service worker context');
      return;
    }

    if (!this.context.turndownService) {
      console.error(
        'UniversalMarkdownConverter: TurndownService not available in current environment'
      );
      return;
    }

    this.setupTurndownService();
    this._isInitialized = true;
    console.info(
      'UniversalMarkdownConverter: Initialized successfully in',
      this.context.isNode ? 'Node.js' : 'Browser',
      'environment'
    );
  }

  private setupTurndownService(): void {
    if (!this.context.turndownService) {
      this.turndownService = null;
      return;
    }

    console.info('UniversalMarkdownConverter: Initializing TurndownService with enhanced rules');

    // Initialize Turndown service with enhanced custom rules
    this.turndownService = new this.context.turndownService({
      headingStyle: 'atx',
      bulletListMarker: '-',
      codeBlockStyle: 'fenced',
      emDelimiter: '*',
      strongDelimiter: '**',
      linkStyle: 'inlined',
      linkReferenceStyle: 'full',
      preformattedCode: true,
      blankReplacement: function (content: string, node: any): string {
        return node.isBlock ? '\n\n' : '';
      },
      keepReplacement: function (content: string, node: any): string {
        return node.isBlock ? '\n\n' + node.outerHTML + '\n\n' : node.outerHTML;
      },
    });

    this.addCustomTurndownRules();
  }

  private addCustomTurndownRules(): void {
    if (!this.turndownService) return;

    // Line number removal rule - handle HTML structures with line numbers
    this.turndownService.addRule('removeLineNumbers', {
      filter: (node: any): boolean => {
        if (node.nodeType === 1) {
          const className = (node.className || '').toLowerCase();
          const id = (node.id || '').toLowerCase();

          const lineNumberPatterns = [
            'line-number',
            'linenumber',
            'line-num',
            'linenum',
            'gutter',
            'line-gutter',
            'hljs-ln-numbers',
            'hljs-ln-line',
            'code-line-number',
            'ln-',
            'line-',
          ];

          return lineNumberPatterns.some(
            pattern => className.includes(pattern) || id.includes(pattern)
          );
        }
        return false;
      },
      replacement: (): string => {
        return '';
      },
    });

    // Code table rule - handle tables used for displaying code with line numbers
    this.turndownService.addRule('codeTable', {
      filter: (node: any): boolean => {
        if (node.nodeName === 'TABLE') {
          const hasCodeStructure = node.querySelector('td > pre, td > code, .hljs, .highlight');
          const hasLineNumbers = node.querySelector('.line-number, .gutter, .hljs-ln');
          return !!(hasCodeStructure || hasLineNumbers);
        }
        return false;
      },
      replacement: (content: string, node: any): string => {
        const codeContent = this.extractCodeFromTable(node);
        return codeContent ? '\n\n```\n' + codeContent + '\n```\n\n' : content;
      },
    });

    // Enhanced blockquote rule
    this.turndownService.addRule('enhancedBlockquote', {
      filter: this.semanticSelectors.quotes,
      replacement: (content: string, node: any): string => {
        const citation = node.querySelector('cite, .citation, .author');
        const citationText = citation ? `\n\nâ€” ${citation.textContent?.trim()}` : '';
        return '\n\n> ' + content.trim().replace(/\n/g, '\n> ') + citationText + '\n\n';
      },
    });

    // Callout/Note enhancement
    this.turndownService.addRule('callouts', {
      filter: this.semanticSelectors.callouts,
      replacement: (content: string, node: any): string => {
        const calloutType = this.getCalloutType(node);
        return `\n\n> **${calloutType}**: ${content.trim()}\n\n`;
      },
    });

    // Figure and caption handling
    this.turndownService.addRule('figures', {
      filter: 'figure',
      replacement: (content: string, node: any): string => {
        const img = node.querySelector('img');
        const caption = node.querySelector('figcaption, .caption');

        if (img && caption) {
          const imgMarkdown = `![${img.alt || ''}](${img.src})`;
          const captionText = caption.textContent?.trim();
          return `\n\n${imgMarkdown}\n*${captionText}*\n\n`;
        }
        return content;
      },
    });
  }

  private extractCodeFromTable(tableNode: any): string {
    const codeRows = Array.from(tableNode.querySelectorAll('tr'));
    return codeRows
      .map((row: any) => {
        const codeCells = Array.from(row.querySelectorAll('td')).filter(
          (cell: any) => !this.isLineNumberCell(cell)
        );
        return codeCells.map((cell: any) => cell.textContent || '').join('');
      })
      .join('\n')
      .trim();
  }

  private isLineNumberCell(cell: any): boolean {
    const className = (cell.className || '').toLowerCase();
    const textContent = (cell.textContent || '').trim();

    // Check if cell contains only numbers or line number patterns
    const isNumericOnly = /^\d+$/.test(textContent);
    const hasLineNumberClass =
      className.includes('line') || className.includes('number') || className.includes('gutter');

    return isNumericOnly || hasLineNumberClass;
  }

  private getCalloutType(node: any): string {
    const className = (node.className || '').toLowerCase();
    const classList = className.split(' ');

    for (const cls of classList) {
      if (['warning', 'warn'].includes(cls)) return 'Warning';
      if (['error', 'danger'].includes(cls)) return 'Error';
      if (['info', 'information'].includes(cls)) return 'Info';
      if (['note', 'notes'].includes(cls)) return 'Note';
      if (['tip', 'tips'].includes(cls)) return 'Tip';
      if (['important', 'important-note'].includes(cls)) return 'Important';
    }

    return 'Note';
  }

  async convertToMarkdown(
    html: string,
    metadata: IDocumentMetadata,
    options: IConversionOptions = {}
  ): Promise<IConversionResult> {
    if (!this._isInitialized || !this.turndownService) {
      throw new Error('UniversalMarkdownConverter not properly initialized');
    }

    console.info('UniversalMarkdownConverter: Starting conversion process');

    try {
      // Preprocess HTML
      const preprocessedHtml = this.preprocessHtml(html, options);

      // Convert to markdown using Turndown
      const rawMarkdown = this.turndownService.turndown(preprocessedHtml);

      // Post-process markdown
      const processedMarkdown = this.postprocessMarkdown(rawMarkdown, options);

      // Extract images
      const images = this.extractImages(html);

      // Generate frontmatter if requested
      const frontmatter = options.generateFrontmatter ? this.generateFrontmatter(metadata) : '';

      // Count words
      const wordCount = this.countWords(processedMarkdown);

      const result: IConversionResult = {
        markdown: processedMarkdown,
        frontmatter,
        metadata,
        images,
        wordCount,
      };

      console.info('UniversalMarkdownConverter: Conversion completed successfully');
      return result;
    } catch (error) {
      console.error('UniversalMarkdownConverter: Conversion failed:', error);
      throw error;
    }
  }

  private preprocessHtml(html: string, options: IConversionOptions): string {
    if (!this.context.DOMParser) {
      console.warn('DOMParser not available, returning original HTML');
      return html;
    }

    const parser = new this.context.DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    const body = doc.body || doc.documentElement;

    // Remove unwanted elements
    this.removeUnwantedElements(body);

    // Normalize whitespace
    this.normalizeWhitespace(body);

    // Enhance semantic structure
    this.enhanceSemanticStructure(body);

    return body.innerHTML;
  }

  private removeUnwantedElements(element: Element): void {
    const unwantedSelectors = [
      'script',
      'style',
      'noscript',
      'iframe',
      'embed',
      'object',
      '.advertisement',
      '.ad',
      '.ads',
      '.sponsor',
      '.promotion',
      '.sidebar',
      '.widget',
      '.social-share',
      '.comments',
      '.navigation',
      '.nav',
      '.menu',
      '.header',
      '.footer',
      '[role="banner"]',
      '[role="navigation"]',
      '[role="complementary"]',
      '.line-number',
      '.line-numbers',
      '.hljs-ln-numbers',
    ];

    unwantedSelectors.forEach(selector => {
      const elements = element.querySelectorAll(selector);
      elements.forEach(el => el.remove());
    });
  }
  private normalizeWhitespace(element: Element): void {
    const walker = element.ownerDocument?.createTreeWalker(element, NodeFilter.SHOW_TEXT, null);

    if (!walker) return;

    const textNodes: Text[] = [];
    let node;
    while ((node = walker.nextNode())) {
      textNodes.push(node as Text);
    }

    textNodes.forEach(textNode => {
      if (textNode.textContent) {
        textNode.textContent = textNode.textContent.replace(/\s+/g, ' ');
      }
    });
  }

  private enhanceSemanticStructure(element: Element): void {
    // Add semantic meaning to code blocks
    const codeBlocks = element.querySelectorAll('pre code, .highlight code, .hljs');
    codeBlocks.forEach((block: any) => {
      const language = this.extractLanguageFromClass(block.className);
      if (language && !block.dataset.language) {
        block.dataset.language = language;
      }
    });
  }

  private postprocessMarkdown(markdown: string, options: IConversionOptions): string {
    let processed = markdown;

    // Clean up extra whitespace
    processed = processed.replace(/\n{3,}/g, '\n\n');
    processed = processed.replace(/[ \t]+$/gm, '');

    // Fix code block formatting
    processed = processed.replace(/```(\w+)?\n\n+/g, '```$1\n');
    processed = processed.replace(/\n\n+```/g, '\n```');

    // Clean up list formatting
    processed = processed.replace(/(\n- .+)\n\n(\n- )/g, '$1$2');

    // Remove empty emphasis
    processed = processed.replace(/\*\*\s*\*\*/g, '');
    processed = processed.replace(/\*\s*\*/g, '');

    return processed.trim();
  }

  private extractLanguageFromClass(className: string): string {
    if (!className) return '';

    const patterns = [
      /language-(\w+)/,
      /lang-(\w+)/,
      /highlight-(\w+)/,
      /(\w+)-code/,
      /hljs-(\w+)/,
    ];

    for (const pattern of patterns) {
      const match = className.match(pattern);
      if (match) return match[1];
    }

    return '';
  }

  private extractImages(html: string): IImageAsset[] {
    if (!this.context.DOMParser) return [];

    const parser = new this.context.DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    const images = doc.querySelectorAll('img');

    return Array.from(images).map((img: any, index) => ({
      url: img.src,
      filename: this.generateImageFilename(img.src, index),
      alt: img.alt || '',
      title: img.title || '',
      mimeType: this.getMimeTypeFromUrl(img.src),
      size: img.width && img.height ? { width: img.width, height: img.height } : undefined,
    }));
  }

  private generateImageFilename(url: string, index: number): string {
    try {
      const urlObj = new URL(url);
      const pathname = urlObj.pathname;
      const filename = pathname.split('/').pop() || `image-${index}`;
      return filename.includes('.') ? filename : `${filename}.jpg`;
    } catch {
      return `image-${index}.jpg`;
    }
  }

  private getMimeTypeFromUrl(url: string): string {
    const extension = url.split('.').pop()?.toLowerCase();
    const mimeTypes: Record<string, string> = {
      jpg: 'image/jpeg',
      jpeg: 'image/jpeg',
      png: 'image/png',
      gif: 'image/gif',
      webp: 'image/webp',
      svg: 'image/svg+xml',
    };
    return mimeTypes[extension || ''] || 'image/jpeg';
  }

  private generateFrontmatter(metadata: IDocumentMetadata): string {
    const yaml = Object.entries(metadata)
      .filter(([_, value]) => value !== undefined && value !== null && value !== '')
      .map(([key, value]) => {
        if (Array.isArray(value)) {
          return `${key}:\n${value.map(v => `  - ${v}`).join('\n')}`;
        }
        return `${key}: ${JSON.stringify(value)}`;
      })
      .join('\n');

    return yaml ? `---\n${yaml}\n---\n\n` : '';
  }

  private countWords(text: string): number {
    return text
      .replace(/[^\w\s]/g, '')
      .split(/\s+/)
      .filter(word => word.length > 0).length;
  }

  // Public utility methods
  cleanMarkdown(markdown: string): string {
    return this.postprocessMarkdown(markdown, {});
  }

  validateMarkdown(markdown: string): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Check for unclosed code blocks
    const codeBlockMatches = markdown.match(/```/g);
    if (codeBlockMatches && codeBlockMatches.length % 2 !== 0) {
      errors.push('Unclosed code block detected');
    }

    // Check for malformed links
    const malformedLinks = markdown.match(/\[([^\]]*)\]\([^)]*$/gm);
    if (malformedLinks) {
      errors.push('Malformed links detected');
    }

    return {
      isValid: errors.length === 0,
      errors,
    };
  }

  getMarkdownStats(markdown: string): {
    words: number;
    characters: number;
    headings: number;
    links: number;
    images: number;
    codeBlocks: number;
  } {
    return {
      words: this.countWords(markdown),
      characters: markdown.length,
      headings: (markdown.match(/^#+\s/gm) || []).length,
      links: (markdown.match(/\[([^\]]*)\]\([^)]*\)/g) || []).length,
      images: (markdown.match(/!\[([^\]]*)\]\([^)]*\)/g) || []).length,
      codeBlocks: (markdown.match(/```/g) || []).length / 2,
    };
  }

  get isInitialized(): boolean {
    return this._isInitialized;
  }

  get environmentInfo(): IEnvironmentContext {
    return { ...this.context };
  }
}

// Export for both CommonJS and ES modules
export default UniversalMarkdownConverter;
