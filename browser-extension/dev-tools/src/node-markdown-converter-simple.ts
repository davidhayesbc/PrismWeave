// Generated by Copilot
// Node.js wrapper for PrismWeave Markdown Converter
// Uses the exact same core logic as the browser extension

import { JSDOM } from 'jsdom';
import TurndownService from 'turndown';
import { IDocumentMetadata, IImageAsset } from '../../src/types/index.js';
import {
  IConversionOptions,
  IConversionResult,
  MarkdownConverterCore,
} from '../../src/utils/markdown-converter-core.js';

export class NodeMarkdownConverter extends MarkdownConverterCore {
  private currentJSDOM: JSDOM | null = null;

  constructor() {
    super();
    this.initializeForNode();
  }

  private initializeForNode(): void {
    try {
      // Initialize TurndownService for Node.js environment
      // Cast to the interface expected by the core
      this.turndownService = new TurndownService() as any;

      // Set up all the rules using the core logic
      this.setupTurndownService();
      this._isInitialized = true;

      console.info('NodeMarkdownConverter: Initialized successfully');
    } catch (error) {
      console.error('NodeMarkdownConverter: Failed to initialize:', error);
      this._isInitialized = false;
      throw error;
    }
  }

  // Override to handle JSDOM setup for Node.js environment
  public convertToMarkdown(html: string, options: IConversionOptions = {}): IConversionResult {
    if (!this._isInitialized || !this.turndownService) {
      throw new Error('NodeMarkdownConverter not properly initialized');
    }

    try {
      // Create JSDOM instance for DOM parsing
      this.currentJSDOM = new JSDOM(html, {
        url: 'http://localhost',
        contentType: 'text/html',
        includeNodeLocations: false,
        storageQuota: 10000000,
      });

      // Set up global document for the core methods that need DOM access
      const originalDocument = (global as any).document;
      const originalWindow = (global as any).window;

      (global as any).document = this.currentJSDOM.window.document;
      (global as any).window = this.currentJSDOM.window;

      try {
        // Use the core conversion logic - this will use all the same rules as the browser extension
        return super.convertToMarkdown(html, options);
      } finally {
        // Restore original globals
        if (originalDocument) {
          (global as any).document = originalDocument;
        } else {
          delete (global as any).document;
        }

        if (originalWindow) {
          (global as any).window = originalWindow;
        } else {
          delete (global as any).window;
        }

        // Clean up JSDOM
        if (this.currentJSDOM) {
          this.currentJSDOM.window.close();
          this.currentJSDOM = null;
        }
      }
    } catch (error) {
      console.error('NodeMarkdownConverter: Conversion failed:', error);
      throw error;
    }
  }

  // Convenience method for testing with URLs
  public async convertUrl(
    url: string,
    options: IConversionOptions = {}
  ): Promise<IConversionResult & { url: string; originalHtml: string }> {
    const fetch = (await import('node-fetch')).default;

    try {
      console.info(`Fetching URL: ${url}`);
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Failed to fetch ${url}: ${response.status} ${response.statusText}`);
      }

      const html = await response.text();
      console.info(`Fetched ${html.length} characters from ${url}`);

      const result = this.convertToMarkdown(html, options);

      // Update metadata with actual URL
      result.metadata.url = url;

      return {
        ...result,
        url,
        originalHtml: html,
      };
    } catch (error) {
      console.error(`NodeMarkdownConverter: Failed to convert URL ${url}:`, error);
      throw error;
    }
  }
}

// Re-export interfaces for convenience
export { IConversionOptions, IConversionResult, IDocumentMetadata, IImageAsset };
