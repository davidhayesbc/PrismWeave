// Generated by Copilot
// Node.js wrapper for PrismWeave Markdown Converter
// Uses the exact same core logic as the browser extension with ZERO duplication

import { JSDOM } from 'jsdom';
import fetch from 'node-fetch';
import TurndownService from 'turndown';

// Re-export interfaces from the core for convenience
interface IConversionOptions {
  preserveFormatting?: boolean;
  includeMetadata?: boolean;
  generateFrontmatter?: boolean;
  customRules?: Record<string, unknown>;
  headingStyle?: 'atx' | 'setext';
  bulletListMarker?: '-' | '*' | '+';
  codeBlockStyle?: 'fenced' | 'indented';
  linkStyle?: 'inlined' | 'referenced';
}

interface IConversionResult {
  markdown: string;
  frontmatter: string;
  metadata: any;
  images: any[];
  wordCount: number;
}

export class NodeMarkdownConverter {
  private core: any = null;
  private contentExtractor: any = null;
  private _isInitialized: boolean = false;

  constructor() {
    // Don't initialize in constructor - make it lazy
  }

  private async initializeForNode(): Promise<void> {
    try {
      // Dynamic import of the core class and content extractor from browser extension
      const { MarkdownConverterCore } = await import(
        '@browser-extension/utils/markdown-converter-core.js'
      );
      const { ContentExtractor } = await import('@browser-extension/utils/content-extractor.js');

      // Create instances
      this.core = new MarkdownConverterCore();
      this.contentExtractor = new ContentExtractor();

      // Initialize TurndownService for Node.js environment
      this.core.turndownService = new TurndownService() as any;

      // Call the protected setup method from the core
      this.core.setupTurndownService();
      this.core._isInitialized = true;

      this._isInitialized = true;

      console.info('NodeMarkdownConverter: Initialized successfully with content extraction');
    } catch (error) {
      console.error('NodeMarkdownConverter: Failed to initialize:', error);
      this._isInitialized = false;
      throw error;
    }
  }

  // Ensure initialization before any operation
  private async ensureInitialized(): Promise<void> {
    if (!this._isInitialized) {
      await this.initializeForNode();
    }
  }

  // Public method for URL conversion
  public async convertUrl(
    url: string,
    options: IConversionOptions = {}
  ): Promise<IConversionResult> {
    await this.ensureInitialized();

    try {
      console.log(`Fetching URL: ${url}`);

      // Fetch the HTML content
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const html = await response.text();
      console.log(`Fetched ${html.length} characters of HTML`);

      // Convert using the wrapper method that handles JSDOM
      return this.convertHtmlWithDOM(html, options);
    } catch (error) {
      console.error('Error converting URL:', error);
      throw error;
    }
  }

  // Main conversion method that handles DOM setup for Node.js
  public async convertHtmlWithDOM(
    html: string,
    options: IConversionOptions = {}
  ): Promise<IConversionResult> {
    await this.ensureInitialized();

    if (!this._isInitialized || !this.core || !this.contentExtractor) {
      throw new Error('NodeMarkdownConverter not properly initialized');
    }

    // Create JSDOM instance for DOM parsing
    const dom = new JSDOM(html, {
      url: 'http://localhost',
      contentType: 'text/html',
      pretendToBeVisual: false,
      resources: undefined, // Don't load external resources (CSS, images, etc.)
      runScripts: 'outside-only', // Only run scripts we inject, not page scripts
    });

    // Set up global DOM environment for the core converter
    const originalDocument = global.document;
    const originalWindow = global.window;
    const originalElement = global.Element;
    const originalDOMParser = global.DOMParser;

    try {
      // Temporarily set JSDOM globals
      global.document = dom.window.document;
      global.window = dom.window as any;
      global.Element = dom.window.Element;
      global.DOMParser = dom.window.DOMParser;

      // CRITICAL FIX: Extract content first, just like the browser extension
      console.log('Extracting main content from HTML...');
      const extractedContent = await this.contentExtractor.extractContent({
        preserveFormatting: options.preserveFormatting || true,
        removeAds: true,
        removeNavigation: true,
      });

      // Use the extracted content, not the full HTML
      const htmlContent = extractedContent.content || extractedContent.cleanedContent || html;
      console.log(`Content extraction completed: ${htmlContent.length} chars`);

      // Build metadata from both extraction and document
      const pageMetadata = {
        title: dom.window.document.title || 'Untitled',
        url: 'extracted-content',
        ...extractedContent.metadata,
      };

      // Now call the core conversion method with extracted content
      const result = this.core.convertToMarkdown(htmlContent, {
        ...options,
        generateFrontmatter: true,
        includeMetadata: true,
      });

      // Enhance the result with extracted metadata
      result.metadata = {
        ...result.metadata,
        ...pageMetadata,
        extractedAt: new Date().toISOString(),
        extractionMethod: 'node-content-extractor',
      };

      return result;
    } catch (error) {
      console.error('NodeMarkdownConverter: Conversion failed:', error);
      throw error;
    } finally {
      // Restore original globals
      if (originalDocument) global.document = originalDocument;
      if (originalWindow) global.window = originalWindow;
      if (originalElement) global.Element = originalElement;
      if (originalDOMParser) global.DOMParser = originalDOMParser;
    }
  }

  // For direct HTML conversion (legacy compatibility)
  public async convertToMarkdown(
    html: string,
    options: IConversionOptions = {}
  ): Promise<IConversionResult> {
    // Check if we're in a proper DOM environment
    if (typeof document === 'undefined' || typeof DOMParser === 'undefined') {
      // If not, use the DOM setup wrapper
      return this.convertHtmlWithDOM(html, options);
    }

    await this.ensureInitialized();

    // If DOM is available, use the core method directly
    return this.core.convertToMarkdown(html, options);
  }

  get isInitialized(): boolean {
    return this._isInitialized;
  }
}

export type { IConversionOptions, IConversionResult };
