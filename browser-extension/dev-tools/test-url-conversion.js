#!/usr/bin/env node
// Generated by Copilot
// URL-based testing tool for PrismWeave markdown conversion
// Fetches a URL, converts to markdown, and saves results for comparison
import chalk from 'chalk';
import fs from 'fs-extra';
import { JSDOM } from 'jsdom';
import fetch from 'node-fetch';
import path from 'path';
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';
import { UniversalMarkdownConverter } from './src/universal-markdown-converter.js';
class UrlTester {
    converter;
    outputDir;
    constructor(outputDir = './test-outputs') {
        this.converter = new UniversalMarkdownConverter();
        this.outputDir = path.resolve(outputDir);
    }
    async testUrl(options) {
        const startTime = Date.now();
        console.log(chalk.blue(`üåê Fetching URL: ${options.url}`));
        try {
            // Fetch the URL
            const response = await fetch(options.url, {
                headers: {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                },
            });
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            const html = await response.text();
            console.log(chalk.green(`‚úì Fetched ${html.length} characters`));
            // Extract metadata from HTML
            const metadata = this.extractMetadata(html, options.url);
            if (options.verbose) {
                console.log(chalk.cyan('üìä Extracted metadata:'), metadata);
            }
            // Convert to markdown
            console.log(chalk.blue('üîÑ Converting to markdown...'));
            const conversionResult = await this.converter.convertToMarkdown(html, metadata, {
                preserveFormatting: options.preserveFormatting,
                includeMetadata: options.includeMetadata,
                generateFrontmatter: options.generateFrontmatter,
            });
            const conversionTime = Date.now() - startTime;
            console.log(chalk.green(`‚úì Conversion completed in ${conversionTime}ms`));
            // Get markdown stats
            const stats = this.converter.getMarkdownStats(conversionResult.markdown);
            const testResult = {
                url: options.url,
                timestamp: new Date().toISOString(),
                originalHtml: html,
                cleanedHtml: '', // Will be set if needed
                markdown: conversionResult.markdown,
                frontmatter: conversionResult.frontmatter,
                metadata: conversionResult.metadata,
                images: conversionResult.images,
                stats,
                conversionTime,
            };
            // Save results
            await this.saveResults(testResult, options);
            // Display stats
            this.displayStats(testResult);
            return testResult;
        }
        catch (error) {
            console.error(chalk.red('‚ùå Error during conversion:'), error);
            throw error;
        }
    }
    extractMetadata(html, url) {
        const dom = new JSDOM(html);
        const document = dom.window.document;
        const metadata = {
            url,
            title: '',
            description: '',
            author: '',
            publishedDate: '',
            canonical: url,
            language: 'en',
        };
        // Extract title
        const titleElement = document.querySelector('title') ||
            document.querySelector('h1') ||
            document.querySelector('meta[property="og:title"]');
        if (titleElement) {
            metadata.title =
                titleElement.textContent?.trim() || titleElement.getAttribute('content')?.trim() || '';
        }
        // Extract description
        const descriptionElement = document.querySelector('meta[name="description"]') ||
            document.querySelector('meta[property="og:description"]');
        if (descriptionElement) {
            metadata.description = descriptionElement.getAttribute('content')?.trim() || '';
        }
        // Extract author
        const authorElement = document.querySelector('meta[name="author"]') ||
            document.querySelector('meta[property="article:author"]') ||
            document.querySelector('.author, .byline');
        if (authorElement) {
            metadata.author =
                authorElement.getAttribute('content')?.trim() || authorElement.textContent?.trim() || '';
        }
        // Extract published date
        const dateElement = document.querySelector('meta[property="article:published_time"]') ||
            document.querySelector('meta[name="date"]') ||
            document.querySelector('time[datetime]') ||
            document.querySelector('.date, .published');
        if (dateElement) {
            metadata.publishedDate =
                dateElement.getAttribute('content') ||
                    dateElement.getAttribute('datetime') ||
                    dateElement.textContent?.trim() ||
                    '';
        }
        // Extract canonical URL
        const canonicalElement = document.querySelector('link[rel="canonical"]');
        if (canonicalElement) {
            metadata.canonical = canonicalElement.getAttribute('href') || url;
        }
        // Extract language
        const htmlElement = document.querySelector('html[lang]');
        if (htmlElement) {
            metadata.language = htmlElement.getAttribute('lang') || 'en';
        }
        return metadata;
    }
    async saveResults(result, options) {
        // Create output directory
        await fs.ensureDir(this.outputDir);
        // Generate filename from URL
        const urlObj = new URL(result.url);
        const hostname = urlObj.hostname.replace(/[^a-zA-Z0-9]/g, '-');
        const pathname = urlObj.pathname.replace(/[^a-zA-Z0-9]/g, '-').substring(0, 50);
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const baseFilename = `${hostname}${pathname}-${timestamp}`;
        if (options.format === 'all' || options.format === 'html' || !options.format) {
            // Save original HTML
            const htmlPath = path.join(this.outputDir, `${baseFilename}.html`);
            await fs.writeFile(htmlPath, result.originalHtml, 'utf8');
            console.log(chalk.gray(`üíæ Saved HTML: ${htmlPath}`));
        }
        if (options.format === 'all' || options.format === 'markdown' || !options.format) {
            // Save markdown
            const markdownContent = result.frontmatter + result.markdown;
            const markdownPath = path.join(this.outputDir, `${baseFilename}.md`);
            await fs.writeFile(markdownPath, markdownContent, 'utf8');
            console.log(chalk.gray(`üíæ Saved Markdown: ${markdownPath}`));
        }
        // Save test result metadata
        const metadataPath = path.join(this.outputDir, `${baseFilename}.json`);
        await fs.writeFile(metadataPath, JSON.stringify(result, null, 2), 'utf8');
        console.log(chalk.gray(`üíæ Saved metadata: ${metadataPath}`));
    }
    displayStats(result) {
        console.log(chalk.yellow('\nüìä Conversion Statistics:'));
        console.log(`   Words: ${result.stats.words}`);
        console.log(`   Characters: ${result.stats.characters}`);
        console.log(`   Headings: ${result.stats.headings}`);
        console.log(`   Links: ${result.stats.links}`);
        console.log(`   Images: ${result.stats.images}`);
        console.log(`   Code blocks: ${result.stats.codeBlocks}`);
        console.log(`   Conversion time: ${result.conversionTime}ms`);
        if (result.images.length > 0) {
            console.log(chalk.yellow('\nüñºÔ∏è  Images found:'));
            result.images.forEach((img, index) => {
                console.log(`   ${index + 1}. ${img.filename} (${img.alt || 'no alt text'})`);
            });
        }
    }
}
// CLI interface
const argv = yargs(hideBin(process.argv))
    .usage('Usage: $0 <url> [options]')
    .command('$0 <url>', 'Test markdown conversion for a URL', yargs => {
    return yargs.positional('url', {
        describe: 'URL to fetch and convert',
        type: 'string',
        demandOption: true,
    });
})
    .option('output', {
    alias: 'o',
    type: 'string',
    description: 'Output directory for results',
    default: './test-outputs',
})
    .option('format', {
    alias: 'f',
    type: 'string',
    choices: ['all', 'markdown', 'html'],
    description: 'Output format',
    default: 'all',
})
    .option('metadata', {
    alias: 'm',
    type: 'boolean',
    description: 'Include metadata in conversion',
    default: true,
})
    .option('frontmatter', {
    type: 'boolean',
    description: 'Generate YAML frontmatter',
    default: true,
})
    .option('preserve', {
    alias: 'p',
    type: 'boolean',
    description: 'Preserve formatting',
    default: true,
})
    .option('verbose', {
    alias: 'v',
    type: 'boolean',
    description: 'Verbose output',
    default: false,
})
    .help()
    .parseSync();
// Main execution
async function main() {
    try {
        console.log(chalk.green('üöÄ PrismWeave URL Tester\n'));
        const tester = new UrlTester(argv.output);
        const options = {
            url: argv.url,
            output: argv.output,
            format: argv.format,
            includeMetadata: argv.metadata,
            preserveFormatting: argv.preserve,
            generateFrontmatter: argv.frontmatter,
            verbose: argv.verbose,
        };
        await tester.testUrl(options);
        console.log(chalk.green('\n‚úÖ Test completed successfully!'));
    }
    catch (error) {
        console.error(chalk.red('\n‚ùå Test failed:'), error);
        process.exit(1);
    }
}
// Export for programmatic use
export { UrlTester };
// Run main function
main().catch(console.error);
