#!/usr/bin/env node

// Generated by Copilot
// PrismWeave Dev Tools - Direct import from browser extension (NO CODE DUPLICATION)
// This file uses the EXACT same files as the browser extension

import chalk from 'chalk';
import { mkdir, writeFile } from 'fs/promises';
import { dirname, join } from 'path';
import { fileURLToPath } from 'url';

// Import DIRECTLY from browser extension - zero duplication
import type { IDocumentMetadata, IImageAsset } from '../src/types/index.js';
import { MarkdownConverterCore } from '../src/utils/markdown-converter-core.js';

// Import TurndownService
import { JSDOM } from 'jsdom';
import fetch from 'node-fetch';
import TurndownService from 'turndown';

const __dirname = dirname(fileURLToPath(import.meta.url));

interface IConversionOptions {
  preserveFormatting?: boolean;
  includeMetadata?: boolean;
  generateFrontmatter?: boolean;
  customRules?: Record<string, unknown>;
  headingStyle?: 'atx' | 'setext';
  bulletListMarker?: '-' | '*' | '+';
  codeBlockStyle?: 'fenced' | 'indented';
  linkStyle?: 'inlined' | 'referenced';
}

interface IConversionResult {
  markdown: string;
  frontmatter: string;
  metadata: IDocumentMetadata;
  images: IImageAsset[];
  wordCount: number;
}

// Node.js wrapper that extends the exact browser extension core
class NodeMarkdownConverter extends MarkdownConverterCore {
  constructor() {
    super();
    this.initializeForNode();
  }

  private initializeForNode(): void {
    // Initialize TurndownService for Node.js environment
    const turndownService = new TurndownService({
      headingStyle: 'atx',
      hr: '---',
      bulletListMarker: '-',
      codeBlockStyle: 'fenced',
      linkStyle: 'inlined',
      emDelimiter: '_',
      strongDelimiter: '**',
    });

    // Apply the exact same rules as the browser extension
    this.turndownService = turndownService as any;
    this.setupTurndownRules();
    this._isInitialized = true;
  }

  async convertUrl(url: string, options: IConversionOptions = {}): Promise<IConversionResult> {
    try {
      console.log(chalk.blue(`üåê Fetching: ${url}`));

      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const html = await response.text();
      console.log(chalk.green(`‚úÖ Fetched ${html.length} characters`));

      // Create JSDOM environment
      const dom = new JSDOM(html, { url });
      global.document = dom.window.document;
      global.window = dom.window as any;
      global.location = dom.window.location;

      try {
        // Use the exact same conversion method as browser extension
        const result = await this.convertContent(dom.window.document.documentElement, options);
        return result;
      } finally {
        // Cleanup globals
        delete global.document;
        delete global.window;
        delete global.location;
      }
    } catch (error) {
      throw new Error(`Failed to convert URL ${url}: ${error.message}`);
    }
  }
}

class DevToolsTester {
  constructor() {
    this.converter = new NodeMarkdownConverter();
    this.outputDir = join(__dirname, 'test-outputs');
  }

  async testUrl(url: string): Promise<void> {
    const startTime = Date.now();

    try {
      console.log(chalk.blue(`\nüîÑ Testing URL: ${url}`));
      console.log(chalk.gray('Using EXACT browser extension code (zero duplication)\n'));

      // Create output directory
      await mkdir(this.outputDir, { recursive: true });

      // Convert using the exact same core logic
      const result = await this.converter.convertUrl(url, {
        generateFrontmatter: true,
        includeMetadata: true,
        preserveFormatting: true,
      });

      const conversionTime = Date.now() - startTime;

      // Generate filename
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const urlSlug = url
        .replace(/[^a-zA-Z0-9]/g, '-')
        .replace(/-+/g, '-')
        .slice(0, 50);
      const filename = `${urlSlug}--${timestamp}.md`;
      const outputPath = join(this.outputDir, filename);

      // Combine frontmatter and markdown
      const output = result.frontmatter + result.markdown;

      // Save file
      await writeFile(outputPath, output, 'utf-8');

      // Display results
      console.log(chalk.green('‚úÖ Conversion completed successfully!'));
      console.log(chalk.cyan(`‚è±Ô∏è  Conversion time: ${conversionTime}ms`));
      console.log(chalk.cyan(`üìù Word count: ${result.wordCount}`));
      console.log(chalk.cyan(`üñºÔ∏è  Images found: ${result.images.length}`));
      console.log(chalk.cyan(`üìÑ Output saved: ${filename}`));

      if (result.metadata.title) {
        console.log(chalk.yellow(`üìã Title: ${result.metadata.title}`));
      }
    } catch (error) {
      console.error(chalk.red(`‚ùå Error: ${error.message}`));
      process.exit(1);
    }
  }
}

// Main execution
async function main() {
  const url = process.argv[2];

  if (!url) {
    console.error(chalk.red('‚ùå Please provide a URL'));
    console.log(chalk.gray('Usage: npm run test-url "https://example.com"'));
    process.exit(1);
  }

  const tester = new DevToolsTester();
  await tester.testUrl(url);
}

if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch(console.error);
}
