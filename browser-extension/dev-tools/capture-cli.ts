#!/usr/bin/env node

// Generated by Copilot
// Simple CLI tool for capturing web pages using PrismWeave algorithms
// Usage: npm run capture <url>
// Uses the same algorithms as the browser extension but adapted for Node.js

import chalk from 'chalk';
import { mkdirSync, writeFileSync } from 'fs';
import { JSDOM } from 'jsdom';
import fetch from 'node-fetch';
import { join } from 'path';

interface ICaptureResult {
  html: string;
  markdown: string;
  metadata: any;
  filename: string;
}

interface IDocumentMetadata {
  title: string;
  url: string;
  captureDate: string;
  tags: string[];
  author?: string;
  wordCount?: number;
  estimatedReadingTime?: number;
}

// Simplified content extractor based on browser extension algorithms
class SimpleContentExtractor {
  private readonly contentSelectors = [
    'article',
    'main',
    '[role="main"]',
    '.content',
    '.post',
    '.entry',
    '#content',
    '#main',
    '.main-content',
    '.article-content',
    '.post-content',
  ];

  private readonly unwantedSelectors = [
    'script',
    'style',
    'nav',
    'header',
    'footer',
    '.advertisement',
    '.ad',
    '.popup',
    '.modal',
    '.sidebar',
    '.menu',
    '.navigation',
  ];

  extractContent(): {
    content: string;
    metadata: IDocumentMetadata;
    wordCount: number;
    readingTime: number;
  } {
    // Find main content
    let contentElement = this.findMainContent();
    if (!contentElement) {
      contentElement = document.body;
    }

    // Clean content
    const cleanedContent = this.cleanContent(contentElement);

    // Extract metadata
    const metadata = this.extractMetadata();

    // Calculate stats
    const text = cleanedContent.textContent || '';
    const wordCount = this.calculateWordCount(text);
    const readingTime = Math.ceil(wordCount / 200); // ~200 WPM

    return {
      content: cleanedContent.innerHTML,
      metadata: {
        ...metadata,
        wordCount,
        estimatedReadingTime: readingTime,
      },
      wordCount,
      readingTime,
    };
  }

  private findMainContent(): Element | null {
    // Try content selectors in order of preference
    for (const selector of this.contentSelectors) {
      const element = document.querySelector(selector);
      if (element && this.hasSubstantialContent(element)) {
        return element;
      }
    }
    return null;
  }

  private hasSubstantialContent(element: Element): boolean {
    const text = element.textContent || '';
    const wordCount = this.calculateWordCount(text);
    return wordCount > 50; // Require at least 50 words
  }

  private cleanContent(content: Element): Element {
    const cloned = content.cloneNode(true) as Element;

    // Remove unwanted elements
    this.unwantedSelectors.forEach(selector => {
      const elements = cloned.querySelectorAll(selector);
      elements.forEach(el => el.remove());
    });

    return cloned;
  }

  private extractMetadata(): IDocumentMetadata {
    const title = this.extractTitle();
    const author = this.extractAuthor();
    const url = (global as any).window?.location?.href || '';

    return {
      title,
      url,
      captureDate: new Date().toISOString(),
      tags: [],
      author,
    };
  }

  private extractTitle(): string {
    // Try multiple title sources
    const titleSources = [
      () => document.querySelector('h1')?.textContent,
      () => document.querySelector('[property="og:title"]')?.getAttribute('content'),
      () => document.querySelector('[name="twitter:title"]')?.getAttribute('content'),
      () => document.title,
      () => document.querySelector('title')?.textContent,
    ];

    for (const source of titleSources) {
      const title = source();
      if (title && title.trim().length > 0) {
        return title.trim();
      }
    }

    return 'Untitled Page';
  }

  private extractAuthor(): string | undefined {
    const authorSelectors = [
      '[property="article:author"]',
      '[name="author"]',
      '[rel="author"]',
      '.author',
      '.byline',
    ];

    for (const selector of authorSelectors) {
      const element = document.querySelector(selector);
      if (element) {
        const author = element.getAttribute('content') || element.textContent;
        if (author && author.trim().length > 0) {
          return author.trim();
        }
      }
    }

    return undefined;
  }

  private calculateWordCount(text: string): number {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }
}

// Simplified markdown converter based on browser extension algorithms
class SimpleMarkdownConverter {
  convertToMarkdown(html: string): string {
    let markdown = html;

    // Headers
    markdown = markdown.replace(/<h([1-6])[^>]*>(.*?)<\/h[1-6]>/gi, (match, level, content) => {
      const headerLevel = '#'.repeat(parseInt(level));
      return `\n${headerLevel} ${this.stripHtml(content)}\n`;
    });

    // Paragraphs
    markdown = markdown.replace(/<p[^>]*>(.*?)<\/p>/gi, '\n$1\n');

    // Strong/Bold
    markdown = markdown.replace(/<(strong|b)[^>]*>(.*?)<\/(strong|b)>/gi, '**$2**');

    // Emphasis/Italic
    markdown = markdown.replace(/<(em|i)[^>]*>(.*?)<\/(em|i)>/gi, '*$2*');

    // Links
    markdown = markdown.replace(/<a[^>]*href=["']([^"']*)["'][^>]*>(.*?)<\/a>/gi, '[$2]($1)');

    // Images
    markdown = markdown.replace(
      /<img[^>]*src=["']([^"']*)["'][^>]*alt=["']([^"']*)["'][^>]*>/gi,
      '![$2]($1)'
    );
    markdown = markdown.replace(
      /<img[^>]*alt=["']([^"']*)["'][^>]*src=["']([^"']*)["'][^>]*>/gi,
      '![$1]($2)'
    );
    markdown = markdown.replace(/<img[^>]*src=["']([^"']*)["'][^>]*>/gi, '![]($1)');

    // Lists
    markdown = markdown.replace(/<ul[^>]*>(.*?)<\/ul>/gis, (match, content) => {
      const items = content.replace(/<li[^>]*>(.*?)<\/li>/gi, '- $1\n');
      return `\n${items}\n`;
    });

    markdown = markdown.replace(/<ol[^>]*>(.*?)<\/ol>/gis, (match, content) => {
      let counter = 1;
      const items = content.replace(/<li[^>]*>(.*?)<\/li>/gi, () => `${counter++}. $1\n`);
      return `\n${items}\n`;
    });

    // Code blocks
    markdown = markdown.replace(/<pre[^>]*><code[^>]*>(.*?)<\/code><\/pre>/gis, '\n```\n$1\n```\n');
    markdown = markdown.replace(/<code[^>]*>(.*?)<\/code>/gi, '`$1`');

    // Blockquotes
    markdown = markdown.replace(/<blockquote[^>]*>(.*?)<\/blockquote>/gis, (match, content) => {
      const lines = this.stripHtml(content).split('\n');
      return '\n' + lines.map(line => `> ${line}`).join('\n') + '\n';
    });

    // Line breaks
    markdown = markdown.replace(/<br[^>]*>/gi, '\n');

    // Strip remaining HTML
    markdown = this.stripHtml(markdown);

    // Clean up whitespace
    markdown = markdown.replace(/\n\s*\n\s*\n/g, '\n\n');
    markdown = markdown.trim();

    return markdown;
  }

  private stripHtml(html: string): string {
    return html.replace(/<[^>]*>/g, '').trim();
  }
}

class PrismWeaveCapture {
  private outputDir: string;

  constructor(outputDir = './test-outputs') {
    this.outputDir = outputDir;
    this.ensureOutputDir();
  }

  async captureUrl(url: string): Promise<ICaptureResult> {
    console.log(chalk.blue(`üîÑ Fetching: ${url}`));

    try {
      // Fetch the page
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const html = await response.text();
      console.log(chalk.green(`‚úÖ Fetched ${html.length} characters`));

      // Set up JSDOM environment to simulate browser
      const dom = new JSDOM(html, {
        url,
        pretendToBeVisual: true,
        resources: 'usable',
      });

      // Make DOM available globally for extraction algorithms
      (global as any).window = dom.window;
      (global as any).document = dom.window.document;
      // Don't override navigator as it causes issues

      // Use simplified extractor and converter (same algorithms as browser extension)
      const extractor = new SimpleContentExtractor();
      const converter = new SimpleMarkdownConverter();

      console.log(chalk.blue('üîÑ Extracting content...'));
      const contentResult = extractor.extractContent();

      console.log(chalk.blue('üîÑ Converting to markdown...'));
      const markdown = converter.convertToMarkdown(contentResult.content);

      // Generate filename
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const urlSlug = url
        .replace(/https?:\/\//, '')
        .replace(/[^a-zA-Z0-9]/g, '-')
        .replace(/-+/g, '-')
        .toLowerCase()
        .slice(0, 50);
      const filename = `${urlSlug}-${timestamp}`;

      // Create complete metadata
      const metadata = {
        ...contentResult.metadata,
        url,
        timestamp: new Date().toISOString(),
        wordCount: contentResult.wordCount,
        readingTime: contentResult.readingTime,
      };

      console.log(chalk.green('‚úÖ Extraction complete'));
      console.log(chalk.cyan(`üìù Word count: ${contentResult.wordCount}`));
      console.log(chalk.cyan(`‚è±Ô∏è  Reading time: ${contentResult.readingTime} min`));

      return {
        html,
        markdown,
        metadata,
        filename,
      };
    } catch (error) {
      console.error(chalk.red('‚ùå Capture failed:'), (error as Error).message);
      throw error;
    }
  }

  saveResults(result: ICaptureResult): void {
    const { html, markdown, metadata, filename } = result;

    // Save HTML
    const htmlPath = join(this.outputDir, `${filename}.html`);
    writeFileSync(htmlPath, html, 'utf8');
    console.log(chalk.gray(`üíæ Saved HTML: ${htmlPath}`));

    // Save Markdown with frontmatter
    const frontmatter = this.generateFrontmatter(metadata);
    const fullMarkdown = `${frontmatter}\n${markdown}`;
    const mdPath = join(this.outputDir, `${filename}.md`);
    writeFileSync(mdPath, fullMarkdown, 'utf8');
    console.log(chalk.gray(`üíæ Saved Markdown: ${mdPath}`));

    // Save metadata as JSON
    const jsonPath = join(this.outputDir, `${filename}.json`);
    writeFileSync(jsonPath, JSON.stringify(metadata, null, 2), 'utf8');
    console.log(chalk.gray(`üíæ Saved metadata: ${jsonPath}`));
  }

  private generateFrontmatter(metadata: any): string {
    const frontmatter = [
      '---',
      `title: "${metadata.title || 'Untitled'}"`,
      `url: "${metadata.url}"`,
      `captured: "${metadata.timestamp}"`,
      `author: "${metadata.author || ''}"`,
      `word_count: ${metadata.wordCount}`,
      `reading_time: ${metadata.readingTime}`,
      `tags: [${metadata.tags.map((tag: string) => `"${tag}"`).join(', ')}]`,
      '---',
    ];

    return frontmatter.join('\n');
  }

  private ensureOutputDir(): void {
    try {
      mkdirSync(this.outputDir, { recursive: true });
    } catch (error) {
      // Directory might already exist
    }
  }
}

// CLI interface
async function main() {
  const url = process.argv[2];

  if (!url) {
    console.error(chalk.red('‚ùå Please provide a URL to capture'));
    console.log(chalk.yellow('Usage: npm run capture <url>'));
    console.log(chalk.yellow('Example: npm run capture "https://example.com/article"'));
    process.exit(1);
  }

  try {
    const capture = new PrismWeaveCapture();
    const result = await capture.captureUrl(url);
    capture.saveResults(result);

    console.log(chalk.green('\nüéâ Capture completed successfully!'));
    console.log(chalk.blue(`üìÅ Files saved in: ${capture['outputDir']}`));
  } catch (error) {
    console.error(chalk.red('‚ùå Capture failed:'), (error as Error).message);
    process.exit(1);
  }
}

// Run the CLI
main().catch(console.error);
